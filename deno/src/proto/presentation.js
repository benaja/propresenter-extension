/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const rv = $root.rv = (() => {

    /**
     * Namespace rv.
     * @exports rv
     * @namespace
     */
    const rv = {};

    rv.data = (function() {

        /**
         * Namespace data.
         * @memberof rv
         * @namespace
         */
        const data = {};

        data.Presentation = (function() {

            /**
             * Properties of a Presentation.
             * @memberof rv.data
             * @interface IPresentation
             * @property {rv.data.IApplicationInfo|null} [applicationInfo] Presentation applicationInfo
             * @property {rv.data.IUUID|null} [uuid] Presentation uuid
             * @property {string|null} [name] Presentation name
             * @property {rv.data.ITimestamp|null} [lastDateUsed] Presentation lastDateUsed
             * @property {rv.data.ITimestamp|null} [lastModifiedDate] Presentation lastModifiedDate
             * @property {string|null} [category] Presentation category
             * @property {string|null} [notes] Presentation notes
             * @property {rv.data.IBackground|null} [background] Presentation background
             * @property {rv.data.IURL|null} [chordChart] Presentation chordChart
             * @property {rv.data.IUUID|null} [selectedArrangement] Presentation selectedArrangement
             * @property {Array.<rv.data.Presentation.IArrangement>|null} [arrangements] Presentation arrangements
             * @property {Array.<rv.data.Presentation.ICueGroup>|null} [cueGroups] Presentation cueGroups
             * @property {Array.<rv.data.ICue>|null} [cues] Presentation cues
             * @property {rv.data.Presentation.ICCLI|null} [ccli] Presentation ccli
             * @property {rv.data.Presentation.IBibleReference|null} [bibleReference] Presentation bibleReference
             * @property {rv.data.Presentation.ITimeline|null} [timeline] Presentation timeline
             * @property {rv.data.ITransition|null} [transition] Presentation transition
             * @property {rv.data.Action.ContentDestination|null} [contentDestination] Presentation contentDestination
             * @property {rv.data.Presentation.IMultiTracksLicensing|null} [multiTracksLicensing] Presentation multiTracksLicensing
             * @property {string|null} [musicKey] Presentation musicKey
             * @property {rv.data.Presentation.IMusic|null} [music] Presentation music
             * @property {number|null} [slideShowDuration] Presentation slideShowDuration
             */

            /**
             * Constructs a new Presentation.
             * @memberof rv.data
             * @classdesc Represents a Presentation.
             * @implements IPresentation
             * @constructor
             * @param {rv.data.IPresentation=} [properties] Properties to set
             */
            function Presentation(properties) {
                this.arrangements = [];
                this.cueGroups = [];
                this.cues = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Presentation applicationInfo.
             * @member {rv.data.IApplicationInfo|null|undefined} applicationInfo
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.applicationInfo = null;

            /**
             * Presentation uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.uuid = null;

            /**
             * Presentation name.
             * @member {string} name
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.name = "";

            /**
             * Presentation lastDateUsed.
             * @member {rv.data.ITimestamp|null|undefined} lastDateUsed
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.lastDateUsed = null;

            /**
             * Presentation lastModifiedDate.
             * @member {rv.data.ITimestamp|null|undefined} lastModifiedDate
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.lastModifiedDate = null;

            /**
             * Presentation category.
             * @member {string} category
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.category = "";

            /**
             * Presentation notes.
             * @member {string} notes
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.notes = "";

            /**
             * Presentation background.
             * @member {rv.data.IBackground|null|undefined} background
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.background = null;

            /**
             * Presentation chordChart.
             * @member {rv.data.IURL|null|undefined} chordChart
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.chordChart = null;

            /**
             * Presentation selectedArrangement.
             * @member {rv.data.IUUID|null|undefined} selectedArrangement
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.selectedArrangement = null;

            /**
             * Presentation arrangements.
             * @member {Array.<rv.data.Presentation.IArrangement>} arrangements
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.arrangements = $util.emptyArray;

            /**
             * Presentation cueGroups.
             * @member {Array.<rv.data.Presentation.ICueGroup>} cueGroups
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.cueGroups = $util.emptyArray;

            /**
             * Presentation cues.
             * @member {Array.<rv.data.ICue>} cues
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.cues = $util.emptyArray;

            /**
             * Presentation ccli.
             * @member {rv.data.Presentation.ICCLI|null|undefined} ccli
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.ccli = null;

            /**
             * Presentation bibleReference.
             * @member {rv.data.Presentation.IBibleReference|null|undefined} bibleReference
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.bibleReference = null;

            /**
             * Presentation timeline.
             * @member {rv.data.Presentation.ITimeline|null|undefined} timeline
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.timeline = null;

            /**
             * Presentation transition.
             * @member {rv.data.ITransition|null|undefined} transition
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.transition = null;

            /**
             * Presentation contentDestination.
             * @member {rv.data.Action.ContentDestination} contentDestination
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.contentDestination = 0;

            /**
             * Presentation multiTracksLicensing.
             * @member {rv.data.Presentation.IMultiTracksLicensing|null|undefined} multiTracksLicensing
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.multiTracksLicensing = null;

            /**
             * Presentation musicKey.
             * @member {string} musicKey
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.musicKey = "";

            /**
             * Presentation music.
             * @member {rv.data.Presentation.IMusic|null|undefined} music
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.music = null;

            /**
             * Presentation slideShowDuration.
             * @member {number|null|undefined} slideShowDuration
             * @memberof rv.data.Presentation
             * @instance
             */
            Presentation.prototype.slideShowDuration = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Presentation SlideShow.
             * @member {"slideShowDuration"|undefined} SlideShow
             * @memberof rv.data.Presentation
             * @instance
             */
            Object.defineProperty(Presentation.prototype, "SlideShow", {
                get: $util.oneOfGetter($oneOfFields = ["slideShowDuration"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Presentation instance using the specified properties.
             * @function create
             * @memberof rv.data.Presentation
             * @static
             * @param {rv.data.IPresentation=} [properties] Properties to set
             * @returns {rv.data.Presentation} Presentation instance
             */
            Presentation.create = function create(properties) {
                return new Presentation(properties);
            };

            /**
             * Encodes the specified Presentation message. Does not implicitly {@link rv.data.Presentation.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Presentation
             * @static
             * @param {rv.data.IPresentation} message Presentation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Presentation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.applicationInfo != null && Object.hasOwnProperty.call(message, "applicationInfo"))
                    $root.rv.data.ApplicationInfo.encode(message.applicationInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                if (message.lastDateUsed != null && Object.hasOwnProperty.call(message, "lastDateUsed"))
                    $root.rv.data.Timestamp.encode(message.lastDateUsed, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.lastModifiedDate != null && Object.hasOwnProperty.call(message, "lastModifiedDate"))
                    $root.rv.data.Timestamp.encode(message.lastModifiedDate, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.category);
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.notes);
                if (message.background != null && Object.hasOwnProperty.call(message, "background"))
                    $root.rv.data.Background.encode(message.background, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.chordChart != null && Object.hasOwnProperty.call(message, "chordChart"))
                    $root.rv.data.URL.encode(message.chordChart, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.selectedArrangement != null && Object.hasOwnProperty.call(message, "selectedArrangement"))
                    $root.rv.data.UUID.encode(message.selectedArrangement, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.arrangements != null && message.arrangements.length)
                    for (let i = 0; i < message.arrangements.length; ++i)
                        $root.rv.data.Presentation.Arrangement.encode(message.arrangements[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.cueGroups != null && message.cueGroups.length)
                    for (let i = 0; i < message.cueGroups.length; ++i)
                        $root.rv.data.Presentation.CueGroup.encode(message.cueGroups[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.cues != null && message.cues.length)
                    for (let i = 0; i < message.cues.length; ++i)
                        $root.rv.data.Cue.encode(message.cues[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.ccli != null && Object.hasOwnProperty.call(message, "ccli"))
                    $root.rv.data.Presentation.CCLI.encode(message.ccli, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.bibleReference != null && Object.hasOwnProperty.call(message, "bibleReference"))
                    $root.rv.data.Presentation.BibleReference.encode(message.bibleReference, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.timeline != null && Object.hasOwnProperty.call(message, "timeline"))
                    $root.rv.data.Presentation.Timeline.encode(message.timeline, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.transition != null && Object.hasOwnProperty.call(message, "transition"))
                    $root.rv.data.Transition.encode(message.transition, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.contentDestination != null && Object.hasOwnProperty.call(message, "contentDestination"))
                    writer.uint32(/* id 19, wireType 0 =*/152).int32(message.contentDestination);
                if (message.slideShowDuration != null && Object.hasOwnProperty.call(message, "slideShowDuration"))
                    writer.uint32(/* id 20, wireType 1 =*/161).double(message.slideShowDuration);
                if (message.multiTracksLicensing != null && Object.hasOwnProperty.call(message, "multiTracksLicensing"))
                    $root.rv.data.Presentation.MultiTracksLicensing.encode(message.multiTracksLicensing, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.musicKey != null && Object.hasOwnProperty.call(message, "musicKey"))
                    writer.uint32(/* id 22, wireType 2 =*/178).string(message.musicKey);
                if (message.music != null && Object.hasOwnProperty.call(message, "music"))
                    $root.rv.data.Presentation.Music.encode(message.music, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Presentation message, length delimited. Does not implicitly {@link rv.data.Presentation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Presentation
             * @static
             * @param {rv.data.IPresentation} message Presentation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Presentation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Presentation message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Presentation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Presentation} Presentation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Presentation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Presentation();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.applicationInfo = $root.rv.data.ApplicationInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.name = reader.string();
                            break;
                        }
                    case 4: {
                            message.lastDateUsed = $root.rv.data.Timestamp.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.lastModifiedDate = $root.rv.data.Timestamp.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.category = reader.string();
                            break;
                        }
                    case 7: {
                            message.notes = reader.string();
                            break;
                        }
                    case 8: {
                            message.background = $root.rv.data.Background.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.chordChart = $root.rv.data.URL.decode(reader, reader.uint32());
                            break;
                        }
                    case 10: {
                            message.selectedArrangement = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            if (!(message.arrangements && message.arrangements.length))
                                message.arrangements = [];
                            message.arrangements.push($root.rv.data.Presentation.Arrangement.decode(reader, reader.uint32()));
                            break;
                        }
                    case 12: {
                            if (!(message.cueGroups && message.cueGroups.length))
                                message.cueGroups = [];
                            message.cueGroups.push($root.rv.data.Presentation.CueGroup.decode(reader, reader.uint32()));
                            break;
                        }
                    case 13: {
                            if (!(message.cues && message.cues.length))
                                message.cues = [];
                            message.cues.push($root.rv.data.Cue.decode(reader, reader.uint32()));
                            break;
                        }
                    case 14: {
                            message.ccli = $root.rv.data.Presentation.CCLI.decode(reader, reader.uint32());
                            break;
                        }
                    case 15: {
                            message.bibleReference = $root.rv.data.Presentation.BibleReference.decode(reader, reader.uint32());
                            break;
                        }
                    case 17: {
                            message.timeline = $root.rv.data.Presentation.Timeline.decode(reader, reader.uint32());
                            break;
                        }
                    case 18: {
                            message.transition = $root.rv.data.Transition.decode(reader, reader.uint32());
                            break;
                        }
                    case 19: {
                            message.contentDestination = reader.int32();
                            break;
                        }
                    case 21: {
                            message.multiTracksLicensing = $root.rv.data.Presentation.MultiTracksLicensing.decode(reader, reader.uint32());
                            break;
                        }
                    case 22: {
                            message.musicKey = reader.string();
                            break;
                        }
                    case 23: {
                            message.music = $root.rv.data.Presentation.Music.decode(reader, reader.uint32());
                            break;
                        }
                    case 20: {
                            message.slideShowDuration = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Presentation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Presentation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Presentation} Presentation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Presentation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Presentation message.
             * @function verify
             * @memberof rv.data.Presentation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Presentation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.applicationInfo != null && message.hasOwnProperty("applicationInfo")) {
                    let error = $root.rv.data.ApplicationInfo.verify(message.applicationInfo);
                    if (error)
                        return "applicationInfo." + error;
                }
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.lastDateUsed != null && message.hasOwnProperty("lastDateUsed")) {
                    let error = $root.rv.data.Timestamp.verify(message.lastDateUsed);
                    if (error)
                        return "lastDateUsed." + error;
                }
                if (message.lastModifiedDate != null && message.hasOwnProperty("lastModifiedDate")) {
                    let error = $root.rv.data.Timestamp.verify(message.lastModifiedDate);
                    if (error)
                        return "lastModifiedDate." + error;
                }
                if (message.category != null && message.hasOwnProperty("category"))
                    if (!$util.isString(message.category))
                        return "category: string expected";
                if (message.notes != null && message.hasOwnProperty("notes"))
                    if (!$util.isString(message.notes))
                        return "notes: string expected";
                if (message.background != null && message.hasOwnProperty("background")) {
                    let error = $root.rv.data.Background.verify(message.background);
                    if (error)
                        return "background." + error;
                }
                if (message.chordChart != null && message.hasOwnProperty("chordChart")) {
                    let error = $root.rv.data.URL.verify(message.chordChart);
                    if (error)
                        return "chordChart." + error;
                }
                if (message.selectedArrangement != null && message.hasOwnProperty("selectedArrangement")) {
                    let error = $root.rv.data.UUID.verify(message.selectedArrangement);
                    if (error)
                        return "selectedArrangement." + error;
                }
                if (message.arrangements != null && message.hasOwnProperty("arrangements")) {
                    if (!Array.isArray(message.arrangements))
                        return "arrangements: array expected";
                    for (let i = 0; i < message.arrangements.length; ++i) {
                        let error = $root.rv.data.Presentation.Arrangement.verify(message.arrangements[i]);
                        if (error)
                            return "arrangements." + error;
                    }
                }
                if (message.cueGroups != null && message.hasOwnProperty("cueGroups")) {
                    if (!Array.isArray(message.cueGroups))
                        return "cueGroups: array expected";
                    for (let i = 0; i < message.cueGroups.length; ++i) {
                        let error = $root.rv.data.Presentation.CueGroup.verify(message.cueGroups[i]);
                        if (error)
                            return "cueGroups." + error;
                    }
                }
                if (message.cues != null && message.hasOwnProperty("cues")) {
                    if (!Array.isArray(message.cues))
                        return "cues: array expected";
                    for (let i = 0; i < message.cues.length; ++i) {
                        let error = $root.rv.data.Cue.verify(message.cues[i]);
                        if (error)
                            return "cues." + error;
                    }
                }
                if (message.ccli != null && message.hasOwnProperty("ccli")) {
                    let error = $root.rv.data.Presentation.CCLI.verify(message.ccli);
                    if (error)
                        return "ccli." + error;
                }
                if (message.bibleReference != null && message.hasOwnProperty("bibleReference")) {
                    let error = $root.rv.data.Presentation.BibleReference.verify(message.bibleReference);
                    if (error)
                        return "bibleReference." + error;
                }
                if (message.timeline != null && message.hasOwnProperty("timeline")) {
                    let error = $root.rv.data.Presentation.Timeline.verify(message.timeline);
                    if (error)
                        return "timeline." + error;
                }
                if (message.transition != null && message.hasOwnProperty("transition")) {
                    let error = $root.rv.data.Transition.verify(message.transition);
                    if (error)
                        return "transition." + error;
                }
                if (message.contentDestination != null && message.hasOwnProperty("contentDestination"))
                    switch (message.contentDestination) {
                    default:
                        return "contentDestination: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.multiTracksLicensing != null && message.hasOwnProperty("multiTracksLicensing")) {
                    let error = $root.rv.data.Presentation.MultiTracksLicensing.verify(message.multiTracksLicensing);
                    if (error)
                        return "multiTracksLicensing." + error;
                }
                if (message.musicKey != null && message.hasOwnProperty("musicKey"))
                    if (!$util.isString(message.musicKey))
                        return "musicKey: string expected";
                if (message.music != null && message.hasOwnProperty("music")) {
                    let error = $root.rv.data.Presentation.Music.verify(message.music);
                    if (error)
                        return "music." + error;
                }
                if (message.slideShowDuration != null && message.hasOwnProperty("slideShowDuration")) {
                    properties.SlideShow = 1;
                    if (typeof message.slideShowDuration !== "number")
                        return "slideShowDuration: number expected";
                }
                return null;
            };

            /**
             * Creates a Presentation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Presentation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Presentation} Presentation
             */
            Presentation.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Presentation)
                    return object;
                let message = new $root.rv.data.Presentation();
                if (object.applicationInfo != null) {
                    if (typeof object.applicationInfo !== "object")
                        throw TypeError(".rv.data.Presentation.applicationInfo: object expected");
                    message.applicationInfo = $root.rv.data.ApplicationInfo.fromObject(object.applicationInfo);
                }
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.Presentation.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                if (object.name != null)
                    message.name = String(object.name);
                if (object.lastDateUsed != null) {
                    if (typeof object.lastDateUsed !== "object")
                        throw TypeError(".rv.data.Presentation.lastDateUsed: object expected");
                    message.lastDateUsed = $root.rv.data.Timestamp.fromObject(object.lastDateUsed);
                }
                if (object.lastModifiedDate != null) {
                    if (typeof object.lastModifiedDate !== "object")
                        throw TypeError(".rv.data.Presentation.lastModifiedDate: object expected");
                    message.lastModifiedDate = $root.rv.data.Timestamp.fromObject(object.lastModifiedDate);
                }
                if (object.category != null)
                    message.category = String(object.category);
                if (object.notes != null)
                    message.notes = String(object.notes);
                if (object.background != null) {
                    if (typeof object.background !== "object")
                        throw TypeError(".rv.data.Presentation.background: object expected");
                    message.background = $root.rv.data.Background.fromObject(object.background);
                }
                if (object.chordChart != null) {
                    if (typeof object.chordChart !== "object")
                        throw TypeError(".rv.data.Presentation.chordChart: object expected");
                    message.chordChart = $root.rv.data.URL.fromObject(object.chordChart);
                }
                if (object.selectedArrangement != null) {
                    if (typeof object.selectedArrangement !== "object")
                        throw TypeError(".rv.data.Presentation.selectedArrangement: object expected");
                    message.selectedArrangement = $root.rv.data.UUID.fromObject(object.selectedArrangement);
                }
                if (object.arrangements) {
                    if (!Array.isArray(object.arrangements))
                        throw TypeError(".rv.data.Presentation.arrangements: array expected");
                    message.arrangements = [];
                    for (let i = 0; i < object.arrangements.length; ++i) {
                        if (typeof object.arrangements[i] !== "object")
                            throw TypeError(".rv.data.Presentation.arrangements: object expected");
                        message.arrangements[i] = $root.rv.data.Presentation.Arrangement.fromObject(object.arrangements[i]);
                    }
                }
                if (object.cueGroups) {
                    if (!Array.isArray(object.cueGroups))
                        throw TypeError(".rv.data.Presentation.cueGroups: array expected");
                    message.cueGroups = [];
                    for (let i = 0; i < object.cueGroups.length; ++i) {
                        if (typeof object.cueGroups[i] !== "object")
                            throw TypeError(".rv.data.Presentation.cueGroups: object expected");
                        message.cueGroups[i] = $root.rv.data.Presentation.CueGroup.fromObject(object.cueGroups[i]);
                    }
                }
                if (object.cues) {
                    if (!Array.isArray(object.cues))
                        throw TypeError(".rv.data.Presentation.cues: array expected");
                    message.cues = [];
                    for (let i = 0; i < object.cues.length; ++i) {
                        if (typeof object.cues[i] !== "object")
                            throw TypeError(".rv.data.Presentation.cues: object expected");
                        message.cues[i] = $root.rv.data.Cue.fromObject(object.cues[i]);
                    }
                }
                if (object.ccli != null) {
                    if (typeof object.ccli !== "object")
                        throw TypeError(".rv.data.Presentation.ccli: object expected");
                    message.ccli = $root.rv.data.Presentation.CCLI.fromObject(object.ccli);
                }
                if (object.bibleReference != null) {
                    if (typeof object.bibleReference !== "object")
                        throw TypeError(".rv.data.Presentation.bibleReference: object expected");
                    message.bibleReference = $root.rv.data.Presentation.BibleReference.fromObject(object.bibleReference);
                }
                if (object.timeline != null) {
                    if (typeof object.timeline !== "object")
                        throw TypeError(".rv.data.Presentation.timeline: object expected");
                    message.timeline = $root.rv.data.Presentation.Timeline.fromObject(object.timeline);
                }
                if (object.transition != null) {
                    if (typeof object.transition !== "object")
                        throw TypeError(".rv.data.Presentation.transition: object expected");
                    message.transition = $root.rv.data.Transition.fromObject(object.transition);
                }
                switch (object.contentDestination) {
                default:
                    if (typeof object.contentDestination === "number") {
                        message.contentDestination = object.contentDestination;
                        break;
                    }
                    break;
                case "CONTENT_DESTINATION_GLOBAL":
                case 0:
                    message.contentDestination = 0;
                    break;
                case "CONTENT_DESTINATION_ANNOUNCEMENTS":
                case 1:
                    message.contentDestination = 1;
                    break;
                }
                if (object.multiTracksLicensing != null) {
                    if (typeof object.multiTracksLicensing !== "object")
                        throw TypeError(".rv.data.Presentation.multiTracksLicensing: object expected");
                    message.multiTracksLicensing = $root.rv.data.Presentation.MultiTracksLicensing.fromObject(object.multiTracksLicensing);
                }
                if (object.musicKey != null)
                    message.musicKey = String(object.musicKey);
                if (object.music != null) {
                    if (typeof object.music !== "object")
                        throw TypeError(".rv.data.Presentation.music: object expected");
                    message.music = $root.rv.data.Presentation.Music.fromObject(object.music);
                }
                if (object.slideShowDuration != null)
                    message.slideShowDuration = Number(object.slideShowDuration);
                return message;
            };

            /**
             * Creates a plain object from a Presentation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Presentation
             * @static
             * @param {rv.data.Presentation} message Presentation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Presentation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.arrangements = [];
                    object.cueGroups = [];
                    object.cues = [];
                }
                if (options.defaults) {
                    object.applicationInfo = null;
                    object.uuid = null;
                    object.name = "";
                    object.lastDateUsed = null;
                    object.lastModifiedDate = null;
                    object.category = "";
                    object.notes = "";
                    object.background = null;
                    object.chordChart = null;
                    object.selectedArrangement = null;
                    object.ccli = null;
                    object.bibleReference = null;
                    object.timeline = null;
                    object.transition = null;
                    object.contentDestination = options.enums === String ? "CONTENT_DESTINATION_GLOBAL" : 0;
                    object.multiTracksLicensing = null;
                    object.musicKey = "";
                    object.music = null;
                }
                if (message.applicationInfo != null && message.hasOwnProperty("applicationInfo"))
                    object.applicationInfo = $root.rv.data.ApplicationInfo.toObject(message.applicationInfo, options);
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.lastDateUsed != null && message.hasOwnProperty("lastDateUsed"))
                    object.lastDateUsed = $root.rv.data.Timestamp.toObject(message.lastDateUsed, options);
                if (message.lastModifiedDate != null && message.hasOwnProperty("lastModifiedDate"))
                    object.lastModifiedDate = $root.rv.data.Timestamp.toObject(message.lastModifiedDate, options);
                if (message.category != null && message.hasOwnProperty("category"))
                    object.category = message.category;
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = message.notes;
                if (message.background != null && message.hasOwnProperty("background"))
                    object.background = $root.rv.data.Background.toObject(message.background, options);
                if (message.chordChart != null && message.hasOwnProperty("chordChart"))
                    object.chordChart = $root.rv.data.URL.toObject(message.chordChart, options);
                if (message.selectedArrangement != null && message.hasOwnProperty("selectedArrangement"))
                    object.selectedArrangement = $root.rv.data.UUID.toObject(message.selectedArrangement, options);
                if (message.arrangements && message.arrangements.length) {
                    object.arrangements = [];
                    for (let j = 0; j < message.arrangements.length; ++j)
                        object.arrangements[j] = $root.rv.data.Presentation.Arrangement.toObject(message.arrangements[j], options);
                }
                if (message.cueGroups && message.cueGroups.length) {
                    object.cueGroups = [];
                    for (let j = 0; j < message.cueGroups.length; ++j)
                        object.cueGroups[j] = $root.rv.data.Presentation.CueGroup.toObject(message.cueGroups[j], options);
                }
                if (message.cues && message.cues.length) {
                    object.cues = [];
                    for (let j = 0; j < message.cues.length; ++j)
                        object.cues[j] = $root.rv.data.Cue.toObject(message.cues[j], options);
                }
                if (message.ccli != null && message.hasOwnProperty("ccli"))
                    object.ccli = $root.rv.data.Presentation.CCLI.toObject(message.ccli, options);
                if (message.bibleReference != null && message.hasOwnProperty("bibleReference"))
                    object.bibleReference = $root.rv.data.Presentation.BibleReference.toObject(message.bibleReference, options);
                if (message.timeline != null && message.hasOwnProperty("timeline"))
                    object.timeline = $root.rv.data.Presentation.Timeline.toObject(message.timeline, options);
                if (message.transition != null && message.hasOwnProperty("transition"))
                    object.transition = $root.rv.data.Transition.toObject(message.transition, options);
                if (message.contentDestination != null && message.hasOwnProperty("contentDestination"))
                    object.contentDestination = options.enums === String ? $root.rv.data.Action.ContentDestination[message.contentDestination] === undefined ? message.contentDestination : $root.rv.data.Action.ContentDestination[message.contentDestination] : message.contentDestination;
                if (message.slideShowDuration != null && message.hasOwnProperty("slideShowDuration")) {
                    object.slideShowDuration = options.json && !isFinite(message.slideShowDuration) ? String(message.slideShowDuration) : message.slideShowDuration;
                    if (options.oneofs)
                        object.SlideShow = "slideShowDuration";
                }
                if (message.multiTracksLicensing != null && message.hasOwnProperty("multiTracksLicensing"))
                    object.multiTracksLicensing = $root.rv.data.Presentation.MultiTracksLicensing.toObject(message.multiTracksLicensing, options);
                if (message.musicKey != null && message.hasOwnProperty("musicKey"))
                    object.musicKey = message.musicKey;
                if (message.music != null && message.hasOwnProperty("music"))
                    object.music = $root.rv.data.Presentation.Music.toObject(message.music, options);
                return object;
            };

            /**
             * Converts this Presentation to JSON.
             * @function toJSON
             * @memberof rv.data.Presentation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Presentation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Presentation
             * @function getTypeUrl
             * @memberof rv.data.Presentation
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Presentation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Presentation";
            };

            Presentation.CCLI = (function() {

                /**
                 * Properties of a CCLI.
                 * @memberof rv.data.Presentation
                 * @interface ICCLI
                 * @property {string|null} [author] CCLI author
                 * @property {string|null} [artistCredits] CCLI artistCredits
                 * @property {string|null} [songTitle] CCLI songTitle
                 * @property {string|null} [publisher] CCLI publisher
                 * @property {number|null} [copyrightYear] CCLI copyrightYear
                 * @property {number|null} [songNumber] CCLI songNumber
                 * @property {boolean|null} [display] CCLI display
                 * @property {string|null} [album] CCLI album
                 * @property {Uint8Array|null} [artwork] CCLI artwork
                 */

                /**
                 * Constructs a new CCLI.
                 * @memberof rv.data.Presentation
                 * @classdesc Represents a CCLI.
                 * @implements ICCLI
                 * @constructor
                 * @param {rv.data.Presentation.ICCLI=} [properties] Properties to set
                 */
                function CCLI(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CCLI author.
                 * @member {string} author
                 * @memberof rv.data.Presentation.CCLI
                 * @instance
                 */
                CCLI.prototype.author = "";

                /**
                 * CCLI artistCredits.
                 * @member {string} artistCredits
                 * @memberof rv.data.Presentation.CCLI
                 * @instance
                 */
                CCLI.prototype.artistCredits = "";

                /**
                 * CCLI songTitle.
                 * @member {string} songTitle
                 * @memberof rv.data.Presentation.CCLI
                 * @instance
                 */
                CCLI.prototype.songTitle = "";

                /**
                 * CCLI publisher.
                 * @member {string} publisher
                 * @memberof rv.data.Presentation.CCLI
                 * @instance
                 */
                CCLI.prototype.publisher = "";

                /**
                 * CCLI copyrightYear.
                 * @member {number} copyrightYear
                 * @memberof rv.data.Presentation.CCLI
                 * @instance
                 */
                CCLI.prototype.copyrightYear = 0;

                /**
                 * CCLI songNumber.
                 * @member {number} songNumber
                 * @memberof rv.data.Presentation.CCLI
                 * @instance
                 */
                CCLI.prototype.songNumber = 0;

                /**
                 * CCLI display.
                 * @member {boolean} display
                 * @memberof rv.data.Presentation.CCLI
                 * @instance
                 */
                CCLI.prototype.display = false;

                /**
                 * CCLI album.
                 * @member {string} album
                 * @memberof rv.data.Presentation.CCLI
                 * @instance
                 */
                CCLI.prototype.album = "";

                /**
                 * CCLI artwork.
                 * @member {Uint8Array} artwork
                 * @memberof rv.data.Presentation.CCLI
                 * @instance
                 */
                CCLI.prototype.artwork = $util.newBuffer([]);

                /**
                 * Creates a new CCLI instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Presentation.CCLI
                 * @static
                 * @param {rv.data.Presentation.ICCLI=} [properties] Properties to set
                 * @returns {rv.data.Presentation.CCLI} CCLI instance
                 */
                CCLI.create = function create(properties) {
                    return new CCLI(properties);
                };

                /**
                 * Encodes the specified CCLI message. Does not implicitly {@link rv.data.Presentation.CCLI.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Presentation.CCLI
                 * @static
                 * @param {rv.data.Presentation.ICCLI} message CCLI message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CCLI.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.author != null && Object.hasOwnProperty.call(message, "author"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.author);
                    if (message.artistCredits != null && Object.hasOwnProperty.call(message, "artistCredits"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.artistCredits);
                    if (message.songTitle != null && Object.hasOwnProperty.call(message, "songTitle"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.songTitle);
                    if (message.publisher != null && Object.hasOwnProperty.call(message, "publisher"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.publisher);
                    if (message.copyrightYear != null && Object.hasOwnProperty.call(message, "copyrightYear"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.copyrightYear);
                    if (message.songNumber != null && Object.hasOwnProperty.call(message, "songNumber"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.songNumber);
                    if (message.display != null && Object.hasOwnProperty.call(message, "display"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.display);
                    if (message.album != null && Object.hasOwnProperty.call(message, "album"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.album);
                    if (message.artwork != null && Object.hasOwnProperty.call(message, "artwork"))
                        writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.artwork);
                    return writer;
                };

                /**
                 * Encodes the specified CCLI message, length delimited. Does not implicitly {@link rv.data.Presentation.CCLI.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Presentation.CCLI
                 * @static
                 * @param {rv.data.Presentation.ICCLI} message CCLI message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CCLI.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CCLI message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Presentation.CCLI
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Presentation.CCLI} CCLI
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CCLI.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Presentation.CCLI();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.author = reader.string();
                                break;
                            }
                        case 2: {
                                message.artistCredits = reader.string();
                                break;
                            }
                        case 3: {
                                message.songTitle = reader.string();
                                break;
                            }
                        case 4: {
                                message.publisher = reader.string();
                                break;
                            }
                        case 5: {
                                message.copyrightYear = reader.uint32();
                                break;
                            }
                        case 6: {
                                message.songNumber = reader.uint32();
                                break;
                            }
                        case 7: {
                                message.display = reader.bool();
                                break;
                            }
                        case 8: {
                                message.album = reader.string();
                                break;
                            }
                        case 9: {
                                message.artwork = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CCLI message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Presentation.CCLI
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Presentation.CCLI} CCLI
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CCLI.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CCLI message.
                 * @function verify
                 * @memberof rv.data.Presentation.CCLI
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CCLI.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.author != null && message.hasOwnProperty("author"))
                        if (!$util.isString(message.author))
                            return "author: string expected";
                    if (message.artistCredits != null && message.hasOwnProperty("artistCredits"))
                        if (!$util.isString(message.artistCredits))
                            return "artistCredits: string expected";
                    if (message.songTitle != null && message.hasOwnProperty("songTitle"))
                        if (!$util.isString(message.songTitle))
                            return "songTitle: string expected";
                    if (message.publisher != null && message.hasOwnProperty("publisher"))
                        if (!$util.isString(message.publisher))
                            return "publisher: string expected";
                    if (message.copyrightYear != null && message.hasOwnProperty("copyrightYear"))
                        if (!$util.isInteger(message.copyrightYear))
                            return "copyrightYear: integer expected";
                    if (message.songNumber != null && message.hasOwnProperty("songNumber"))
                        if (!$util.isInteger(message.songNumber))
                            return "songNumber: integer expected";
                    if (message.display != null && message.hasOwnProperty("display"))
                        if (typeof message.display !== "boolean")
                            return "display: boolean expected";
                    if (message.album != null && message.hasOwnProperty("album"))
                        if (!$util.isString(message.album))
                            return "album: string expected";
                    if (message.artwork != null && message.hasOwnProperty("artwork"))
                        if (!(message.artwork && typeof message.artwork.length === "number" || $util.isString(message.artwork)))
                            return "artwork: buffer expected";
                    return null;
                };

                /**
                 * Creates a CCLI message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Presentation.CCLI
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Presentation.CCLI} CCLI
                 */
                CCLI.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Presentation.CCLI)
                        return object;
                    let message = new $root.rv.data.Presentation.CCLI();
                    if (object.author != null)
                        message.author = String(object.author);
                    if (object.artistCredits != null)
                        message.artistCredits = String(object.artistCredits);
                    if (object.songTitle != null)
                        message.songTitle = String(object.songTitle);
                    if (object.publisher != null)
                        message.publisher = String(object.publisher);
                    if (object.copyrightYear != null)
                        message.copyrightYear = object.copyrightYear >>> 0;
                    if (object.songNumber != null)
                        message.songNumber = object.songNumber >>> 0;
                    if (object.display != null)
                        message.display = Boolean(object.display);
                    if (object.album != null)
                        message.album = String(object.album);
                    if (object.artwork != null)
                        if (typeof object.artwork === "string")
                            $util.base64.decode(object.artwork, message.artwork = $util.newBuffer($util.base64.length(object.artwork)), 0);
                        else if (object.artwork.length >= 0)
                            message.artwork = object.artwork;
                    return message;
                };

                /**
                 * Creates a plain object from a CCLI message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Presentation.CCLI
                 * @static
                 * @param {rv.data.Presentation.CCLI} message CCLI
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CCLI.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.author = "";
                        object.artistCredits = "";
                        object.songTitle = "";
                        object.publisher = "";
                        object.copyrightYear = 0;
                        object.songNumber = 0;
                        object.display = false;
                        object.album = "";
                        if (options.bytes === String)
                            object.artwork = "";
                        else {
                            object.artwork = [];
                            if (options.bytes !== Array)
                                object.artwork = $util.newBuffer(object.artwork);
                        }
                    }
                    if (message.author != null && message.hasOwnProperty("author"))
                        object.author = message.author;
                    if (message.artistCredits != null && message.hasOwnProperty("artistCredits"))
                        object.artistCredits = message.artistCredits;
                    if (message.songTitle != null && message.hasOwnProperty("songTitle"))
                        object.songTitle = message.songTitle;
                    if (message.publisher != null && message.hasOwnProperty("publisher"))
                        object.publisher = message.publisher;
                    if (message.copyrightYear != null && message.hasOwnProperty("copyrightYear"))
                        object.copyrightYear = message.copyrightYear;
                    if (message.songNumber != null && message.hasOwnProperty("songNumber"))
                        object.songNumber = message.songNumber;
                    if (message.display != null && message.hasOwnProperty("display"))
                        object.display = message.display;
                    if (message.album != null && message.hasOwnProperty("album"))
                        object.album = message.album;
                    if (message.artwork != null && message.hasOwnProperty("artwork"))
                        object.artwork = options.bytes === String ? $util.base64.encode(message.artwork, 0, message.artwork.length) : options.bytes === Array ? Array.prototype.slice.call(message.artwork) : message.artwork;
                    return object;
                };

                /**
                 * Converts this CCLI to JSON.
                 * @function toJSON
                 * @memberof rv.data.Presentation.CCLI
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CCLI.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for CCLI
                 * @function getTypeUrl
                 * @memberof rv.data.Presentation.CCLI
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                CCLI.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Presentation.CCLI";
                };

                return CCLI;
            })();

            Presentation.BibleReference = (function() {

                /**
                 * Properties of a BibleReference.
                 * @memberof rv.data.Presentation
                 * @interface IBibleReference
                 * @property {number|null} [bookIndex] BibleReference bookIndex
                 * @property {string|null} [bookName] BibleReference bookName
                 * @property {rv.data.IIntRange|null} [chapterRange] BibleReference chapterRange
                 * @property {rv.data.IIntRange|null} [verseRange] BibleReference verseRange
                 * @property {string|null} [translationName] BibleReference translationName
                 * @property {string|null} [translationDisplayAbbreviation] BibleReference translationDisplayAbbreviation
                 * @property {string|null} [translationInternalAbbreviation] BibleReference translationInternalAbbreviation
                 * @property {string|null} [bookKey] BibleReference bookKey
                 */

                /**
                 * Constructs a new BibleReference.
                 * @memberof rv.data.Presentation
                 * @classdesc Represents a BibleReference.
                 * @implements IBibleReference
                 * @constructor
                 * @param {rv.data.Presentation.IBibleReference=} [properties] Properties to set
                 */
                function BibleReference(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BibleReference bookIndex.
                 * @member {number} bookIndex
                 * @memberof rv.data.Presentation.BibleReference
                 * @instance
                 */
                BibleReference.prototype.bookIndex = 0;

                /**
                 * BibleReference bookName.
                 * @member {string} bookName
                 * @memberof rv.data.Presentation.BibleReference
                 * @instance
                 */
                BibleReference.prototype.bookName = "";

                /**
                 * BibleReference chapterRange.
                 * @member {rv.data.IIntRange|null|undefined} chapterRange
                 * @memberof rv.data.Presentation.BibleReference
                 * @instance
                 */
                BibleReference.prototype.chapterRange = null;

                /**
                 * BibleReference verseRange.
                 * @member {rv.data.IIntRange|null|undefined} verseRange
                 * @memberof rv.data.Presentation.BibleReference
                 * @instance
                 */
                BibleReference.prototype.verseRange = null;

                /**
                 * BibleReference translationName.
                 * @member {string} translationName
                 * @memberof rv.data.Presentation.BibleReference
                 * @instance
                 */
                BibleReference.prototype.translationName = "";

                /**
                 * BibleReference translationDisplayAbbreviation.
                 * @member {string} translationDisplayAbbreviation
                 * @memberof rv.data.Presentation.BibleReference
                 * @instance
                 */
                BibleReference.prototype.translationDisplayAbbreviation = "";

                /**
                 * BibleReference translationInternalAbbreviation.
                 * @member {string} translationInternalAbbreviation
                 * @memberof rv.data.Presentation.BibleReference
                 * @instance
                 */
                BibleReference.prototype.translationInternalAbbreviation = "";

                /**
                 * BibleReference bookKey.
                 * @member {string} bookKey
                 * @memberof rv.data.Presentation.BibleReference
                 * @instance
                 */
                BibleReference.prototype.bookKey = "";

                /**
                 * Creates a new BibleReference instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Presentation.BibleReference
                 * @static
                 * @param {rv.data.Presentation.IBibleReference=} [properties] Properties to set
                 * @returns {rv.data.Presentation.BibleReference} BibleReference instance
                 */
                BibleReference.create = function create(properties) {
                    return new BibleReference(properties);
                };

                /**
                 * Encodes the specified BibleReference message. Does not implicitly {@link rv.data.Presentation.BibleReference.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Presentation.BibleReference
                 * @static
                 * @param {rv.data.Presentation.IBibleReference} message BibleReference message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BibleReference.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bookIndex != null && Object.hasOwnProperty.call(message, "bookIndex"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.bookIndex);
                    if (message.bookName != null && Object.hasOwnProperty.call(message, "bookName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.bookName);
                    if (message.chapterRange != null && Object.hasOwnProperty.call(message, "chapterRange"))
                        $root.rv.data.IntRange.encode(message.chapterRange, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.verseRange != null && Object.hasOwnProperty.call(message, "verseRange"))
                        $root.rv.data.IntRange.encode(message.verseRange, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.translationName != null && Object.hasOwnProperty.call(message, "translationName"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.translationName);
                    if (message.translationDisplayAbbreviation != null && Object.hasOwnProperty.call(message, "translationDisplayAbbreviation"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.translationDisplayAbbreviation);
                    if (message.translationInternalAbbreviation != null && Object.hasOwnProperty.call(message, "translationInternalAbbreviation"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.translationInternalAbbreviation);
                    if (message.bookKey != null && Object.hasOwnProperty.call(message, "bookKey"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.bookKey);
                    return writer;
                };

                /**
                 * Encodes the specified BibleReference message, length delimited. Does not implicitly {@link rv.data.Presentation.BibleReference.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Presentation.BibleReference
                 * @static
                 * @param {rv.data.Presentation.IBibleReference} message BibleReference message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BibleReference.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BibleReference message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Presentation.BibleReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Presentation.BibleReference} BibleReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BibleReference.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Presentation.BibleReference();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.bookIndex = reader.uint32();
                                break;
                            }
                        case 2: {
                                message.bookName = reader.string();
                                break;
                            }
                        case 3: {
                                message.chapterRange = $root.rv.data.IntRange.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.verseRange = $root.rv.data.IntRange.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.translationName = reader.string();
                                break;
                            }
                        case 6: {
                                message.translationDisplayAbbreviation = reader.string();
                                break;
                            }
                        case 7: {
                                message.translationInternalAbbreviation = reader.string();
                                break;
                            }
                        case 8: {
                                message.bookKey = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BibleReference message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Presentation.BibleReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Presentation.BibleReference} BibleReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BibleReference.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BibleReference message.
                 * @function verify
                 * @memberof rv.data.Presentation.BibleReference
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BibleReference.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bookIndex != null && message.hasOwnProperty("bookIndex"))
                        if (!$util.isInteger(message.bookIndex))
                            return "bookIndex: integer expected";
                    if (message.bookName != null && message.hasOwnProperty("bookName"))
                        if (!$util.isString(message.bookName))
                            return "bookName: string expected";
                    if (message.chapterRange != null && message.hasOwnProperty("chapterRange")) {
                        let error = $root.rv.data.IntRange.verify(message.chapterRange);
                        if (error)
                            return "chapterRange." + error;
                    }
                    if (message.verseRange != null && message.hasOwnProperty("verseRange")) {
                        let error = $root.rv.data.IntRange.verify(message.verseRange);
                        if (error)
                            return "verseRange." + error;
                    }
                    if (message.translationName != null && message.hasOwnProperty("translationName"))
                        if (!$util.isString(message.translationName))
                            return "translationName: string expected";
                    if (message.translationDisplayAbbreviation != null && message.hasOwnProperty("translationDisplayAbbreviation"))
                        if (!$util.isString(message.translationDisplayAbbreviation))
                            return "translationDisplayAbbreviation: string expected";
                    if (message.translationInternalAbbreviation != null && message.hasOwnProperty("translationInternalAbbreviation"))
                        if (!$util.isString(message.translationInternalAbbreviation))
                            return "translationInternalAbbreviation: string expected";
                    if (message.bookKey != null && message.hasOwnProperty("bookKey"))
                        if (!$util.isString(message.bookKey))
                            return "bookKey: string expected";
                    return null;
                };

                /**
                 * Creates a BibleReference message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Presentation.BibleReference
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Presentation.BibleReference} BibleReference
                 */
                BibleReference.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Presentation.BibleReference)
                        return object;
                    let message = new $root.rv.data.Presentation.BibleReference();
                    if (object.bookIndex != null)
                        message.bookIndex = object.bookIndex >>> 0;
                    if (object.bookName != null)
                        message.bookName = String(object.bookName);
                    if (object.chapterRange != null) {
                        if (typeof object.chapterRange !== "object")
                            throw TypeError(".rv.data.Presentation.BibleReference.chapterRange: object expected");
                        message.chapterRange = $root.rv.data.IntRange.fromObject(object.chapterRange);
                    }
                    if (object.verseRange != null) {
                        if (typeof object.verseRange !== "object")
                            throw TypeError(".rv.data.Presentation.BibleReference.verseRange: object expected");
                        message.verseRange = $root.rv.data.IntRange.fromObject(object.verseRange);
                    }
                    if (object.translationName != null)
                        message.translationName = String(object.translationName);
                    if (object.translationDisplayAbbreviation != null)
                        message.translationDisplayAbbreviation = String(object.translationDisplayAbbreviation);
                    if (object.translationInternalAbbreviation != null)
                        message.translationInternalAbbreviation = String(object.translationInternalAbbreviation);
                    if (object.bookKey != null)
                        message.bookKey = String(object.bookKey);
                    return message;
                };

                /**
                 * Creates a plain object from a BibleReference message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Presentation.BibleReference
                 * @static
                 * @param {rv.data.Presentation.BibleReference} message BibleReference
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BibleReference.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.bookIndex = 0;
                        object.bookName = "";
                        object.chapterRange = null;
                        object.verseRange = null;
                        object.translationName = "";
                        object.translationDisplayAbbreviation = "";
                        object.translationInternalAbbreviation = "";
                        object.bookKey = "";
                    }
                    if (message.bookIndex != null && message.hasOwnProperty("bookIndex"))
                        object.bookIndex = message.bookIndex;
                    if (message.bookName != null && message.hasOwnProperty("bookName"))
                        object.bookName = message.bookName;
                    if (message.chapterRange != null && message.hasOwnProperty("chapterRange"))
                        object.chapterRange = $root.rv.data.IntRange.toObject(message.chapterRange, options);
                    if (message.verseRange != null && message.hasOwnProperty("verseRange"))
                        object.verseRange = $root.rv.data.IntRange.toObject(message.verseRange, options);
                    if (message.translationName != null && message.hasOwnProperty("translationName"))
                        object.translationName = message.translationName;
                    if (message.translationDisplayAbbreviation != null && message.hasOwnProperty("translationDisplayAbbreviation"))
                        object.translationDisplayAbbreviation = message.translationDisplayAbbreviation;
                    if (message.translationInternalAbbreviation != null && message.hasOwnProperty("translationInternalAbbreviation"))
                        object.translationInternalAbbreviation = message.translationInternalAbbreviation;
                    if (message.bookKey != null && message.hasOwnProperty("bookKey"))
                        object.bookKey = message.bookKey;
                    return object;
                };

                /**
                 * Converts this BibleReference to JSON.
                 * @function toJSON
                 * @memberof rv.data.Presentation.BibleReference
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BibleReference.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BibleReference
                 * @function getTypeUrl
                 * @memberof rv.data.Presentation.BibleReference
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BibleReference.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Presentation.BibleReference";
                };

                return BibleReference;
            })();

            Presentation.Timeline = (function() {

                /**
                 * Properties of a Timeline.
                 * @memberof rv.data.Presentation
                 * @interface ITimeline
                 * @property {Array.<rv.data.Presentation.Timeline.ICue>|null} [cues] Timeline cues
                 * @property {number|null} [duration] Timeline duration
                 * @property {boolean|null} [loop] Timeline loop
                 * @property {rv.data.IAction|null} [audioAction] Timeline audioAction
                 * @property {boolean|null} [timecodeEnable] Timeline timecodeEnable
                 * @property {number|null} [timecodeOffset] Timeline timecodeOffset
                 * @property {Array.<rv.data.Presentation.Timeline.ICue>|null} [cuesV2] Timeline cuesV2
                 */

                /**
                 * Constructs a new Timeline.
                 * @memberof rv.data.Presentation
                 * @classdesc Represents a Timeline.
                 * @implements ITimeline
                 * @constructor
                 * @param {rv.data.Presentation.ITimeline=} [properties] Properties to set
                 */
                function Timeline(properties) {
                    this.cues = [];
                    this.cuesV2 = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Timeline cues.
                 * @member {Array.<rv.data.Presentation.Timeline.ICue>} cues
                 * @memberof rv.data.Presentation.Timeline
                 * @instance
                 */
                Timeline.prototype.cues = $util.emptyArray;

                /**
                 * Timeline duration.
                 * @member {number} duration
                 * @memberof rv.data.Presentation.Timeline
                 * @instance
                 */
                Timeline.prototype.duration = 0;

                /**
                 * Timeline loop.
                 * @member {boolean} loop
                 * @memberof rv.data.Presentation.Timeline
                 * @instance
                 */
                Timeline.prototype.loop = false;

                /**
                 * Timeline audioAction.
                 * @member {rv.data.IAction|null|undefined} audioAction
                 * @memberof rv.data.Presentation.Timeline
                 * @instance
                 */
                Timeline.prototype.audioAction = null;

                /**
                 * Timeline timecodeEnable.
                 * @member {boolean} timecodeEnable
                 * @memberof rv.data.Presentation.Timeline
                 * @instance
                 */
                Timeline.prototype.timecodeEnable = false;

                /**
                 * Timeline timecodeOffset.
                 * @member {number} timecodeOffset
                 * @memberof rv.data.Presentation.Timeline
                 * @instance
                 */
                Timeline.prototype.timecodeOffset = 0;

                /**
                 * Timeline cuesV2.
                 * @member {Array.<rv.data.Presentation.Timeline.ICue>} cuesV2
                 * @memberof rv.data.Presentation.Timeline
                 * @instance
                 */
                Timeline.prototype.cuesV2 = $util.emptyArray;

                /**
                 * Creates a new Timeline instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Presentation.Timeline
                 * @static
                 * @param {rv.data.Presentation.ITimeline=} [properties] Properties to set
                 * @returns {rv.data.Presentation.Timeline} Timeline instance
                 */
                Timeline.create = function create(properties) {
                    return new Timeline(properties);
                };

                /**
                 * Encodes the specified Timeline message. Does not implicitly {@link rv.data.Presentation.Timeline.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Presentation.Timeline
                 * @static
                 * @param {rv.data.Presentation.ITimeline} message Timeline message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timeline.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.cues != null && message.cues.length)
                        for (let i = 0; i < message.cues.length; ++i)
                            $root.rv.data.Presentation.Timeline.Cue.encode(message.cues[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.duration);
                    if (message.loop != null && Object.hasOwnProperty.call(message, "loop"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.loop);
                    if (message.audioAction != null && Object.hasOwnProperty.call(message, "audioAction"))
                        $root.rv.data.Action.encode(message.audioAction, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.timecodeEnable != null && Object.hasOwnProperty.call(message, "timecodeEnable"))
                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.timecodeEnable);
                    if (message.timecodeOffset != null && Object.hasOwnProperty.call(message, "timecodeOffset"))
                        writer.uint32(/* id 10, wireType 1 =*/81).double(message.timecodeOffset);
                    if (message.cuesV2 != null && message.cuesV2.length)
                        for (let i = 0; i < message.cuesV2.length; ++i)
                            $root.rv.data.Presentation.Timeline.Cue.encode(message.cuesV2[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Timeline message, length delimited. Does not implicitly {@link rv.data.Presentation.Timeline.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Presentation.Timeline
                 * @static
                 * @param {rv.data.Presentation.ITimeline} message Timeline message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timeline.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Timeline message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Presentation.Timeline
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Presentation.Timeline} Timeline
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timeline.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Presentation.Timeline();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.cues && message.cues.length))
                                    message.cues = [];
                                message.cues.push($root.rv.data.Presentation.Timeline.Cue.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                message.duration = reader.double();
                                break;
                            }
                        case 6: {
                                message.loop = reader.bool();
                                break;
                            }
                        case 8: {
                                message.audioAction = $root.rv.data.Action.decode(reader, reader.uint32());
                                break;
                            }
                        case 9: {
                                message.timecodeEnable = reader.bool();
                                break;
                            }
                        case 10: {
                                message.timecodeOffset = reader.double();
                                break;
                            }
                        case 11: {
                                if (!(message.cuesV2 && message.cuesV2.length))
                                    message.cuesV2 = [];
                                message.cuesV2.push($root.rv.data.Presentation.Timeline.Cue.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Timeline message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Presentation.Timeline
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Presentation.Timeline} Timeline
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timeline.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Timeline message.
                 * @function verify
                 * @memberof rv.data.Presentation.Timeline
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Timeline.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cues != null && message.hasOwnProperty("cues")) {
                        if (!Array.isArray(message.cues))
                            return "cues: array expected";
                        for (let i = 0; i < message.cues.length; ++i) {
                            let error = $root.rv.data.Presentation.Timeline.Cue.verify(message.cues[i]);
                            if (error)
                                return "cues." + error;
                        }
                    }
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        if (typeof message.duration !== "number")
                            return "duration: number expected";
                    if (message.loop != null && message.hasOwnProperty("loop"))
                        if (typeof message.loop !== "boolean")
                            return "loop: boolean expected";
                    if (message.audioAction != null && message.hasOwnProperty("audioAction")) {
                        let error = $root.rv.data.Action.verify(message.audioAction);
                        if (error)
                            return "audioAction." + error;
                    }
                    if (message.timecodeEnable != null && message.hasOwnProperty("timecodeEnable"))
                        if (typeof message.timecodeEnable !== "boolean")
                            return "timecodeEnable: boolean expected";
                    if (message.timecodeOffset != null && message.hasOwnProperty("timecodeOffset"))
                        if (typeof message.timecodeOffset !== "number")
                            return "timecodeOffset: number expected";
                    if (message.cuesV2 != null && message.hasOwnProperty("cuesV2")) {
                        if (!Array.isArray(message.cuesV2))
                            return "cuesV2: array expected";
                        for (let i = 0; i < message.cuesV2.length; ++i) {
                            let error = $root.rv.data.Presentation.Timeline.Cue.verify(message.cuesV2[i]);
                            if (error)
                                return "cuesV2." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Timeline message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Presentation.Timeline
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Presentation.Timeline} Timeline
                 */
                Timeline.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Presentation.Timeline)
                        return object;
                    let message = new $root.rv.data.Presentation.Timeline();
                    if (object.cues) {
                        if (!Array.isArray(object.cues))
                            throw TypeError(".rv.data.Presentation.Timeline.cues: array expected");
                        message.cues = [];
                        for (let i = 0; i < object.cues.length; ++i) {
                            if (typeof object.cues[i] !== "object")
                                throw TypeError(".rv.data.Presentation.Timeline.cues: object expected");
                            message.cues[i] = $root.rv.data.Presentation.Timeline.Cue.fromObject(object.cues[i]);
                        }
                    }
                    if (object.duration != null)
                        message.duration = Number(object.duration);
                    if (object.loop != null)
                        message.loop = Boolean(object.loop);
                    if (object.audioAction != null) {
                        if (typeof object.audioAction !== "object")
                            throw TypeError(".rv.data.Presentation.Timeline.audioAction: object expected");
                        message.audioAction = $root.rv.data.Action.fromObject(object.audioAction);
                    }
                    if (object.timecodeEnable != null)
                        message.timecodeEnable = Boolean(object.timecodeEnable);
                    if (object.timecodeOffset != null)
                        message.timecodeOffset = Number(object.timecodeOffset);
                    if (object.cuesV2) {
                        if (!Array.isArray(object.cuesV2))
                            throw TypeError(".rv.data.Presentation.Timeline.cuesV2: array expected");
                        message.cuesV2 = [];
                        for (let i = 0; i < object.cuesV2.length; ++i) {
                            if (typeof object.cuesV2[i] !== "object")
                                throw TypeError(".rv.data.Presentation.Timeline.cuesV2: object expected");
                            message.cuesV2[i] = $root.rv.data.Presentation.Timeline.Cue.fromObject(object.cuesV2[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Timeline message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Presentation.Timeline
                 * @static
                 * @param {rv.data.Presentation.Timeline} message Timeline
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Timeline.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.cues = [];
                        object.cuesV2 = [];
                    }
                    if (options.defaults) {
                        object.duration = 0;
                        object.loop = false;
                        object.audioAction = null;
                        object.timecodeEnable = false;
                        object.timecodeOffset = 0;
                    }
                    if (message.cues && message.cues.length) {
                        object.cues = [];
                        for (let j = 0; j < message.cues.length; ++j)
                            object.cues[j] = $root.rv.data.Presentation.Timeline.Cue.toObject(message.cues[j], options);
                    }
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
                    if (message.loop != null && message.hasOwnProperty("loop"))
                        object.loop = message.loop;
                    if (message.audioAction != null && message.hasOwnProperty("audioAction"))
                        object.audioAction = $root.rv.data.Action.toObject(message.audioAction, options);
                    if (message.timecodeEnable != null && message.hasOwnProperty("timecodeEnable"))
                        object.timecodeEnable = message.timecodeEnable;
                    if (message.timecodeOffset != null && message.hasOwnProperty("timecodeOffset"))
                        object.timecodeOffset = options.json && !isFinite(message.timecodeOffset) ? String(message.timecodeOffset) : message.timecodeOffset;
                    if (message.cuesV2 && message.cuesV2.length) {
                        object.cuesV2 = [];
                        for (let j = 0; j < message.cuesV2.length; ++j)
                            object.cuesV2[j] = $root.rv.data.Presentation.Timeline.Cue.toObject(message.cuesV2[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Timeline to JSON.
                 * @function toJSON
                 * @memberof rv.data.Presentation.Timeline
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Timeline.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Timeline
                 * @function getTypeUrl
                 * @memberof rv.data.Presentation.Timeline
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Timeline.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Presentation.Timeline";
                };

                Timeline.Cue = (function() {

                    /**
                     * Properties of a Cue.
                     * @memberof rv.data.Presentation.Timeline
                     * @interface ICue
                     * @property {number|null} [triggerTime] Cue triggerTime
                     * @property {string|null} [name] Cue name
                     * @property {rv.data.IUUID|null} [cueId] Cue cueId
                     * @property {rv.data.IAction|null} [action] Cue action
                     */

                    /**
                     * Constructs a new Cue.
                     * @memberof rv.data.Presentation.Timeline
                     * @classdesc Represents a Cue.
                     * @implements ICue
                     * @constructor
                     * @param {rv.data.Presentation.Timeline.ICue=} [properties] Properties to set
                     */
                    function Cue(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Cue triggerTime.
                     * @member {number} triggerTime
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @instance
                     */
                    Cue.prototype.triggerTime = 0;

                    /**
                     * Cue name.
                     * @member {string} name
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @instance
                     */
                    Cue.prototype.name = "";

                    /**
                     * Cue cueId.
                     * @member {rv.data.IUUID|null|undefined} cueId
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @instance
                     */
                    Cue.prototype.cueId = null;

                    /**
                     * Cue action.
                     * @member {rv.data.IAction|null|undefined} action
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @instance
                     */
                    Cue.prototype.action = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Cue triggerInfo.
                     * @member {"cueId"|"action"|undefined} triggerInfo
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @instance
                     */
                    Object.defineProperty(Cue.prototype, "triggerInfo", {
                        get: $util.oneOfGetter($oneOfFields = ["cueId", "action"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new Cue instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @static
                     * @param {rv.data.Presentation.Timeline.ICue=} [properties] Properties to set
                     * @returns {rv.data.Presentation.Timeline.Cue} Cue instance
                     */
                    Cue.create = function create(properties) {
                        return new Cue(properties);
                    };

                    /**
                     * Encodes the specified Cue message. Does not implicitly {@link rv.data.Presentation.Timeline.Cue.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @static
                     * @param {rv.data.Presentation.Timeline.ICue} message Cue message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Cue.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.triggerTime != null && Object.hasOwnProperty.call(message, "triggerTime"))
                            writer.uint32(/* id 1, wireType 1 =*/9).double(message.triggerTime);
                        if (message.cueId != null && Object.hasOwnProperty.call(message, "cueId"))
                            $root.rv.data.UUID.encode(message.cueId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                        if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                            $root.rv.data.Action.encode(message.action, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Cue message, length delimited. Does not implicitly {@link rv.data.Presentation.Timeline.Cue.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @static
                     * @param {rv.data.Presentation.Timeline.ICue} message Cue message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Cue.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Cue message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Presentation.Timeline.Cue} Cue
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Cue.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Presentation.Timeline.Cue();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.triggerTime = reader.double();
                                    break;
                                }
                            case 3: {
                                    message.name = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.cueId = $root.rv.data.UUID.decode(reader, reader.uint32());
                                    break;
                                }
                            case 4: {
                                    message.action = $root.rv.data.Action.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Cue message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Presentation.Timeline.Cue} Cue
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Cue.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Cue message.
                     * @function verify
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Cue.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.triggerTime != null && message.hasOwnProperty("triggerTime"))
                            if (typeof message.triggerTime !== "number")
                                return "triggerTime: number expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.cueId != null && message.hasOwnProperty("cueId")) {
                            properties.triggerInfo = 1;
                            {
                                let error = $root.rv.data.UUID.verify(message.cueId);
                                if (error)
                                    return "cueId." + error;
                            }
                        }
                        if (message.action != null && message.hasOwnProperty("action")) {
                            if (properties.triggerInfo === 1)
                                return "triggerInfo: multiple values";
                            properties.triggerInfo = 1;
                            {
                                let error = $root.rv.data.Action.verify(message.action);
                                if (error)
                                    return "action." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Cue message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Presentation.Timeline.Cue} Cue
                     */
                    Cue.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Presentation.Timeline.Cue)
                            return object;
                        let message = new $root.rv.data.Presentation.Timeline.Cue();
                        if (object.triggerTime != null)
                            message.triggerTime = Number(object.triggerTime);
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.cueId != null) {
                            if (typeof object.cueId !== "object")
                                throw TypeError(".rv.data.Presentation.Timeline.Cue.cueId: object expected");
                            message.cueId = $root.rv.data.UUID.fromObject(object.cueId);
                        }
                        if (object.action != null) {
                            if (typeof object.action !== "object")
                                throw TypeError(".rv.data.Presentation.Timeline.Cue.action: object expected");
                            message.action = $root.rv.data.Action.fromObject(object.action);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Cue message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @static
                     * @param {rv.data.Presentation.Timeline.Cue} message Cue
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Cue.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.triggerTime = 0;
                            object.name = "";
                        }
                        if (message.triggerTime != null && message.hasOwnProperty("triggerTime"))
                            object.triggerTime = options.json && !isFinite(message.triggerTime) ? String(message.triggerTime) : message.triggerTime;
                        if (message.cueId != null && message.hasOwnProperty("cueId")) {
                            object.cueId = $root.rv.data.UUID.toObject(message.cueId, options);
                            if (options.oneofs)
                                object.triggerInfo = "cueId";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.action != null && message.hasOwnProperty("action")) {
                            object.action = $root.rv.data.Action.toObject(message.action, options);
                            if (options.oneofs)
                                object.triggerInfo = "action";
                        }
                        return object;
                    };

                    /**
                     * Converts this Cue to JSON.
                     * @function toJSON
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Cue.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Cue
                     * @function getTypeUrl
                     * @memberof rv.data.Presentation.Timeline.Cue
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Cue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Presentation.Timeline.Cue";
                    };

                    return Cue;
                })();

                return Timeline;
            })();

            Presentation.Arrangement = (function() {

                /**
                 * Properties of an Arrangement.
                 * @memberof rv.data.Presentation
                 * @interface IArrangement
                 * @property {rv.data.IUUID|null} [uuid] Arrangement uuid
                 * @property {string|null} [name] Arrangement name
                 * @property {Array.<rv.data.IUUID>|null} [groupIdentifiers] Arrangement groupIdentifiers
                 */

                /**
                 * Constructs a new Arrangement.
                 * @memberof rv.data.Presentation
                 * @classdesc Represents an Arrangement.
                 * @implements IArrangement
                 * @constructor
                 * @param {rv.data.Presentation.IArrangement=} [properties] Properties to set
                 */
                function Arrangement(properties) {
                    this.groupIdentifiers = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Arrangement uuid.
                 * @member {rv.data.IUUID|null|undefined} uuid
                 * @memberof rv.data.Presentation.Arrangement
                 * @instance
                 */
                Arrangement.prototype.uuid = null;

                /**
                 * Arrangement name.
                 * @member {string} name
                 * @memberof rv.data.Presentation.Arrangement
                 * @instance
                 */
                Arrangement.prototype.name = "";

                /**
                 * Arrangement groupIdentifiers.
                 * @member {Array.<rv.data.IUUID>} groupIdentifiers
                 * @memberof rv.data.Presentation.Arrangement
                 * @instance
                 */
                Arrangement.prototype.groupIdentifiers = $util.emptyArray;

                /**
                 * Creates a new Arrangement instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Presentation.Arrangement
                 * @static
                 * @param {rv.data.Presentation.IArrangement=} [properties] Properties to set
                 * @returns {rv.data.Presentation.Arrangement} Arrangement instance
                 */
                Arrangement.create = function create(properties) {
                    return new Arrangement(properties);
                };

                /**
                 * Encodes the specified Arrangement message. Does not implicitly {@link rv.data.Presentation.Arrangement.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Presentation.Arrangement
                 * @static
                 * @param {rv.data.Presentation.IArrangement} message Arrangement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Arrangement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                        $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.groupIdentifiers != null && message.groupIdentifiers.length)
                        for (let i = 0; i < message.groupIdentifiers.length; ++i)
                            $root.rv.data.UUID.encode(message.groupIdentifiers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Arrangement message, length delimited. Does not implicitly {@link rv.data.Presentation.Arrangement.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Presentation.Arrangement
                 * @static
                 * @param {rv.data.Presentation.IArrangement} message Arrangement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Arrangement.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Arrangement message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Presentation.Arrangement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Presentation.Arrangement} Arrangement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Arrangement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Presentation.Arrangement();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.name = reader.string();
                                break;
                            }
                        case 3: {
                                if (!(message.groupIdentifiers && message.groupIdentifiers.length))
                                    message.groupIdentifiers = [];
                                message.groupIdentifiers.push($root.rv.data.UUID.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Arrangement message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Presentation.Arrangement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Presentation.Arrangement} Arrangement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Arrangement.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Arrangement message.
                 * @function verify
                 * @memberof rv.data.Presentation.Arrangement
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Arrangement.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uuid != null && message.hasOwnProperty("uuid")) {
                        let error = $root.rv.data.UUID.verify(message.uuid);
                        if (error)
                            return "uuid." + error;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.groupIdentifiers != null && message.hasOwnProperty("groupIdentifiers")) {
                        if (!Array.isArray(message.groupIdentifiers))
                            return "groupIdentifiers: array expected";
                        for (let i = 0; i < message.groupIdentifiers.length; ++i) {
                            let error = $root.rv.data.UUID.verify(message.groupIdentifiers[i]);
                            if (error)
                                return "groupIdentifiers." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Arrangement message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Presentation.Arrangement
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Presentation.Arrangement} Arrangement
                 */
                Arrangement.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Presentation.Arrangement)
                        return object;
                    let message = new $root.rv.data.Presentation.Arrangement();
                    if (object.uuid != null) {
                        if (typeof object.uuid !== "object")
                            throw TypeError(".rv.data.Presentation.Arrangement.uuid: object expected");
                        message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.groupIdentifiers) {
                        if (!Array.isArray(object.groupIdentifiers))
                            throw TypeError(".rv.data.Presentation.Arrangement.groupIdentifiers: array expected");
                        message.groupIdentifiers = [];
                        for (let i = 0; i < object.groupIdentifiers.length; ++i) {
                            if (typeof object.groupIdentifiers[i] !== "object")
                                throw TypeError(".rv.data.Presentation.Arrangement.groupIdentifiers: object expected");
                            message.groupIdentifiers[i] = $root.rv.data.UUID.fromObject(object.groupIdentifiers[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Arrangement message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Presentation.Arrangement
                 * @static
                 * @param {rv.data.Presentation.Arrangement} message Arrangement
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Arrangement.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.groupIdentifiers = [];
                    if (options.defaults) {
                        object.uuid = null;
                        object.name = "";
                    }
                    if (message.uuid != null && message.hasOwnProperty("uuid"))
                        object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.groupIdentifiers && message.groupIdentifiers.length) {
                        object.groupIdentifiers = [];
                        for (let j = 0; j < message.groupIdentifiers.length; ++j)
                            object.groupIdentifiers[j] = $root.rv.data.UUID.toObject(message.groupIdentifiers[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Arrangement to JSON.
                 * @function toJSON
                 * @memberof rv.data.Presentation.Arrangement
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Arrangement.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Arrangement
                 * @function getTypeUrl
                 * @memberof rv.data.Presentation.Arrangement
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Arrangement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Presentation.Arrangement";
                };

                return Arrangement;
            })();

            Presentation.CueGroup = (function() {

                /**
                 * Properties of a CueGroup.
                 * @memberof rv.data.Presentation
                 * @interface ICueGroup
                 * @property {rv.data.IGroup|null} [group] CueGroup group
                 * @property {Array.<rv.data.IUUID>|null} [cueIdentifiers] CueGroup cueIdentifiers
                 */

                /**
                 * Constructs a new CueGroup.
                 * @memberof rv.data.Presentation
                 * @classdesc Represents a CueGroup.
                 * @implements ICueGroup
                 * @constructor
                 * @param {rv.data.Presentation.ICueGroup=} [properties] Properties to set
                 */
                function CueGroup(properties) {
                    this.cueIdentifiers = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CueGroup group.
                 * @member {rv.data.IGroup|null|undefined} group
                 * @memberof rv.data.Presentation.CueGroup
                 * @instance
                 */
                CueGroup.prototype.group = null;

                /**
                 * CueGroup cueIdentifiers.
                 * @member {Array.<rv.data.IUUID>} cueIdentifiers
                 * @memberof rv.data.Presentation.CueGroup
                 * @instance
                 */
                CueGroup.prototype.cueIdentifiers = $util.emptyArray;

                /**
                 * Creates a new CueGroup instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Presentation.CueGroup
                 * @static
                 * @param {rv.data.Presentation.ICueGroup=} [properties] Properties to set
                 * @returns {rv.data.Presentation.CueGroup} CueGroup instance
                 */
                CueGroup.create = function create(properties) {
                    return new CueGroup(properties);
                };

                /**
                 * Encodes the specified CueGroup message. Does not implicitly {@link rv.data.Presentation.CueGroup.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Presentation.CueGroup
                 * @static
                 * @param {rv.data.Presentation.ICueGroup} message CueGroup message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CueGroup.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.group != null && Object.hasOwnProperty.call(message, "group"))
                        $root.rv.data.Group.encode(message.group, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.cueIdentifiers != null && message.cueIdentifiers.length)
                        for (let i = 0; i < message.cueIdentifiers.length; ++i)
                            $root.rv.data.UUID.encode(message.cueIdentifiers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CueGroup message, length delimited. Does not implicitly {@link rv.data.Presentation.CueGroup.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Presentation.CueGroup
                 * @static
                 * @param {rv.data.Presentation.ICueGroup} message CueGroup message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CueGroup.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CueGroup message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Presentation.CueGroup
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Presentation.CueGroup} CueGroup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CueGroup.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Presentation.CueGroup();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.group = $root.rv.data.Group.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                if (!(message.cueIdentifiers && message.cueIdentifiers.length))
                                    message.cueIdentifiers = [];
                                message.cueIdentifiers.push($root.rv.data.UUID.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CueGroup message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Presentation.CueGroup
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Presentation.CueGroup} CueGroup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CueGroup.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CueGroup message.
                 * @function verify
                 * @memberof rv.data.Presentation.CueGroup
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CueGroup.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.group != null && message.hasOwnProperty("group")) {
                        let error = $root.rv.data.Group.verify(message.group);
                        if (error)
                            return "group." + error;
                    }
                    if (message.cueIdentifiers != null && message.hasOwnProperty("cueIdentifiers")) {
                        if (!Array.isArray(message.cueIdentifiers))
                            return "cueIdentifiers: array expected";
                        for (let i = 0; i < message.cueIdentifiers.length; ++i) {
                            let error = $root.rv.data.UUID.verify(message.cueIdentifiers[i]);
                            if (error)
                                return "cueIdentifiers." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a CueGroup message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Presentation.CueGroup
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Presentation.CueGroup} CueGroup
                 */
                CueGroup.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Presentation.CueGroup)
                        return object;
                    let message = new $root.rv.data.Presentation.CueGroup();
                    if (object.group != null) {
                        if (typeof object.group !== "object")
                            throw TypeError(".rv.data.Presentation.CueGroup.group: object expected");
                        message.group = $root.rv.data.Group.fromObject(object.group);
                    }
                    if (object.cueIdentifiers) {
                        if (!Array.isArray(object.cueIdentifiers))
                            throw TypeError(".rv.data.Presentation.CueGroup.cueIdentifiers: array expected");
                        message.cueIdentifiers = [];
                        for (let i = 0; i < object.cueIdentifiers.length; ++i) {
                            if (typeof object.cueIdentifiers[i] !== "object")
                                throw TypeError(".rv.data.Presentation.CueGroup.cueIdentifiers: object expected");
                            message.cueIdentifiers[i] = $root.rv.data.UUID.fromObject(object.cueIdentifiers[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CueGroup message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Presentation.CueGroup
                 * @static
                 * @param {rv.data.Presentation.CueGroup} message CueGroup
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CueGroup.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.cueIdentifiers = [];
                    if (options.defaults)
                        object.group = null;
                    if (message.group != null && message.hasOwnProperty("group"))
                        object.group = $root.rv.data.Group.toObject(message.group, options);
                    if (message.cueIdentifiers && message.cueIdentifiers.length) {
                        object.cueIdentifiers = [];
                        for (let j = 0; j < message.cueIdentifiers.length; ++j)
                            object.cueIdentifiers[j] = $root.rv.data.UUID.toObject(message.cueIdentifiers[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this CueGroup to JSON.
                 * @function toJSON
                 * @memberof rv.data.Presentation.CueGroup
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CueGroup.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for CueGroup
                 * @function getTypeUrl
                 * @memberof rv.data.Presentation.CueGroup
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                CueGroup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Presentation.CueGroup";
                };

                return CueGroup;
            })();

            Presentation.MultiTracksLicensing = (function() {

                /**
                 * Properties of a MultiTracksLicensing.
                 * @memberof rv.data.Presentation
                 * @interface IMultiTracksLicensing
                 * @property {number|Long|null} [songIdentifier] MultiTracksLicensing songIdentifier
                 * @property {string|null} [customerIdentifier] MultiTracksLicensing customerIdentifier
                 * @property {rv.data.ITimestamp|null} [expirationDate] MultiTracksLicensing expirationDate
                 * @property {rv.data.ITimestamp|null} [licenseExpiration] MultiTracksLicensing licenseExpiration
                 * @property {rv.data.Presentation.MultiTracksLicensing.Subscription|null} [subscription] MultiTracksLicensing subscription
                 */

                /**
                 * Constructs a new MultiTracksLicensing.
                 * @memberof rv.data.Presentation
                 * @classdesc Represents a MultiTracksLicensing.
                 * @implements IMultiTracksLicensing
                 * @constructor
                 * @param {rv.data.Presentation.IMultiTracksLicensing=} [properties] Properties to set
                 */
                function MultiTracksLicensing(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MultiTracksLicensing songIdentifier.
                 * @member {number|Long} songIdentifier
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @instance
                 */
                MultiTracksLicensing.prototype.songIdentifier = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MultiTracksLicensing customerIdentifier.
                 * @member {string} customerIdentifier
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @instance
                 */
                MultiTracksLicensing.prototype.customerIdentifier = "";

                /**
                 * MultiTracksLicensing expirationDate.
                 * @member {rv.data.ITimestamp|null|undefined} expirationDate
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @instance
                 */
                MultiTracksLicensing.prototype.expirationDate = null;

                /**
                 * MultiTracksLicensing licenseExpiration.
                 * @member {rv.data.ITimestamp|null|undefined} licenseExpiration
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @instance
                 */
                MultiTracksLicensing.prototype.licenseExpiration = null;

                /**
                 * MultiTracksLicensing subscription.
                 * @member {rv.data.Presentation.MultiTracksLicensing.Subscription} subscription
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @instance
                 */
                MultiTracksLicensing.prototype.subscription = 0;

                /**
                 * Creates a new MultiTracksLicensing instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @static
                 * @param {rv.data.Presentation.IMultiTracksLicensing=} [properties] Properties to set
                 * @returns {rv.data.Presentation.MultiTracksLicensing} MultiTracksLicensing instance
                 */
                MultiTracksLicensing.create = function create(properties) {
                    return new MultiTracksLicensing(properties);
                };

                /**
                 * Encodes the specified MultiTracksLicensing message. Does not implicitly {@link rv.data.Presentation.MultiTracksLicensing.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @static
                 * @param {rv.data.Presentation.IMultiTracksLicensing} message MultiTracksLicensing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MultiTracksLicensing.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.songIdentifier != null && Object.hasOwnProperty.call(message, "songIdentifier"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.songIdentifier);
                    if (message.customerIdentifier != null && Object.hasOwnProperty.call(message, "customerIdentifier"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.customerIdentifier);
                    if (message.expirationDate != null && Object.hasOwnProperty.call(message, "expirationDate"))
                        $root.rv.data.Timestamp.encode(message.expirationDate, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.licenseExpiration != null && Object.hasOwnProperty.call(message, "licenseExpiration"))
                        $root.rv.data.Timestamp.encode(message.licenseExpiration, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.subscription != null && Object.hasOwnProperty.call(message, "subscription"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.subscription);
                    return writer;
                };

                /**
                 * Encodes the specified MultiTracksLicensing message, length delimited. Does not implicitly {@link rv.data.Presentation.MultiTracksLicensing.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @static
                 * @param {rv.data.Presentation.IMultiTracksLicensing} message MultiTracksLicensing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MultiTracksLicensing.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MultiTracksLicensing message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Presentation.MultiTracksLicensing} MultiTracksLicensing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MultiTracksLicensing.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Presentation.MultiTracksLicensing();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.songIdentifier = reader.int64();
                                break;
                            }
                        case 2: {
                                message.customerIdentifier = reader.string();
                                break;
                            }
                        case 3: {
                                message.expirationDate = $root.rv.data.Timestamp.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.licenseExpiration = $root.rv.data.Timestamp.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.subscription = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MultiTracksLicensing message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Presentation.MultiTracksLicensing} MultiTracksLicensing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MultiTracksLicensing.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MultiTracksLicensing message.
                 * @function verify
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MultiTracksLicensing.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.songIdentifier != null && message.hasOwnProperty("songIdentifier"))
                        if (!$util.isInteger(message.songIdentifier) && !(message.songIdentifier && $util.isInteger(message.songIdentifier.low) && $util.isInteger(message.songIdentifier.high)))
                            return "songIdentifier: integer|Long expected";
                    if (message.customerIdentifier != null && message.hasOwnProperty("customerIdentifier"))
                        if (!$util.isString(message.customerIdentifier))
                            return "customerIdentifier: string expected";
                    if (message.expirationDate != null && message.hasOwnProperty("expirationDate")) {
                        let error = $root.rv.data.Timestamp.verify(message.expirationDate);
                        if (error)
                            return "expirationDate." + error;
                    }
                    if (message.licenseExpiration != null && message.hasOwnProperty("licenseExpiration")) {
                        let error = $root.rv.data.Timestamp.verify(message.licenseExpiration);
                        if (error)
                            return "licenseExpiration." + error;
                    }
                    if (message.subscription != null && message.hasOwnProperty("subscription"))
                        switch (message.subscription) {
                        default:
                            return "subscription: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a MultiTracksLicensing message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Presentation.MultiTracksLicensing} MultiTracksLicensing
                 */
                MultiTracksLicensing.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Presentation.MultiTracksLicensing)
                        return object;
                    let message = new $root.rv.data.Presentation.MultiTracksLicensing();
                    if (object.songIdentifier != null)
                        if ($util.Long)
                            (message.songIdentifier = $util.Long.fromValue(object.songIdentifier)).unsigned = false;
                        else if (typeof object.songIdentifier === "string")
                            message.songIdentifier = parseInt(object.songIdentifier, 10);
                        else if (typeof object.songIdentifier === "number")
                            message.songIdentifier = object.songIdentifier;
                        else if (typeof object.songIdentifier === "object")
                            message.songIdentifier = new $util.LongBits(object.songIdentifier.low >>> 0, object.songIdentifier.high >>> 0).toNumber();
                    if (object.customerIdentifier != null)
                        message.customerIdentifier = String(object.customerIdentifier);
                    if (object.expirationDate != null) {
                        if (typeof object.expirationDate !== "object")
                            throw TypeError(".rv.data.Presentation.MultiTracksLicensing.expirationDate: object expected");
                        message.expirationDate = $root.rv.data.Timestamp.fromObject(object.expirationDate);
                    }
                    if (object.licenseExpiration != null) {
                        if (typeof object.licenseExpiration !== "object")
                            throw TypeError(".rv.data.Presentation.MultiTracksLicensing.licenseExpiration: object expected");
                        message.licenseExpiration = $root.rv.data.Timestamp.fromObject(object.licenseExpiration);
                    }
                    switch (object.subscription) {
                    default:
                        if (typeof object.subscription === "number") {
                            message.subscription = object.subscription;
                            break;
                        }
                        break;
                    case "SUBSCRIPTION_CHART_PRO":
                    case 0:
                        message.subscription = 0;
                        break;
                    case "SUBSCRIPTION_SLIDE_PRO":
                    case 1:
                        message.subscription = 1;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MultiTracksLicensing message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @static
                 * @param {rv.data.Presentation.MultiTracksLicensing} message MultiTracksLicensing
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MultiTracksLicensing.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.songIdentifier = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.songIdentifier = options.longs === String ? "0" : 0;
                        object.customerIdentifier = "";
                        object.expirationDate = null;
                        object.licenseExpiration = null;
                        object.subscription = options.enums === String ? "SUBSCRIPTION_CHART_PRO" : 0;
                    }
                    if (message.songIdentifier != null && message.hasOwnProperty("songIdentifier"))
                        if (typeof message.songIdentifier === "number")
                            object.songIdentifier = options.longs === String ? String(message.songIdentifier) : message.songIdentifier;
                        else
                            object.songIdentifier = options.longs === String ? $util.Long.prototype.toString.call(message.songIdentifier) : options.longs === Number ? new $util.LongBits(message.songIdentifier.low >>> 0, message.songIdentifier.high >>> 0).toNumber() : message.songIdentifier;
                    if (message.customerIdentifier != null && message.hasOwnProperty("customerIdentifier"))
                        object.customerIdentifier = message.customerIdentifier;
                    if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                        object.expirationDate = $root.rv.data.Timestamp.toObject(message.expirationDate, options);
                    if (message.licenseExpiration != null && message.hasOwnProperty("licenseExpiration"))
                        object.licenseExpiration = $root.rv.data.Timestamp.toObject(message.licenseExpiration, options);
                    if (message.subscription != null && message.hasOwnProperty("subscription"))
                        object.subscription = options.enums === String ? $root.rv.data.Presentation.MultiTracksLicensing.Subscription[message.subscription] === undefined ? message.subscription : $root.rv.data.Presentation.MultiTracksLicensing.Subscription[message.subscription] : message.subscription;
                    return object;
                };

                /**
                 * Converts this MultiTracksLicensing to JSON.
                 * @function toJSON
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MultiTracksLicensing.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MultiTracksLicensing
                 * @function getTypeUrl
                 * @memberof rv.data.Presentation.MultiTracksLicensing
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MultiTracksLicensing.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Presentation.MultiTracksLicensing";
                };

                /**
                 * Subscription enum.
                 * @name rv.data.Presentation.MultiTracksLicensing.Subscription
                 * @enum {number}
                 * @property {number} SUBSCRIPTION_CHART_PRO=0 SUBSCRIPTION_CHART_PRO value
                 * @property {number} SUBSCRIPTION_SLIDE_PRO=1 SUBSCRIPTION_SLIDE_PRO value
                 */
                MultiTracksLicensing.Subscription = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "SUBSCRIPTION_CHART_PRO"] = 0;
                    values[valuesById[1] = "SUBSCRIPTION_SLIDE_PRO"] = 1;
                    return values;
                })();

                return MultiTracksLicensing;
            })();

            Presentation.Music = (function() {

                /**
                 * Properties of a Music.
                 * @memberof rv.data.Presentation
                 * @interface IMusic
                 * @property {string|null} [originalMusicKey] Music originalMusicKey
                 * @property {string|null} [userMusicKey] Music userMusicKey
                 * @property {rv.data.IMusicKeyScale|null} [original] Music original
                 * @property {rv.data.IMusicKeyScale|null} [user] Music user
                 */

                /**
                 * Constructs a new Music.
                 * @memberof rv.data.Presentation
                 * @classdesc Represents a Music.
                 * @implements IMusic
                 * @constructor
                 * @param {rv.data.Presentation.IMusic=} [properties] Properties to set
                 */
                function Music(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Music originalMusicKey.
                 * @member {string} originalMusicKey
                 * @memberof rv.data.Presentation.Music
                 * @instance
                 */
                Music.prototype.originalMusicKey = "";

                /**
                 * Music userMusicKey.
                 * @member {string} userMusicKey
                 * @memberof rv.data.Presentation.Music
                 * @instance
                 */
                Music.prototype.userMusicKey = "";

                /**
                 * Music original.
                 * @member {rv.data.IMusicKeyScale|null|undefined} original
                 * @memberof rv.data.Presentation.Music
                 * @instance
                 */
                Music.prototype.original = null;

                /**
                 * Music user.
                 * @member {rv.data.IMusicKeyScale|null|undefined} user
                 * @memberof rv.data.Presentation.Music
                 * @instance
                 */
                Music.prototype.user = null;

                /**
                 * Creates a new Music instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Presentation.Music
                 * @static
                 * @param {rv.data.Presentation.IMusic=} [properties] Properties to set
                 * @returns {rv.data.Presentation.Music} Music instance
                 */
                Music.create = function create(properties) {
                    return new Music(properties);
                };

                /**
                 * Encodes the specified Music message. Does not implicitly {@link rv.data.Presentation.Music.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Presentation.Music
                 * @static
                 * @param {rv.data.Presentation.IMusic} message Music message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Music.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.originalMusicKey != null && Object.hasOwnProperty.call(message, "originalMusicKey"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.originalMusicKey);
                    if (message.userMusicKey != null && Object.hasOwnProperty.call(message, "userMusicKey"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.userMusicKey);
                    if (message.original != null && Object.hasOwnProperty.call(message, "original"))
                        $root.rv.data.MusicKeyScale.encode(message.original, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                        $root.rv.data.MusicKeyScale.encode(message.user, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Music message, length delimited. Does not implicitly {@link rv.data.Presentation.Music.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Presentation.Music
                 * @static
                 * @param {rv.data.Presentation.IMusic} message Music message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Music.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Music message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Presentation.Music
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Presentation.Music} Music
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Music.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Presentation.Music();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.originalMusicKey = reader.string();
                                break;
                            }
                        case 2: {
                                message.userMusicKey = reader.string();
                                break;
                            }
                        case 3: {
                                message.original = $root.rv.data.MusicKeyScale.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.user = $root.rv.data.MusicKeyScale.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Music message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Presentation.Music
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Presentation.Music} Music
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Music.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Music message.
                 * @function verify
                 * @memberof rv.data.Presentation.Music
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Music.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.originalMusicKey != null && message.hasOwnProperty("originalMusicKey"))
                        if (!$util.isString(message.originalMusicKey))
                            return "originalMusicKey: string expected";
                    if (message.userMusicKey != null && message.hasOwnProperty("userMusicKey"))
                        if (!$util.isString(message.userMusicKey))
                            return "userMusicKey: string expected";
                    if (message.original != null && message.hasOwnProperty("original")) {
                        let error = $root.rv.data.MusicKeyScale.verify(message.original);
                        if (error)
                            return "original." + error;
                    }
                    if (message.user != null && message.hasOwnProperty("user")) {
                        let error = $root.rv.data.MusicKeyScale.verify(message.user);
                        if (error)
                            return "user." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Music message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Presentation.Music
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Presentation.Music} Music
                 */
                Music.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Presentation.Music)
                        return object;
                    let message = new $root.rv.data.Presentation.Music();
                    if (object.originalMusicKey != null)
                        message.originalMusicKey = String(object.originalMusicKey);
                    if (object.userMusicKey != null)
                        message.userMusicKey = String(object.userMusicKey);
                    if (object.original != null) {
                        if (typeof object.original !== "object")
                            throw TypeError(".rv.data.Presentation.Music.original: object expected");
                        message.original = $root.rv.data.MusicKeyScale.fromObject(object.original);
                    }
                    if (object.user != null) {
                        if (typeof object.user !== "object")
                            throw TypeError(".rv.data.Presentation.Music.user: object expected");
                        message.user = $root.rv.data.MusicKeyScale.fromObject(object.user);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Music message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Presentation.Music
                 * @static
                 * @param {rv.data.Presentation.Music} message Music
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Music.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.originalMusicKey = "";
                        object.userMusicKey = "";
                        object.original = null;
                        object.user = null;
                    }
                    if (message.originalMusicKey != null && message.hasOwnProperty("originalMusicKey"))
                        object.originalMusicKey = message.originalMusicKey;
                    if (message.userMusicKey != null && message.hasOwnProperty("userMusicKey"))
                        object.userMusicKey = message.userMusicKey;
                    if (message.original != null && message.hasOwnProperty("original"))
                        object.original = $root.rv.data.MusicKeyScale.toObject(message.original, options);
                    if (message.user != null && message.hasOwnProperty("user"))
                        object.user = $root.rv.data.MusicKeyScale.toObject(message.user, options);
                    return object;
                };

                /**
                 * Converts this Music to JSON.
                 * @function toJSON
                 * @memberof rv.data.Presentation.Music
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Music.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Music
                 * @function getTypeUrl
                 * @memberof rv.data.Presentation.Music
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Music.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Presentation.Music";
                };

                return Music;
            })();

            return Presentation;
        })();

        data.Action = (function() {

            /**
             * Properties of an Action.
             * @memberof rv.data
             * @interface IAction
             * @property {rv.data.IUUID|null} [uuid] Action uuid
             * @property {string|null} [name] Action name
             * @property {rv.data.Action.ILabel|null} [label] Action label
             * @property {number|null} [delayTime] Action delayTime
             * @property {rv.data.Action.IOldType|null} [oldType] Action oldType
             * @property {boolean|null} [isEnabled] Action isEnabled
             * @property {rv.data.Action.ILayerIdentification|null} [layerIdentification] Action layerIdentification
             * @property {number|null} [duration] Action duration
             * @property {rv.data.Action.ActionType|null} [type] Action type
             * @property {rv.data.ICollectionElementType|null} [collectionElement] Action collectionElement
             * @property {rv.data.Action.IPlaylistItemType|null} [playlistItem] Action playlistItem
             * @property {rv.data.Action.IBlendModeType|null} [blendMode] Action blendMode
             * @property {rv.data.Action.ITransitionType|null} [transition] Action transition
             * @property {rv.data.Action.IMediaType|null} [media] Action media
             * @property {rv.data.Action.IDoubleType|null} [doubleItem] Action doubleItem
             * @property {rv.data.Action.IEffectsType|null} [effects] Action effects
             * @property {rv.data.Action.ISlideType|null} [slide] Action slide
             * @property {rv.data.Action.IBackgroundType|null} [background] Action background
             * @property {rv.data.Action.ITimerType|null} [timer] Action timer
             * @property {rv.data.Action.IClearType|null} [clear] Action clear
             * @property {rv.data.Action.IStageLayoutType|null} [stage] Action stage
             * @property {rv.data.Action.IPropType|null} [prop] Action prop
             * @property {rv.data.Action.IMaskType|null} [mask] Action mask
             * @property {rv.data.Action.IMessageType|null} [message] Action message
             * @property {rv.data.Action.ICommunicationType|null} [communication] Action communication
             * @property {rv.data.Action.IMultiScreenType|null} [multiScreen] Action multiScreen
             * @property {rv.data.Action.IDocumentType|null} [presentationDocument] Action presentationDocument
             * @property {rv.data.Action.IExternalPresentationType|null} [externalPresentation] Action externalPresentation
             * @property {rv.data.Action.IAudienceLookType|null} [audienceLook] Action audienceLook
             * @property {rv.data.Action.IAudioInputType|null} [audioInput] Action audioInput
             * @property {rv.data.Action.ISlideDestinationType|null} [slideDestination] Action slideDestination
             * @property {rv.data.Action.IMacroType|null} [macro] Action macro
             * @property {rv.data.Action.IClearGroupType|null} [clearGroup] Action clearGroup
             * @property {rv.data.Action.ITransportControlType|null} [transportControl] Action transportControl
             * @property {rv.data.Action.ICaptureType|null} [capture] Action capture
             */

            /**
             * Constructs a new Action.
             * @memberof rv.data
             * @classdesc Represents an Action.
             * @implements IAction
             * @constructor
             * @param {rv.data.IAction=} [properties] Properties to set
             */
            function Action(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Action uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.uuid = null;

            /**
             * Action name.
             * @member {string} name
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.name = "";

            /**
             * Action label.
             * @member {rv.data.Action.ILabel|null|undefined} label
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.label = null;

            /**
             * Action delayTime.
             * @member {number} delayTime
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.delayTime = 0;

            /**
             * Action oldType.
             * @member {rv.data.Action.IOldType|null|undefined} oldType
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.oldType = null;

            /**
             * Action isEnabled.
             * @member {boolean} isEnabled
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.isEnabled = false;

            /**
             * Action layerIdentification.
             * @member {rv.data.Action.ILayerIdentification|null|undefined} layerIdentification
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.layerIdentification = null;

            /**
             * Action duration.
             * @member {number} duration
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.duration = 0;

            /**
             * Action type.
             * @member {rv.data.Action.ActionType} type
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.type = 0;

            /**
             * Action collectionElement.
             * @member {rv.data.ICollectionElementType|null|undefined} collectionElement
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.collectionElement = null;

            /**
             * Action playlistItem.
             * @member {rv.data.Action.IPlaylistItemType|null|undefined} playlistItem
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.playlistItem = null;

            /**
             * Action blendMode.
             * @member {rv.data.Action.IBlendModeType|null|undefined} blendMode
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.blendMode = null;

            /**
             * Action transition.
             * @member {rv.data.Action.ITransitionType|null|undefined} transition
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.transition = null;

            /**
             * Action media.
             * @member {rv.data.Action.IMediaType|null|undefined} media
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.media = null;

            /**
             * Action doubleItem.
             * @member {rv.data.Action.IDoubleType|null|undefined} doubleItem
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.doubleItem = null;

            /**
             * Action effects.
             * @member {rv.data.Action.IEffectsType|null|undefined} effects
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.effects = null;

            /**
             * Action slide.
             * @member {rv.data.Action.ISlideType|null|undefined} slide
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.slide = null;

            /**
             * Action background.
             * @member {rv.data.Action.IBackgroundType|null|undefined} background
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.background = null;

            /**
             * Action timer.
             * @member {rv.data.Action.ITimerType|null|undefined} timer
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.timer = null;

            /**
             * Action clear.
             * @member {rv.data.Action.IClearType|null|undefined} clear
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.clear = null;

            /**
             * Action stage.
             * @member {rv.data.Action.IStageLayoutType|null|undefined} stage
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.stage = null;

            /**
             * Action prop.
             * @member {rv.data.Action.IPropType|null|undefined} prop
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.prop = null;

            /**
             * Action mask.
             * @member {rv.data.Action.IMaskType|null|undefined} mask
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.mask = null;

            /**
             * Action message.
             * @member {rv.data.Action.IMessageType|null|undefined} message
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.message = null;

            /**
             * Action communication.
             * @member {rv.data.Action.ICommunicationType|null|undefined} communication
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.communication = null;

            /**
             * Action multiScreen.
             * @member {rv.data.Action.IMultiScreenType|null|undefined} multiScreen
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.multiScreen = null;

            /**
             * Action presentationDocument.
             * @member {rv.data.Action.IDocumentType|null|undefined} presentationDocument
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.presentationDocument = null;

            /**
             * Action externalPresentation.
             * @member {rv.data.Action.IExternalPresentationType|null|undefined} externalPresentation
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.externalPresentation = null;

            /**
             * Action audienceLook.
             * @member {rv.data.Action.IAudienceLookType|null|undefined} audienceLook
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.audienceLook = null;

            /**
             * Action audioInput.
             * @member {rv.data.Action.IAudioInputType|null|undefined} audioInput
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.audioInput = null;

            /**
             * Action slideDestination.
             * @member {rv.data.Action.ISlideDestinationType|null|undefined} slideDestination
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.slideDestination = null;

            /**
             * Action macro.
             * @member {rv.data.Action.IMacroType|null|undefined} macro
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.macro = null;

            /**
             * Action clearGroup.
             * @member {rv.data.Action.IClearGroupType|null|undefined} clearGroup
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.clearGroup = null;

            /**
             * Action transportControl.
             * @member {rv.data.Action.ITransportControlType|null|undefined} transportControl
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.transportControl = null;

            /**
             * Action capture.
             * @member {rv.data.Action.ICaptureType|null|undefined} capture
             * @memberof rv.data.Action
             * @instance
             */
            Action.prototype.capture = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Action ActionTypeData.
             * @member {"collectionElement"|"playlistItem"|"blendMode"|"transition"|"media"|"doubleItem"|"effects"|"slide"|"background"|"timer"|"clear"|"stage"|"prop"|"mask"|"message"|"communication"|"multiScreen"|"presentationDocument"|"externalPresentation"|"audienceLook"|"audioInput"|"slideDestination"|"macro"|"clearGroup"|"transportControl"|"capture"|undefined} ActionTypeData
             * @memberof rv.data.Action
             * @instance
             */
            Object.defineProperty(Action.prototype, "ActionTypeData", {
                get: $util.oneOfGetter($oneOfFields = ["collectionElement", "playlistItem", "blendMode", "transition", "media", "doubleItem", "effects", "slide", "background", "timer", "clear", "stage", "prop", "mask", "message", "communication", "multiScreen", "presentationDocument", "externalPresentation", "audienceLook", "audioInput", "slideDestination", "macro", "clearGroup", "transportControl", "capture"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Action instance using the specified properties.
             * @function create
             * @memberof rv.data.Action
             * @static
             * @param {rv.data.IAction=} [properties] Properties to set
             * @returns {rv.data.Action} Action instance
             */
            Action.create = function create(properties) {
                return new Action(properties);
            };

            /**
             * Encodes the specified Action message. Does not implicitly {@link rv.data.Action.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Action
             * @static
             * @param {rv.data.IAction} message Action message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Action.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    $root.rv.data.Action.Label.encode(message.label, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.delayTime != null && Object.hasOwnProperty.call(message, "delayTime"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.delayTime);
                if (message.oldType != null && Object.hasOwnProperty.call(message, "oldType"))
                    $root.rv.data.Action.OldType.encode(message.oldType, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.isEnabled != null && Object.hasOwnProperty.call(message, "isEnabled"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isEnabled);
                if (message.layerIdentification != null && Object.hasOwnProperty.call(message, "layerIdentification"))
                    $root.rv.data.Action.LayerIdentification.encode(message.layerIdentification, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                    writer.uint32(/* id 8, wireType 1 =*/65).double(message.duration);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.type);
                if (message.collectionElement != null && Object.hasOwnProperty.call(message, "collectionElement"))
                    $root.rv.data.CollectionElementType.encode(message.collectionElement, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.playlistItem != null && Object.hasOwnProperty.call(message, "playlistItem"))
                    $root.rv.data.Action.PlaylistItemType.encode(message.playlistItem, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.blendMode != null && Object.hasOwnProperty.call(message, "blendMode"))
                    $root.rv.data.Action.BlendModeType.encode(message.blendMode, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.transition != null && Object.hasOwnProperty.call(message, "transition"))
                    $root.rv.data.Action.TransitionType.encode(message.transition, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.media != null && Object.hasOwnProperty.call(message, "media"))
                    $root.rv.data.Action.MediaType.encode(message.media, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.doubleItem != null && Object.hasOwnProperty.call(message, "doubleItem"))
                    $root.rv.data.Action.DoubleType.encode(message.doubleItem, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.effects != null && Object.hasOwnProperty.call(message, "effects"))
                    $root.rv.data.Action.EffectsType.encode(message.effects, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.slide != null && Object.hasOwnProperty.call(message, "slide"))
                    $root.rv.data.Action.SlideType.encode(message.slide, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.background != null && Object.hasOwnProperty.call(message, "background"))
                    $root.rv.data.Action.BackgroundType.encode(message.background, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                if (message.timer != null && Object.hasOwnProperty.call(message, "timer"))
                    $root.rv.data.Action.TimerType.encode(message.timer, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                if (message.clear != null && Object.hasOwnProperty.call(message, "clear"))
                    $root.rv.data.Action.ClearType.encode(message.clear, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                if (message.stage != null && Object.hasOwnProperty.call(message, "stage"))
                    $root.rv.data.Action.StageLayoutType.encode(message.stage, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
                if (message.prop != null && Object.hasOwnProperty.call(message, "prop"))
                    $root.rv.data.Action.PropType.encode(message.prop, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
                if (message.mask != null && Object.hasOwnProperty.call(message, "mask"))
                    $root.rv.data.Action.MaskType.encode(message.mask, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.rv.data.Action.MessageType.encode(message.message, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                if (message.communication != null && Object.hasOwnProperty.call(message, "communication"))
                    $root.rv.data.Action.CommunicationType.encode(message.communication, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
                if (message.multiScreen != null && Object.hasOwnProperty.call(message, "multiScreen"))
                    $root.rv.data.Action.MultiScreenType.encode(message.multiScreen, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
                if (message.presentationDocument != null && Object.hasOwnProperty.call(message, "presentationDocument"))
                    $root.rv.data.Action.DocumentType.encode(message.presentationDocument, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
                if (message.externalPresentation != null && Object.hasOwnProperty.call(message, "externalPresentation"))
                    $root.rv.data.Action.ExternalPresentationType.encode(message.externalPresentation, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
                if (message.audienceLook != null && Object.hasOwnProperty.call(message, "audienceLook"))
                    $root.rv.data.Action.AudienceLookType.encode(message.audienceLook, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
                if (message.audioInput != null && Object.hasOwnProperty.call(message, "audioInput"))
                    $root.rv.data.Action.AudioInputType.encode(message.audioInput, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
                if (message.slideDestination != null && Object.hasOwnProperty.call(message, "slideDestination"))
                    $root.rv.data.Action.SlideDestinationType.encode(message.slideDestination, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
                if (message.macro != null && Object.hasOwnProperty.call(message, "macro"))
                    $root.rv.data.Action.MacroType.encode(message.macro, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
                if (message.clearGroup != null && Object.hasOwnProperty.call(message, "clearGroup"))
                    $root.rv.data.Action.ClearGroupType.encode(message.clearGroup, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
                if (message.transportControl != null && Object.hasOwnProperty.call(message, "transportControl"))
                    $root.rv.data.Action.TransportControlType.encode(message.transportControl, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
                if (message.capture != null && Object.hasOwnProperty.call(message, "capture"))
                    $root.rv.data.Action.CaptureType.encode(message.capture, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Action message, length delimited. Does not implicitly {@link rv.data.Action.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Action
             * @static
             * @param {rv.data.IAction} message Action message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Action.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Action message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Action
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Action} Action
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Action.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.label = $root.rv.data.Action.Label.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.delayTime = reader.double();
                            break;
                        }
                    case 5: {
                            message.oldType = $root.rv.data.Action.OldType.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.isEnabled = reader.bool();
                            break;
                        }
                    case 7: {
                            message.layerIdentification = $root.rv.data.Action.LayerIdentification.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.duration = reader.double();
                            break;
                        }
                    case 9: {
                            message.type = reader.int32();
                            break;
                        }
                    case 16: {
                            message.collectionElement = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                            break;
                        }
                    case 17: {
                            message.playlistItem = $root.rv.data.Action.PlaylistItemType.decode(reader, reader.uint32());
                            break;
                        }
                    case 18: {
                            message.blendMode = $root.rv.data.Action.BlendModeType.decode(reader, reader.uint32());
                            break;
                        }
                    case 19: {
                            message.transition = $root.rv.data.Action.TransitionType.decode(reader, reader.uint32());
                            break;
                        }
                    case 20: {
                            message.media = $root.rv.data.Action.MediaType.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.doubleItem = $root.rv.data.Action.DoubleType.decode(reader, reader.uint32());
                            break;
                        }
                    case 22: {
                            message.effects = $root.rv.data.Action.EffectsType.decode(reader, reader.uint32());
                            break;
                        }
                    case 23: {
                            message.slide = $root.rv.data.Action.SlideType.decode(reader, reader.uint32());
                            break;
                        }
                    case 24: {
                            message.background = $root.rv.data.Action.BackgroundType.decode(reader, reader.uint32());
                            break;
                        }
                    case 25: {
                            message.timer = $root.rv.data.Action.TimerType.decode(reader, reader.uint32());
                            break;
                        }
                    case 26: {
                            message.clear = $root.rv.data.Action.ClearType.decode(reader, reader.uint32());
                            break;
                        }
                    case 27: {
                            message.stage = $root.rv.data.Action.StageLayoutType.decode(reader, reader.uint32());
                            break;
                        }
                    case 28: {
                            message.prop = $root.rv.data.Action.PropType.decode(reader, reader.uint32());
                            break;
                        }
                    case 29: {
                            message.mask = $root.rv.data.Action.MaskType.decode(reader, reader.uint32());
                            break;
                        }
                    case 30: {
                            message.message = $root.rv.data.Action.MessageType.decode(reader, reader.uint32());
                            break;
                        }
                    case 32: {
                            message.communication = $root.rv.data.Action.CommunicationType.decode(reader, reader.uint32());
                            break;
                        }
                    case 33: {
                            message.multiScreen = $root.rv.data.Action.MultiScreenType.decode(reader, reader.uint32());
                            break;
                        }
                    case 34: {
                            message.presentationDocument = $root.rv.data.Action.DocumentType.decode(reader, reader.uint32());
                            break;
                        }
                    case 36: {
                            message.externalPresentation = $root.rv.data.Action.ExternalPresentationType.decode(reader, reader.uint32());
                            break;
                        }
                    case 37: {
                            message.audienceLook = $root.rv.data.Action.AudienceLookType.decode(reader, reader.uint32());
                            break;
                        }
                    case 38: {
                            message.audioInput = $root.rv.data.Action.AudioInputType.decode(reader, reader.uint32());
                            break;
                        }
                    case 39: {
                            message.slideDestination = $root.rv.data.Action.SlideDestinationType.decode(reader, reader.uint32());
                            break;
                        }
                    case 40: {
                            message.macro = $root.rv.data.Action.MacroType.decode(reader, reader.uint32());
                            break;
                        }
                    case 41: {
                            message.clearGroup = $root.rv.data.Action.ClearGroupType.decode(reader, reader.uint32());
                            break;
                        }
                    case 42: {
                            message.transportControl = $root.rv.data.Action.TransportControlType.decode(reader, reader.uint32());
                            break;
                        }
                    case 43: {
                            message.capture = $root.rv.data.Action.CaptureType.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Action message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Action
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Action} Action
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Action.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Action message.
             * @function verify
             * @memberof rv.data.Action
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Action.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.label != null && message.hasOwnProperty("label")) {
                    let error = $root.rv.data.Action.Label.verify(message.label);
                    if (error)
                        return "label." + error;
                }
                if (message.delayTime != null && message.hasOwnProperty("delayTime"))
                    if (typeof message.delayTime !== "number")
                        return "delayTime: number expected";
                if (message.oldType != null && message.hasOwnProperty("oldType")) {
                    let error = $root.rv.data.Action.OldType.verify(message.oldType);
                    if (error)
                        return "oldType." + error;
                }
                if (message.isEnabled != null && message.hasOwnProperty("isEnabled"))
                    if (typeof message.isEnabled !== "boolean")
                        return "isEnabled: boolean expected";
                if (message.layerIdentification != null && message.hasOwnProperty("layerIdentification")) {
                    let error = $root.rv.data.Action.LayerIdentification.verify(message.layerIdentification);
                    if (error)
                        return "layerIdentification." + error;
                }
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (typeof message.duration !== "number")
                        return "duration: number expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                        break;
                    }
                if (message.collectionElement != null && message.hasOwnProperty("collectionElement")) {
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.CollectionElementType.verify(message.collectionElement);
                        if (error)
                            return "collectionElement." + error;
                    }
                }
                if (message.playlistItem != null && message.hasOwnProperty("playlistItem")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.PlaylistItemType.verify(message.playlistItem);
                        if (error)
                            return "playlistItem." + error;
                    }
                }
                if (message.blendMode != null && message.hasOwnProperty("blendMode")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.BlendModeType.verify(message.blendMode);
                        if (error)
                            return "blendMode." + error;
                    }
                }
                if (message.transition != null && message.hasOwnProperty("transition")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.TransitionType.verify(message.transition);
                        if (error)
                            return "transition." + error;
                    }
                }
                if (message.media != null && message.hasOwnProperty("media")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.MediaType.verify(message.media);
                        if (error)
                            return "media." + error;
                    }
                }
                if (message.doubleItem != null && message.hasOwnProperty("doubleItem")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.DoubleType.verify(message.doubleItem);
                        if (error)
                            return "doubleItem." + error;
                    }
                }
                if (message.effects != null && message.hasOwnProperty("effects")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.EffectsType.verify(message.effects);
                        if (error)
                            return "effects." + error;
                    }
                }
                if (message.slide != null && message.hasOwnProperty("slide")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.SlideType.verify(message.slide);
                        if (error)
                            return "slide." + error;
                    }
                }
                if (message.background != null && message.hasOwnProperty("background")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.BackgroundType.verify(message.background);
                        if (error)
                            return "background." + error;
                    }
                }
                if (message.timer != null && message.hasOwnProperty("timer")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.TimerType.verify(message.timer);
                        if (error)
                            return "timer." + error;
                    }
                }
                if (message.clear != null && message.hasOwnProperty("clear")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.ClearType.verify(message.clear);
                        if (error)
                            return "clear." + error;
                    }
                }
                if (message.stage != null && message.hasOwnProperty("stage")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.StageLayoutType.verify(message.stage);
                        if (error)
                            return "stage." + error;
                    }
                }
                if (message.prop != null && message.hasOwnProperty("prop")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.PropType.verify(message.prop);
                        if (error)
                            return "prop." + error;
                    }
                }
                if (message.mask != null && message.hasOwnProperty("mask")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.MaskType.verify(message.mask);
                        if (error)
                            return "mask." + error;
                    }
                }
                if (message.message != null && message.hasOwnProperty("message")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.MessageType.verify(message.message);
                        if (error)
                            return "message." + error;
                    }
                }
                if (message.communication != null && message.hasOwnProperty("communication")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.CommunicationType.verify(message.communication);
                        if (error)
                            return "communication." + error;
                    }
                }
                if (message.multiScreen != null && message.hasOwnProperty("multiScreen")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.MultiScreenType.verify(message.multiScreen);
                        if (error)
                            return "multiScreen." + error;
                    }
                }
                if (message.presentationDocument != null && message.hasOwnProperty("presentationDocument")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.DocumentType.verify(message.presentationDocument);
                        if (error)
                            return "presentationDocument." + error;
                    }
                }
                if (message.externalPresentation != null && message.hasOwnProperty("externalPresentation")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.ExternalPresentationType.verify(message.externalPresentation);
                        if (error)
                            return "externalPresentation." + error;
                    }
                }
                if (message.audienceLook != null && message.hasOwnProperty("audienceLook")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.AudienceLookType.verify(message.audienceLook);
                        if (error)
                            return "audienceLook." + error;
                    }
                }
                if (message.audioInput != null && message.hasOwnProperty("audioInput")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.AudioInputType.verify(message.audioInput);
                        if (error)
                            return "audioInput." + error;
                    }
                }
                if (message.slideDestination != null && message.hasOwnProperty("slideDestination")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.SlideDestinationType.verify(message.slideDestination);
                        if (error)
                            return "slideDestination." + error;
                    }
                }
                if (message.macro != null && message.hasOwnProperty("macro")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.MacroType.verify(message.macro);
                        if (error)
                            return "macro." + error;
                    }
                }
                if (message.clearGroup != null && message.hasOwnProperty("clearGroup")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.ClearGroupType.verify(message.clearGroup);
                        if (error)
                            return "clearGroup." + error;
                    }
                }
                if (message.transportControl != null && message.hasOwnProperty("transportControl")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.TransportControlType.verify(message.transportControl);
                        if (error)
                            return "transportControl." + error;
                    }
                }
                if (message.capture != null && message.hasOwnProperty("capture")) {
                    if (properties.ActionTypeData === 1)
                        return "ActionTypeData: multiple values";
                    properties.ActionTypeData = 1;
                    {
                        let error = $root.rv.data.Action.CaptureType.verify(message.capture);
                        if (error)
                            return "capture." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Action message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Action
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Action} Action
             */
            Action.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Action)
                    return object;
                let message = new $root.rv.data.Action();
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.Action.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                if (object.name != null)
                    message.name = String(object.name);
                if (object.label != null) {
                    if (typeof object.label !== "object")
                        throw TypeError(".rv.data.Action.label: object expected");
                    message.label = $root.rv.data.Action.Label.fromObject(object.label);
                }
                if (object.delayTime != null)
                    message.delayTime = Number(object.delayTime);
                if (object.oldType != null) {
                    if (typeof object.oldType !== "object")
                        throw TypeError(".rv.data.Action.oldType: object expected");
                    message.oldType = $root.rv.data.Action.OldType.fromObject(object.oldType);
                }
                if (object.isEnabled != null)
                    message.isEnabled = Boolean(object.isEnabled);
                if (object.layerIdentification != null) {
                    if (typeof object.layerIdentification !== "object")
                        throw TypeError(".rv.data.Action.layerIdentification: object expected");
                    message.layerIdentification = $root.rv.data.Action.LayerIdentification.fromObject(object.layerIdentification);
                }
                if (object.duration != null)
                    message.duration = Number(object.duration);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "ACTION_TYPE_UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "ACTION_TYPE_STAGE_LAYOUT":
                case 1:
                    message.type = 1;
                    break;
                case "ACTION_TYPE_MEDIA":
                case 2:
                    message.type = 2;
                    break;
                case "ACTION_TYPE_TIMER":
                case 3:
                    message.type = 3;
                    break;
                case "ACTION_TYPE_COMMUNICATION":
                case 4:
                    message.type = 4;
                    break;
                case "ACTION_TYPE_CLEAR":
                case 5:
                    message.type = 5;
                    break;
                case "ACTION_TYPE_PROP":
                case 6:
                    message.type = 6;
                    break;
                case "ACTION_TYPE_MASK":
                case 7:
                    message.type = 7;
                    break;
                case "ACTION_TYPE_MESSAGE":
                case 8:
                    message.type = 8;
                    break;
                case "ACTION_TYPE_SOCIAL_MEDIA":
                case 9:
                    message.type = 9;
                    break;
                case "ACTION_TYPE_MULTISCREEN":
                case 10:
                    message.type = 10;
                    break;
                case "ACTION_TYPE_PRESENTATION_SLIDE":
                case 11:
                    message.type = 11;
                    break;
                case "ACTION_TYPE_FOREGROUND_MEDIA":
                case 12:
                    message.type = 12;
                    break;
                case "ACTION_TYPE_BACKGROUND_MEDIA":
                case 13:
                    message.type = 13;
                    break;
                case "ACTION_TYPE_PRESENTATION_DOCUMENT":
                case 14:
                    message.type = 14;
                    break;
                case "ACTION_TYPE_PROP_SLIDE":
                case 15:
                    message.type = 15;
                    break;
                case "ACTION_TYPE_EXTERNAL_PRESENTATION":
                case 17:
                    message.type = 17;
                    break;
                case "ACTION_TYPE_AUDIENCE_LOOK":
                case 18:
                    message.type = 18;
                    break;
                case "ACTION_TYPE_AUDIO_INPUT":
                case 19:
                    message.type = 19;
                    break;
                case "ACTION_TYPE_AUDIO_BIN_PLAYLIST":
                case 20:
                    message.type = 20;
                    break;
                case "ACTION_TYPE_MEDIA_BIN_PLAYLIST":
                case 21:
                    message.type = 21;
                    break;
                case "ACTION_TYPE_SLIDE_DESTINATION":
                case 22:
                    message.type = 22;
                    break;
                case "ACTION_TYPE_MACRO":
                case 23:
                    message.type = 23;
                    break;
                case "ACTION_TYPE_CLEAR_GROUP":
                case 24:
                    message.type = 24;
                    break;
                case "ACTION_TYPE_CAPTURE":
                case 25:
                    message.type = 25;
                    break;
                case "ACTION_TYPE_LIBRARY_PLAYLIST":
                case 26:
                    message.type = 26;
                    break;
                }
                if (object.collectionElement != null) {
                    if (typeof object.collectionElement !== "object")
                        throw TypeError(".rv.data.Action.collectionElement: object expected");
                    message.collectionElement = $root.rv.data.CollectionElementType.fromObject(object.collectionElement);
                }
                if (object.playlistItem != null) {
                    if (typeof object.playlistItem !== "object")
                        throw TypeError(".rv.data.Action.playlistItem: object expected");
                    message.playlistItem = $root.rv.data.Action.PlaylistItemType.fromObject(object.playlistItem);
                }
                if (object.blendMode != null) {
                    if (typeof object.blendMode !== "object")
                        throw TypeError(".rv.data.Action.blendMode: object expected");
                    message.blendMode = $root.rv.data.Action.BlendModeType.fromObject(object.blendMode);
                }
                if (object.transition != null) {
                    if (typeof object.transition !== "object")
                        throw TypeError(".rv.data.Action.transition: object expected");
                    message.transition = $root.rv.data.Action.TransitionType.fromObject(object.transition);
                }
                if (object.media != null) {
                    if (typeof object.media !== "object")
                        throw TypeError(".rv.data.Action.media: object expected");
                    message.media = $root.rv.data.Action.MediaType.fromObject(object.media);
                }
                if (object.doubleItem != null) {
                    if (typeof object.doubleItem !== "object")
                        throw TypeError(".rv.data.Action.doubleItem: object expected");
                    message.doubleItem = $root.rv.data.Action.DoubleType.fromObject(object.doubleItem);
                }
                if (object.effects != null) {
                    if (typeof object.effects !== "object")
                        throw TypeError(".rv.data.Action.effects: object expected");
                    message.effects = $root.rv.data.Action.EffectsType.fromObject(object.effects);
                }
                if (object.slide != null) {
                    if (typeof object.slide !== "object")
                        throw TypeError(".rv.data.Action.slide: object expected");
                    message.slide = $root.rv.data.Action.SlideType.fromObject(object.slide);
                }
                if (object.background != null) {
                    if (typeof object.background !== "object")
                        throw TypeError(".rv.data.Action.background: object expected");
                    message.background = $root.rv.data.Action.BackgroundType.fromObject(object.background);
                }
                if (object.timer != null) {
                    if (typeof object.timer !== "object")
                        throw TypeError(".rv.data.Action.timer: object expected");
                    message.timer = $root.rv.data.Action.TimerType.fromObject(object.timer);
                }
                if (object.clear != null) {
                    if (typeof object.clear !== "object")
                        throw TypeError(".rv.data.Action.clear: object expected");
                    message.clear = $root.rv.data.Action.ClearType.fromObject(object.clear);
                }
                if (object.stage != null) {
                    if (typeof object.stage !== "object")
                        throw TypeError(".rv.data.Action.stage: object expected");
                    message.stage = $root.rv.data.Action.StageLayoutType.fromObject(object.stage);
                }
                if (object.prop != null) {
                    if (typeof object.prop !== "object")
                        throw TypeError(".rv.data.Action.prop: object expected");
                    message.prop = $root.rv.data.Action.PropType.fromObject(object.prop);
                }
                if (object.mask != null) {
                    if (typeof object.mask !== "object")
                        throw TypeError(".rv.data.Action.mask: object expected");
                    message.mask = $root.rv.data.Action.MaskType.fromObject(object.mask);
                }
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".rv.data.Action.message: object expected");
                    message.message = $root.rv.data.Action.MessageType.fromObject(object.message);
                }
                if (object.communication != null) {
                    if (typeof object.communication !== "object")
                        throw TypeError(".rv.data.Action.communication: object expected");
                    message.communication = $root.rv.data.Action.CommunicationType.fromObject(object.communication);
                }
                if (object.multiScreen != null) {
                    if (typeof object.multiScreen !== "object")
                        throw TypeError(".rv.data.Action.multiScreen: object expected");
                    message.multiScreen = $root.rv.data.Action.MultiScreenType.fromObject(object.multiScreen);
                }
                if (object.presentationDocument != null) {
                    if (typeof object.presentationDocument !== "object")
                        throw TypeError(".rv.data.Action.presentationDocument: object expected");
                    message.presentationDocument = $root.rv.data.Action.DocumentType.fromObject(object.presentationDocument);
                }
                if (object.externalPresentation != null) {
                    if (typeof object.externalPresentation !== "object")
                        throw TypeError(".rv.data.Action.externalPresentation: object expected");
                    message.externalPresentation = $root.rv.data.Action.ExternalPresentationType.fromObject(object.externalPresentation);
                }
                if (object.audienceLook != null) {
                    if (typeof object.audienceLook !== "object")
                        throw TypeError(".rv.data.Action.audienceLook: object expected");
                    message.audienceLook = $root.rv.data.Action.AudienceLookType.fromObject(object.audienceLook);
                }
                if (object.audioInput != null) {
                    if (typeof object.audioInput !== "object")
                        throw TypeError(".rv.data.Action.audioInput: object expected");
                    message.audioInput = $root.rv.data.Action.AudioInputType.fromObject(object.audioInput);
                }
                if (object.slideDestination != null) {
                    if (typeof object.slideDestination !== "object")
                        throw TypeError(".rv.data.Action.slideDestination: object expected");
                    message.slideDestination = $root.rv.data.Action.SlideDestinationType.fromObject(object.slideDestination);
                }
                if (object.macro != null) {
                    if (typeof object.macro !== "object")
                        throw TypeError(".rv.data.Action.macro: object expected");
                    message.macro = $root.rv.data.Action.MacroType.fromObject(object.macro);
                }
                if (object.clearGroup != null) {
                    if (typeof object.clearGroup !== "object")
                        throw TypeError(".rv.data.Action.clearGroup: object expected");
                    message.clearGroup = $root.rv.data.Action.ClearGroupType.fromObject(object.clearGroup);
                }
                if (object.transportControl != null) {
                    if (typeof object.transportControl !== "object")
                        throw TypeError(".rv.data.Action.transportControl: object expected");
                    message.transportControl = $root.rv.data.Action.TransportControlType.fromObject(object.transportControl);
                }
                if (object.capture != null) {
                    if (typeof object.capture !== "object")
                        throw TypeError(".rv.data.Action.capture: object expected");
                    message.capture = $root.rv.data.Action.CaptureType.fromObject(object.capture);
                }
                return message;
            };

            /**
             * Creates a plain object from an Action message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Action
             * @static
             * @param {rv.data.Action} message Action
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Action.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uuid = null;
                    object.name = "";
                    object.label = null;
                    object.delayTime = 0;
                    object.oldType = null;
                    object.isEnabled = false;
                    object.layerIdentification = null;
                    object.duration = 0;
                    object.type = options.enums === String ? "ACTION_TYPE_UNKNOWN" : 0;
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = $root.rv.data.Action.Label.toObject(message.label, options);
                if (message.delayTime != null && message.hasOwnProperty("delayTime"))
                    object.delayTime = options.json && !isFinite(message.delayTime) ? String(message.delayTime) : message.delayTime;
                if (message.oldType != null && message.hasOwnProperty("oldType"))
                    object.oldType = $root.rv.data.Action.OldType.toObject(message.oldType, options);
                if (message.isEnabled != null && message.hasOwnProperty("isEnabled"))
                    object.isEnabled = message.isEnabled;
                if (message.layerIdentification != null && message.hasOwnProperty("layerIdentification"))
                    object.layerIdentification = $root.rv.data.Action.LayerIdentification.toObject(message.layerIdentification, options);
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.rv.data.Action.ActionType[message.type] === undefined ? message.type : $root.rv.data.Action.ActionType[message.type] : message.type;
                if (message.collectionElement != null && message.hasOwnProperty("collectionElement")) {
                    object.collectionElement = $root.rv.data.CollectionElementType.toObject(message.collectionElement, options);
                    if (options.oneofs)
                        object.ActionTypeData = "collectionElement";
                }
                if (message.playlistItem != null && message.hasOwnProperty("playlistItem")) {
                    object.playlistItem = $root.rv.data.Action.PlaylistItemType.toObject(message.playlistItem, options);
                    if (options.oneofs)
                        object.ActionTypeData = "playlistItem";
                }
                if (message.blendMode != null && message.hasOwnProperty("blendMode")) {
                    object.blendMode = $root.rv.data.Action.BlendModeType.toObject(message.blendMode, options);
                    if (options.oneofs)
                        object.ActionTypeData = "blendMode";
                }
                if (message.transition != null && message.hasOwnProperty("transition")) {
                    object.transition = $root.rv.data.Action.TransitionType.toObject(message.transition, options);
                    if (options.oneofs)
                        object.ActionTypeData = "transition";
                }
                if (message.media != null && message.hasOwnProperty("media")) {
                    object.media = $root.rv.data.Action.MediaType.toObject(message.media, options);
                    if (options.oneofs)
                        object.ActionTypeData = "media";
                }
                if (message.doubleItem != null && message.hasOwnProperty("doubleItem")) {
                    object.doubleItem = $root.rv.data.Action.DoubleType.toObject(message.doubleItem, options);
                    if (options.oneofs)
                        object.ActionTypeData = "doubleItem";
                }
                if (message.effects != null && message.hasOwnProperty("effects")) {
                    object.effects = $root.rv.data.Action.EffectsType.toObject(message.effects, options);
                    if (options.oneofs)
                        object.ActionTypeData = "effects";
                }
                if (message.slide != null && message.hasOwnProperty("slide")) {
                    object.slide = $root.rv.data.Action.SlideType.toObject(message.slide, options);
                    if (options.oneofs)
                        object.ActionTypeData = "slide";
                }
                if (message.background != null && message.hasOwnProperty("background")) {
                    object.background = $root.rv.data.Action.BackgroundType.toObject(message.background, options);
                    if (options.oneofs)
                        object.ActionTypeData = "background";
                }
                if (message.timer != null && message.hasOwnProperty("timer")) {
                    object.timer = $root.rv.data.Action.TimerType.toObject(message.timer, options);
                    if (options.oneofs)
                        object.ActionTypeData = "timer";
                }
                if (message.clear != null && message.hasOwnProperty("clear")) {
                    object.clear = $root.rv.data.Action.ClearType.toObject(message.clear, options);
                    if (options.oneofs)
                        object.ActionTypeData = "clear";
                }
                if (message.stage != null && message.hasOwnProperty("stage")) {
                    object.stage = $root.rv.data.Action.StageLayoutType.toObject(message.stage, options);
                    if (options.oneofs)
                        object.ActionTypeData = "stage";
                }
                if (message.prop != null && message.hasOwnProperty("prop")) {
                    object.prop = $root.rv.data.Action.PropType.toObject(message.prop, options);
                    if (options.oneofs)
                        object.ActionTypeData = "prop";
                }
                if (message.mask != null && message.hasOwnProperty("mask")) {
                    object.mask = $root.rv.data.Action.MaskType.toObject(message.mask, options);
                    if (options.oneofs)
                        object.ActionTypeData = "mask";
                }
                if (message.message != null && message.hasOwnProperty("message")) {
                    object.message = $root.rv.data.Action.MessageType.toObject(message.message, options);
                    if (options.oneofs)
                        object.ActionTypeData = "message";
                }
                if (message.communication != null && message.hasOwnProperty("communication")) {
                    object.communication = $root.rv.data.Action.CommunicationType.toObject(message.communication, options);
                    if (options.oneofs)
                        object.ActionTypeData = "communication";
                }
                if (message.multiScreen != null && message.hasOwnProperty("multiScreen")) {
                    object.multiScreen = $root.rv.data.Action.MultiScreenType.toObject(message.multiScreen, options);
                    if (options.oneofs)
                        object.ActionTypeData = "multiScreen";
                }
                if (message.presentationDocument != null && message.hasOwnProperty("presentationDocument")) {
                    object.presentationDocument = $root.rv.data.Action.DocumentType.toObject(message.presentationDocument, options);
                    if (options.oneofs)
                        object.ActionTypeData = "presentationDocument";
                }
                if (message.externalPresentation != null && message.hasOwnProperty("externalPresentation")) {
                    object.externalPresentation = $root.rv.data.Action.ExternalPresentationType.toObject(message.externalPresentation, options);
                    if (options.oneofs)
                        object.ActionTypeData = "externalPresentation";
                }
                if (message.audienceLook != null && message.hasOwnProperty("audienceLook")) {
                    object.audienceLook = $root.rv.data.Action.AudienceLookType.toObject(message.audienceLook, options);
                    if (options.oneofs)
                        object.ActionTypeData = "audienceLook";
                }
                if (message.audioInput != null && message.hasOwnProperty("audioInput")) {
                    object.audioInput = $root.rv.data.Action.AudioInputType.toObject(message.audioInput, options);
                    if (options.oneofs)
                        object.ActionTypeData = "audioInput";
                }
                if (message.slideDestination != null && message.hasOwnProperty("slideDestination")) {
                    object.slideDestination = $root.rv.data.Action.SlideDestinationType.toObject(message.slideDestination, options);
                    if (options.oneofs)
                        object.ActionTypeData = "slideDestination";
                }
                if (message.macro != null && message.hasOwnProperty("macro")) {
                    object.macro = $root.rv.data.Action.MacroType.toObject(message.macro, options);
                    if (options.oneofs)
                        object.ActionTypeData = "macro";
                }
                if (message.clearGroup != null && message.hasOwnProperty("clearGroup")) {
                    object.clearGroup = $root.rv.data.Action.ClearGroupType.toObject(message.clearGroup, options);
                    if (options.oneofs)
                        object.ActionTypeData = "clearGroup";
                }
                if (message.transportControl != null && message.hasOwnProperty("transportControl")) {
                    object.transportControl = $root.rv.data.Action.TransportControlType.toObject(message.transportControl, options);
                    if (options.oneofs)
                        object.ActionTypeData = "transportControl";
                }
                if (message.capture != null && message.hasOwnProperty("capture")) {
                    object.capture = $root.rv.data.Action.CaptureType.toObject(message.capture, options);
                    if (options.oneofs)
                        object.ActionTypeData = "capture";
                }
                return object;
            };

            /**
             * Converts this Action to JSON.
             * @function toJSON
             * @memberof rv.data.Action
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Action.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Action
             * @function getTypeUrl
             * @memberof rv.data.Action
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Action.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Action";
            };

            Action.OldType = (function() {

                /**
                 * Properties of an OldType.
                 * @memberof rv.data.Action
                 * @interface IOldType
                 * @property {rv.data.Action.OldType.Category|null} [category] OldType category
                 * @property {number|null} [applicationType] OldType applicationType
                 */

                /**
                 * Constructs a new OldType.
                 * @memberof rv.data.Action
                 * @classdesc Represents an OldType.
                 * @implements IOldType
                 * @constructor
                 * @param {rv.data.Action.IOldType=} [properties] Properties to set
                 */
                function OldType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * OldType category.
                 * @member {rv.data.Action.OldType.Category} category
                 * @memberof rv.data.Action.OldType
                 * @instance
                 */
                OldType.prototype.category = 0;

                /**
                 * OldType applicationType.
                 * @member {number} applicationType
                 * @memberof rv.data.Action.OldType
                 * @instance
                 */
                OldType.prototype.applicationType = 0;

                /**
                 * Creates a new OldType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.OldType
                 * @static
                 * @param {rv.data.Action.IOldType=} [properties] Properties to set
                 * @returns {rv.data.Action.OldType} OldType instance
                 */
                OldType.create = function create(properties) {
                    return new OldType(properties);
                };

                /**
                 * Encodes the specified OldType message. Does not implicitly {@link rv.data.Action.OldType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.OldType
                 * @static
                 * @param {rv.data.Action.IOldType} message OldType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OldType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.category);
                    if (message.applicationType != null && Object.hasOwnProperty.call(message, "applicationType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.applicationType);
                    return writer;
                };

                /**
                 * Encodes the specified OldType message, length delimited. Does not implicitly {@link rv.data.Action.OldType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.OldType
                 * @static
                 * @param {rv.data.Action.IOldType} message OldType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OldType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an OldType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.OldType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.OldType} OldType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OldType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.OldType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.category = reader.int32();
                                break;
                            }
                        case 2: {
                                message.applicationType = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an OldType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.OldType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.OldType} OldType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OldType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an OldType message.
                 * @function verify
                 * @memberof rv.data.Action.OldType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OldType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.category != null && message.hasOwnProperty("category"))
                        switch (message.category) {
                        default:
                            return "category: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.applicationType != null && message.hasOwnProperty("applicationType"))
                        if (!$util.isInteger(message.applicationType))
                            return "applicationType: integer expected";
                    return null;
                };

                /**
                 * Creates an OldType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.OldType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.OldType} OldType
                 */
                OldType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.OldType)
                        return object;
                    let message = new $root.rv.data.Action.OldType();
                    switch (object.category) {
                    default:
                        if (typeof object.category === "number") {
                            message.category = object.category;
                            break;
                        }
                        break;
                    case "CATEGORY_UNKNOWN":
                    case 0:
                        message.category = 0;
                        break;
                    case "CATEGORY_MEDIA":
                    case 1:
                        message.category = 1;
                        break;
                    case "CATEGORY_APPLICATION":
                    case 2:
                        message.category = 2;
                        break;
                    }
                    if (object.applicationType != null)
                        message.applicationType = object.applicationType | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an OldType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.OldType
                 * @static
                 * @param {rv.data.Action.OldType} message OldType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OldType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.category = options.enums === String ? "CATEGORY_UNKNOWN" : 0;
                        object.applicationType = 0;
                    }
                    if (message.category != null && message.hasOwnProperty("category"))
                        object.category = options.enums === String ? $root.rv.data.Action.OldType.Category[message.category] === undefined ? message.category : $root.rv.data.Action.OldType.Category[message.category] : message.category;
                    if (message.applicationType != null && message.hasOwnProperty("applicationType"))
                        object.applicationType = message.applicationType;
                    return object;
                };

                /**
                 * Converts this OldType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.OldType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OldType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for OldType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.OldType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                OldType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.OldType";
                };

                /**
                 * Category enum.
                 * @name rv.data.Action.OldType.Category
                 * @enum {number}
                 * @property {number} CATEGORY_UNKNOWN=0 CATEGORY_UNKNOWN value
                 * @property {number} CATEGORY_MEDIA=1 CATEGORY_MEDIA value
                 * @property {number} CATEGORY_APPLICATION=2 CATEGORY_APPLICATION value
                 */
                OldType.Category = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CATEGORY_UNKNOWN"] = 0;
                    values[valuesById[1] = "CATEGORY_MEDIA"] = 1;
                    values[valuesById[2] = "CATEGORY_APPLICATION"] = 2;
                    return values;
                })();

                return OldType;
            })();

            Action.Label = (function() {

                /**
                 * Properties of a Label.
                 * @memberof rv.data.Action
                 * @interface ILabel
                 * @property {string|null} [text] Label text
                 * @property {rv.data.IColor|null} [color] Label color
                 */

                /**
                 * Constructs a new Label.
                 * @memberof rv.data.Action
                 * @classdesc Represents a Label.
                 * @implements ILabel
                 * @constructor
                 * @param {rv.data.Action.ILabel=} [properties] Properties to set
                 */
                function Label(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Label text.
                 * @member {string} text
                 * @memberof rv.data.Action.Label
                 * @instance
                 */
                Label.prototype.text = "";

                /**
                 * Label color.
                 * @member {rv.data.IColor|null|undefined} color
                 * @memberof rv.data.Action.Label
                 * @instance
                 */
                Label.prototype.color = null;

                /**
                 * Creates a new Label instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.Label
                 * @static
                 * @param {rv.data.Action.ILabel=} [properties] Properties to set
                 * @returns {rv.data.Action.Label} Label instance
                 */
                Label.create = function create(properties) {
                    return new Label(properties);
                };

                /**
                 * Encodes the specified Label message. Does not implicitly {@link rv.data.Action.Label.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.Label
                 * @static
                 * @param {rv.data.Action.ILabel} message Label message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Label.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
                    if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                        $root.rv.data.Color.encode(message.color, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Label message, length delimited. Does not implicitly {@link rv.data.Action.Label.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.Label
                 * @static
                 * @param {rv.data.Action.ILabel} message Label message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Label.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Label message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.Label
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.Label} Label
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Label.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.Label();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2: {
                                message.text = reader.string();
                                break;
                            }
                        case 3: {
                                message.color = $root.rv.data.Color.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Label message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.Label
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.Label} Label
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Label.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Label message.
                 * @function verify
                 * @memberof rv.data.Action.Label
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Label.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.text != null && message.hasOwnProperty("text"))
                        if (!$util.isString(message.text))
                            return "text: string expected";
                    if (message.color != null && message.hasOwnProperty("color")) {
                        let error = $root.rv.data.Color.verify(message.color);
                        if (error)
                            return "color." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Label message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.Label
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.Label} Label
                 */
                Label.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.Label)
                        return object;
                    let message = new $root.rv.data.Action.Label();
                    if (object.text != null)
                        message.text = String(object.text);
                    if (object.color != null) {
                        if (typeof object.color !== "object")
                            throw TypeError(".rv.data.Action.Label.color: object expected");
                        message.color = $root.rv.data.Color.fromObject(object.color);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Label message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.Label
                 * @static
                 * @param {rv.data.Action.Label} message Label
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Label.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.text = "";
                        object.color = null;
                    }
                    if (message.text != null && message.hasOwnProperty("text"))
                        object.text = message.text;
                    if (message.color != null && message.hasOwnProperty("color"))
                        object.color = $root.rv.data.Color.toObject(message.color, options);
                    return object;
                };

                /**
                 * Converts this Label to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.Label
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Label.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Label
                 * @function getTypeUrl
                 * @memberof rv.data.Action.Label
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Label.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.Label";
                };

                return Label;
            })();

            Action.LayerIdentification = (function() {

                /**
                 * Properties of a LayerIdentification.
                 * @memberof rv.data.Action
                 * @interface ILayerIdentification
                 * @property {rv.data.IUUID|null} [uuid] LayerIdentification uuid
                 * @property {string|null} [name] LayerIdentification name
                 */

                /**
                 * Constructs a new LayerIdentification.
                 * @memberof rv.data.Action
                 * @classdesc Represents a LayerIdentification.
                 * @implements ILayerIdentification
                 * @constructor
                 * @param {rv.data.Action.ILayerIdentification=} [properties] Properties to set
                 */
                function LayerIdentification(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LayerIdentification uuid.
                 * @member {rv.data.IUUID|null|undefined} uuid
                 * @memberof rv.data.Action.LayerIdentification
                 * @instance
                 */
                LayerIdentification.prototype.uuid = null;

                /**
                 * LayerIdentification name.
                 * @member {string} name
                 * @memberof rv.data.Action.LayerIdentification
                 * @instance
                 */
                LayerIdentification.prototype.name = "";

                /**
                 * Creates a new LayerIdentification instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.LayerIdentification
                 * @static
                 * @param {rv.data.Action.ILayerIdentification=} [properties] Properties to set
                 * @returns {rv.data.Action.LayerIdentification} LayerIdentification instance
                 */
                LayerIdentification.create = function create(properties) {
                    return new LayerIdentification(properties);
                };

                /**
                 * Encodes the specified LayerIdentification message. Does not implicitly {@link rv.data.Action.LayerIdentification.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.LayerIdentification
                 * @static
                 * @param {rv.data.Action.ILayerIdentification} message LayerIdentification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LayerIdentification.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                        $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    return writer;
                };

                /**
                 * Encodes the specified LayerIdentification message, length delimited. Does not implicitly {@link rv.data.Action.LayerIdentification.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.LayerIdentification
                 * @static
                 * @param {rv.data.Action.ILayerIdentification} message LayerIdentification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LayerIdentification.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LayerIdentification message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.LayerIdentification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.LayerIdentification} LayerIdentification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LayerIdentification.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.LayerIdentification();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.name = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LayerIdentification message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.LayerIdentification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.LayerIdentification} LayerIdentification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LayerIdentification.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LayerIdentification message.
                 * @function verify
                 * @memberof rv.data.Action.LayerIdentification
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LayerIdentification.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uuid != null && message.hasOwnProperty("uuid")) {
                        let error = $root.rv.data.UUID.verify(message.uuid);
                        if (error)
                            return "uuid." + error;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a LayerIdentification message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.LayerIdentification
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.LayerIdentification} LayerIdentification
                 */
                LayerIdentification.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.LayerIdentification)
                        return object;
                    let message = new $root.rv.data.Action.LayerIdentification();
                    if (object.uuid != null) {
                        if (typeof object.uuid !== "object")
                            throw TypeError(".rv.data.Action.LayerIdentification.uuid: object expected");
                        message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a LayerIdentification message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.LayerIdentification
                 * @static
                 * @param {rv.data.Action.LayerIdentification} message LayerIdentification
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LayerIdentification.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.uuid = null;
                        object.name = "";
                    }
                    if (message.uuid != null && message.hasOwnProperty("uuid"))
                        object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this LayerIdentification to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.LayerIdentification
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LayerIdentification.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for LayerIdentification
                 * @function getTypeUrl
                 * @memberof rv.data.Action.LayerIdentification
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                LayerIdentification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.LayerIdentification";
                };

                return LayerIdentification;
            })();

            Action.PlaylistItemType = (function() {

                /**
                 * Properties of a PlaylistItemType.
                 * @memberof rv.data.Action
                 * @interface IPlaylistItemType
                 * @property {rv.data.IUUID|null} [playlistUuid] PlaylistItemType playlistUuid
                 * @property {string|null} [playlistName] PlaylistItemType playlistName
                 * @property {rv.data.IUUID|null} [itemUuid] PlaylistItemType itemUuid
                 * @property {string|null} [itemName] PlaylistItemType itemName
                 * @property {boolean|null} [selectPlaylist] PlaylistItemType selectPlaylist
                 * @property {boolean|null} [alwaysRetrigger] PlaylistItemType alwaysRetrigger
                 */

                /**
                 * Constructs a new PlaylistItemType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a PlaylistItemType.
                 * @implements IPlaylistItemType
                 * @constructor
                 * @param {rv.data.Action.IPlaylistItemType=} [properties] Properties to set
                 */
                function PlaylistItemType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlaylistItemType playlistUuid.
                 * @member {rv.data.IUUID|null|undefined} playlistUuid
                 * @memberof rv.data.Action.PlaylistItemType
                 * @instance
                 */
                PlaylistItemType.prototype.playlistUuid = null;

                /**
                 * PlaylistItemType playlistName.
                 * @member {string} playlistName
                 * @memberof rv.data.Action.PlaylistItemType
                 * @instance
                 */
                PlaylistItemType.prototype.playlistName = "";

                /**
                 * PlaylistItemType itemUuid.
                 * @member {rv.data.IUUID|null|undefined} itemUuid
                 * @memberof rv.data.Action.PlaylistItemType
                 * @instance
                 */
                PlaylistItemType.prototype.itemUuid = null;

                /**
                 * PlaylistItemType itemName.
                 * @member {string} itemName
                 * @memberof rv.data.Action.PlaylistItemType
                 * @instance
                 */
                PlaylistItemType.prototype.itemName = "";

                /**
                 * PlaylistItemType selectPlaylist.
                 * @member {boolean} selectPlaylist
                 * @memberof rv.data.Action.PlaylistItemType
                 * @instance
                 */
                PlaylistItemType.prototype.selectPlaylist = false;

                /**
                 * PlaylistItemType alwaysRetrigger.
                 * @member {boolean} alwaysRetrigger
                 * @memberof rv.data.Action.PlaylistItemType
                 * @instance
                 */
                PlaylistItemType.prototype.alwaysRetrigger = false;

                /**
                 * Creates a new PlaylistItemType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.PlaylistItemType
                 * @static
                 * @param {rv.data.Action.IPlaylistItemType=} [properties] Properties to set
                 * @returns {rv.data.Action.PlaylistItemType} PlaylistItemType instance
                 */
                PlaylistItemType.create = function create(properties) {
                    return new PlaylistItemType(properties);
                };

                /**
                 * Encodes the specified PlaylistItemType message. Does not implicitly {@link rv.data.Action.PlaylistItemType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.PlaylistItemType
                 * @static
                 * @param {rv.data.Action.IPlaylistItemType} message PlaylistItemType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlaylistItemType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.playlistUuid != null && Object.hasOwnProperty.call(message, "playlistUuid"))
                        $root.rv.data.UUID.encode(message.playlistUuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.playlistName != null && Object.hasOwnProperty.call(message, "playlistName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.playlistName);
                    if (message.itemUuid != null && Object.hasOwnProperty.call(message, "itemUuid"))
                        $root.rv.data.UUID.encode(message.itemUuid, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.itemName != null && Object.hasOwnProperty.call(message, "itemName"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.itemName);
                    if (message.selectPlaylist != null && Object.hasOwnProperty.call(message, "selectPlaylist"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.selectPlaylist);
                    if (message.alwaysRetrigger != null && Object.hasOwnProperty.call(message, "alwaysRetrigger"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.alwaysRetrigger);
                    return writer;
                };

                /**
                 * Encodes the specified PlaylistItemType message, length delimited. Does not implicitly {@link rv.data.Action.PlaylistItemType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.PlaylistItemType
                 * @static
                 * @param {rv.data.Action.IPlaylistItemType} message PlaylistItemType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlaylistItemType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlaylistItemType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.PlaylistItemType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.PlaylistItemType} PlaylistItemType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlaylistItemType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.PlaylistItemType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.playlistUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.playlistName = reader.string();
                                break;
                            }
                        case 3: {
                                message.itemUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.itemName = reader.string();
                                break;
                            }
                        case 5: {
                                message.selectPlaylist = reader.bool();
                                break;
                            }
                        case 6: {
                                message.alwaysRetrigger = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlaylistItemType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.PlaylistItemType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.PlaylistItemType} PlaylistItemType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlaylistItemType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlaylistItemType message.
                 * @function verify
                 * @memberof rv.data.Action.PlaylistItemType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlaylistItemType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.playlistUuid != null && message.hasOwnProperty("playlistUuid")) {
                        let error = $root.rv.data.UUID.verify(message.playlistUuid);
                        if (error)
                            return "playlistUuid." + error;
                    }
                    if (message.playlistName != null && message.hasOwnProperty("playlistName"))
                        if (!$util.isString(message.playlistName))
                            return "playlistName: string expected";
                    if (message.itemUuid != null && message.hasOwnProperty("itemUuid")) {
                        let error = $root.rv.data.UUID.verify(message.itemUuid);
                        if (error)
                            return "itemUuid." + error;
                    }
                    if (message.itemName != null && message.hasOwnProperty("itemName"))
                        if (!$util.isString(message.itemName))
                            return "itemName: string expected";
                    if (message.selectPlaylist != null && message.hasOwnProperty("selectPlaylist"))
                        if (typeof message.selectPlaylist !== "boolean")
                            return "selectPlaylist: boolean expected";
                    if (message.alwaysRetrigger != null && message.hasOwnProperty("alwaysRetrigger"))
                        if (typeof message.alwaysRetrigger !== "boolean")
                            return "alwaysRetrigger: boolean expected";
                    return null;
                };

                /**
                 * Creates a PlaylistItemType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.PlaylistItemType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.PlaylistItemType} PlaylistItemType
                 */
                PlaylistItemType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.PlaylistItemType)
                        return object;
                    let message = new $root.rv.data.Action.PlaylistItemType();
                    if (object.playlistUuid != null) {
                        if (typeof object.playlistUuid !== "object")
                            throw TypeError(".rv.data.Action.PlaylistItemType.playlistUuid: object expected");
                        message.playlistUuid = $root.rv.data.UUID.fromObject(object.playlistUuid);
                    }
                    if (object.playlistName != null)
                        message.playlistName = String(object.playlistName);
                    if (object.itemUuid != null) {
                        if (typeof object.itemUuid !== "object")
                            throw TypeError(".rv.data.Action.PlaylistItemType.itemUuid: object expected");
                        message.itemUuid = $root.rv.data.UUID.fromObject(object.itemUuid);
                    }
                    if (object.itemName != null)
                        message.itemName = String(object.itemName);
                    if (object.selectPlaylist != null)
                        message.selectPlaylist = Boolean(object.selectPlaylist);
                    if (object.alwaysRetrigger != null)
                        message.alwaysRetrigger = Boolean(object.alwaysRetrigger);
                    return message;
                };

                /**
                 * Creates a plain object from a PlaylistItemType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.PlaylistItemType
                 * @static
                 * @param {rv.data.Action.PlaylistItemType} message PlaylistItemType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlaylistItemType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.playlistUuid = null;
                        object.playlistName = "";
                        object.itemUuid = null;
                        object.itemName = "";
                        object.selectPlaylist = false;
                        object.alwaysRetrigger = false;
                    }
                    if (message.playlistUuid != null && message.hasOwnProperty("playlistUuid"))
                        object.playlistUuid = $root.rv.data.UUID.toObject(message.playlistUuid, options);
                    if (message.playlistName != null && message.hasOwnProperty("playlistName"))
                        object.playlistName = message.playlistName;
                    if (message.itemUuid != null && message.hasOwnProperty("itemUuid"))
                        object.itemUuid = $root.rv.data.UUID.toObject(message.itemUuid, options);
                    if (message.itemName != null && message.hasOwnProperty("itemName"))
                        object.itemName = message.itemName;
                    if (message.selectPlaylist != null && message.hasOwnProperty("selectPlaylist"))
                        object.selectPlaylist = message.selectPlaylist;
                    if (message.alwaysRetrigger != null && message.hasOwnProperty("alwaysRetrigger"))
                        object.alwaysRetrigger = message.alwaysRetrigger;
                    return object;
                };

                /**
                 * Converts this PlaylistItemType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.PlaylistItemType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlaylistItemType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlaylistItemType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.PlaylistItemType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlaylistItemType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.PlaylistItemType";
                };

                return PlaylistItemType;
            })();

            Action.BlendModeType = (function() {

                /**
                 * Properties of a BlendModeType.
                 * @memberof rv.data.Action
                 * @interface IBlendModeType
                 * @property {rv.data.Layer.BlendMode|null} [blendMode] BlendModeType blendMode
                 * @property {rv.data.Layer.IBlending|null} [blend] BlendModeType blend
                 */

                /**
                 * Constructs a new BlendModeType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a BlendModeType.
                 * @implements IBlendModeType
                 * @constructor
                 * @param {rv.data.Action.IBlendModeType=} [properties] Properties to set
                 */
                function BlendModeType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BlendModeType blendMode.
                 * @member {rv.data.Layer.BlendMode} blendMode
                 * @memberof rv.data.Action.BlendModeType
                 * @instance
                 */
                BlendModeType.prototype.blendMode = 0;

                /**
                 * BlendModeType blend.
                 * @member {rv.data.Layer.IBlending|null|undefined} blend
                 * @memberof rv.data.Action.BlendModeType
                 * @instance
                 */
                BlendModeType.prototype.blend = null;

                /**
                 * Creates a new BlendModeType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.BlendModeType
                 * @static
                 * @param {rv.data.Action.IBlendModeType=} [properties] Properties to set
                 * @returns {rv.data.Action.BlendModeType} BlendModeType instance
                 */
                BlendModeType.create = function create(properties) {
                    return new BlendModeType(properties);
                };

                /**
                 * Encodes the specified BlendModeType message. Does not implicitly {@link rv.data.Action.BlendModeType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.BlendModeType
                 * @static
                 * @param {rv.data.Action.IBlendModeType} message BlendModeType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlendModeType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.blendMode != null && Object.hasOwnProperty.call(message, "blendMode"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.blendMode);
                    if (message.blend != null && Object.hasOwnProperty.call(message, "blend"))
                        $root.rv.data.Layer.Blending.encode(message.blend, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified BlendModeType message, length delimited. Does not implicitly {@link rv.data.Action.BlendModeType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.BlendModeType
                 * @static
                 * @param {rv.data.Action.IBlendModeType} message BlendModeType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlendModeType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BlendModeType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.BlendModeType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.BlendModeType} BlendModeType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlendModeType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.BlendModeType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.blendMode = reader.int32();
                                break;
                            }
                        case 2: {
                                message.blend = $root.rv.data.Layer.Blending.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BlendModeType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.BlendModeType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.BlendModeType} BlendModeType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlendModeType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BlendModeType message.
                 * @function verify
                 * @memberof rv.data.Action.BlendModeType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BlendModeType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.blendMode != null && message.hasOwnProperty("blendMode"))
                        switch (message.blendMode) {
                        default:
                            return "blendMode: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                        case 19:
                        case 20:
                        case 21:
                        case 22:
                        case 23:
                        case 24:
                        case 25:
                        case 26:
                            break;
                        }
                    if (message.blend != null && message.hasOwnProperty("blend")) {
                        let error = $root.rv.data.Layer.Blending.verify(message.blend);
                        if (error)
                            return "blend." + error;
                    }
                    return null;
                };

                /**
                 * Creates a BlendModeType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.BlendModeType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.BlendModeType} BlendModeType
                 */
                BlendModeType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.BlendModeType)
                        return object;
                    let message = new $root.rv.data.Action.BlendModeType();
                    switch (object.blendMode) {
                    default:
                        if (typeof object.blendMode === "number") {
                            message.blendMode = object.blendMode;
                            break;
                        }
                        break;
                    case "BLEND_MODE_NORMAL":
                    case 0:
                        message.blendMode = 0;
                        break;
                    case "BLEND_MODE_DISSOLVE":
                    case 1:
                        message.blendMode = 1;
                        break;
                    case "BLEND_MODE_DARKEN":
                    case 2:
                        message.blendMode = 2;
                        break;
                    case "BLEND_MODE_MULTIPLY":
                    case 3:
                        message.blendMode = 3;
                        break;
                    case "BLEND_MODE_COLOR_BURN":
                    case 4:
                        message.blendMode = 4;
                        break;
                    case "BLEND_MODE_LINEAR_BURN":
                    case 5:
                        message.blendMode = 5;
                        break;
                    case "BLEND_MODE_DARKER_COLOR":
                    case 6:
                        message.blendMode = 6;
                        break;
                    case "BLEND_MODE_LIGHTEN":
                    case 7:
                        message.blendMode = 7;
                        break;
                    case "BLEND_MODE_SCREEN":
                    case 8:
                        message.blendMode = 8;
                        break;
                    case "BLEND_MODE_COLOR_DODGE":
                    case 9:
                        message.blendMode = 9;
                        break;
                    case "BLEND_MODE_LINEAR_DODGE":
                    case 10:
                        message.blendMode = 10;
                        break;
                    case "BLEND_MODE_LIGHTER_COLOR":
                    case 11:
                        message.blendMode = 11;
                        break;
                    case "BLEND_MODE_OVERLAY":
                    case 12:
                        message.blendMode = 12;
                        break;
                    case "BLEND_MODE_SOFT_LIGHT":
                    case 13:
                        message.blendMode = 13;
                        break;
                    case "BLEND_MODE_HARD_LIGHT":
                    case 14:
                        message.blendMode = 14;
                        break;
                    case "BLEND_MODE_VIVID_LIGHT":
                    case 15:
                        message.blendMode = 15;
                        break;
                    case "BLEND_MODE_LINEAR_LIGHT":
                    case 16:
                        message.blendMode = 16;
                        break;
                    case "BLEND_MODE_PIN_LIGHT":
                    case 17:
                        message.blendMode = 17;
                        break;
                    case "BLEND_MODE_HARD_MIX":
                    case 18:
                        message.blendMode = 18;
                        break;
                    case "BLEND_MODE_DIFFERENCE":
                    case 19:
                        message.blendMode = 19;
                        break;
                    case "BLEND_MODE_EXCLUSION":
                    case 20:
                        message.blendMode = 20;
                        break;
                    case "BLEND_MODE_SUBTRACT":
                    case 21:
                        message.blendMode = 21;
                        break;
                    case "BLEND_MODE_DIVIDE":
                    case 22:
                        message.blendMode = 22;
                        break;
                    case "BLEND_MODE_HUE":
                    case 23:
                        message.blendMode = 23;
                        break;
                    case "BLEND_MODE_SATURATION":
                    case 24:
                        message.blendMode = 24;
                        break;
                    case "BLEND_MODE_COLOR":
                    case 25:
                        message.blendMode = 25;
                        break;
                    case "BLEND_MODE_LUMINOSITY":
                    case 26:
                        message.blendMode = 26;
                        break;
                    }
                    if (object.blend != null) {
                        if (typeof object.blend !== "object")
                            throw TypeError(".rv.data.Action.BlendModeType.blend: object expected");
                        message.blend = $root.rv.data.Layer.Blending.fromObject(object.blend);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BlendModeType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.BlendModeType
                 * @static
                 * @param {rv.data.Action.BlendModeType} message BlendModeType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BlendModeType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.blendMode = options.enums === String ? "BLEND_MODE_NORMAL" : 0;
                        object.blend = null;
                    }
                    if (message.blendMode != null && message.hasOwnProperty("blendMode"))
                        object.blendMode = options.enums === String ? $root.rv.data.Layer.BlendMode[message.blendMode] === undefined ? message.blendMode : $root.rv.data.Layer.BlendMode[message.blendMode] : message.blendMode;
                    if (message.blend != null && message.hasOwnProperty("blend"))
                        object.blend = $root.rv.data.Layer.Blending.toObject(message.blend, options);
                    return object;
                };

                /**
                 * Converts this BlendModeType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.BlendModeType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BlendModeType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BlendModeType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.BlendModeType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BlendModeType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.BlendModeType";
                };

                return BlendModeType;
            })();

            Action.TransitionType = (function() {

                /**
                 * Properties of a TransitionType.
                 * @memberof rv.data.Action
                 * @interface ITransitionType
                 * @property {string|null} [transitionName] TransitionType transitionName
                 * @property {rv.data.ITransition|null} [transition] TransitionType transition
                 */

                /**
                 * Constructs a new TransitionType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a TransitionType.
                 * @implements ITransitionType
                 * @constructor
                 * @param {rv.data.Action.ITransitionType=} [properties] Properties to set
                 */
                function TransitionType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TransitionType transitionName.
                 * @member {string} transitionName
                 * @memberof rv.data.Action.TransitionType
                 * @instance
                 */
                TransitionType.prototype.transitionName = "";

                /**
                 * TransitionType transition.
                 * @member {rv.data.ITransition|null|undefined} transition
                 * @memberof rv.data.Action.TransitionType
                 * @instance
                 */
                TransitionType.prototype.transition = null;

                /**
                 * Creates a new TransitionType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.TransitionType
                 * @static
                 * @param {rv.data.Action.ITransitionType=} [properties] Properties to set
                 * @returns {rv.data.Action.TransitionType} TransitionType instance
                 */
                TransitionType.create = function create(properties) {
                    return new TransitionType(properties);
                };

                /**
                 * Encodes the specified TransitionType message. Does not implicitly {@link rv.data.Action.TransitionType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.TransitionType
                 * @static
                 * @param {rv.data.Action.ITransitionType} message TransitionType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransitionType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transitionName != null && Object.hasOwnProperty.call(message, "transitionName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.transitionName);
                    if (message.transition != null && Object.hasOwnProperty.call(message, "transition"))
                        $root.rv.data.Transition.encode(message.transition, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TransitionType message, length delimited. Does not implicitly {@link rv.data.Action.TransitionType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.TransitionType
                 * @static
                 * @param {rv.data.Action.ITransitionType} message TransitionType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransitionType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TransitionType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.TransitionType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.TransitionType} TransitionType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransitionType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.TransitionType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.transitionName = reader.string();
                                break;
                            }
                        case 2: {
                                message.transition = $root.rv.data.Transition.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TransitionType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.TransitionType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.TransitionType} TransitionType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransitionType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TransitionType message.
                 * @function verify
                 * @memberof rv.data.Action.TransitionType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransitionType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.transitionName != null && message.hasOwnProperty("transitionName"))
                        if (!$util.isString(message.transitionName))
                            return "transitionName: string expected";
                    if (message.transition != null && message.hasOwnProperty("transition")) {
                        let error = $root.rv.data.Transition.verify(message.transition);
                        if (error)
                            return "transition." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TransitionType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.TransitionType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.TransitionType} TransitionType
                 */
                TransitionType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.TransitionType)
                        return object;
                    let message = new $root.rv.data.Action.TransitionType();
                    if (object.transitionName != null)
                        message.transitionName = String(object.transitionName);
                    if (object.transition != null) {
                        if (typeof object.transition !== "object")
                            throw TypeError(".rv.data.Action.TransitionType.transition: object expected");
                        message.transition = $root.rv.data.Transition.fromObject(object.transition);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TransitionType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.TransitionType
                 * @static
                 * @param {rv.data.Action.TransitionType} message TransitionType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransitionType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.transitionName = "";
                        object.transition = null;
                    }
                    if (message.transitionName != null && message.hasOwnProperty("transitionName"))
                        object.transitionName = message.transitionName;
                    if (message.transition != null && message.hasOwnProperty("transition"))
                        object.transition = $root.rv.data.Transition.toObject(message.transition, options);
                    return object;
                };

                /**
                 * Converts this TransitionType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.TransitionType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransitionType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TransitionType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.TransitionType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TransitionType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.TransitionType";
                };

                return TransitionType;
            })();

            Action.DoubleType = (function() {

                /**
                 * Properties of a DoubleType.
                 * @memberof rv.data.Action
                 * @interface IDoubleType
                 * @property {number|null} [value] DoubleType value
                 */

                /**
                 * Constructs a new DoubleType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a DoubleType.
                 * @implements IDoubleType
                 * @constructor
                 * @param {rv.data.Action.IDoubleType=} [properties] Properties to set
                 */
                function DoubleType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DoubleType value.
                 * @member {number} value
                 * @memberof rv.data.Action.DoubleType
                 * @instance
                 */
                DoubleType.prototype.value = 0;

                /**
                 * Creates a new DoubleType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.DoubleType
                 * @static
                 * @param {rv.data.Action.IDoubleType=} [properties] Properties to set
                 * @returns {rv.data.Action.DoubleType} DoubleType instance
                 */
                DoubleType.create = function create(properties) {
                    return new DoubleType(properties);
                };

                /**
                 * Encodes the specified DoubleType message. Does not implicitly {@link rv.data.Action.DoubleType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.DoubleType
                 * @static
                 * @param {rv.data.Action.IDoubleType} message DoubleType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DoubleType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                    return writer;
                };

                /**
                 * Encodes the specified DoubleType message, length delimited. Does not implicitly {@link rv.data.Action.DoubleType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.DoubleType
                 * @static
                 * @param {rv.data.Action.IDoubleType} message DoubleType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DoubleType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DoubleType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.DoubleType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.DoubleType} DoubleType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DoubleType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.DoubleType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.value = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DoubleType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.DoubleType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.DoubleType} DoubleType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DoubleType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DoubleType message.
                 * @function verify
                 * @memberof rv.data.Action.DoubleType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DoubleType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "number")
                            return "value: number expected";
                    return null;
                };

                /**
                 * Creates a DoubleType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.DoubleType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.DoubleType} DoubleType
                 */
                DoubleType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.DoubleType)
                        return object;
                    let message = new $root.rv.data.Action.DoubleType();
                    if (object.value != null)
                        message.value = Number(object.value);
                    return message;
                };

                /**
                 * Creates a plain object from a DoubleType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.DoubleType
                 * @static
                 * @param {rv.data.Action.DoubleType} message DoubleType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DoubleType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.value = 0;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                    return object;
                };

                /**
                 * Converts this DoubleType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.DoubleType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DoubleType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for DoubleType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.DoubleType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                DoubleType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.DoubleType";
                };

                return DoubleType;
            })();

            Action.EffectsType = (function() {

                /**
                 * Properties of an EffectsType.
                 * @memberof rv.data.Action
                 * @interface IEffectsType
                 * @property {Array.<rv.data.IEffect>|null} [effects] EffectsType effects
                 */

                /**
                 * Constructs a new EffectsType.
                 * @memberof rv.data.Action
                 * @classdesc Represents an EffectsType.
                 * @implements IEffectsType
                 * @constructor
                 * @param {rv.data.Action.IEffectsType=} [properties] Properties to set
                 */
                function EffectsType(properties) {
                    this.effects = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EffectsType effects.
                 * @member {Array.<rv.data.IEffect>} effects
                 * @memberof rv.data.Action.EffectsType
                 * @instance
                 */
                EffectsType.prototype.effects = $util.emptyArray;

                /**
                 * Creates a new EffectsType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.EffectsType
                 * @static
                 * @param {rv.data.Action.IEffectsType=} [properties] Properties to set
                 * @returns {rv.data.Action.EffectsType} EffectsType instance
                 */
                EffectsType.create = function create(properties) {
                    return new EffectsType(properties);
                };

                /**
                 * Encodes the specified EffectsType message. Does not implicitly {@link rv.data.Action.EffectsType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.EffectsType
                 * @static
                 * @param {rv.data.Action.IEffectsType} message EffectsType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EffectsType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.effects != null && message.effects.length)
                        for (let i = 0; i < message.effects.length; ++i)
                            $root.rv.data.Effect.encode(message.effects[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified EffectsType message, length delimited. Does not implicitly {@link rv.data.Action.EffectsType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.EffectsType
                 * @static
                 * @param {rv.data.Action.IEffectsType} message EffectsType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EffectsType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EffectsType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.EffectsType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.EffectsType} EffectsType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EffectsType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.EffectsType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.effects && message.effects.length))
                                    message.effects = [];
                                message.effects.push($root.rv.data.Effect.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EffectsType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.EffectsType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.EffectsType} EffectsType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EffectsType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EffectsType message.
                 * @function verify
                 * @memberof rv.data.Action.EffectsType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EffectsType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.effects != null && message.hasOwnProperty("effects")) {
                        if (!Array.isArray(message.effects))
                            return "effects: array expected";
                        for (let i = 0; i < message.effects.length; ++i) {
                            let error = $root.rv.data.Effect.verify(message.effects[i]);
                            if (error)
                                return "effects." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an EffectsType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.EffectsType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.EffectsType} EffectsType
                 */
                EffectsType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.EffectsType)
                        return object;
                    let message = new $root.rv.data.Action.EffectsType();
                    if (object.effects) {
                        if (!Array.isArray(object.effects))
                            throw TypeError(".rv.data.Action.EffectsType.effects: array expected");
                        message.effects = [];
                        for (let i = 0; i < object.effects.length; ++i) {
                            if (typeof object.effects[i] !== "object")
                                throw TypeError(".rv.data.Action.EffectsType.effects: object expected");
                            message.effects[i] = $root.rv.data.Effect.fromObject(object.effects[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an EffectsType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.EffectsType
                 * @static
                 * @param {rv.data.Action.EffectsType} message EffectsType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EffectsType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.effects = [];
                    if (message.effects && message.effects.length) {
                        object.effects = [];
                        for (let j = 0; j < message.effects.length; ++j)
                            object.effects[j] = $root.rv.data.Effect.toObject(message.effects[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this EffectsType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.EffectsType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EffectsType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for EffectsType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.EffectsType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EffectsType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.EffectsType";
                };

                return EffectsType;
            })();

            Action.MediaType = (function() {

                /**
                 * Properties of a MediaType.
                 * @memberof rv.data.Action
                 * @interface IMediaType
                 * @property {number|null} [transitionDuration] MediaType transitionDuration
                 * @property {rv.data.IUUID|null} [selectedEffectPresetUuid] MediaType selectedEffectPresetUuid
                 * @property {rv.data.ITransition|null} [transition] MediaType transition
                 * @property {Array.<rv.data.IEffect>|null} [effects] MediaType effects
                 * @property {rv.data.IMedia|null} [element] MediaType element
                 * @property {rv.data.Action.LayerType|null} [layerType] MediaType layerType
                 * @property {boolean|null} [alwaysRetrigger] MediaType alwaysRetrigger
                 * @property {Array.<rv.data.Action.MediaType.IPlaybackMarker>|null} [markers] MediaType markers
                 * @property {rv.data.Action.MediaType.IImage|null} [image] MediaType image
                 * @property {rv.data.Action.MediaType.IVideo|null} [video] MediaType video
                 * @property {rv.data.Action.MediaType.IAudio|null} [audio] MediaType audio
                 * @property {rv.data.Action.MediaType.ILiveVideo|null} [liveVideo] MediaType liveVideo
                 */

                /**
                 * Constructs a new MediaType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a MediaType.
                 * @implements IMediaType
                 * @constructor
                 * @param {rv.data.Action.IMediaType=} [properties] Properties to set
                 */
                function MediaType(properties) {
                    this.effects = [];
                    this.markers = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MediaType transitionDuration.
                 * @member {number} transitionDuration
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 */
                MediaType.prototype.transitionDuration = 0;

                /**
                 * MediaType selectedEffectPresetUuid.
                 * @member {rv.data.IUUID|null|undefined} selectedEffectPresetUuid
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 */
                MediaType.prototype.selectedEffectPresetUuid = null;

                /**
                 * MediaType transition.
                 * @member {rv.data.ITransition|null|undefined} transition
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 */
                MediaType.prototype.transition = null;

                /**
                 * MediaType effects.
                 * @member {Array.<rv.data.IEffect>} effects
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 */
                MediaType.prototype.effects = $util.emptyArray;

                /**
                 * MediaType element.
                 * @member {rv.data.IMedia|null|undefined} element
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 */
                MediaType.prototype.element = null;

                /**
                 * MediaType layerType.
                 * @member {rv.data.Action.LayerType} layerType
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 */
                MediaType.prototype.layerType = 0;

                /**
                 * MediaType alwaysRetrigger.
                 * @member {boolean} alwaysRetrigger
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 */
                MediaType.prototype.alwaysRetrigger = false;

                /**
                 * MediaType markers.
                 * @member {Array.<rv.data.Action.MediaType.IPlaybackMarker>} markers
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 */
                MediaType.prototype.markers = $util.emptyArray;

                /**
                 * MediaType image.
                 * @member {rv.data.Action.MediaType.IImage|null|undefined} image
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 */
                MediaType.prototype.image = null;

                /**
                 * MediaType video.
                 * @member {rv.data.Action.MediaType.IVideo|null|undefined} video
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 */
                MediaType.prototype.video = null;

                /**
                 * MediaType audio.
                 * @member {rv.data.Action.MediaType.IAudio|null|undefined} audio
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 */
                MediaType.prototype.audio = null;

                /**
                 * MediaType liveVideo.
                 * @member {rv.data.Action.MediaType.ILiveVideo|null|undefined} liveVideo
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 */
                MediaType.prototype.liveVideo = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * MediaType MediaType.
                 * @member {"image"|"video"|"audio"|"liveVideo"|undefined} MediaType
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 */
                Object.defineProperty(MediaType.prototype, "MediaType", {
                    get: $util.oneOfGetter($oneOfFields = ["image", "video", "audio", "liveVideo"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new MediaType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.MediaType
                 * @static
                 * @param {rv.data.Action.IMediaType=} [properties] Properties to set
                 * @returns {rv.data.Action.MediaType} MediaType instance
                 */
                MediaType.create = function create(properties) {
                    return new MediaType(properties);
                };

                /**
                 * Encodes the specified MediaType message. Does not implicitly {@link rv.data.Action.MediaType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.MediaType
                 * @static
                 * @param {rv.data.Action.IMediaType} message MediaType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MediaType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transitionDuration != null && Object.hasOwnProperty.call(message, "transitionDuration"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.transitionDuration);
                    if (message.selectedEffectPresetUuid != null && Object.hasOwnProperty.call(message, "selectedEffectPresetUuid"))
                        $root.rv.data.UUID.encode(message.selectedEffectPresetUuid, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.transition != null && Object.hasOwnProperty.call(message, "transition"))
                        $root.rv.data.Transition.encode(message.transition, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.effects != null && message.effects.length)
                        for (let i = 0; i < message.effects.length; ++i)
                            $root.rv.data.Effect.encode(message.effects[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.element != null && Object.hasOwnProperty.call(message, "element"))
                        $root.rv.data.Media.encode(message.element, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                        $root.rv.data.Action.MediaType.Image.encode(message.image, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.video != null && Object.hasOwnProperty.call(message, "video"))
                        $root.rv.data.Action.MediaType.Video.encode(message.video, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                        $root.rv.data.Action.MediaType.Audio.encode(message.audio, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.liveVideo != null && Object.hasOwnProperty.call(message, "liveVideo"))
                        $root.rv.data.Action.MediaType.LiveVideo.encode(message.liveVideo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.layerType != null && Object.hasOwnProperty.call(message, "layerType"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.layerType);
                    if (message.alwaysRetrigger != null && Object.hasOwnProperty.call(message, "alwaysRetrigger"))
                        writer.uint32(/* id 11, wireType 0 =*/88).bool(message.alwaysRetrigger);
                    if (message.markers != null && message.markers.length)
                        for (let i = 0; i < message.markers.length; ++i)
                            $root.rv.data.Action.MediaType.PlaybackMarker.encode(message.markers[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MediaType message, length delimited. Does not implicitly {@link rv.data.Action.MediaType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.MediaType
                 * @static
                 * @param {rv.data.Action.IMediaType} message MediaType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MediaType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MediaType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.MediaType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.MediaType} MediaType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MediaType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.MediaType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.transitionDuration = reader.double();
                                break;
                            }
                        case 2: {
                                message.selectedEffectPresetUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.transition = $root.rv.data.Transition.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                if (!(message.effects && message.effects.length))
                                    message.effects = [];
                                message.effects.push($root.rv.data.Effect.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                message.element = $root.rv.data.Media.decode(reader, reader.uint32());
                                break;
                            }
                        case 10: {
                                message.layerType = reader.int32();
                                break;
                            }
                        case 11: {
                                message.alwaysRetrigger = reader.bool();
                                break;
                            }
                        case 12: {
                                if (!(message.markers && message.markers.length))
                                    message.markers = [];
                                message.markers.push($root.rv.data.Action.MediaType.PlaybackMarker.decode(reader, reader.uint32()));
                                break;
                            }
                        case 6: {
                                message.image = $root.rv.data.Action.MediaType.Image.decode(reader, reader.uint32());
                                break;
                            }
                        case 7: {
                                message.video = $root.rv.data.Action.MediaType.Video.decode(reader, reader.uint32());
                                break;
                            }
                        case 8: {
                                message.audio = $root.rv.data.Action.MediaType.Audio.decode(reader, reader.uint32());
                                break;
                            }
                        case 9: {
                                message.liveVideo = $root.rv.data.Action.MediaType.LiveVideo.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MediaType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.MediaType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.MediaType} MediaType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MediaType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MediaType message.
                 * @function verify
                 * @memberof rv.data.Action.MediaType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MediaType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.transitionDuration != null && message.hasOwnProperty("transitionDuration"))
                        if (typeof message.transitionDuration !== "number")
                            return "transitionDuration: number expected";
                    if (message.selectedEffectPresetUuid != null && message.hasOwnProperty("selectedEffectPresetUuid")) {
                        let error = $root.rv.data.UUID.verify(message.selectedEffectPresetUuid);
                        if (error)
                            return "selectedEffectPresetUuid." + error;
                    }
                    if (message.transition != null && message.hasOwnProperty("transition")) {
                        let error = $root.rv.data.Transition.verify(message.transition);
                        if (error)
                            return "transition." + error;
                    }
                    if (message.effects != null && message.hasOwnProperty("effects")) {
                        if (!Array.isArray(message.effects))
                            return "effects: array expected";
                        for (let i = 0; i < message.effects.length; ++i) {
                            let error = $root.rv.data.Effect.verify(message.effects[i]);
                            if (error)
                                return "effects." + error;
                        }
                    }
                    if (message.element != null && message.hasOwnProperty("element")) {
                        let error = $root.rv.data.Media.verify(message.element);
                        if (error)
                            return "element." + error;
                    }
                    if (message.layerType != null && message.hasOwnProperty("layerType"))
                        switch (message.layerType) {
                        default:
                            return "layerType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.alwaysRetrigger != null && message.hasOwnProperty("alwaysRetrigger"))
                        if (typeof message.alwaysRetrigger !== "boolean")
                            return "alwaysRetrigger: boolean expected";
                    if (message.markers != null && message.hasOwnProperty("markers")) {
                        if (!Array.isArray(message.markers))
                            return "markers: array expected";
                        for (let i = 0; i < message.markers.length; ++i) {
                            let error = $root.rv.data.Action.MediaType.PlaybackMarker.verify(message.markers[i]);
                            if (error)
                                return "markers." + error;
                        }
                    }
                    if (message.image != null && message.hasOwnProperty("image")) {
                        properties.MediaType = 1;
                        {
                            let error = $root.rv.data.Action.MediaType.Image.verify(message.image);
                            if (error)
                                return "image." + error;
                        }
                    }
                    if (message.video != null && message.hasOwnProperty("video")) {
                        if (properties.MediaType === 1)
                            return "MediaType: multiple values";
                        properties.MediaType = 1;
                        {
                            let error = $root.rv.data.Action.MediaType.Video.verify(message.video);
                            if (error)
                                return "video." + error;
                        }
                    }
                    if (message.audio != null && message.hasOwnProperty("audio")) {
                        if (properties.MediaType === 1)
                            return "MediaType: multiple values";
                        properties.MediaType = 1;
                        {
                            let error = $root.rv.data.Action.MediaType.Audio.verify(message.audio);
                            if (error)
                                return "audio." + error;
                        }
                    }
                    if (message.liveVideo != null && message.hasOwnProperty("liveVideo")) {
                        if (properties.MediaType === 1)
                            return "MediaType: multiple values";
                        properties.MediaType = 1;
                        {
                            let error = $root.rv.data.Action.MediaType.LiveVideo.verify(message.liveVideo);
                            if (error)
                                return "liveVideo." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MediaType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.MediaType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.MediaType} MediaType
                 */
                MediaType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.MediaType)
                        return object;
                    let message = new $root.rv.data.Action.MediaType();
                    if (object.transitionDuration != null)
                        message.transitionDuration = Number(object.transitionDuration);
                    if (object.selectedEffectPresetUuid != null) {
                        if (typeof object.selectedEffectPresetUuid !== "object")
                            throw TypeError(".rv.data.Action.MediaType.selectedEffectPresetUuid: object expected");
                        message.selectedEffectPresetUuid = $root.rv.data.UUID.fromObject(object.selectedEffectPresetUuid);
                    }
                    if (object.transition != null) {
                        if (typeof object.transition !== "object")
                            throw TypeError(".rv.data.Action.MediaType.transition: object expected");
                        message.transition = $root.rv.data.Transition.fromObject(object.transition);
                    }
                    if (object.effects) {
                        if (!Array.isArray(object.effects))
                            throw TypeError(".rv.data.Action.MediaType.effects: array expected");
                        message.effects = [];
                        for (let i = 0; i < object.effects.length; ++i) {
                            if (typeof object.effects[i] !== "object")
                                throw TypeError(".rv.data.Action.MediaType.effects: object expected");
                            message.effects[i] = $root.rv.data.Effect.fromObject(object.effects[i]);
                        }
                    }
                    if (object.element != null) {
                        if (typeof object.element !== "object")
                            throw TypeError(".rv.data.Action.MediaType.element: object expected");
                        message.element = $root.rv.data.Media.fromObject(object.element);
                    }
                    switch (object.layerType) {
                    default:
                        if (typeof object.layerType === "number") {
                            message.layerType = object.layerType;
                            break;
                        }
                        break;
                    case "LAYER_TYPE_BACKGROUND":
                    case 0:
                        message.layerType = 0;
                        break;
                    case "LAYER_TYPE_FOREGROUND":
                    case 1:
                        message.layerType = 1;
                        break;
                    case "LAYER_TYPE_FILL":
                    case 2:
                        message.layerType = 2;
                        break;
                    case "LAYER_TYPE_INPUT":
                    case 3:
                        message.layerType = 3;
                        break;
                    }
                    if (object.alwaysRetrigger != null)
                        message.alwaysRetrigger = Boolean(object.alwaysRetrigger);
                    if (object.markers) {
                        if (!Array.isArray(object.markers))
                            throw TypeError(".rv.data.Action.MediaType.markers: array expected");
                        message.markers = [];
                        for (let i = 0; i < object.markers.length; ++i) {
                            if (typeof object.markers[i] !== "object")
                                throw TypeError(".rv.data.Action.MediaType.markers: object expected");
                            message.markers[i] = $root.rv.data.Action.MediaType.PlaybackMarker.fromObject(object.markers[i]);
                        }
                    }
                    if (object.image != null) {
                        if (typeof object.image !== "object")
                            throw TypeError(".rv.data.Action.MediaType.image: object expected");
                        message.image = $root.rv.data.Action.MediaType.Image.fromObject(object.image);
                    }
                    if (object.video != null) {
                        if (typeof object.video !== "object")
                            throw TypeError(".rv.data.Action.MediaType.video: object expected");
                        message.video = $root.rv.data.Action.MediaType.Video.fromObject(object.video);
                    }
                    if (object.audio != null) {
                        if (typeof object.audio !== "object")
                            throw TypeError(".rv.data.Action.MediaType.audio: object expected");
                        message.audio = $root.rv.data.Action.MediaType.Audio.fromObject(object.audio);
                    }
                    if (object.liveVideo != null) {
                        if (typeof object.liveVideo !== "object")
                            throw TypeError(".rv.data.Action.MediaType.liveVideo: object expected");
                        message.liveVideo = $root.rv.data.Action.MediaType.LiveVideo.fromObject(object.liveVideo);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MediaType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.MediaType
                 * @static
                 * @param {rv.data.Action.MediaType} message MediaType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MediaType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.effects = [];
                        object.markers = [];
                    }
                    if (options.defaults) {
                        object.transitionDuration = 0;
                        object.selectedEffectPresetUuid = null;
                        object.transition = null;
                        object.element = null;
                        object.layerType = options.enums === String ? "LAYER_TYPE_BACKGROUND" : 0;
                        object.alwaysRetrigger = false;
                    }
                    if (message.transitionDuration != null && message.hasOwnProperty("transitionDuration"))
                        object.transitionDuration = options.json && !isFinite(message.transitionDuration) ? String(message.transitionDuration) : message.transitionDuration;
                    if (message.selectedEffectPresetUuid != null && message.hasOwnProperty("selectedEffectPresetUuid"))
                        object.selectedEffectPresetUuid = $root.rv.data.UUID.toObject(message.selectedEffectPresetUuid, options);
                    if (message.transition != null && message.hasOwnProperty("transition"))
                        object.transition = $root.rv.data.Transition.toObject(message.transition, options);
                    if (message.effects && message.effects.length) {
                        object.effects = [];
                        for (let j = 0; j < message.effects.length; ++j)
                            object.effects[j] = $root.rv.data.Effect.toObject(message.effects[j], options);
                    }
                    if (message.element != null && message.hasOwnProperty("element"))
                        object.element = $root.rv.data.Media.toObject(message.element, options);
                    if (message.image != null && message.hasOwnProperty("image")) {
                        object.image = $root.rv.data.Action.MediaType.Image.toObject(message.image, options);
                        if (options.oneofs)
                            object.MediaType = "image";
                    }
                    if (message.video != null && message.hasOwnProperty("video")) {
                        object.video = $root.rv.data.Action.MediaType.Video.toObject(message.video, options);
                        if (options.oneofs)
                            object.MediaType = "video";
                    }
                    if (message.audio != null && message.hasOwnProperty("audio")) {
                        object.audio = $root.rv.data.Action.MediaType.Audio.toObject(message.audio, options);
                        if (options.oneofs)
                            object.MediaType = "audio";
                    }
                    if (message.liveVideo != null && message.hasOwnProperty("liveVideo")) {
                        object.liveVideo = $root.rv.data.Action.MediaType.LiveVideo.toObject(message.liveVideo, options);
                        if (options.oneofs)
                            object.MediaType = "liveVideo";
                    }
                    if (message.layerType != null && message.hasOwnProperty("layerType"))
                        object.layerType = options.enums === String ? $root.rv.data.Action.LayerType[message.layerType] === undefined ? message.layerType : $root.rv.data.Action.LayerType[message.layerType] : message.layerType;
                    if (message.alwaysRetrigger != null && message.hasOwnProperty("alwaysRetrigger"))
                        object.alwaysRetrigger = message.alwaysRetrigger;
                    if (message.markers && message.markers.length) {
                        object.markers = [];
                        for (let j = 0; j < message.markers.length; ++j)
                            object.markers[j] = $root.rv.data.Action.MediaType.PlaybackMarker.toObject(message.markers[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MediaType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.MediaType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MediaType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MediaType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.MediaType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MediaType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.MediaType";
                };

                MediaType.Image = (function() {

                    /**
                     * Properties of an Image.
                     * @memberof rv.data.Action.MediaType
                     * @interface IImage
                     */

                    /**
                     * Constructs a new Image.
                     * @memberof rv.data.Action.MediaType
                     * @classdesc Represents an Image.
                     * @implements IImage
                     * @constructor
                     * @param {rv.data.Action.MediaType.IImage=} [properties] Properties to set
                     */
                    function Image(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Image instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.MediaType.Image
                     * @static
                     * @param {rv.data.Action.MediaType.IImage=} [properties] Properties to set
                     * @returns {rv.data.Action.MediaType.Image} Image instance
                     */
                    Image.create = function create(properties) {
                        return new Image(properties);
                    };

                    /**
                     * Encodes the specified Image message. Does not implicitly {@link rv.data.Action.MediaType.Image.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.MediaType.Image
                     * @static
                     * @param {rv.data.Action.MediaType.IImage} message Image message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Image.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Image message, length delimited. Does not implicitly {@link rv.data.Action.MediaType.Image.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.MediaType.Image
                     * @static
                     * @param {rv.data.Action.MediaType.IImage} message Image message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Image.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Image message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.MediaType.Image
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.MediaType.Image} Image
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Image.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.MediaType.Image();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Image message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.MediaType.Image
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.MediaType.Image} Image
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Image.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Image message.
                     * @function verify
                     * @memberof rv.data.Action.MediaType.Image
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Image.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates an Image message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.MediaType.Image
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.MediaType.Image} Image
                     */
                    Image.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.MediaType.Image)
                            return object;
                        return new $root.rv.data.Action.MediaType.Image();
                    };

                    /**
                     * Creates a plain object from an Image message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.MediaType.Image
                     * @static
                     * @param {rv.data.Action.MediaType.Image} message Image
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Image.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Image to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.MediaType.Image
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Image.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Image
                     * @function getTypeUrl
                     * @memberof rv.data.Action.MediaType.Image
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Image.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.MediaType.Image";
                    };

                    return Image;
                })();

                MediaType.Video = (function() {

                    /**
                     * Properties of a Video.
                     * @memberof rv.data.Action.MediaType
                     * @interface IVideo
                     * @property {rv.data.Action.MediaType.PlaybackBehavior|null} [playbackBehavior] Video playbackBehavior
                     * @property {rv.data.Action.MediaType.EndBehavior|null} [endBehavior] Video endBehavior
                     * @property {number|null} [loopTime] Video loopTime
                     * @property {number|null} [timesToLoop] Video timesToLoop
                     * @property {boolean|null} [softLoop] Video softLoop
                     * @property {number|null} [softLoopDuration] Video softLoopDuration
                     */

                    /**
                     * Constructs a new Video.
                     * @memberof rv.data.Action.MediaType
                     * @classdesc Represents a Video.
                     * @implements IVideo
                     * @constructor
                     * @param {rv.data.Action.MediaType.IVideo=} [properties] Properties to set
                     */
                    function Video(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Video playbackBehavior.
                     * @member {rv.data.Action.MediaType.PlaybackBehavior} playbackBehavior
                     * @memberof rv.data.Action.MediaType.Video
                     * @instance
                     */
                    Video.prototype.playbackBehavior = 0;

                    /**
                     * Video endBehavior.
                     * @member {rv.data.Action.MediaType.EndBehavior} endBehavior
                     * @memberof rv.data.Action.MediaType.Video
                     * @instance
                     */
                    Video.prototype.endBehavior = 0;

                    /**
                     * Video loopTime.
                     * @member {number} loopTime
                     * @memberof rv.data.Action.MediaType.Video
                     * @instance
                     */
                    Video.prototype.loopTime = 0;

                    /**
                     * Video timesToLoop.
                     * @member {number} timesToLoop
                     * @memberof rv.data.Action.MediaType.Video
                     * @instance
                     */
                    Video.prototype.timesToLoop = 0;

                    /**
                     * Video softLoop.
                     * @member {boolean} softLoop
                     * @memberof rv.data.Action.MediaType.Video
                     * @instance
                     */
                    Video.prototype.softLoop = false;

                    /**
                     * Video softLoopDuration.
                     * @member {number} softLoopDuration
                     * @memberof rv.data.Action.MediaType.Video
                     * @instance
                     */
                    Video.prototype.softLoopDuration = 0;

                    /**
                     * Creates a new Video instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.MediaType.Video
                     * @static
                     * @param {rv.data.Action.MediaType.IVideo=} [properties] Properties to set
                     * @returns {rv.data.Action.MediaType.Video} Video instance
                     */
                    Video.create = function create(properties) {
                        return new Video(properties);
                    };

                    /**
                     * Encodes the specified Video message. Does not implicitly {@link rv.data.Action.MediaType.Video.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.MediaType.Video
                     * @static
                     * @param {rv.data.Action.MediaType.IVideo} message Video message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Video.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.playbackBehavior != null && Object.hasOwnProperty.call(message, "playbackBehavior"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.playbackBehavior);
                        if (message.endBehavior != null && Object.hasOwnProperty.call(message, "endBehavior"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.endBehavior);
                        if (message.loopTime != null && Object.hasOwnProperty.call(message, "loopTime"))
                            writer.uint32(/* id 3, wireType 1 =*/25).double(message.loopTime);
                        if (message.timesToLoop != null && Object.hasOwnProperty.call(message, "timesToLoop"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.timesToLoop);
                        if (message.softLoop != null && Object.hasOwnProperty.call(message, "softLoop"))
                            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.softLoop);
                        if (message.softLoopDuration != null && Object.hasOwnProperty.call(message, "softLoopDuration"))
                            writer.uint32(/* id 6, wireType 1 =*/49).double(message.softLoopDuration);
                        return writer;
                    };

                    /**
                     * Encodes the specified Video message, length delimited. Does not implicitly {@link rv.data.Action.MediaType.Video.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.MediaType.Video
                     * @static
                     * @param {rv.data.Action.MediaType.IVideo} message Video message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Video.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Video message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.MediaType.Video
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.MediaType.Video} Video
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Video.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.MediaType.Video();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.playbackBehavior = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.endBehavior = reader.int32();
                                    break;
                                }
                            case 3: {
                                    message.loopTime = reader.double();
                                    break;
                                }
                            case 4: {
                                    message.timesToLoop = reader.uint32();
                                    break;
                                }
                            case 5: {
                                    message.softLoop = reader.bool();
                                    break;
                                }
                            case 6: {
                                    message.softLoopDuration = reader.double();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Video message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.MediaType.Video
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.MediaType.Video} Video
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Video.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Video message.
                     * @function verify
                     * @memberof rv.data.Action.MediaType.Video
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Video.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.playbackBehavior != null && message.hasOwnProperty("playbackBehavior"))
                            switch (message.playbackBehavior) {
                            default:
                                return "playbackBehavior: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.endBehavior != null && message.hasOwnProperty("endBehavior"))
                            switch (message.endBehavior) {
                            default:
                                return "endBehavior: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                        if (message.loopTime != null && message.hasOwnProperty("loopTime"))
                            if (typeof message.loopTime !== "number")
                                return "loopTime: number expected";
                        if (message.timesToLoop != null && message.hasOwnProperty("timesToLoop"))
                            if (!$util.isInteger(message.timesToLoop))
                                return "timesToLoop: integer expected";
                        if (message.softLoop != null && message.hasOwnProperty("softLoop"))
                            if (typeof message.softLoop !== "boolean")
                                return "softLoop: boolean expected";
                        if (message.softLoopDuration != null && message.hasOwnProperty("softLoopDuration"))
                            if (typeof message.softLoopDuration !== "number")
                                return "softLoopDuration: number expected";
                        return null;
                    };

                    /**
                     * Creates a Video message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.MediaType.Video
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.MediaType.Video} Video
                     */
                    Video.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.MediaType.Video)
                            return object;
                        let message = new $root.rv.data.Action.MediaType.Video();
                        switch (object.playbackBehavior) {
                        default:
                            if (typeof object.playbackBehavior === "number") {
                                message.playbackBehavior = object.playbackBehavior;
                                break;
                            }
                            break;
                        case "PLAYBACK_BEHAVIOR_STOP":
                        case 0:
                            message.playbackBehavior = 0;
                            break;
                        case "PLAYBACK_BEHAVIOR_LOOP":
                        case 1:
                            message.playbackBehavior = 1;
                            break;
                        case "PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT":
                        case 2:
                            message.playbackBehavior = 2;
                            break;
                        case "PLAYBACK_BEHAVIOR_LOOP_FOR_TIME":
                        case 3:
                            message.playbackBehavior = 3;
                            break;
                        }
                        switch (object.endBehavior) {
                        default:
                            if (typeof object.endBehavior === "number") {
                                message.endBehavior = object.endBehavior;
                                break;
                            }
                            break;
                        case "END_BEHAVIOR_STOP":
                        case 0:
                            message.endBehavior = 0;
                            break;
                        case "END_BEHAVIOR_STOP_ON_BLACK":
                        case 1:
                            message.endBehavior = 1;
                            break;
                        case "END_BEHAVIOR_STOP_ON_CLEAR":
                        case 2:
                            message.endBehavior = 2;
                            break;
                        case "END_BEHAVIOR_FADE_TO_BLACK":
                        case 3:
                            message.endBehavior = 3;
                            break;
                        case "END_BEHAVIOR_FADE_TO_CLEAR":
                        case 4:
                            message.endBehavior = 4;
                            break;
                        }
                        if (object.loopTime != null)
                            message.loopTime = Number(object.loopTime);
                        if (object.timesToLoop != null)
                            message.timesToLoop = object.timesToLoop >>> 0;
                        if (object.softLoop != null)
                            message.softLoop = Boolean(object.softLoop);
                        if (object.softLoopDuration != null)
                            message.softLoopDuration = Number(object.softLoopDuration);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Video message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.MediaType.Video
                     * @static
                     * @param {rv.data.Action.MediaType.Video} message Video
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Video.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.playbackBehavior = options.enums === String ? "PLAYBACK_BEHAVIOR_STOP" : 0;
                            object.endBehavior = options.enums === String ? "END_BEHAVIOR_STOP" : 0;
                            object.loopTime = 0;
                            object.timesToLoop = 0;
                            object.softLoop = false;
                            object.softLoopDuration = 0;
                        }
                        if (message.playbackBehavior != null && message.hasOwnProperty("playbackBehavior"))
                            object.playbackBehavior = options.enums === String ? $root.rv.data.Action.MediaType.PlaybackBehavior[message.playbackBehavior] === undefined ? message.playbackBehavior : $root.rv.data.Action.MediaType.PlaybackBehavior[message.playbackBehavior] : message.playbackBehavior;
                        if (message.endBehavior != null && message.hasOwnProperty("endBehavior"))
                            object.endBehavior = options.enums === String ? $root.rv.data.Action.MediaType.EndBehavior[message.endBehavior] === undefined ? message.endBehavior : $root.rv.data.Action.MediaType.EndBehavior[message.endBehavior] : message.endBehavior;
                        if (message.loopTime != null && message.hasOwnProperty("loopTime"))
                            object.loopTime = options.json && !isFinite(message.loopTime) ? String(message.loopTime) : message.loopTime;
                        if (message.timesToLoop != null && message.hasOwnProperty("timesToLoop"))
                            object.timesToLoop = message.timesToLoop;
                        if (message.softLoop != null && message.hasOwnProperty("softLoop"))
                            object.softLoop = message.softLoop;
                        if (message.softLoopDuration != null && message.hasOwnProperty("softLoopDuration"))
                            object.softLoopDuration = options.json && !isFinite(message.softLoopDuration) ? String(message.softLoopDuration) : message.softLoopDuration;
                        return object;
                    };

                    /**
                     * Converts this Video to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.MediaType.Video
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Video.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Video
                     * @function getTypeUrl
                     * @memberof rv.data.Action.MediaType.Video
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Video.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.MediaType.Video";
                    };

                    return Video;
                })();

                MediaType.Audio = (function() {

                    /**
                     * Properties of an Audio.
                     * @memberof rv.data.Action.MediaType
                     * @interface IAudio
                     * @property {rv.data.Action.MediaType.PlaybackBehavior|null} [playbackBehavior] Audio playbackBehavior
                     * @property {number|null} [loopTime] Audio loopTime
                     * @property {number|null} [timesToLoop] Audio timesToLoop
                     * @property {rv.data.Action.MediaType.Audio.MediaActionAudioType|null} [audioType] Audio audioType
                     */

                    /**
                     * Constructs a new Audio.
                     * @memberof rv.data.Action.MediaType
                     * @classdesc Represents an Audio.
                     * @implements IAudio
                     * @constructor
                     * @param {rv.data.Action.MediaType.IAudio=} [properties] Properties to set
                     */
                    function Audio(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Audio playbackBehavior.
                     * @member {rv.data.Action.MediaType.PlaybackBehavior} playbackBehavior
                     * @memberof rv.data.Action.MediaType.Audio
                     * @instance
                     */
                    Audio.prototype.playbackBehavior = 0;

                    /**
                     * Audio loopTime.
                     * @member {number} loopTime
                     * @memberof rv.data.Action.MediaType.Audio
                     * @instance
                     */
                    Audio.prototype.loopTime = 0;

                    /**
                     * Audio timesToLoop.
                     * @member {number} timesToLoop
                     * @memberof rv.data.Action.MediaType.Audio
                     * @instance
                     */
                    Audio.prototype.timesToLoop = 0;

                    /**
                     * Audio audioType.
                     * @member {rv.data.Action.MediaType.Audio.MediaActionAudioType} audioType
                     * @memberof rv.data.Action.MediaType.Audio
                     * @instance
                     */
                    Audio.prototype.audioType = 0;

                    /**
                     * Creates a new Audio instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.MediaType.Audio
                     * @static
                     * @param {rv.data.Action.MediaType.IAudio=} [properties] Properties to set
                     * @returns {rv.data.Action.MediaType.Audio} Audio instance
                     */
                    Audio.create = function create(properties) {
                        return new Audio(properties);
                    };

                    /**
                     * Encodes the specified Audio message. Does not implicitly {@link rv.data.Action.MediaType.Audio.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.MediaType.Audio
                     * @static
                     * @param {rv.data.Action.MediaType.IAudio} message Audio message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Audio.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.playbackBehavior != null && Object.hasOwnProperty.call(message, "playbackBehavior"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.playbackBehavior);
                        if (message.loopTime != null && Object.hasOwnProperty.call(message, "loopTime"))
                            writer.uint32(/* id 2, wireType 1 =*/17).double(message.loopTime);
                        if (message.timesToLoop != null && Object.hasOwnProperty.call(message, "timesToLoop"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timesToLoop);
                        if (message.audioType != null && Object.hasOwnProperty.call(message, "audioType"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.audioType);
                        return writer;
                    };

                    /**
                     * Encodes the specified Audio message, length delimited. Does not implicitly {@link rv.data.Action.MediaType.Audio.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.MediaType.Audio
                     * @static
                     * @param {rv.data.Action.MediaType.IAudio} message Audio message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Audio.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Audio message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.MediaType.Audio
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.MediaType.Audio} Audio
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Audio.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.MediaType.Audio();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.playbackBehavior = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.loopTime = reader.double();
                                    break;
                                }
                            case 3: {
                                    message.timesToLoop = reader.uint32();
                                    break;
                                }
                            case 4: {
                                    message.audioType = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Audio message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.MediaType.Audio
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.MediaType.Audio} Audio
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Audio.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Audio message.
                     * @function verify
                     * @memberof rv.data.Action.MediaType.Audio
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Audio.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.playbackBehavior != null && message.hasOwnProperty("playbackBehavior"))
                            switch (message.playbackBehavior) {
                            default:
                                return "playbackBehavior: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.loopTime != null && message.hasOwnProperty("loopTime"))
                            if (typeof message.loopTime !== "number")
                                return "loopTime: number expected";
                        if (message.timesToLoop != null && message.hasOwnProperty("timesToLoop"))
                            if (!$util.isInteger(message.timesToLoop))
                                return "timesToLoop: integer expected";
                        if (message.audioType != null && message.hasOwnProperty("audioType"))
                            switch (message.audioType) {
                            default:
                                return "audioType: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates an Audio message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.MediaType.Audio
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.MediaType.Audio} Audio
                     */
                    Audio.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.MediaType.Audio)
                            return object;
                        let message = new $root.rv.data.Action.MediaType.Audio();
                        switch (object.playbackBehavior) {
                        default:
                            if (typeof object.playbackBehavior === "number") {
                                message.playbackBehavior = object.playbackBehavior;
                                break;
                            }
                            break;
                        case "PLAYBACK_BEHAVIOR_STOP":
                        case 0:
                            message.playbackBehavior = 0;
                            break;
                        case "PLAYBACK_BEHAVIOR_LOOP":
                        case 1:
                            message.playbackBehavior = 1;
                            break;
                        case "PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT":
                        case 2:
                            message.playbackBehavior = 2;
                            break;
                        case "PLAYBACK_BEHAVIOR_LOOP_FOR_TIME":
                        case 3:
                            message.playbackBehavior = 3;
                            break;
                        }
                        if (object.loopTime != null)
                            message.loopTime = Number(object.loopTime);
                        if (object.timesToLoop != null)
                            message.timesToLoop = object.timesToLoop >>> 0;
                        switch (object.audioType) {
                        default:
                            if (typeof object.audioType === "number") {
                                message.audioType = object.audioType;
                                break;
                            }
                            break;
                        case "MEDIA_ACTION_AUDIO_TYPE_TUNE":
                        case 0:
                            message.audioType = 0;
                            break;
                        case "MEDIA_ACTION_AUDIO_TYPE_SOUND":
                        case 1:
                            message.audioType = 1;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an Audio message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.MediaType.Audio
                     * @static
                     * @param {rv.data.Action.MediaType.Audio} message Audio
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Audio.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.playbackBehavior = options.enums === String ? "PLAYBACK_BEHAVIOR_STOP" : 0;
                            object.loopTime = 0;
                            object.timesToLoop = 0;
                            object.audioType = options.enums === String ? "MEDIA_ACTION_AUDIO_TYPE_TUNE" : 0;
                        }
                        if (message.playbackBehavior != null && message.hasOwnProperty("playbackBehavior"))
                            object.playbackBehavior = options.enums === String ? $root.rv.data.Action.MediaType.PlaybackBehavior[message.playbackBehavior] === undefined ? message.playbackBehavior : $root.rv.data.Action.MediaType.PlaybackBehavior[message.playbackBehavior] : message.playbackBehavior;
                        if (message.loopTime != null && message.hasOwnProperty("loopTime"))
                            object.loopTime = options.json && !isFinite(message.loopTime) ? String(message.loopTime) : message.loopTime;
                        if (message.timesToLoop != null && message.hasOwnProperty("timesToLoop"))
                            object.timesToLoop = message.timesToLoop;
                        if (message.audioType != null && message.hasOwnProperty("audioType"))
                            object.audioType = options.enums === String ? $root.rv.data.Action.MediaType.Audio.MediaActionAudioType[message.audioType] === undefined ? message.audioType : $root.rv.data.Action.MediaType.Audio.MediaActionAudioType[message.audioType] : message.audioType;
                        return object;
                    };

                    /**
                     * Converts this Audio to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.MediaType.Audio
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Audio.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Audio
                     * @function getTypeUrl
                     * @memberof rv.data.Action.MediaType.Audio
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Audio.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.MediaType.Audio";
                    };

                    /**
                     * MediaActionAudioType enum.
                     * @name rv.data.Action.MediaType.Audio.MediaActionAudioType
                     * @enum {number}
                     * @property {number} MEDIA_ACTION_AUDIO_TYPE_TUNE=0 MEDIA_ACTION_AUDIO_TYPE_TUNE value
                     * @property {number} MEDIA_ACTION_AUDIO_TYPE_SOUND=1 MEDIA_ACTION_AUDIO_TYPE_SOUND value
                     */
                    Audio.MediaActionAudioType = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "MEDIA_ACTION_AUDIO_TYPE_TUNE"] = 0;
                        values[valuesById[1] = "MEDIA_ACTION_AUDIO_TYPE_SOUND"] = 1;
                        return values;
                    })();

                    return Audio;
                })();

                MediaType.LiveVideo = (function() {

                    /**
                     * Properties of a LiveVideo.
                     * @memberof rv.data.Action.MediaType
                     * @interface ILiveVideo
                     */

                    /**
                     * Constructs a new LiveVideo.
                     * @memberof rv.data.Action.MediaType
                     * @classdesc Represents a LiveVideo.
                     * @implements ILiveVideo
                     * @constructor
                     * @param {rv.data.Action.MediaType.ILiveVideo=} [properties] Properties to set
                     */
                    function LiveVideo(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new LiveVideo instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.MediaType.LiveVideo
                     * @static
                     * @param {rv.data.Action.MediaType.ILiveVideo=} [properties] Properties to set
                     * @returns {rv.data.Action.MediaType.LiveVideo} LiveVideo instance
                     */
                    LiveVideo.create = function create(properties) {
                        return new LiveVideo(properties);
                    };

                    /**
                     * Encodes the specified LiveVideo message. Does not implicitly {@link rv.data.Action.MediaType.LiveVideo.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.MediaType.LiveVideo
                     * @static
                     * @param {rv.data.Action.MediaType.ILiveVideo} message LiveVideo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LiveVideo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified LiveVideo message, length delimited. Does not implicitly {@link rv.data.Action.MediaType.LiveVideo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.MediaType.LiveVideo
                     * @static
                     * @param {rv.data.Action.MediaType.ILiveVideo} message LiveVideo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LiveVideo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a LiveVideo message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.MediaType.LiveVideo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.MediaType.LiveVideo} LiveVideo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LiveVideo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.MediaType.LiveVideo();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a LiveVideo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.MediaType.LiveVideo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.MediaType.LiveVideo} LiveVideo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LiveVideo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a LiveVideo message.
                     * @function verify
                     * @memberof rv.data.Action.MediaType.LiveVideo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    LiveVideo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a LiveVideo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.MediaType.LiveVideo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.MediaType.LiveVideo} LiveVideo
                     */
                    LiveVideo.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.MediaType.LiveVideo)
                            return object;
                        return new $root.rv.data.Action.MediaType.LiveVideo();
                    };

                    /**
                     * Creates a plain object from a LiveVideo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.MediaType.LiveVideo
                     * @static
                     * @param {rv.data.Action.MediaType.LiveVideo} message LiveVideo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    LiveVideo.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this LiveVideo to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.MediaType.LiveVideo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    LiveVideo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for LiveVideo
                     * @function getTypeUrl
                     * @memberof rv.data.Action.MediaType.LiveVideo
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    LiveVideo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.MediaType.LiveVideo";
                    };

                    return LiveVideo;
                })();

                MediaType.PlaybackMarker = (function() {

                    /**
                     * Properties of a PlaybackMarker.
                     * @memberof rv.data.Action.MediaType
                     * @interface IPlaybackMarker
                     * @property {rv.data.IUUID|null} [uuid] PlaybackMarker uuid
                     * @property {number|null} [time] PlaybackMarker time
                     * @property {rv.data.IColor|null} [color] PlaybackMarker color
                     * @property {string|null} [name] PlaybackMarker name
                     * @property {Array.<rv.data.IAction>|null} [actions] PlaybackMarker actions
                     */

                    /**
                     * Constructs a new PlaybackMarker.
                     * @memberof rv.data.Action.MediaType
                     * @classdesc Represents a PlaybackMarker.
                     * @implements IPlaybackMarker
                     * @constructor
                     * @param {rv.data.Action.MediaType.IPlaybackMarker=} [properties] Properties to set
                     */
                    function PlaybackMarker(properties) {
                        this.actions = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PlaybackMarker uuid.
                     * @member {rv.data.IUUID|null|undefined} uuid
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @instance
                     */
                    PlaybackMarker.prototype.uuid = null;

                    /**
                     * PlaybackMarker time.
                     * @member {number} time
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @instance
                     */
                    PlaybackMarker.prototype.time = 0;

                    /**
                     * PlaybackMarker color.
                     * @member {rv.data.IColor|null|undefined} color
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @instance
                     */
                    PlaybackMarker.prototype.color = null;

                    /**
                     * PlaybackMarker name.
                     * @member {string} name
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @instance
                     */
                    PlaybackMarker.prototype.name = "";

                    /**
                     * PlaybackMarker actions.
                     * @member {Array.<rv.data.IAction>} actions
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @instance
                     */
                    PlaybackMarker.prototype.actions = $util.emptyArray;

                    /**
                     * Creates a new PlaybackMarker instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @static
                     * @param {rv.data.Action.MediaType.IPlaybackMarker=} [properties] Properties to set
                     * @returns {rv.data.Action.MediaType.PlaybackMarker} PlaybackMarker instance
                     */
                    PlaybackMarker.create = function create(properties) {
                        return new PlaybackMarker(properties);
                    };

                    /**
                     * Encodes the specified PlaybackMarker message. Does not implicitly {@link rv.data.Action.MediaType.PlaybackMarker.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @static
                     * @param {rv.data.Action.MediaType.IPlaybackMarker} message PlaybackMarker message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PlaybackMarker.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                            $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                            writer.uint32(/* id 2, wireType 1 =*/17).double(message.time);
                        if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                            $root.rv.data.Color.encode(message.color, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                        if (message.actions != null && message.actions.length)
                            for (let i = 0; i < message.actions.length; ++i)
                                $root.rv.data.Action.encode(message.actions[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified PlaybackMarker message, length delimited. Does not implicitly {@link rv.data.Action.MediaType.PlaybackMarker.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @static
                     * @param {rv.data.Action.MediaType.IPlaybackMarker} message PlaybackMarker message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PlaybackMarker.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PlaybackMarker message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.MediaType.PlaybackMarker} PlaybackMarker
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PlaybackMarker.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.MediaType.PlaybackMarker();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                    break;
                                }
                            case 2: {
                                    message.time = reader.double();
                                    break;
                                }
                            case 3: {
                                    message.color = $root.rv.data.Color.decode(reader, reader.uint32());
                                    break;
                                }
                            case 4: {
                                    message.name = reader.string();
                                    break;
                                }
                            case 5: {
                                    if (!(message.actions && message.actions.length))
                                        message.actions = [];
                                    message.actions.push($root.rv.data.Action.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PlaybackMarker message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.MediaType.PlaybackMarker} PlaybackMarker
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PlaybackMarker.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PlaybackMarker message.
                     * @function verify
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PlaybackMarker.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.uuid != null && message.hasOwnProperty("uuid")) {
                            let error = $root.rv.data.UUID.verify(message.uuid);
                            if (error)
                                return "uuid." + error;
                        }
                        if (message.time != null && message.hasOwnProperty("time"))
                            if (typeof message.time !== "number")
                                return "time: number expected";
                        if (message.color != null && message.hasOwnProperty("color")) {
                            let error = $root.rv.data.Color.verify(message.color);
                            if (error)
                                return "color." + error;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.actions != null && message.hasOwnProperty("actions")) {
                            if (!Array.isArray(message.actions))
                                return "actions: array expected";
                            for (let i = 0; i < message.actions.length; ++i) {
                                let error = $root.rv.data.Action.verify(message.actions[i]);
                                if (error)
                                    return "actions." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a PlaybackMarker message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.MediaType.PlaybackMarker} PlaybackMarker
                     */
                    PlaybackMarker.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.MediaType.PlaybackMarker)
                            return object;
                        let message = new $root.rv.data.Action.MediaType.PlaybackMarker();
                        if (object.uuid != null) {
                            if (typeof object.uuid !== "object")
                                throw TypeError(".rv.data.Action.MediaType.PlaybackMarker.uuid: object expected");
                            message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                        }
                        if (object.time != null)
                            message.time = Number(object.time);
                        if (object.color != null) {
                            if (typeof object.color !== "object")
                                throw TypeError(".rv.data.Action.MediaType.PlaybackMarker.color: object expected");
                            message.color = $root.rv.data.Color.fromObject(object.color);
                        }
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.actions) {
                            if (!Array.isArray(object.actions))
                                throw TypeError(".rv.data.Action.MediaType.PlaybackMarker.actions: array expected");
                            message.actions = [];
                            for (let i = 0; i < object.actions.length; ++i) {
                                if (typeof object.actions[i] !== "object")
                                    throw TypeError(".rv.data.Action.MediaType.PlaybackMarker.actions: object expected");
                                message.actions[i] = $root.rv.data.Action.fromObject(object.actions[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a PlaybackMarker message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @static
                     * @param {rv.data.Action.MediaType.PlaybackMarker} message PlaybackMarker
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PlaybackMarker.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.actions = [];
                        if (options.defaults) {
                            object.uuid = null;
                            object.time = 0;
                            object.color = null;
                            object.name = "";
                        }
                        if (message.uuid != null && message.hasOwnProperty("uuid"))
                            object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                        if (message.time != null && message.hasOwnProperty("time"))
                            object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
                        if (message.color != null && message.hasOwnProperty("color"))
                            object.color = $root.rv.data.Color.toObject(message.color, options);
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.actions && message.actions.length) {
                            object.actions = [];
                            for (let j = 0; j < message.actions.length; ++j)
                                object.actions[j] = $root.rv.data.Action.toObject(message.actions[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this PlaybackMarker to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PlaybackMarker.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for PlaybackMarker
                     * @function getTypeUrl
                     * @memberof rv.data.Action.MediaType.PlaybackMarker
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    PlaybackMarker.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.MediaType.PlaybackMarker";
                    };

                    return PlaybackMarker;
                })();

                /**
                 * PlaybackBehavior enum.
                 * @name rv.data.Action.MediaType.PlaybackBehavior
                 * @enum {number}
                 * @property {number} PLAYBACK_BEHAVIOR_STOP=0 PLAYBACK_BEHAVIOR_STOP value
                 * @property {number} PLAYBACK_BEHAVIOR_LOOP=1 PLAYBACK_BEHAVIOR_LOOP value
                 * @property {number} PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT=2 PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT value
                 * @property {number} PLAYBACK_BEHAVIOR_LOOP_FOR_TIME=3 PLAYBACK_BEHAVIOR_LOOP_FOR_TIME value
                 */
                MediaType.PlaybackBehavior = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "PLAYBACK_BEHAVIOR_STOP"] = 0;
                    values[valuesById[1] = "PLAYBACK_BEHAVIOR_LOOP"] = 1;
                    values[valuesById[2] = "PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT"] = 2;
                    values[valuesById[3] = "PLAYBACK_BEHAVIOR_LOOP_FOR_TIME"] = 3;
                    return values;
                })();

                /**
                 * EndBehavior enum.
                 * @name rv.data.Action.MediaType.EndBehavior
                 * @enum {number}
                 * @property {number} END_BEHAVIOR_STOP=0 END_BEHAVIOR_STOP value
                 * @property {number} END_BEHAVIOR_STOP_ON_BLACK=1 END_BEHAVIOR_STOP_ON_BLACK value
                 * @property {number} END_BEHAVIOR_STOP_ON_CLEAR=2 END_BEHAVIOR_STOP_ON_CLEAR value
                 * @property {number} END_BEHAVIOR_FADE_TO_BLACK=3 END_BEHAVIOR_FADE_TO_BLACK value
                 * @property {number} END_BEHAVIOR_FADE_TO_CLEAR=4 END_BEHAVIOR_FADE_TO_CLEAR value
                 */
                MediaType.EndBehavior = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "END_BEHAVIOR_STOP"] = 0;
                    values[valuesById[1] = "END_BEHAVIOR_STOP_ON_BLACK"] = 1;
                    values[valuesById[2] = "END_BEHAVIOR_STOP_ON_CLEAR"] = 2;
                    values[valuesById[3] = "END_BEHAVIOR_FADE_TO_BLACK"] = 3;
                    values[valuesById[4] = "END_BEHAVIOR_FADE_TO_CLEAR"] = 4;
                    return values;
                })();

                return MediaType;
            })();

            Action.SlideType = (function() {

                /**
                 * Properties of a SlideType.
                 * @memberof rv.data.Action
                 * @interface ISlideType
                 * @property {rv.data.IPresentationSlide|null} [presentation] SlideType presentation
                 * @property {rv.data.IPropSlide|null} [prop] SlideType prop
                 */

                /**
                 * Constructs a new SlideType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a SlideType.
                 * @implements ISlideType
                 * @constructor
                 * @param {rv.data.Action.ISlideType=} [properties] Properties to set
                 */
                function SlideType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SlideType presentation.
                 * @member {rv.data.IPresentationSlide|null|undefined} presentation
                 * @memberof rv.data.Action.SlideType
                 * @instance
                 */
                SlideType.prototype.presentation = null;

                /**
                 * SlideType prop.
                 * @member {rv.data.IPropSlide|null|undefined} prop
                 * @memberof rv.data.Action.SlideType
                 * @instance
                 */
                SlideType.prototype.prop = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * SlideType Slide.
                 * @member {"presentation"|"prop"|undefined} Slide
                 * @memberof rv.data.Action.SlideType
                 * @instance
                 */
                Object.defineProperty(SlideType.prototype, "Slide", {
                    get: $util.oneOfGetter($oneOfFields = ["presentation", "prop"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new SlideType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.SlideType
                 * @static
                 * @param {rv.data.Action.ISlideType=} [properties] Properties to set
                 * @returns {rv.data.Action.SlideType} SlideType instance
                 */
                SlideType.create = function create(properties) {
                    return new SlideType(properties);
                };

                /**
                 * Encodes the specified SlideType message. Does not implicitly {@link rv.data.Action.SlideType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.SlideType
                 * @static
                 * @param {rv.data.Action.ISlideType} message SlideType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SlideType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.presentation != null && Object.hasOwnProperty.call(message, "presentation"))
                        $root.rv.data.PresentationSlide.encode(message.presentation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.prop != null && Object.hasOwnProperty.call(message, "prop"))
                        $root.rv.data.PropSlide.encode(message.prop, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SlideType message, length delimited. Does not implicitly {@link rv.data.Action.SlideType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.SlideType
                 * @static
                 * @param {rv.data.Action.ISlideType} message SlideType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SlideType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SlideType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.SlideType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.SlideType} SlideType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SlideType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.SlideType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2: {
                                message.presentation = $root.rv.data.PresentationSlide.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.prop = $root.rv.data.PropSlide.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SlideType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.SlideType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.SlideType} SlideType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SlideType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SlideType message.
                 * @function verify
                 * @memberof rv.data.Action.SlideType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SlideType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.presentation != null && message.hasOwnProperty("presentation")) {
                        properties.Slide = 1;
                        {
                            let error = $root.rv.data.PresentationSlide.verify(message.presentation);
                            if (error)
                                return "presentation." + error;
                        }
                    }
                    if (message.prop != null && message.hasOwnProperty("prop")) {
                        if (properties.Slide === 1)
                            return "Slide: multiple values";
                        properties.Slide = 1;
                        {
                            let error = $root.rv.data.PropSlide.verify(message.prop);
                            if (error)
                                return "prop." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SlideType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.SlideType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.SlideType} SlideType
                 */
                SlideType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.SlideType)
                        return object;
                    let message = new $root.rv.data.Action.SlideType();
                    if (object.presentation != null) {
                        if (typeof object.presentation !== "object")
                            throw TypeError(".rv.data.Action.SlideType.presentation: object expected");
                        message.presentation = $root.rv.data.PresentationSlide.fromObject(object.presentation);
                    }
                    if (object.prop != null) {
                        if (typeof object.prop !== "object")
                            throw TypeError(".rv.data.Action.SlideType.prop: object expected");
                        message.prop = $root.rv.data.PropSlide.fromObject(object.prop);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SlideType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.SlideType
                 * @static
                 * @param {rv.data.Action.SlideType} message SlideType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SlideType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.presentation != null && message.hasOwnProperty("presentation")) {
                        object.presentation = $root.rv.data.PresentationSlide.toObject(message.presentation, options);
                        if (options.oneofs)
                            object.Slide = "presentation";
                    }
                    if (message.prop != null && message.hasOwnProperty("prop")) {
                        object.prop = $root.rv.data.PropSlide.toObject(message.prop, options);
                        if (options.oneofs)
                            object.Slide = "prop";
                    }
                    return object;
                };

                /**
                 * Converts this SlideType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.SlideType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SlideType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SlideType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.SlideType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SlideType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.SlideType";
                };

                return SlideType;
            })();

            Action.BackgroundType = (function() {

                /**
                 * Properties of a BackgroundType.
                 * @memberof rv.data.Action
                 * @interface IBackgroundType
                 * @property {rv.data.IBackground|null} [element] BackgroundType element
                 */

                /**
                 * Constructs a new BackgroundType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a BackgroundType.
                 * @implements IBackgroundType
                 * @constructor
                 * @param {rv.data.Action.IBackgroundType=} [properties] Properties to set
                 */
                function BackgroundType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BackgroundType element.
                 * @member {rv.data.IBackground|null|undefined} element
                 * @memberof rv.data.Action.BackgroundType
                 * @instance
                 */
                BackgroundType.prototype.element = null;

                /**
                 * Creates a new BackgroundType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.BackgroundType
                 * @static
                 * @param {rv.data.Action.IBackgroundType=} [properties] Properties to set
                 * @returns {rv.data.Action.BackgroundType} BackgroundType instance
                 */
                BackgroundType.create = function create(properties) {
                    return new BackgroundType(properties);
                };

                /**
                 * Encodes the specified BackgroundType message. Does not implicitly {@link rv.data.Action.BackgroundType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.BackgroundType
                 * @static
                 * @param {rv.data.Action.IBackgroundType} message BackgroundType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BackgroundType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.element != null && Object.hasOwnProperty.call(message, "element"))
                        $root.rv.data.Background.encode(message.element, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified BackgroundType message, length delimited. Does not implicitly {@link rv.data.Action.BackgroundType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.BackgroundType
                 * @static
                 * @param {rv.data.Action.IBackgroundType} message BackgroundType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BackgroundType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BackgroundType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.BackgroundType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.BackgroundType} BackgroundType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BackgroundType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.BackgroundType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.element = $root.rv.data.Background.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BackgroundType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.BackgroundType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.BackgroundType} BackgroundType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BackgroundType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BackgroundType message.
                 * @function verify
                 * @memberof rv.data.Action.BackgroundType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BackgroundType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.element != null && message.hasOwnProperty("element")) {
                        let error = $root.rv.data.Background.verify(message.element);
                        if (error)
                            return "element." + error;
                    }
                    return null;
                };

                /**
                 * Creates a BackgroundType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.BackgroundType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.BackgroundType} BackgroundType
                 */
                BackgroundType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.BackgroundType)
                        return object;
                    let message = new $root.rv.data.Action.BackgroundType();
                    if (object.element != null) {
                        if (typeof object.element !== "object")
                            throw TypeError(".rv.data.Action.BackgroundType.element: object expected");
                        message.element = $root.rv.data.Background.fromObject(object.element);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BackgroundType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.BackgroundType
                 * @static
                 * @param {rv.data.Action.BackgroundType} message BackgroundType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BackgroundType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.element = null;
                    if (message.element != null && message.hasOwnProperty("element"))
                        object.element = $root.rv.data.Background.toObject(message.element, options);
                    return object;
                };

                /**
                 * Converts this BackgroundType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.BackgroundType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BackgroundType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BackgroundType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.BackgroundType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BackgroundType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.BackgroundType";
                };

                return BackgroundType;
            })();

            Action.TimerType = (function() {

                /**
                 * Properties of a TimerType.
                 * @memberof rv.data.Action
                 * @interface ITimerType
                 * @property {rv.data.Action.TimerType.TimerAction|null} [actionType] TimerType actionType
                 * @property {rv.data.ICollectionElementType|null} [timerIdentification] TimerType timerIdentification
                 * @property {rv.data.Timer.IConfiguration|null} [timerConfiguration] TimerType timerConfiguration
                 * @property {number|null} [incrementAmount] TimerType incrementAmount
                 */

                /**
                 * Constructs a new TimerType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a TimerType.
                 * @implements ITimerType
                 * @constructor
                 * @param {rv.data.Action.ITimerType=} [properties] Properties to set
                 */
                function TimerType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TimerType actionType.
                 * @member {rv.data.Action.TimerType.TimerAction} actionType
                 * @memberof rv.data.Action.TimerType
                 * @instance
                 */
                TimerType.prototype.actionType = 0;

                /**
                 * TimerType timerIdentification.
                 * @member {rv.data.ICollectionElementType|null|undefined} timerIdentification
                 * @memberof rv.data.Action.TimerType
                 * @instance
                 */
                TimerType.prototype.timerIdentification = null;

                /**
                 * TimerType timerConfiguration.
                 * @member {rv.data.Timer.IConfiguration|null|undefined} timerConfiguration
                 * @memberof rv.data.Action.TimerType
                 * @instance
                 */
                TimerType.prototype.timerConfiguration = null;

                /**
                 * TimerType incrementAmount.
                 * @member {number} incrementAmount
                 * @memberof rv.data.Action.TimerType
                 * @instance
                 */
                TimerType.prototype.incrementAmount = 0;

                /**
                 * Creates a new TimerType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.TimerType
                 * @static
                 * @param {rv.data.Action.ITimerType=} [properties] Properties to set
                 * @returns {rv.data.Action.TimerType} TimerType instance
                 */
                TimerType.create = function create(properties) {
                    return new TimerType(properties);
                };

                /**
                 * Encodes the specified TimerType message. Does not implicitly {@link rv.data.Action.TimerType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.TimerType
                 * @static
                 * @param {rv.data.Action.ITimerType} message TimerType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimerType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.actionType != null && Object.hasOwnProperty.call(message, "actionType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.actionType);
                    if (message.timerIdentification != null && Object.hasOwnProperty.call(message, "timerIdentification"))
                        $root.rv.data.CollectionElementType.encode(message.timerIdentification, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.timerConfiguration != null && Object.hasOwnProperty.call(message, "timerConfiguration"))
                        $root.rv.data.Timer.Configuration.encode(message.timerConfiguration, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.incrementAmount != null && Object.hasOwnProperty.call(message, "incrementAmount"))
                        writer.uint32(/* id 11, wireType 1 =*/89).double(message.incrementAmount);
                    return writer;
                };

                /**
                 * Encodes the specified TimerType message, length delimited. Does not implicitly {@link rv.data.Action.TimerType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.TimerType
                 * @static
                 * @param {rv.data.Action.ITimerType} message TimerType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimerType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TimerType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.TimerType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.TimerType} TimerType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimerType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.TimerType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2: {
                                message.actionType = reader.int32();
                                break;
                            }
                        case 4: {
                                message.timerIdentification = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                                break;
                            }
                        case 10: {
                                message.timerConfiguration = $root.rv.data.Timer.Configuration.decode(reader, reader.uint32());
                                break;
                            }
                        case 11: {
                                message.incrementAmount = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TimerType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.TimerType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.TimerType} TimerType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimerType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TimerType message.
                 * @function verify
                 * @memberof rv.data.Action.TimerType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TimerType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.actionType != null && message.hasOwnProperty("actionType"))
                        switch (message.actionType) {
                        default:
                            return "actionType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.timerIdentification != null && message.hasOwnProperty("timerIdentification")) {
                        let error = $root.rv.data.CollectionElementType.verify(message.timerIdentification);
                        if (error)
                            return "timerIdentification." + error;
                    }
                    if (message.timerConfiguration != null && message.hasOwnProperty("timerConfiguration")) {
                        let error = $root.rv.data.Timer.Configuration.verify(message.timerConfiguration);
                        if (error)
                            return "timerConfiguration." + error;
                    }
                    if (message.incrementAmount != null && message.hasOwnProperty("incrementAmount"))
                        if (typeof message.incrementAmount !== "number")
                            return "incrementAmount: number expected";
                    return null;
                };

                /**
                 * Creates a TimerType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.TimerType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.TimerType} TimerType
                 */
                TimerType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.TimerType)
                        return object;
                    let message = new $root.rv.data.Action.TimerType();
                    switch (object.actionType) {
                    default:
                        if (typeof object.actionType === "number") {
                            message.actionType = object.actionType;
                            break;
                        }
                        break;
                    case "ACTION_START":
                    case 0:
                        message.actionType = 0;
                        break;
                    case "ACTION_STOP":
                    case 1:
                        message.actionType = 1;
                        break;
                    case "ACTION_RESET":
                    case 2:
                        message.actionType = 2;
                        break;
                    case "ACTION_RESET_AND_START":
                    case 3:
                        message.actionType = 3;
                        break;
                    case "ACTION_STOP_AND_RESET":
                    case 4:
                        message.actionType = 4;
                        break;
                    case "ACTION_INCREMENT":
                    case 5:
                        message.actionType = 5;
                        break;
                    }
                    if (object.timerIdentification != null) {
                        if (typeof object.timerIdentification !== "object")
                            throw TypeError(".rv.data.Action.TimerType.timerIdentification: object expected");
                        message.timerIdentification = $root.rv.data.CollectionElementType.fromObject(object.timerIdentification);
                    }
                    if (object.timerConfiguration != null) {
                        if (typeof object.timerConfiguration !== "object")
                            throw TypeError(".rv.data.Action.TimerType.timerConfiguration: object expected");
                        message.timerConfiguration = $root.rv.data.Timer.Configuration.fromObject(object.timerConfiguration);
                    }
                    if (object.incrementAmount != null)
                        message.incrementAmount = Number(object.incrementAmount);
                    return message;
                };

                /**
                 * Creates a plain object from a TimerType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.TimerType
                 * @static
                 * @param {rv.data.Action.TimerType} message TimerType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimerType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.actionType = options.enums === String ? "ACTION_START" : 0;
                        object.timerIdentification = null;
                        object.timerConfiguration = null;
                        object.incrementAmount = 0;
                    }
                    if (message.actionType != null && message.hasOwnProperty("actionType"))
                        object.actionType = options.enums === String ? $root.rv.data.Action.TimerType.TimerAction[message.actionType] === undefined ? message.actionType : $root.rv.data.Action.TimerType.TimerAction[message.actionType] : message.actionType;
                    if (message.timerIdentification != null && message.hasOwnProperty("timerIdentification"))
                        object.timerIdentification = $root.rv.data.CollectionElementType.toObject(message.timerIdentification, options);
                    if (message.timerConfiguration != null && message.hasOwnProperty("timerConfiguration"))
                        object.timerConfiguration = $root.rv.data.Timer.Configuration.toObject(message.timerConfiguration, options);
                    if (message.incrementAmount != null && message.hasOwnProperty("incrementAmount"))
                        object.incrementAmount = options.json && !isFinite(message.incrementAmount) ? String(message.incrementAmount) : message.incrementAmount;
                    return object;
                };

                /**
                 * Converts this TimerType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.TimerType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TimerType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TimerType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.TimerType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TimerType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.TimerType";
                };

                /**
                 * TimerAction enum.
                 * @name rv.data.Action.TimerType.TimerAction
                 * @enum {number}
                 * @property {number} ACTION_START=0 ACTION_START value
                 * @property {number} ACTION_STOP=1 ACTION_STOP value
                 * @property {number} ACTION_RESET=2 ACTION_RESET value
                 * @property {number} ACTION_RESET_AND_START=3 ACTION_RESET_AND_START value
                 * @property {number} ACTION_STOP_AND_RESET=4 ACTION_STOP_AND_RESET value
                 * @property {number} ACTION_INCREMENT=5 ACTION_INCREMENT value
                 */
                TimerType.TimerAction = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ACTION_START"] = 0;
                    values[valuesById[1] = "ACTION_STOP"] = 1;
                    values[valuesById[2] = "ACTION_RESET"] = 2;
                    values[valuesById[3] = "ACTION_RESET_AND_START"] = 3;
                    values[valuesById[4] = "ACTION_STOP_AND_RESET"] = 4;
                    values[valuesById[5] = "ACTION_INCREMENT"] = 5;
                    return values;
                })();

                return TimerType;
            })();

            Action.ClearType = (function() {

                /**
                 * Properties of a ClearType.
                 * @memberof rv.data.Action
                 * @interface IClearType
                 * @property {rv.data.Action.ClearType.ClearTargetLayer|null} [targetLayer] ClearType targetLayer
                 * @property {rv.data.Action.ContentDestination|null} [contentDestination] ClearType contentDestination
                 */

                /**
                 * Constructs a new ClearType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a ClearType.
                 * @implements IClearType
                 * @constructor
                 * @param {rv.data.Action.IClearType=} [properties] Properties to set
                 */
                function ClearType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ClearType targetLayer.
                 * @member {rv.data.Action.ClearType.ClearTargetLayer} targetLayer
                 * @memberof rv.data.Action.ClearType
                 * @instance
                 */
                ClearType.prototype.targetLayer = 0;

                /**
                 * ClearType contentDestination.
                 * @member {rv.data.Action.ContentDestination} contentDestination
                 * @memberof rv.data.Action.ClearType
                 * @instance
                 */
                ClearType.prototype.contentDestination = 0;

                /**
                 * Creates a new ClearType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.ClearType
                 * @static
                 * @param {rv.data.Action.IClearType=} [properties] Properties to set
                 * @returns {rv.data.Action.ClearType} ClearType instance
                 */
                ClearType.create = function create(properties) {
                    return new ClearType(properties);
                };

                /**
                 * Encodes the specified ClearType message. Does not implicitly {@link rv.data.Action.ClearType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.ClearType
                 * @static
                 * @param {rv.data.Action.IClearType} message ClearType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClearType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.targetLayer != null && Object.hasOwnProperty.call(message, "targetLayer"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.targetLayer);
                    if (message.contentDestination != null && Object.hasOwnProperty.call(message, "contentDestination"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.contentDestination);
                    return writer;
                };

                /**
                 * Encodes the specified ClearType message, length delimited. Does not implicitly {@link rv.data.Action.ClearType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.ClearType
                 * @static
                 * @param {rv.data.Action.IClearType} message ClearType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClearType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ClearType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.ClearType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.ClearType} ClearType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClearType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.ClearType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2: {
                                message.targetLayer = reader.int32();
                                break;
                            }
                        case 4: {
                                message.contentDestination = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ClearType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.ClearType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.ClearType} ClearType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClearType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ClearType message.
                 * @function verify
                 * @memberof rv.data.Action.ClearType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ClearType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.targetLayer != null && message.hasOwnProperty("targetLayer"))
                        switch (message.targetLayer) {
                        default:
                            return "targetLayer: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                            break;
                        }
                    if (message.contentDestination != null && message.hasOwnProperty("contentDestination"))
                        switch (message.contentDestination) {
                        default:
                            return "contentDestination: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a ClearType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.ClearType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.ClearType} ClearType
                 */
                ClearType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.ClearType)
                        return object;
                    let message = new $root.rv.data.Action.ClearType();
                    switch (object.targetLayer) {
                    default:
                        if (typeof object.targetLayer === "number") {
                            message.targetLayer = object.targetLayer;
                            break;
                        }
                        break;
                    case "CLEAR_TARGET_LAYER_ALL":
                    case 0:
                        message.targetLayer = 0;
                        break;
                    case "CLEAR_TARGET_LAYER_AUDIO":
                    case 1:
                        message.targetLayer = 1;
                        break;
                    case "CLEAR_TARGET_LAYER_BACKGROUND":
                    case 2:
                        message.targetLayer = 2;
                        break;
                    case "CLEAR_TARGET_LAYER_LIVE_VIDEO":
                    case 3:
                        message.targetLayer = 3;
                        break;
                    case "CLEAR_TARGET_LAYER_PROP":
                    case 4:
                        message.targetLayer = 4;
                        break;
                    case "CLEAR_TARGET_LAYER_SLIDE":
                    case 5:
                        message.targetLayer = 5;
                        break;
                    case "CLEAR_TARGET_LAYER_LOGO":
                    case 6:
                        message.targetLayer = 6;
                        break;
                    case "CLEAR_TARGET_LAYER_MESSAGES":
                    case 7:
                        message.targetLayer = 7;
                        break;
                    case "CLEAR_TARGET_LAYER_AUDIO_EFFECTS":
                    case 8:
                        message.targetLayer = 8;
                        break;
                    }
                    switch (object.contentDestination) {
                    default:
                        if (typeof object.contentDestination === "number") {
                            message.contentDestination = object.contentDestination;
                            break;
                        }
                        break;
                    case "CONTENT_DESTINATION_GLOBAL":
                    case 0:
                        message.contentDestination = 0;
                        break;
                    case "CONTENT_DESTINATION_ANNOUNCEMENTS":
                    case 1:
                        message.contentDestination = 1;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ClearType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.ClearType
                 * @static
                 * @param {rv.data.Action.ClearType} message ClearType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClearType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.targetLayer = options.enums === String ? "CLEAR_TARGET_LAYER_ALL" : 0;
                        object.contentDestination = options.enums === String ? "CONTENT_DESTINATION_GLOBAL" : 0;
                    }
                    if (message.targetLayer != null && message.hasOwnProperty("targetLayer"))
                        object.targetLayer = options.enums === String ? $root.rv.data.Action.ClearType.ClearTargetLayer[message.targetLayer] === undefined ? message.targetLayer : $root.rv.data.Action.ClearType.ClearTargetLayer[message.targetLayer] : message.targetLayer;
                    if (message.contentDestination != null && message.hasOwnProperty("contentDestination"))
                        object.contentDestination = options.enums === String ? $root.rv.data.Action.ContentDestination[message.contentDestination] === undefined ? message.contentDestination : $root.rv.data.Action.ContentDestination[message.contentDestination] : message.contentDestination;
                    return object;
                };

                /**
                 * Converts this ClearType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.ClearType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ClearType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ClearType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.ClearType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ClearType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.ClearType";
                };

                /**
                 * ClearTargetLayer enum.
                 * @name rv.data.Action.ClearType.ClearTargetLayer
                 * @enum {number}
                 * @property {number} CLEAR_TARGET_LAYER_ALL=0 CLEAR_TARGET_LAYER_ALL value
                 * @property {number} CLEAR_TARGET_LAYER_AUDIO=1 CLEAR_TARGET_LAYER_AUDIO value
                 * @property {number} CLEAR_TARGET_LAYER_BACKGROUND=2 CLEAR_TARGET_LAYER_BACKGROUND value
                 * @property {number} CLEAR_TARGET_LAYER_LIVE_VIDEO=3 CLEAR_TARGET_LAYER_LIVE_VIDEO value
                 * @property {number} CLEAR_TARGET_LAYER_PROP=4 CLEAR_TARGET_LAYER_PROP value
                 * @property {number} CLEAR_TARGET_LAYER_SLIDE=5 CLEAR_TARGET_LAYER_SLIDE value
                 * @property {number} CLEAR_TARGET_LAYER_LOGO=6 CLEAR_TARGET_LAYER_LOGO value
                 * @property {number} CLEAR_TARGET_LAYER_MESSAGES=7 CLEAR_TARGET_LAYER_MESSAGES value
                 * @property {number} CLEAR_TARGET_LAYER_AUDIO_EFFECTS=8 CLEAR_TARGET_LAYER_AUDIO_EFFECTS value
                 */
                ClearType.ClearTargetLayer = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CLEAR_TARGET_LAYER_ALL"] = 0;
                    values[valuesById[1] = "CLEAR_TARGET_LAYER_AUDIO"] = 1;
                    values[valuesById[2] = "CLEAR_TARGET_LAYER_BACKGROUND"] = 2;
                    values[valuesById[3] = "CLEAR_TARGET_LAYER_LIVE_VIDEO"] = 3;
                    values[valuesById[4] = "CLEAR_TARGET_LAYER_PROP"] = 4;
                    values[valuesById[5] = "CLEAR_TARGET_LAYER_SLIDE"] = 5;
                    values[valuesById[6] = "CLEAR_TARGET_LAYER_LOGO"] = 6;
                    values[valuesById[7] = "CLEAR_TARGET_LAYER_MESSAGES"] = 7;
                    values[valuesById[8] = "CLEAR_TARGET_LAYER_AUDIO_EFFECTS"] = 8;
                    return values;
                })();

                return ClearType;
            })();

            Action.ClearGroupType = (function() {

                /**
                 * Properties of a ClearGroupType.
                 * @memberof rv.data.Action
                 * @interface IClearGroupType
                 * @property {rv.data.ICollectionElementType|null} [identification] ClearGroupType identification
                 */

                /**
                 * Constructs a new ClearGroupType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a ClearGroupType.
                 * @implements IClearGroupType
                 * @constructor
                 * @param {rv.data.Action.IClearGroupType=} [properties] Properties to set
                 */
                function ClearGroupType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ClearGroupType identification.
                 * @member {rv.data.ICollectionElementType|null|undefined} identification
                 * @memberof rv.data.Action.ClearGroupType
                 * @instance
                 */
                ClearGroupType.prototype.identification = null;

                /**
                 * Creates a new ClearGroupType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.ClearGroupType
                 * @static
                 * @param {rv.data.Action.IClearGroupType=} [properties] Properties to set
                 * @returns {rv.data.Action.ClearGroupType} ClearGroupType instance
                 */
                ClearGroupType.create = function create(properties) {
                    return new ClearGroupType(properties);
                };

                /**
                 * Encodes the specified ClearGroupType message. Does not implicitly {@link rv.data.Action.ClearGroupType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.ClearGroupType
                 * @static
                 * @param {rv.data.Action.IClearGroupType} message ClearGroupType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClearGroupType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.identification != null && Object.hasOwnProperty.call(message, "identification"))
                        $root.rv.data.CollectionElementType.encode(message.identification, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ClearGroupType message, length delimited. Does not implicitly {@link rv.data.Action.ClearGroupType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.ClearGroupType
                 * @static
                 * @param {rv.data.Action.IClearGroupType} message ClearGroupType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClearGroupType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ClearGroupType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.ClearGroupType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.ClearGroupType} ClearGroupType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClearGroupType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.ClearGroupType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.identification = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ClearGroupType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.ClearGroupType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.ClearGroupType} ClearGroupType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClearGroupType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ClearGroupType message.
                 * @function verify
                 * @memberof rv.data.Action.ClearGroupType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ClearGroupType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.identification != null && message.hasOwnProperty("identification")) {
                        let error = $root.rv.data.CollectionElementType.verify(message.identification);
                        if (error)
                            return "identification." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ClearGroupType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.ClearGroupType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.ClearGroupType} ClearGroupType
                 */
                ClearGroupType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.ClearGroupType)
                        return object;
                    let message = new $root.rv.data.Action.ClearGroupType();
                    if (object.identification != null) {
                        if (typeof object.identification !== "object")
                            throw TypeError(".rv.data.Action.ClearGroupType.identification: object expected");
                        message.identification = $root.rv.data.CollectionElementType.fromObject(object.identification);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ClearGroupType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.ClearGroupType
                 * @static
                 * @param {rv.data.Action.ClearGroupType} message ClearGroupType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClearGroupType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.identification = null;
                    if (message.identification != null && message.hasOwnProperty("identification"))
                        object.identification = $root.rv.data.CollectionElementType.toObject(message.identification, options);
                    return object;
                };

                /**
                 * Converts this ClearGroupType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.ClearGroupType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ClearGroupType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ClearGroupType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.ClearGroupType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ClearGroupType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.ClearGroupType";
                };

                return ClearGroupType;
            })();

            Action.TransportControlType = (function() {

                /**
                 * Properties of a TransportControlType.
                 * @memberof rv.data.Action
                 * @interface ITransportControlType
                 * @property {rv.data.Action.TransportControlType.IPlay|null} [play] TransportControlType play
                 * @property {rv.data.Action.TransportControlType.IPause|null} [pause] TransportControlType pause
                 * @property {rv.data.Action.TransportControlType.IJumpToTime|null} [jumpToTime] TransportControlType jumpToTime
                 */

                /**
                 * Constructs a new TransportControlType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a TransportControlType.
                 * @implements ITransportControlType
                 * @constructor
                 * @param {rv.data.Action.ITransportControlType=} [properties] Properties to set
                 */
                function TransportControlType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TransportControlType play.
                 * @member {rv.data.Action.TransportControlType.IPlay|null|undefined} play
                 * @memberof rv.data.Action.TransportControlType
                 * @instance
                 */
                TransportControlType.prototype.play = null;

                /**
                 * TransportControlType pause.
                 * @member {rv.data.Action.TransportControlType.IPause|null|undefined} pause
                 * @memberof rv.data.Action.TransportControlType
                 * @instance
                 */
                TransportControlType.prototype.pause = null;

                /**
                 * TransportControlType jumpToTime.
                 * @member {rv.data.Action.TransportControlType.IJumpToTime|null|undefined} jumpToTime
                 * @memberof rv.data.Action.TransportControlType
                 * @instance
                 */
                TransportControlType.prototype.jumpToTime = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * TransportControlType Command.
                 * @member {"play"|"pause"|"jumpToTime"|undefined} Command
                 * @memberof rv.data.Action.TransportControlType
                 * @instance
                 */
                Object.defineProperty(TransportControlType.prototype, "Command", {
                    get: $util.oneOfGetter($oneOfFields = ["play", "pause", "jumpToTime"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new TransportControlType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.TransportControlType
                 * @static
                 * @param {rv.data.Action.ITransportControlType=} [properties] Properties to set
                 * @returns {rv.data.Action.TransportControlType} TransportControlType instance
                 */
                TransportControlType.create = function create(properties) {
                    return new TransportControlType(properties);
                };

                /**
                 * Encodes the specified TransportControlType message. Does not implicitly {@link rv.data.Action.TransportControlType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.TransportControlType
                 * @static
                 * @param {rv.data.Action.ITransportControlType} message TransportControlType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransportControlType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.play != null && Object.hasOwnProperty.call(message, "play"))
                        $root.rv.data.Action.TransportControlType.Play.encode(message.play, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.pause != null && Object.hasOwnProperty.call(message, "pause"))
                        $root.rv.data.Action.TransportControlType.Pause.encode(message.pause, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.jumpToTime != null && Object.hasOwnProperty.call(message, "jumpToTime"))
                        $root.rv.data.Action.TransportControlType.JumpToTime.encode(message.jumpToTime, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TransportControlType message, length delimited. Does not implicitly {@link rv.data.Action.TransportControlType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.TransportControlType
                 * @static
                 * @param {rv.data.Action.ITransportControlType} message TransportControlType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransportControlType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TransportControlType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.TransportControlType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.TransportControlType} TransportControlType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransportControlType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.TransportControlType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.play = $root.rv.data.Action.TransportControlType.Play.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.pause = $root.rv.data.Action.TransportControlType.Pause.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.jumpToTime = $root.rv.data.Action.TransportControlType.JumpToTime.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TransportControlType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.TransportControlType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.TransportControlType} TransportControlType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransportControlType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TransportControlType message.
                 * @function verify
                 * @memberof rv.data.Action.TransportControlType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransportControlType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.play != null && message.hasOwnProperty("play")) {
                        properties.Command = 1;
                        {
                            let error = $root.rv.data.Action.TransportControlType.Play.verify(message.play);
                            if (error)
                                return "play." + error;
                        }
                    }
                    if (message.pause != null && message.hasOwnProperty("pause")) {
                        if (properties.Command === 1)
                            return "Command: multiple values";
                        properties.Command = 1;
                        {
                            let error = $root.rv.data.Action.TransportControlType.Pause.verify(message.pause);
                            if (error)
                                return "pause." + error;
                        }
                    }
                    if (message.jumpToTime != null && message.hasOwnProperty("jumpToTime")) {
                        if (properties.Command === 1)
                            return "Command: multiple values";
                        properties.Command = 1;
                        {
                            let error = $root.rv.data.Action.TransportControlType.JumpToTime.verify(message.jumpToTime);
                            if (error)
                                return "jumpToTime." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TransportControlType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.TransportControlType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.TransportControlType} TransportControlType
                 */
                TransportControlType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.TransportControlType)
                        return object;
                    let message = new $root.rv.data.Action.TransportControlType();
                    if (object.play != null) {
                        if (typeof object.play !== "object")
                            throw TypeError(".rv.data.Action.TransportControlType.play: object expected");
                        message.play = $root.rv.data.Action.TransportControlType.Play.fromObject(object.play);
                    }
                    if (object.pause != null) {
                        if (typeof object.pause !== "object")
                            throw TypeError(".rv.data.Action.TransportControlType.pause: object expected");
                        message.pause = $root.rv.data.Action.TransportControlType.Pause.fromObject(object.pause);
                    }
                    if (object.jumpToTime != null) {
                        if (typeof object.jumpToTime !== "object")
                            throw TypeError(".rv.data.Action.TransportControlType.jumpToTime: object expected");
                        message.jumpToTime = $root.rv.data.Action.TransportControlType.JumpToTime.fromObject(object.jumpToTime);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TransportControlType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.TransportControlType
                 * @static
                 * @param {rv.data.Action.TransportControlType} message TransportControlType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransportControlType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.play != null && message.hasOwnProperty("play")) {
                        object.play = $root.rv.data.Action.TransportControlType.Play.toObject(message.play, options);
                        if (options.oneofs)
                            object.Command = "play";
                    }
                    if (message.pause != null && message.hasOwnProperty("pause")) {
                        object.pause = $root.rv.data.Action.TransportControlType.Pause.toObject(message.pause, options);
                        if (options.oneofs)
                            object.Command = "pause";
                    }
                    if (message.jumpToTime != null && message.hasOwnProperty("jumpToTime")) {
                        object.jumpToTime = $root.rv.data.Action.TransportControlType.JumpToTime.toObject(message.jumpToTime, options);
                        if (options.oneofs)
                            object.Command = "jumpToTime";
                    }
                    return object;
                };

                /**
                 * Converts this TransportControlType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.TransportControlType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransportControlType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TransportControlType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.TransportControlType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TransportControlType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.TransportControlType";
                };

                TransportControlType.Play = (function() {

                    /**
                     * Properties of a Play.
                     * @memberof rv.data.Action.TransportControlType
                     * @interface IPlay
                     */

                    /**
                     * Constructs a new Play.
                     * @memberof rv.data.Action.TransportControlType
                     * @classdesc Represents a Play.
                     * @implements IPlay
                     * @constructor
                     * @param {rv.data.Action.TransportControlType.IPlay=} [properties] Properties to set
                     */
                    function Play(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Play instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.TransportControlType.Play
                     * @static
                     * @param {rv.data.Action.TransportControlType.IPlay=} [properties] Properties to set
                     * @returns {rv.data.Action.TransportControlType.Play} Play instance
                     */
                    Play.create = function create(properties) {
                        return new Play(properties);
                    };

                    /**
                     * Encodes the specified Play message. Does not implicitly {@link rv.data.Action.TransportControlType.Play.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.TransportControlType.Play
                     * @static
                     * @param {rv.data.Action.TransportControlType.IPlay} message Play message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Play.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Play message, length delimited. Does not implicitly {@link rv.data.Action.TransportControlType.Play.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.TransportControlType.Play
                     * @static
                     * @param {rv.data.Action.TransportControlType.IPlay} message Play message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Play.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Play message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.TransportControlType.Play
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.TransportControlType.Play} Play
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Play.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.TransportControlType.Play();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Play message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.TransportControlType.Play
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.TransportControlType.Play} Play
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Play.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Play message.
                     * @function verify
                     * @memberof rv.data.Action.TransportControlType.Play
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Play.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Play message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.TransportControlType.Play
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.TransportControlType.Play} Play
                     */
                    Play.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.TransportControlType.Play)
                            return object;
                        return new $root.rv.data.Action.TransportControlType.Play();
                    };

                    /**
                     * Creates a plain object from a Play message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.TransportControlType.Play
                     * @static
                     * @param {rv.data.Action.TransportControlType.Play} message Play
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Play.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Play to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.TransportControlType.Play
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Play.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Play
                     * @function getTypeUrl
                     * @memberof rv.data.Action.TransportControlType.Play
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Play.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.TransportControlType.Play";
                    };

                    return Play;
                })();

                TransportControlType.Pause = (function() {

                    /**
                     * Properties of a Pause.
                     * @memberof rv.data.Action.TransportControlType
                     * @interface IPause
                     */

                    /**
                     * Constructs a new Pause.
                     * @memberof rv.data.Action.TransportControlType
                     * @classdesc Represents a Pause.
                     * @implements IPause
                     * @constructor
                     * @param {rv.data.Action.TransportControlType.IPause=} [properties] Properties to set
                     */
                    function Pause(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Pause instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.TransportControlType.Pause
                     * @static
                     * @param {rv.data.Action.TransportControlType.IPause=} [properties] Properties to set
                     * @returns {rv.data.Action.TransportControlType.Pause} Pause instance
                     */
                    Pause.create = function create(properties) {
                        return new Pause(properties);
                    };

                    /**
                     * Encodes the specified Pause message. Does not implicitly {@link rv.data.Action.TransportControlType.Pause.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.TransportControlType.Pause
                     * @static
                     * @param {rv.data.Action.TransportControlType.IPause} message Pause message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Pause.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Pause message, length delimited. Does not implicitly {@link rv.data.Action.TransportControlType.Pause.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.TransportControlType.Pause
                     * @static
                     * @param {rv.data.Action.TransportControlType.IPause} message Pause message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Pause.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Pause message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.TransportControlType.Pause
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.TransportControlType.Pause} Pause
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Pause.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.TransportControlType.Pause();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Pause message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.TransportControlType.Pause
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.TransportControlType.Pause} Pause
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Pause.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Pause message.
                     * @function verify
                     * @memberof rv.data.Action.TransportControlType.Pause
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Pause.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Pause message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.TransportControlType.Pause
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.TransportControlType.Pause} Pause
                     */
                    Pause.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.TransportControlType.Pause)
                            return object;
                        return new $root.rv.data.Action.TransportControlType.Pause();
                    };

                    /**
                     * Creates a plain object from a Pause message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.TransportControlType.Pause
                     * @static
                     * @param {rv.data.Action.TransportControlType.Pause} message Pause
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Pause.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Pause to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.TransportControlType.Pause
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Pause.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Pause
                     * @function getTypeUrl
                     * @memberof rv.data.Action.TransportControlType.Pause
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Pause.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.TransportControlType.Pause";
                    };

                    return Pause;
                })();

                TransportControlType.JumpToTime = (function() {

                    /**
                     * Properties of a JumpToTime.
                     * @memberof rv.data.Action.TransportControlType
                     * @interface IJumpToTime
                     * @property {number|null} [time] JumpToTime time
                     */

                    /**
                     * Constructs a new JumpToTime.
                     * @memberof rv.data.Action.TransportControlType
                     * @classdesc Represents a JumpToTime.
                     * @implements IJumpToTime
                     * @constructor
                     * @param {rv.data.Action.TransportControlType.IJumpToTime=} [properties] Properties to set
                     */
                    function JumpToTime(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * JumpToTime time.
                     * @member {number} time
                     * @memberof rv.data.Action.TransportControlType.JumpToTime
                     * @instance
                     */
                    JumpToTime.prototype.time = 0;

                    /**
                     * Creates a new JumpToTime instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.TransportControlType.JumpToTime
                     * @static
                     * @param {rv.data.Action.TransportControlType.IJumpToTime=} [properties] Properties to set
                     * @returns {rv.data.Action.TransportControlType.JumpToTime} JumpToTime instance
                     */
                    JumpToTime.create = function create(properties) {
                        return new JumpToTime(properties);
                    };

                    /**
                     * Encodes the specified JumpToTime message. Does not implicitly {@link rv.data.Action.TransportControlType.JumpToTime.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.TransportControlType.JumpToTime
                     * @static
                     * @param {rv.data.Action.TransportControlType.IJumpToTime} message JumpToTime message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JumpToTime.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                            writer.uint32(/* id 1, wireType 1 =*/9).double(message.time);
                        return writer;
                    };

                    /**
                     * Encodes the specified JumpToTime message, length delimited. Does not implicitly {@link rv.data.Action.TransportControlType.JumpToTime.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.TransportControlType.JumpToTime
                     * @static
                     * @param {rv.data.Action.TransportControlType.IJumpToTime} message JumpToTime message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JumpToTime.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a JumpToTime message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.TransportControlType.JumpToTime
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.TransportControlType.JumpToTime} JumpToTime
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JumpToTime.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.TransportControlType.JumpToTime();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.time = reader.double();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a JumpToTime message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.TransportControlType.JumpToTime
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.TransportControlType.JumpToTime} JumpToTime
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JumpToTime.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a JumpToTime message.
                     * @function verify
                     * @memberof rv.data.Action.TransportControlType.JumpToTime
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    JumpToTime.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.time != null && message.hasOwnProperty("time"))
                            if (typeof message.time !== "number")
                                return "time: number expected";
                        return null;
                    };

                    /**
                     * Creates a JumpToTime message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.TransportControlType.JumpToTime
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.TransportControlType.JumpToTime} JumpToTime
                     */
                    JumpToTime.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.TransportControlType.JumpToTime)
                            return object;
                        let message = new $root.rv.data.Action.TransportControlType.JumpToTime();
                        if (object.time != null)
                            message.time = Number(object.time);
                        return message;
                    };

                    /**
                     * Creates a plain object from a JumpToTime message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.TransportControlType.JumpToTime
                     * @static
                     * @param {rv.data.Action.TransportControlType.JumpToTime} message JumpToTime
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    JumpToTime.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.time = 0;
                        if (message.time != null && message.hasOwnProperty("time"))
                            object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
                        return object;
                    };

                    /**
                     * Converts this JumpToTime to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.TransportControlType.JumpToTime
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    JumpToTime.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for JumpToTime
                     * @function getTypeUrl
                     * @memberof rv.data.Action.TransportControlType.JumpToTime
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    JumpToTime.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.TransportControlType.JumpToTime";
                    };

                    return JumpToTime;
                })();

                return TransportControlType;
            })();

            Action.StageLayoutType = (function() {

                /**
                 * Properties of a StageLayoutType.
                 * @memberof rv.data.Action
                 * @interface IStageLayoutType
                 * @property {Array.<rv.data.Stage.IScreenAssignment>|null} [stageScreenAssignments] StageLayoutType stageScreenAssignments
                 * @property {rv.data.Action.StageLayoutType.SlideTarget|null} [slideTarget] StageLayoutType slideTarget
                 */

                /**
                 * Constructs a new StageLayoutType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a StageLayoutType.
                 * @implements IStageLayoutType
                 * @constructor
                 * @param {rv.data.Action.IStageLayoutType=} [properties] Properties to set
                 */
                function StageLayoutType(properties) {
                    this.stageScreenAssignments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StageLayoutType stageScreenAssignments.
                 * @member {Array.<rv.data.Stage.IScreenAssignment>} stageScreenAssignments
                 * @memberof rv.data.Action.StageLayoutType
                 * @instance
                 */
                StageLayoutType.prototype.stageScreenAssignments = $util.emptyArray;

                /**
                 * StageLayoutType slideTarget.
                 * @member {rv.data.Action.StageLayoutType.SlideTarget} slideTarget
                 * @memberof rv.data.Action.StageLayoutType
                 * @instance
                 */
                StageLayoutType.prototype.slideTarget = 0;

                /**
                 * Creates a new StageLayoutType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.StageLayoutType
                 * @static
                 * @param {rv.data.Action.IStageLayoutType=} [properties] Properties to set
                 * @returns {rv.data.Action.StageLayoutType} StageLayoutType instance
                 */
                StageLayoutType.create = function create(properties) {
                    return new StageLayoutType(properties);
                };

                /**
                 * Encodes the specified StageLayoutType message. Does not implicitly {@link rv.data.Action.StageLayoutType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.StageLayoutType
                 * @static
                 * @param {rv.data.Action.IStageLayoutType} message StageLayoutType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StageLayoutType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.stageScreenAssignments != null && message.stageScreenAssignments.length)
                        for (let i = 0; i < message.stageScreenAssignments.length; ++i)
                            $root.rv.data.Stage.ScreenAssignment.encode(message.stageScreenAssignments[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.slideTarget != null && Object.hasOwnProperty.call(message, "slideTarget"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.slideTarget);
                    return writer;
                };

                /**
                 * Encodes the specified StageLayoutType message, length delimited. Does not implicitly {@link rv.data.Action.StageLayoutType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.StageLayoutType
                 * @static
                 * @param {rv.data.Action.IStageLayoutType} message StageLayoutType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StageLayoutType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StageLayoutType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.StageLayoutType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.StageLayoutType} StageLayoutType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StageLayoutType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.StageLayoutType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 4: {
                                if (!(message.stageScreenAssignments && message.stageScreenAssignments.length))
                                    message.stageScreenAssignments = [];
                                message.stageScreenAssignments.push($root.rv.data.Stage.ScreenAssignment.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                message.slideTarget = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StageLayoutType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.StageLayoutType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.StageLayoutType} StageLayoutType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StageLayoutType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StageLayoutType message.
                 * @function verify
                 * @memberof rv.data.Action.StageLayoutType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StageLayoutType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.stageScreenAssignments != null && message.hasOwnProperty("stageScreenAssignments")) {
                        if (!Array.isArray(message.stageScreenAssignments))
                            return "stageScreenAssignments: array expected";
                        for (let i = 0; i < message.stageScreenAssignments.length; ++i) {
                            let error = $root.rv.data.Stage.ScreenAssignment.verify(message.stageScreenAssignments[i]);
                            if (error)
                                return "stageScreenAssignments." + error;
                        }
                    }
                    if (message.slideTarget != null && message.hasOwnProperty("slideTarget"))
                        switch (message.slideTarget) {
                        default:
                            return "slideTarget: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a StageLayoutType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.StageLayoutType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.StageLayoutType} StageLayoutType
                 */
                StageLayoutType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.StageLayoutType)
                        return object;
                    let message = new $root.rv.data.Action.StageLayoutType();
                    if (object.stageScreenAssignments) {
                        if (!Array.isArray(object.stageScreenAssignments))
                            throw TypeError(".rv.data.Action.StageLayoutType.stageScreenAssignments: array expected");
                        message.stageScreenAssignments = [];
                        for (let i = 0; i < object.stageScreenAssignments.length; ++i) {
                            if (typeof object.stageScreenAssignments[i] !== "object")
                                throw TypeError(".rv.data.Action.StageLayoutType.stageScreenAssignments: object expected");
                            message.stageScreenAssignments[i] = $root.rv.data.Stage.ScreenAssignment.fromObject(object.stageScreenAssignments[i]);
                        }
                    }
                    switch (object.slideTarget) {
                    default:
                        if (typeof object.slideTarget === "number") {
                            message.slideTarget = object.slideTarget;
                            break;
                        }
                        break;
                    case "SLIDE_TARGET_NO_CHANGE":
                    case 0:
                        message.slideTarget = 0;
                        break;
                    case "SLIDE_TARGET_STAGE_ONLY":
                    case 1:
                        message.slideTarget = 1;
                        break;
                    case "SLIDE_TARGET_ALL":
                    case 2:
                        message.slideTarget = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a StageLayoutType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.StageLayoutType
                 * @static
                 * @param {rv.data.Action.StageLayoutType} message StageLayoutType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StageLayoutType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.stageScreenAssignments = [];
                    if (options.defaults)
                        object.slideTarget = options.enums === String ? "SLIDE_TARGET_NO_CHANGE" : 0;
                    if (message.stageScreenAssignments && message.stageScreenAssignments.length) {
                        object.stageScreenAssignments = [];
                        for (let j = 0; j < message.stageScreenAssignments.length; ++j)
                            object.stageScreenAssignments[j] = $root.rv.data.Stage.ScreenAssignment.toObject(message.stageScreenAssignments[j], options);
                    }
                    if (message.slideTarget != null && message.hasOwnProperty("slideTarget"))
                        object.slideTarget = options.enums === String ? $root.rv.data.Action.StageLayoutType.SlideTarget[message.slideTarget] === undefined ? message.slideTarget : $root.rv.data.Action.StageLayoutType.SlideTarget[message.slideTarget] : message.slideTarget;
                    return object;
                };

                /**
                 * Converts this StageLayoutType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.StageLayoutType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StageLayoutType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for StageLayoutType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.StageLayoutType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                StageLayoutType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.StageLayoutType";
                };

                /**
                 * SlideTarget enum.
                 * @name rv.data.Action.StageLayoutType.SlideTarget
                 * @enum {number}
                 * @property {number} SLIDE_TARGET_NO_CHANGE=0 SLIDE_TARGET_NO_CHANGE value
                 * @property {number} SLIDE_TARGET_STAGE_ONLY=1 SLIDE_TARGET_STAGE_ONLY value
                 * @property {number} SLIDE_TARGET_ALL=2 SLIDE_TARGET_ALL value
                 */
                StageLayoutType.SlideTarget = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "SLIDE_TARGET_NO_CHANGE"] = 0;
                    values[valuesById[1] = "SLIDE_TARGET_STAGE_ONLY"] = 1;
                    values[valuesById[2] = "SLIDE_TARGET_ALL"] = 2;
                    return values;
                })();

                return StageLayoutType;
            })();

            Action.SlideDestinationType = (function() {

                /**
                 * Properties of a SlideDestinationType.
                 * @memberof rv.data.Action
                 * @interface ISlideDestinationType
                 * @property {rv.data.Action.StageLayoutType.SlideTarget|null} [slideTarget] SlideDestinationType slideTarget
                 */

                /**
                 * Constructs a new SlideDestinationType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a SlideDestinationType.
                 * @implements ISlideDestinationType
                 * @constructor
                 * @param {rv.data.Action.ISlideDestinationType=} [properties] Properties to set
                 */
                function SlideDestinationType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SlideDestinationType slideTarget.
                 * @member {rv.data.Action.StageLayoutType.SlideTarget} slideTarget
                 * @memberof rv.data.Action.SlideDestinationType
                 * @instance
                 */
                SlideDestinationType.prototype.slideTarget = 0;

                /**
                 * Creates a new SlideDestinationType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.SlideDestinationType
                 * @static
                 * @param {rv.data.Action.ISlideDestinationType=} [properties] Properties to set
                 * @returns {rv.data.Action.SlideDestinationType} SlideDestinationType instance
                 */
                SlideDestinationType.create = function create(properties) {
                    return new SlideDestinationType(properties);
                };

                /**
                 * Encodes the specified SlideDestinationType message. Does not implicitly {@link rv.data.Action.SlideDestinationType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.SlideDestinationType
                 * @static
                 * @param {rv.data.Action.ISlideDestinationType} message SlideDestinationType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SlideDestinationType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.slideTarget != null && Object.hasOwnProperty.call(message, "slideTarget"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slideTarget);
                    return writer;
                };

                /**
                 * Encodes the specified SlideDestinationType message, length delimited. Does not implicitly {@link rv.data.Action.SlideDestinationType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.SlideDestinationType
                 * @static
                 * @param {rv.data.Action.ISlideDestinationType} message SlideDestinationType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SlideDestinationType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SlideDestinationType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.SlideDestinationType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.SlideDestinationType} SlideDestinationType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SlideDestinationType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.SlideDestinationType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.slideTarget = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SlideDestinationType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.SlideDestinationType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.SlideDestinationType} SlideDestinationType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SlideDestinationType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SlideDestinationType message.
                 * @function verify
                 * @memberof rv.data.Action.SlideDestinationType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SlideDestinationType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.slideTarget != null && message.hasOwnProperty("slideTarget"))
                        switch (message.slideTarget) {
                        default:
                            return "slideTarget: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a SlideDestinationType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.SlideDestinationType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.SlideDestinationType} SlideDestinationType
                 */
                SlideDestinationType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.SlideDestinationType)
                        return object;
                    let message = new $root.rv.data.Action.SlideDestinationType();
                    switch (object.slideTarget) {
                    default:
                        if (typeof object.slideTarget === "number") {
                            message.slideTarget = object.slideTarget;
                            break;
                        }
                        break;
                    case "SLIDE_TARGET_NO_CHANGE":
                    case 0:
                        message.slideTarget = 0;
                        break;
                    case "SLIDE_TARGET_STAGE_ONLY":
                    case 1:
                        message.slideTarget = 1;
                        break;
                    case "SLIDE_TARGET_ALL":
                    case 2:
                        message.slideTarget = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SlideDestinationType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.SlideDestinationType
                 * @static
                 * @param {rv.data.Action.SlideDestinationType} message SlideDestinationType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SlideDestinationType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.slideTarget = options.enums === String ? "SLIDE_TARGET_NO_CHANGE" : 0;
                    if (message.slideTarget != null && message.hasOwnProperty("slideTarget"))
                        object.slideTarget = options.enums === String ? $root.rv.data.Action.StageLayoutType.SlideTarget[message.slideTarget] === undefined ? message.slideTarget : $root.rv.data.Action.StageLayoutType.SlideTarget[message.slideTarget] : message.slideTarget;
                    return object;
                };

                /**
                 * Converts this SlideDestinationType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.SlideDestinationType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SlideDestinationType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SlideDestinationType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.SlideDestinationType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SlideDestinationType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.SlideDestinationType";
                };

                return SlideDestinationType;
            })();

            Action.PropType = (function() {

                /**
                 * Properties of a PropType.
                 * @memberof rv.data.Action
                 * @interface IPropType
                 * @property {rv.data.ICollectionElementType|null} [identification] PropType identification
                 */

                /**
                 * Constructs a new PropType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a PropType.
                 * @implements IPropType
                 * @constructor
                 * @param {rv.data.Action.IPropType=} [properties] Properties to set
                 */
                function PropType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PropType identification.
                 * @member {rv.data.ICollectionElementType|null|undefined} identification
                 * @memberof rv.data.Action.PropType
                 * @instance
                 */
                PropType.prototype.identification = null;

                /**
                 * Creates a new PropType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.PropType
                 * @static
                 * @param {rv.data.Action.IPropType=} [properties] Properties to set
                 * @returns {rv.data.Action.PropType} PropType instance
                 */
                PropType.create = function create(properties) {
                    return new PropType(properties);
                };

                /**
                 * Encodes the specified PropType message. Does not implicitly {@link rv.data.Action.PropType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.PropType
                 * @static
                 * @param {rv.data.Action.IPropType} message PropType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PropType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.identification != null && Object.hasOwnProperty.call(message, "identification"))
                        $root.rv.data.CollectionElementType.encode(message.identification, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PropType message, length delimited. Does not implicitly {@link rv.data.Action.PropType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.PropType
                 * @static
                 * @param {rv.data.Action.IPropType} message PropType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PropType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PropType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.PropType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.PropType} PropType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PropType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.PropType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 3: {
                                message.identification = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PropType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.PropType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.PropType} PropType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PropType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PropType message.
                 * @function verify
                 * @memberof rv.data.Action.PropType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PropType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.identification != null && message.hasOwnProperty("identification")) {
                        let error = $root.rv.data.CollectionElementType.verify(message.identification);
                        if (error)
                            return "identification." + error;
                    }
                    return null;
                };

                /**
                 * Creates a PropType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.PropType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.PropType} PropType
                 */
                PropType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.PropType)
                        return object;
                    let message = new $root.rv.data.Action.PropType();
                    if (object.identification != null) {
                        if (typeof object.identification !== "object")
                            throw TypeError(".rv.data.Action.PropType.identification: object expected");
                        message.identification = $root.rv.data.CollectionElementType.fromObject(object.identification);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PropType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.PropType
                 * @static
                 * @param {rv.data.Action.PropType} message PropType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PropType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.identification = null;
                    if (message.identification != null && message.hasOwnProperty("identification"))
                        object.identification = $root.rv.data.CollectionElementType.toObject(message.identification, options);
                    return object;
                };

                /**
                 * Converts this PropType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.PropType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PropType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PropType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.PropType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PropType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.PropType";
                };

                return PropType;
            })();

            Action.MaskType = (function() {

                /**
                 * Properties of a MaskType.
                 * @memberof rv.data.Action
                 * @interface IMaskType
                 * @property {rv.data.ICollectionElementType|null} [identification] MaskType identification
                 */

                /**
                 * Constructs a new MaskType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a MaskType.
                 * @implements IMaskType
                 * @constructor
                 * @param {rv.data.Action.IMaskType=} [properties] Properties to set
                 */
                function MaskType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MaskType identification.
                 * @member {rv.data.ICollectionElementType|null|undefined} identification
                 * @memberof rv.data.Action.MaskType
                 * @instance
                 */
                MaskType.prototype.identification = null;

                /**
                 * Creates a new MaskType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.MaskType
                 * @static
                 * @param {rv.data.Action.IMaskType=} [properties] Properties to set
                 * @returns {rv.data.Action.MaskType} MaskType instance
                 */
                MaskType.create = function create(properties) {
                    return new MaskType(properties);
                };

                /**
                 * Encodes the specified MaskType message. Does not implicitly {@link rv.data.Action.MaskType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.MaskType
                 * @static
                 * @param {rv.data.Action.IMaskType} message MaskType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MaskType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.identification != null && Object.hasOwnProperty.call(message, "identification"))
                        $root.rv.data.CollectionElementType.encode(message.identification, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MaskType message, length delimited. Does not implicitly {@link rv.data.Action.MaskType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.MaskType
                 * @static
                 * @param {rv.data.Action.IMaskType} message MaskType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MaskType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MaskType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.MaskType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.MaskType} MaskType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MaskType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.MaskType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 3: {
                                message.identification = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MaskType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.MaskType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.MaskType} MaskType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MaskType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MaskType message.
                 * @function verify
                 * @memberof rv.data.Action.MaskType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MaskType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.identification != null && message.hasOwnProperty("identification")) {
                        let error = $root.rv.data.CollectionElementType.verify(message.identification);
                        if (error)
                            return "identification." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MaskType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.MaskType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.MaskType} MaskType
                 */
                MaskType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.MaskType)
                        return object;
                    let message = new $root.rv.data.Action.MaskType();
                    if (object.identification != null) {
                        if (typeof object.identification !== "object")
                            throw TypeError(".rv.data.Action.MaskType.identification: object expected");
                        message.identification = $root.rv.data.CollectionElementType.fromObject(object.identification);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MaskType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.MaskType
                 * @static
                 * @param {rv.data.Action.MaskType} message MaskType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MaskType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.identification = null;
                    if (message.identification != null && message.hasOwnProperty("identification"))
                        object.identification = $root.rv.data.CollectionElementType.toObject(message.identification, options);
                    return object;
                };

                /**
                 * Converts this MaskType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.MaskType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MaskType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MaskType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.MaskType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MaskType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.MaskType";
                };

                return MaskType;
            })();

            Action.MessageType = (function() {

                /**
                 * Properties of a MessageType.
                 * @memberof rv.data.Action
                 * @interface IMessageType
                 * @property {rv.data.ICollectionElementType|null} [messageIdentificaton] MessageType messageIdentificaton
                 * @property {Array.<rv.data.Message.ITokenValue>|null} [content] MessageType content
                 */

                /**
                 * Constructs a new MessageType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a MessageType.
                 * @implements IMessageType
                 * @constructor
                 * @param {rv.data.Action.IMessageType=} [properties] Properties to set
                 */
                function MessageType(properties) {
                    this.content = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageType messageIdentificaton.
                 * @member {rv.data.ICollectionElementType|null|undefined} messageIdentificaton
                 * @memberof rv.data.Action.MessageType
                 * @instance
                 */
                MessageType.prototype.messageIdentificaton = null;

                /**
                 * MessageType content.
                 * @member {Array.<rv.data.Message.ITokenValue>} content
                 * @memberof rv.data.Action.MessageType
                 * @instance
                 */
                MessageType.prototype.content = $util.emptyArray;

                /**
                 * Creates a new MessageType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.MessageType
                 * @static
                 * @param {rv.data.Action.IMessageType=} [properties] Properties to set
                 * @returns {rv.data.Action.MessageType} MessageType instance
                 */
                MessageType.create = function create(properties) {
                    return new MessageType(properties);
                };

                /**
                 * Encodes the specified MessageType message. Does not implicitly {@link rv.data.Action.MessageType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.MessageType
                 * @static
                 * @param {rv.data.Action.IMessageType} message MessageType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.messageIdentificaton != null && Object.hasOwnProperty.call(message, "messageIdentificaton"))
                        $root.rv.data.CollectionElementType.encode(message.messageIdentificaton, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.content != null && message.content.length)
                        for (let i = 0; i < message.content.length; ++i)
                            $root.rv.data.Message.TokenValue.encode(message.content[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MessageType message, length delimited. Does not implicitly {@link rv.data.Action.MessageType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.MessageType
                 * @static
                 * @param {rv.data.Action.IMessageType} message MessageType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.MessageType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.MessageType} MessageType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.MessageType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.messageIdentificaton = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                if (!(message.content && message.content.length))
                                    message.content = [];
                                message.content.push($root.rv.data.Message.TokenValue.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.MessageType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.MessageType} MessageType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageType message.
                 * @function verify
                 * @memberof rv.data.Action.MessageType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.messageIdentificaton != null && message.hasOwnProperty("messageIdentificaton")) {
                        let error = $root.rv.data.CollectionElementType.verify(message.messageIdentificaton);
                        if (error)
                            return "messageIdentificaton." + error;
                    }
                    if (message.content != null && message.hasOwnProperty("content")) {
                        if (!Array.isArray(message.content))
                            return "content: array expected";
                        for (let i = 0; i < message.content.length; ++i) {
                            let error = $root.rv.data.Message.TokenValue.verify(message.content[i]);
                            if (error)
                                return "content." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MessageType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.MessageType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.MessageType} MessageType
                 */
                MessageType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.MessageType)
                        return object;
                    let message = new $root.rv.data.Action.MessageType();
                    if (object.messageIdentificaton != null) {
                        if (typeof object.messageIdentificaton !== "object")
                            throw TypeError(".rv.data.Action.MessageType.messageIdentificaton: object expected");
                        message.messageIdentificaton = $root.rv.data.CollectionElementType.fromObject(object.messageIdentificaton);
                    }
                    if (object.content) {
                        if (!Array.isArray(object.content))
                            throw TypeError(".rv.data.Action.MessageType.content: array expected");
                        message.content = [];
                        for (let i = 0; i < object.content.length; ++i) {
                            if (typeof object.content[i] !== "object")
                                throw TypeError(".rv.data.Action.MessageType.content: object expected");
                            message.content[i] = $root.rv.data.Message.TokenValue.fromObject(object.content[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MessageType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.MessageType
                 * @static
                 * @param {rv.data.Action.MessageType} message MessageType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.content = [];
                    if (options.defaults)
                        object.messageIdentificaton = null;
                    if (message.messageIdentificaton != null && message.hasOwnProperty("messageIdentificaton"))
                        object.messageIdentificaton = $root.rv.data.CollectionElementType.toObject(message.messageIdentificaton, options);
                    if (message.content && message.content.length) {
                        object.content = [];
                        for (let j = 0; j < message.content.length; ++j)
                            object.content[j] = $root.rv.data.Message.TokenValue.toObject(message.content[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MessageType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.MessageType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.MessageType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.MessageType";
                };

                return MessageType;
            })();

            Action.CommunicationType = (function() {

                /**
                 * Properties of a CommunicationType.
                 * @memberof rv.data.Action
                 * @interface ICommunicationType
                 * @property {rv.data.ICollectionElementType|null} [deviceIdentification] CommunicationType deviceIdentification
                 * @property {string|null} [format] CommunicationType format
                 * @property {string|null} [description] CommunicationType description
                 * @property {Array.<rv.data.Action.CommunicationType.ICommand>|null} [commands] CommunicationType commands
                 * @property {rv.data.Action.CommunicationType.IMIDICommand|null} [midiCommand] CommunicationType midiCommand
                 * @property {rv.data.Action.CommunicationType.IGlobalCacheCommand|null} [globalCacheCommand] CommunicationType globalCacheCommand
                 * @property {rv.data.Action.CommunicationType.IGVG100Command|null} [gvg100Command] CommunicationType gvg100Command
                 * @property {rv.data.Action.CommunicationType.ISonyBVSCommand|null} [sony_BVSCommand] CommunicationType sony_BVSCommand
                 */

                /**
                 * Constructs a new CommunicationType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a CommunicationType.
                 * @implements ICommunicationType
                 * @constructor
                 * @param {rv.data.Action.ICommunicationType=} [properties] Properties to set
                 */
                function CommunicationType(properties) {
                    this.commands = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommunicationType deviceIdentification.
                 * @member {rv.data.ICollectionElementType|null|undefined} deviceIdentification
                 * @memberof rv.data.Action.CommunicationType
                 * @instance
                 */
                CommunicationType.prototype.deviceIdentification = null;

                /**
                 * CommunicationType format.
                 * @member {string} format
                 * @memberof rv.data.Action.CommunicationType
                 * @instance
                 */
                CommunicationType.prototype.format = "";

                /**
                 * CommunicationType description.
                 * @member {string} description
                 * @memberof rv.data.Action.CommunicationType
                 * @instance
                 */
                CommunicationType.prototype.description = "";

                /**
                 * CommunicationType commands.
                 * @member {Array.<rv.data.Action.CommunicationType.ICommand>} commands
                 * @memberof rv.data.Action.CommunicationType
                 * @instance
                 */
                CommunicationType.prototype.commands = $util.emptyArray;

                /**
                 * CommunicationType midiCommand.
                 * @member {rv.data.Action.CommunicationType.IMIDICommand|null|undefined} midiCommand
                 * @memberof rv.data.Action.CommunicationType
                 * @instance
                 */
                CommunicationType.prototype.midiCommand = null;

                /**
                 * CommunicationType globalCacheCommand.
                 * @member {rv.data.Action.CommunicationType.IGlobalCacheCommand|null|undefined} globalCacheCommand
                 * @memberof rv.data.Action.CommunicationType
                 * @instance
                 */
                CommunicationType.prototype.globalCacheCommand = null;

                /**
                 * CommunicationType gvg100Command.
                 * @member {rv.data.Action.CommunicationType.IGVG100Command|null|undefined} gvg100Command
                 * @memberof rv.data.Action.CommunicationType
                 * @instance
                 */
                CommunicationType.prototype.gvg100Command = null;

                /**
                 * CommunicationType sony_BVSCommand.
                 * @member {rv.data.Action.CommunicationType.ISonyBVSCommand|null|undefined} sony_BVSCommand
                 * @memberof rv.data.Action.CommunicationType
                 * @instance
                 */
                CommunicationType.prototype.sony_BVSCommand = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * CommunicationType CommandTypeData.
                 * @member {"midiCommand"|"globalCacheCommand"|"gvg100Command"|"sony_BVSCommand"|undefined} CommandTypeData
                 * @memberof rv.data.Action.CommunicationType
                 * @instance
                 */
                Object.defineProperty(CommunicationType.prototype, "CommandTypeData", {
                    get: $util.oneOfGetter($oneOfFields = ["midiCommand", "globalCacheCommand", "gvg100Command", "sony_BVSCommand"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new CommunicationType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.CommunicationType
                 * @static
                 * @param {rv.data.Action.ICommunicationType=} [properties] Properties to set
                 * @returns {rv.data.Action.CommunicationType} CommunicationType instance
                 */
                CommunicationType.create = function create(properties) {
                    return new CommunicationType(properties);
                };

                /**
                 * Encodes the specified CommunicationType message. Does not implicitly {@link rv.data.Action.CommunicationType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.CommunicationType
                 * @static
                 * @param {rv.data.Action.ICommunicationType} message CommunicationType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommunicationType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deviceIdentification != null && Object.hasOwnProperty.call(message, "deviceIdentification"))
                        $root.rv.data.CollectionElementType.encode(message.deviceIdentification, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.format);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
                    if (message.commands != null && message.commands.length)
                        for (let i = 0; i < message.commands.length; ++i)
                            $root.rv.data.Action.CommunicationType.Command.encode(message.commands[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.midiCommand != null && Object.hasOwnProperty.call(message, "midiCommand"))
                        $root.rv.data.Action.CommunicationType.MIDICommand.encode(message.midiCommand, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.globalCacheCommand != null && Object.hasOwnProperty.call(message, "globalCacheCommand"))
                        $root.rv.data.Action.CommunicationType.GlobalCacheCommand.encode(message.globalCacheCommand, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.gvg100Command != null && Object.hasOwnProperty.call(message, "gvg100Command"))
                        $root.rv.data.Action.CommunicationType.GVG100Command.encode(message.gvg100Command, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.sony_BVSCommand != null && Object.hasOwnProperty.call(message, "sony_BVSCommand"))
                        $root.rv.data.Action.CommunicationType.SonyBVSCommand.encode(message.sony_BVSCommand, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CommunicationType message, length delimited. Does not implicitly {@link rv.data.Action.CommunicationType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.CommunicationType
                 * @static
                 * @param {rv.data.Action.ICommunicationType} message CommunicationType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommunicationType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommunicationType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.CommunicationType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.CommunicationType} CommunicationType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommunicationType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.CommunicationType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.deviceIdentification = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.format = reader.string();
                                break;
                            }
                        case 3: {
                                message.description = reader.string();
                                break;
                            }
                        case 4: {
                                if (!(message.commands && message.commands.length))
                                    message.commands = [];
                                message.commands.push($root.rv.data.Action.CommunicationType.Command.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                message.midiCommand = $root.rv.data.Action.CommunicationType.MIDICommand.decode(reader, reader.uint32());
                                break;
                            }
                        case 6: {
                                message.globalCacheCommand = $root.rv.data.Action.CommunicationType.GlobalCacheCommand.decode(reader, reader.uint32());
                                break;
                            }
                        case 7: {
                                message.gvg100Command = $root.rv.data.Action.CommunicationType.GVG100Command.decode(reader, reader.uint32());
                                break;
                            }
                        case 8: {
                                message.sony_BVSCommand = $root.rv.data.Action.CommunicationType.SonyBVSCommand.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommunicationType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.CommunicationType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.CommunicationType} CommunicationType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommunicationType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommunicationType message.
                 * @function verify
                 * @memberof rv.data.Action.CommunicationType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommunicationType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.deviceIdentification != null && message.hasOwnProperty("deviceIdentification")) {
                        let error = $root.rv.data.CollectionElementType.verify(message.deviceIdentification);
                        if (error)
                            return "deviceIdentification." + error;
                    }
                    if (message.format != null && message.hasOwnProperty("format"))
                        if (!$util.isString(message.format))
                            return "format: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.commands != null && message.hasOwnProperty("commands")) {
                        if (!Array.isArray(message.commands))
                            return "commands: array expected";
                        for (let i = 0; i < message.commands.length; ++i) {
                            let error = $root.rv.data.Action.CommunicationType.Command.verify(message.commands[i]);
                            if (error)
                                return "commands." + error;
                        }
                    }
                    if (message.midiCommand != null && message.hasOwnProperty("midiCommand")) {
                        properties.CommandTypeData = 1;
                        {
                            let error = $root.rv.data.Action.CommunicationType.MIDICommand.verify(message.midiCommand);
                            if (error)
                                return "midiCommand." + error;
                        }
                    }
                    if (message.globalCacheCommand != null && message.hasOwnProperty("globalCacheCommand")) {
                        if (properties.CommandTypeData === 1)
                            return "CommandTypeData: multiple values";
                        properties.CommandTypeData = 1;
                        {
                            let error = $root.rv.data.Action.CommunicationType.GlobalCacheCommand.verify(message.globalCacheCommand);
                            if (error)
                                return "globalCacheCommand." + error;
                        }
                    }
                    if (message.gvg100Command != null && message.hasOwnProperty("gvg100Command")) {
                        if (properties.CommandTypeData === 1)
                            return "CommandTypeData: multiple values";
                        properties.CommandTypeData = 1;
                        {
                            let error = $root.rv.data.Action.CommunicationType.GVG100Command.verify(message.gvg100Command);
                            if (error)
                                return "gvg100Command." + error;
                        }
                    }
                    if (message.sony_BVSCommand != null && message.hasOwnProperty("sony_BVSCommand")) {
                        if (properties.CommandTypeData === 1)
                            return "CommandTypeData: multiple values";
                        properties.CommandTypeData = 1;
                        {
                            let error = $root.rv.data.Action.CommunicationType.SonyBVSCommand.verify(message.sony_BVSCommand);
                            if (error)
                                return "sony_BVSCommand." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a CommunicationType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.CommunicationType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.CommunicationType} CommunicationType
                 */
                CommunicationType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.CommunicationType)
                        return object;
                    let message = new $root.rv.data.Action.CommunicationType();
                    if (object.deviceIdentification != null) {
                        if (typeof object.deviceIdentification !== "object")
                            throw TypeError(".rv.data.Action.CommunicationType.deviceIdentification: object expected");
                        message.deviceIdentification = $root.rv.data.CollectionElementType.fromObject(object.deviceIdentification);
                    }
                    if (object.format != null)
                        message.format = String(object.format);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.commands) {
                        if (!Array.isArray(object.commands))
                            throw TypeError(".rv.data.Action.CommunicationType.commands: array expected");
                        message.commands = [];
                        for (let i = 0; i < object.commands.length; ++i) {
                            if (typeof object.commands[i] !== "object")
                                throw TypeError(".rv.data.Action.CommunicationType.commands: object expected");
                            message.commands[i] = $root.rv.data.Action.CommunicationType.Command.fromObject(object.commands[i]);
                        }
                    }
                    if (object.midiCommand != null) {
                        if (typeof object.midiCommand !== "object")
                            throw TypeError(".rv.data.Action.CommunicationType.midiCommand: object expected");
                        message.midiCommand = $root.rv.data.Action.CommunicationType.MIDICommand.fromObject(object.midiCommand);
                    }
                    if (object.globalCacheCommand != null) {
                        if (typeof object.globalCacheCommand !== "object")
                            throw TypeError(".rv.data.Action.CommunicationType.globalCacheCommand: object expected");
                        message.globalCacheCommand = $root.rv.data.Action.CommunicationType.GlobalCacheCommand.fromObject(object.globalCacheCommand);
                    }
                    if (object.gvg100Command != null) {
                        if (typeof object.gvg100Command !== "object")
                            throw TypeError(".rv.data.Action.CommunicationType.gvg100Command: object expected");
                        message.gvg100Command = $root.rv.data.Action.CommunicationType.GVG100Command.fromObject(object.gvg100Command);
                    }
                    if (object.sony_BVSCommand != null) {
                        if (typeof object.sony_BVSCommand !== "object")
                            throw TypeError(".rv.data.Action.CommunicationType.sony_BVSCommand: object expected");
                        message.sony_BVSCommand = $root.rv.data.Action.CommunicationType.SonyBVSCommand.fromObject(object.sony_BVSCommand);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CommunicationType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.CommunicationType
                 * @static
                 * @param {rv.data.Action.CommunicationType} message CommunicationType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommunicationType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.commands = [];
                    if (options.defaults) {
                        object.deviceIdentification = null;
                        object.format = "";
                        object.description = "";
                    }
                    if (message.deviceIdentification != null && message.hasOwnProperty("deviceIdentification"))
                        object.deviceIdentification = $root.rv.data.CollectionElementType.toObject(message.deviceIdentification, options);
                    if (message.format != null && message.hasOwnProperty("format"))
                        object.format = message.format;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.commands && message.commands.length) {
                        object.commands = [];
                        for (let j = 0; j < message.commands.length; ++j)
                            object.commands[j] = $root.rv.data.Action.CommunicationType.Command.toObject(message.commands[j], options);
                    }
                    if (message.midiCommand != null && message.hasOwnProperty("midiCommand")) {
                        object.midiCommand = $root.rv.data.Action.CommunicationType.MIDICommand.toObject(message.midiCommand, options);
                        if (options.oneofs)
                            object.CommandTypeData = "midiCommand";
                    }
                    if (message.globalCacheCommand != null && message.hasOwnProperty("globalCacheCommand")) {
                        object.globalCacheCommand = $root.rv.data.Action.CommunicationType.GlobalCacheCommand.toObject(message.globalCacheCommand, options);
                        if (options.oneofs)
                            object.CommandTypeData = "globalCacheCommand";
                    }
                    if (message.gvg100Command != null && message.hasOwnProperty("gvg100Command")) {
                        object.gvg100Command = $root.rv.data.Action.CommunicationType.GVG100Command.toObject(message.gvg100Command, options);
                        if (options.oneofs)
                            object.CommandTypeData = "gvg100Command";
                    }
                    if (message.sony_BVSCommand != null && message.hasOwnProperty("sony_BVSCommand")) {
                        object.sony_BVSCommand = $root.rv.data.Action.CommunicationType.SonyBVSCommand.toObject(message.sony_BVSCommand, options);
                        if (options.oneofs)
                            object.CommandTypeData = "sony_BVSCommand";
                    }
                    return object;
                };

                /**
                 * Converts this CommunicationType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.CommunicationType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommunicationType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for CommunicationType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.CommunicationType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                CommunicationType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.CommunicationType";
                };

                CommunicationType.Command = (function() {

                    /**
                     * Properties of a Command.
                     * @memberof rv.data.Action.CommunicationType
                     * @interface ICommand
                     * @property {string|null} [name] Command name
                     * @property {string|null} [value] Command value
                     * @property {rv.data.IIntRange|null} [replacementRange] Command replacementRange
                     * @property {Array.<string>|null} [possibleValues] Command possibleValues
                     */

                    /**
                     * Constructs a new Command.
                     * @memberof rv.data.Action.CommunicationType
                     * @classdesc Represents a Command.
                     * @implements ICommand
                     * @constructor
                     * @param {rv.data.Action.CommunicationType.ICommand=} [properties] Properties to set
                     */
                    function Command(properties) {
                        this.possibleValues = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Command name.
                     * @member {string} name
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @instance
                     */
                    Command.prototype.name = "";

                    /**
                     * Command value.
                     * @member {string} value
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @instance
                     */
                    Command.prototype.value = "";

                    /**
                     * Command replacementRange.
                     * @member {rv.data.IIntRange|null|undefined} replacementRange
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @instance
                     */
                    Command.prototype.replacementRange = null;

                    /**
                     * Command possibleValues.
                     * @member {Array.<string>} possibleValues
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @instance
                     */
                    Command.prototype.possibleValues = $util.emptyArray;

                    /**
                     * Creates a new Command instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @static
                     * @param {rv.data.Action.CommunicationType.ICommand=} [properties] Properties to set
                     * @returns {rv.data.Action.CommunicationType.Command} Command instance
                     */
                    Command.create = function create(properties) {
                        return new Command(properties);
                    };

                    /**
                     * Encodes the specified Command message. Does not implicitly {@link rv.data.Action.CommunicationType.Command.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @static
                     * @param {rv.data.Action.CommunicationType.ICommand} message Command message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Command.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                        if (message.replacementRange != null && Object.hasOwnProperty.call(message, "replacementRange"))
                            $root.rv.data.IntRange.encode(message.replacementRange, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.possibleValues != null && message.possibleValues.length)
                            for (let i = 0; i < message.possibleValues.length; ++i)
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.possibleValues[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified Command message, length delimited. Does not implicitly {@link rv.data.Action.CommunicationType.Command.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @static
                     * @param {rv.data.Action.CommunicationType.ICommand} message Command message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Command.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Command message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.CommunicationType.Command} Command
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Command.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.CommunicationType.Command();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.name = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.value = reader.string();
                                    break;
                                }
                            case 3: {
                                    message.replacementRange = $root.rv.data.IntRange.decode(reader, reader.uint32());
                                    break;
                                }
                            case 4: {
                                    if (!(message.possibleValues && message.possibleValues.length))
                                        message.possibleValues = [];
                                    message.possibleValues.push(reader.string());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Command message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.CommunicationType.Command} Command
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Command.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Command message.
                     * @function verify
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Command.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isString(message.value))
                                return "value: string expected";
                        if (message.replacementRange != null && message.hasOwnProperty("replacementRange")) {
                            let error = $root.rv.data.IntRange.verify(message.replacementRange);
                            if (error)
                                return "replacementRange." + error;
                        }
                        if (message.possibleValues != null && message.hasOwnProperty("possibleValues")) {
                            if (!Array.isArray(message.possibleValues))
                                return "possibleValues: array expected";
                            for (let i = 0; i < message.possibleValues.length; ++i)
                                if (!$util.isString(message.possibleValues[i]))
                                    return "possibleValues: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Command message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.CommunicationType.Command} Command
                     */
                    Command.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.CommunicationType.Command)
                            return object;
                        let message = new $root.rv.data.Action.CommunicationType.Command();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.value != null)
                            message.value = String(object.value);
                        if (object.replacementRange != null) {
                            if (typeof object.replacementRange !== "object")
                                throw TypeError(".rv.data.Action.CommunicationType.Command.replacementRange: object expected");
                            message.replacementRange = $root.rv.data.IntRange.fromObject(object.replacementRange);
                        }
                        if (object.possibleValues) {
                            if (!Array.isArray(object.possibleValues))
                                throw TypeError(".rv.data.Action.CommunicationType.Command.possibleValues: array expected");
                            message.possibleValues = [];
                            for (let i = 0; i < object.possibleValues.length; ++i)
                                message.possibleValues[i] = String(object.possibleValues[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Command message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @static
                     * @param {rv.data.Action.CommunicationType.Command} message Command
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Command.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.possibleValues = [];
                        if (options.defaults) {
                            object.name = "";
                            object.value = "";
                            object.replacementRange = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = message.value;
                        if (message.replacementRange != null && message.hasOwnProperty("replacementRange"))
                            object.replacementRange = $root.rv.data.IntRange.toObject(message.replacementRange, options);
                        if (message.possibleValues && message.possibleValues.length) {
                            object.possibleValues = [];
                            for (let j = 0; j < message.possibleValues.length; ++j)
                                object.possibleValues[j] = message.possibleValues[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this Command to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Command.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Command
                     * @function getTypeUrl
                     * @memberof rv.data.Action.CommunicationType.Command
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Command.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.CommunicationType.Command";
                    };

                    return Command;
                })();

                CommunicationType.MIDICommand = (function() {

                    /**
                     * Properties of a MIDICommand.
                     * @memberof rv.data.Action.CommunicationType
                     * @interface IMIDICommand
                     * @property {rv.data.Action.CommunicationType.MIDICommand.State|null} [state] MIDICommand state
                     * @property {number|null} [channel] MIDICommand channel
                     * @property {number|null} [note] MIDICommand note
                     * @property {number|null} [intensity] MIDICommand intensity
                     */

                    /**
                     * Constructs a new MIDICommand.
                     * @memberof rv.data.Action.CommunicationType
                     * @classdesc Represents a MIDICommand.
                     * @implements IMIDICommand
                     * @constructor
                     * @param {rv.data.Action.CommunicationType.IMIDICommand=} [properties] Properties to set
                     */
                    function MIDICommand(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MIDICommand state.
                     * @member {rv.data.Action.CommunicationType.MIDICommand.State} state
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @instance
                     */
                    MIDICommand.prototype.state = 0;

                    /**
                     * MIDICommand channel.
                     * @member {number} channel
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @instance
                     */
                    MIDICommand.prototype.channel = 0;

                    /**
                     * MIDICommand note.
                     * @member {number} note
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @instance
                     */
                    MIDICommand.prototype.note = 0;

                    /**
                     * MIDICommand intensity.
                     * @member {number} intensity
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @instance
                     */
                    MIDICommand.prototype.intensity = 0;

                    /**
                     * Creates a new MIDICommand instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @static
                     * @param {rv.data.Action.CommunicationType.IMIDICommand=} [properties] Properties to set
                     * @returns {rv.data.Action.CommunicationType.MIDICommand} MIDICommand instance
                     */
                    MIDICommand.create = function create(properties) {
                        return new MIDICommand(properties);
                    };

                    /**
                     * Encodes the specified MIDICommand message. Does not implicitly {@link rv.data.Action.CommunicationType.MIDICommand.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @static
                     * @param {rv.data.Action.CommunicationType.IMIDICommand} message MIDICommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MIDICommand.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                        if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.channel);
                        if (message.note != null && Object.hasOwnProperty.call(message, "note"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.note);
                        if (message.intensity != null && Object.hasOwnProperty.call(message, "intensity"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.intensity);
                        return writer;
                    };

                    /**
                     * Encodes the specified MIDICommand message, length delimited. Does not implicitly {@link rv.data.Action.CommunicationType.MIDICommand.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @static
                     * @param {rv.data.Action.CommunicationType.IMIDICommand} message MIDICommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MIDICommand.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MIDICommand message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.CommunicationType.MIDICommand} MIDICommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MIDICommand.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.CommunicationType.MIDICommand();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.state = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.channel = reader.uint32();
                                    break;
                                }
                            case 3: {
                                    message.note = reader.uint32();
                                    break;
                                }
                            case 4: {
                                    message.intensity = reader.uint32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a MIDICommand message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.CommunicationType.MIDICommand} MIDICommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MIDICommand.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MIDICommand message.
                     * @function verify
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MIDICommand.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.state != null && message.hasOwnProperty("state"))
                            switch (message.state) {
                            default:
                                return "state: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        if (message.channel != null && message.hasOwnProperty("channel"))
                            if (!$util.isInteger(message.channel))
                                return "channel: integer expected";
                        if (message.note != null && message.hasOwnProperty("note"))
                            if (!$util.isInteger(message.note))
                                return "note: integer expected";
                        if (message.intensity != null && message.hasOwnProperty("intensity"))
                            if (!$util.isInteger(message.intensity))
                                return "intensity: integer expected";
                        return null;
                    };

                    /**
                     * Creates a MIDICommand message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.CommunicationType.MIDICommand} MIDICommand
                     */
                    MIDICommand.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.CommunicationType.MIDICommand)
                            return object;
                        let message = new $root.rv.data.Action.CommunicationType.MIDICommand();
                        switch (object.state) {
                        default:
                            if (typeof object.state === "number") {
                                message.state = object.state;
                                break;
                            }
                            break;
                        case "STATE_ON":
                        case 0:
                            message.state = 0;
                            break;
                        case "STATE_OFF":
                        case 1:
                            message.state = 1;
                            break;
                        }
                        if (object.channel != null)
                            message.channel = object.channel >>> 0;
                        if (object.note != null)
                            message.note = object.note >>> 0;
                        if (object.intensity != null)
                            message.intensity = object.intensity >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a MIDICommand message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @static
                     * @param {rv.data.Action.CommunicationType.MIDICommand} message MIDICommand
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MIDICommand.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.state = options.enums === String ? "STATE_ON" : 0;
                            object.channel = 0;
                            object.note = 0;
                            object.intensity = 0;
                        }
                        if (message.state != null && message.hasOwnProperty("state"))
                            object.state = options.enums === String ? $root.rv.data.Action.CommunicationType.MIDICommand.State[message.state] === undefined ? message.state : $root.rv.data.Action.CommunicationType.MIDICommand.State[message.state] : message.state;
                        if (message.channel != null && message.hasOwnProperty("channel"))
                            object.channel = message.channel;
                        if (message.note != null && message.hasOwnProperty("note"))
                            object.note = message.note;
                        if (message.intensity != null && message.hasOwnProperty("intensity"))
                            object.intensity = message.intensity;
                        return object;
                    };

                    /**
                     * Converts this MIDICommand to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MIDICommand.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for MIDICommand
                     * @function getTypeUrl
                     * @memberof rv.data.Action.CommunicationType.MIDICommand
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    MIDICommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.CommunicationType.MIDICommand";
                    };

                    /**
                     * State enum.
                     * @name rv.data.Action.CommunicationType.MIDICommand.State
                     * @enum {number}
                     * @property {number} STATE_ON=0 STATE_ON value
                     * @property {number} STATE_OFF=1 STATE_OFF value
                     */
                    MIDICommand.State = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "STATE_ON"] = 0;
                        values[valuesById[1] = "STATE_OFF"] = 1;
                        return values;
                    })();

                    return MIDICommand;
                })();

                CommunicationType.GlobalCacheCommand = (function() {

                    /**
                     * Properties of a GlobalCacheCommand.
                     * @memberof rv.data.Action.CommunicationType
                     * @interface IGlobalCacheCommand
                     * @property {rv.data.Action.CommunicationType.GlobalCacheCommand.CommandAction|null} [commandAction] GlobalCacheCommand commandAction
                     * @property {number|null} [output] GlobalCacheCommand output
                     * @property {number|null} [interval] GlobalCacheCommand interval
                     */

                    /**
                     * Constructs a new GlobalCacheCommand.
                     * @memberof rv.data.Action.CommunicationType
                     * @classdesc Represents a GlobalCacheCommand.
                     * @implements IGlobalCacheCommand
                     * @constructor
                     * @param {rv.data.Action.CommunicationType.IGlobalCacheCommand=} [properties] Properties to set
                     */
                    function GlobalCacheCommand(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GlobalCacheCommand commandAction.
                     * @member {rv.data.Action.CommunicationType.GlobalCacheCommand.CommandAction} commandAction
                     * @memberof rv.data.Action.CommunicationType.GlobalCacheCommand
                     * @instance
                     */
                    GlobalCacheCommand.prototype.commandAction = 0;

                    /**
                     * GlobalCacheCommand output.
                     * @member {number} output
                     * @memberof rv.data.Action.CommunicationType.GlobalCacheCommand
                     * @instance
                     */
                    GlobalCacheCommand.prototype.output = 0;

                    /**
                     * GlobalCacheCommand interval.
                     * @member {number} interval
                     * @memberof rv.data.Action.CommunicationType.GlobalCacheCommand
                     * @instance
                     */
                    GlobalCacheCommand.prototype.interval = 0;

                    /**
                     * Creates a new GlobalCacheCommand instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.CommunicationType.GlobalCacheCommand
                     * @static
                     * @param {rv.data.Action.CommunicationType.IGlobalCacheCommand=} [properties] Properties to set
                     * @returns {rv.data.Action.CommunicationType.GlobalCacheCommand} GlobalCacheCommand instance
                     */
                    GlobalCacheCommand.create = function create(properties) {
                        return new GlobalCacheCommand(properties);
                    };

                    /**
                     * Encodes the specified GlobalCacheCommand message. Does not implicitly {@link rv.data.Action.CommunicationType.GlobalCacheCommand.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.CommunicationType.GlobalCacheCommand
                     * @static
                     * @param {rv.data.Action.CommunicationType.IGlobalCacheCommand} message GlobalCacheCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GlobalCacheCommand.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.commandAction != null && Object.hasOwnProperty.call(message, "commandAction"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.commandAction);
                        if (message.output != null && Object.hasOwnProperty.call(message, "output"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.output);
                        if (message.interval != null && Object.hasOwnProperty.call(message, "interval"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.interval);
                        return writer;
                    };

                    /**
                     * Encodes the specified GlobalCacheCommand message, length delimited. Does not implicitly {@link rv.data.Action.CommunicationType.GlobalCacheCommand.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.CommunicationType.GlobalCacheCommand
                     * @static
                     * @param {rv.data.Action.CommunicationType.IGlobalCacheCommand} message GlobalCacheCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GlobalCacheCommand.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GlobalCacheCommand message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.CommunicationType.GlobalCacheCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.CommunicationType.GlobalCacheCommand} GlobalCacheCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GlobalCacheCommand.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.CommunicationType.GlobalCacheCommand();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.commandAction = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.output = reader.uint32();
                                    break;
                                }
                            case 3: {
                                    message.interval = reader.uint32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GlobalCacheCommand message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.CommunicationType.GlobalCacheCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.CommunicationType.GlobalCacheCommand} GlobalCacheCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GlobalCacheCommand.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GlobalCacheCommand message.
                     * @function verify
                     * @memberof rv.data.Action.CommunicationType.GlobalCacheCommand
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GlobalCacheCommand.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.commandAction != null && message.hasOwnProperty("commandAction"))
                            switch (message.commandAction) {
                            default:
                                return "commandAction: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.output != null && message.hasOwnProperty("output"))
                            if (!$util.isInteger(message.output))
                                return "output: integer expected";
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            if (!$util.isInteger(message.interval))
                                return "interval: integer expected";
                        return null;
                    };

                    /**
                     * Creates a GlobalCacheCommand message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.CommunicationType.GlobalCacheCommand
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.CommunicationType.GlobalCacheCommand} GlobalCacheCommand
                     */
                    GlobalCacheCommand.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.CommunicationType.GlobalCacheCommand)
                            return object;
                        let message = new $root.rv.data.Action.CommunicationType.GlobalCacheCommand();
                        switch (object.commandAction) {
                        default:
                            if (typeof object.commandAction === "number") {
                                message.commandAction = object.commandAction;
                                break;
                            }
                            break;
                        case "COMMAND_ACTION_ON":
                        case 0:
                            message.commandAction = 0;
                            break;
                        case "COMMAND_ACTION_OFF":
                        case 1:
                            message.commandAction = 1;
                            break;
                        case "COMMAND_ACTION_ON_OFF_WITH_INTERVAL":
                        case 2:
                            message.commandAction = 2;
                            break;
                        case "COMMAND_ACTION_OFF_ON_WITH_INTERVAL":
                        case 3:
                            message.commandAction = 3;
                            break;
                        }
                        if (object.output != null)
                            message.output = object.output >>> 0;
                        if (object.interval != null)
                            message.interval = object.interval >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a GlobalCacheCommand message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.CommunicationType.GlobalCacheCommand
                     * @static
                     * @param {rv.data.Action.CommunicationType.GlobalCacheCommand} message GlobalCacheCommand
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GlobalCacheCommand.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.commandAction = options.enums === String ? "COMMAND_ACTION_ON" : 0;
                            object.output = 0;
                            object.interval = 0;
                        }
                        if (message.commandAction != null && message.hasOwnProperty("commandAction"))
                            object.commandAction = options.enums === String ? $root.rv.data.Action.CommunicationType.GlobalCacheCommand.CommandAction[message.commandAction] === undefined ? message.commandAction : $root.rv.data.Action.CommunicationType.GlobalCacheCommand.CommandAction[message.commandAction] : message.commandAction;
                        if (message.output != null && message.hasOwnProperty("output"))
                            object.output = message.output;
                        if (message.interval != null && message.hasOwnProperty("interval"))
                            object.interval = message.interval;
                        return object;
                    };

                    /**
                     * Converts this GlobalCacheCommand to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.CommunicationType.GlobalCacheCommand
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GlobalCacheCommand.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for GlobalCacheCommand
                     * @function getTypeUrl
                     * @memberof rv.data.Action.CommunicationType.GlobalCacheCommand
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    GlobalCacheCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.CommunicationType.GlobalCacheCommand";
                    };

                    /**
                     * CommandAction enum.
                     * @name rv.data.Action.CommunicationType.GlobalCacheCommand.CommandAction
                     * @enum {number}
                     * @property {number} COMMAND_ACTION_ON=0 COMMAND_ACTION_ON value
                     * @property {number} COMMAND_ACTION_OFF=1 COMMAND_ACTION_OFF value
                     * @property {number} COMMAND_ACTION_ON_OFF_WITH_INTERVAL=2 COMMAND_ACTION_ON_OFF_WITH_INTERVAL value
                     * @property {number} COMMAND_ACTION_OFF_ON_WITH_INTERVAL=3 COMMAND_ACTION_OFF_ON_WITH_INTERVAL value
                     */
                    GlobalCacheCommand.CommandAction = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "COMMAND_ACTION_ON"] = 0;
                        values[valuesById[1] = "COMMAND_ACTION_OFF"] = 1;
                        values[valuesById[2] = "COMMAND_ACTION_ON_OFF_WITH_INTERVAL"] = 2;
                        values[valuesById[3] = "COMMAND_ACTION_OFF_ON_WITH_INTERVAL"] = 3;
                        return values;
                    })();

                    return GlobalCacheCommand;
                })();

                CommunicationType.GVG100Command = (function() {

                    /**
                     * Properties of a GVG100Command.
                     * @memberof rv.data.Action.CommunicationType
                     * @interface IGVG100Command
                     * @property {rv.data.Action.CommunicationType.GVG100Command.CommandAction|null} [commandAction] GVG100Command commandAction
                     */

                    /**
                     * Constructs a new GVG100Command.
                     * @memberof rv.data.Action.CommunicationType
                     * @classdesc Represents a GVG100Command.
                     * @implements IGVG100Command
                     * @constructor
                     * @param {rv.data.Action.CommunicationType.IGVG100Command=} [properties] Properties to set
                     */
                    function GVG100Command(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GVG100Command commandAction.
                     * @member {rv.data.Action.CommunicationType.GVG100Command.CommandAction} commandAction
                     * @memberof rv.data.Action.CommunicationType.GVG100Command
                     * @instance
                     */
                    GVG100Command.prototype.commandAction = 0;

                    /**
                     * Creates a new GVG100Command instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.CommunicationType.GVG100Command
                     * @static
                     * @param {rv.data.Action.CommunicationType.IGVG100Command=} [properties] Properties to set
                     * @returns {rv.data.Action.CommunicationType.GVG100Command} GVG100Command instance
                     */
                    GVG100Command.create = function create(properties) {
                        return new GVG100Command(properties);
                    };

                    /**
                     * Encodes the specified GVG100Command message. Does not implicitly {@link rv.data.Action.CommunicationType.GVG100Command.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.CommunicationType.GVG100Command
                     * @static
                     * @param {rv.data.Action.CommunicationType.IGVG100Command} message GVG100Command message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GVG100Command.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.commandAction != null && Object.hasOwnProperty.call(message, "commandAction"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.commandAction);
                        return writer;
                    };

                    /**
                     * Encodes the specified GVG100Command message, length delimited. Does not implicitly {@link rv.data.Action.CommunicationType.GVG100Command.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.CommunicationType.GVG100Command
                     * @static
                     * @param {rv.data.Action.CommunicationType.IGVG100Command} message GVG100Command message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GVG100Command.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GVG100Command message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.CommunicationType.GVG100Command
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.CommunicationType.GVG100Command} GVG100Command
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GVG100Command.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.CommunicationType.GVG100Command();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.commandAction = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GVG100Command message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.CommunicationType.GVG100Command
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.CommunicationType.GVG100Command} GVG100Command
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GVG100Command.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GVG100Command message.
                     * @function verify
                     * @memberof rv.data.Action.CommunicationType.GVG100Command
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GVG100Command.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.commandAction != null && message.hasOwnProperty("commandAction"))
                            switch (message.commandAction) {
                            default:
                                return "commandAction: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a GVG100Command message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.CommunicationType.GVG100Command
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.CommunicationType.GVG100Command} GVG100Command
                     */
                    GVG100Command.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.CommunicationType.GVG100Command)
                            return object;
                        let message = new $root.rv.data.Action.CommunicationType.GVG100Command();
                        switch (object.commandAction) {
                        default:
                            if (typeof object.commandAction === "number") {
                                message.commandAction = object.commandAction;
                                break;
                            }
                            break;
                        case "COMMAND_ACTION_FADE_TO_BLACK":
                        case 0:
                            message.commandAction = 0;
                            break;
                        case "COMMAND_ACTION_DSK_TOGGLE":
                        case 1:
                            message.commandAction = 1;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GVG100Command message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.CommunicationType.GVG100Command
                     * @static
                     * @param {rv.data.Action.CommunicationType.GVG100Command} message GVG100Command
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GVG100Command.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.commandAction = options.enums === String ? "COMMAND_ACTION_FADE_TO_BLACK" : 0;
                        if (message.commandAction != null && message.hasOwnProperty("commandAction"))
                            object.commandAction = options.enums === String ? $root.rv.data.Action.CommunicationType.GVG100Command.CommandAction[message.commandAction] === undefined ? message.commandAction : $root.rv.data.Action.CommunicationType.GVG100Command.CommandAction[message.commandAction] : message.commandAction;
                        return object;
                    };

                    /**
                     * Converts this GVG100Command to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.CommunicationType.GVG100Command
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GVG100Command.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for GVG100Command
                     * @function getTypeUrl
                     * @memberof rv.data.Action.CommunicationType.GVG100Command
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    GVG100Command.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.CommunicationType.GVG100Command";
                    };

                    /**
                     * CommandAction enum.
                     * @name rv.data.Action.CommunicationType.GVG100Command.CommandAction
                     * @enum {number}
                     * @property {number} COMMAND_ACTION_FADE_TO_BLACK=0 COMMAND_ACTION_FADE_TO_BLACK value
                     * @property {number} COMMAND_ACTION_DSK_TOGGLE=1 COMMAND_ACTION_DSK_TOGGLE value
                     */
                    GVG100Command.CommandAction = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "COMMAND_ACTION_FADE_TO_BLACK"] = 0;
                        values[valuesById[1] = "COMMAND_ACTION_DSK_TOGGLE"] = 1;
                        return values;
                    })();

                    return GVG100Command;
                })();

                CommunicationType.SonyBVSCommand = (function() {

                    /**
                     * Properties of a SonyBVSCommand.
                     * @memberof rv.data.Action.CommunicationType
                     * @interface ISonyBVSCommand
                     * @property {rv.data.Action.CommunicationType.SonyBVSCommand.CommandAction|null} [commandAction] SonyBVSCommand commandAction
                     */

                    /**
                     * Constructs a new SonyBVSCommand.
                     * @memberof rv.data.Action.CommunicationType
                     * @classdesc Represents a SonyBVSCommand.
                     * @implements ISonyBVSCommand
                     * @constructor
                     * @param {rv.data.Action.CommunicationType.ISonyBVSCommand=} [properties] Properties to set
                     */
                    function SonyBVSCommand(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SonyBVSCommand commandAction.
                     * @member {rv.data.Action.CommunicationType.SonyBVSCommand.CommandAction} commandAction
                     * @memberof rv.data.Action.CommunicationType.SonyBVSCommand
                     * @instance
                     */
                    SonyBVSCommand.prototype.commandAction = 0;

                    /**
                     * Creates a new SonyBVSCommand instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.CommunicationType.SonyBVSCommand
                     * @static
                     * @param {rv.data.Action.CommunicationType.ISonyBVSCommand=} [properties] Properties to set
                     * @returns {rv.data.Action.CommunicationType.SonyBVSCommand} SonyBVSCommand instance
                     */
                    SonyBVSCommand.create = function create(properties) {
                        return new SonyBVSCommand(properties);
                    };

                    /**
                     * Encodes the specified SonyBVSCommand message. Does not implicitly {@link rv.data.Action.CommunicationType.SonyBVSCommand.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.CommunicationType.SonyBVSCommand
                     * @static
                     * @param {rv.data.Action.CommunicationType.ISonyBVSCommand} message SonyBVSCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SonyBVSCommand.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.commandAction != null && Object.hasOwnProperty.call(message, "commandAction"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.commandAction);
                        return writer;
                    };

                    /**
                     * Encodes the specified SonyBVSCommand message, length delimited. Does not implicitly {@link rv.data.Action.CommunicationType.SonyBVSCommand.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.CommunicationType.SonyBVSCommand
                     * @static
                     * @param {rv.data.Action.CommunicationType.ISonyBVSCommand} message SonyBVSCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SonyBVSCommand.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a SonyBVSCommand message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.CommunicationType.SonyBVSCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.CommunicationType.SonyBVSCommand} SonyBVSCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SonyBVSCommand.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.CommunicationType.SonyBVSCommand();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.commandAction = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a SonyBVSCommand message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.CommunicationType.SonyBVSCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.CommunicationType.SonyBVSCommand} SonyBVSCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SonyBVSCommand.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a SonyBVSCommand message.
                     * @function verify
                     * @memberof rv.data.Action.CommunicationType.SonyBVSCommand
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SonyBVSCommand.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.commandAction != null && message.hasOwnProperty("commandAction"))
                            switch (message.commandAction) {
                            default:
                                return "commandAction: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a SonyBVSCommand message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.CommunicationType.SonyBVSCommand
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.CommunicationType.SonyBVSCommand} SonyBVSCommand
                     */
                    SonyBVSCommand.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.CommunicationType.SonyBVSCommand)
                            return object;
                        let message = new $root.rv.data.Action.CommunicationType.SonyBVSCommand();
                        switch (object.commandAction) {
                        default:
                            if (typeof object.commandAction === "number") {
                                message.commandAction = object.commandAction;
                                break;
                            }
                            break;
                        case "COMMAND_ACTION_FADE_TO_BLACK":
                        case 0:
                            message.commandAction = 0;
                            break;
                        case "COMMAND_ACTION_KEY_ON":
                        case 1:
                            message.commandAction = 1;
                            break;
                        case "COMMAND_ACTION_KEY_OFF":
                        case 2:
                            message.commandAction = 2;
                            break;
                        case "COMMAND_ACTION_DSK_ON":
                        case 3:
                            message.commandAction = 3;
                            break;
                        case "COMMAND_ACTION_DSK_OFF":
                        case 4:
                            message.commandAction = 4;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a SonyBVSCommand message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.CommunicationType.SonyBVSCommand
                     * @static
                     * @param {rv.data.Action.CommunicationType.SonyBVSCommand} message SonyBVSCommand
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SonyBVSCommand.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.commandAction = options.enums === String ? "COMMAND_ACTION_FADE_TO_BLACK" : 0;
                        if (message.commandAction != null && message.hasOwnProperty("commandAction"))
                            object.commandAction = options.enums === String ? $root.rv.data.Action.CommunicationType.SonyBVSCommand.CommandAction[message.commandAction] === undefined ? message.commandAction : $root.rv.data.Action.CommunicationType.SonyBVSCommand.CommandAction[message.commandAction] : message.commandAction;
                        return object;
                    };

                    /**
                     * Converts this SonyBVSCommand to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.CommunicationType.SonyBVSCommand
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SonyBVSCommand.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for SonyBVSCommand
                     * @function getTypeUrl
                     * @memberof rv.data.Action.CommunicationType.SonyBVSCommand
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    SonyBVSCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.CommunicationType.SonyBVSCommand";
                    };

                    /**
                     * CommandAction enum.
                     * @name rv.data.Action.CommunicationType.SonyBVSCommand.CommandAction
                     * @enum {number}
                     * @property {number} COMMAND_ACTION_FADE_TO_BLACK=0 COMMAND_ACTION_FADE_TO_BLACK value
                     * @property {number} COMMAND_ACTION_KEY_ON=1 COMMAND_ACTION_KEY_ON value
                     * @property {number} COMMAND_ACTION_KEY_OFF=2 COMMAND_ACTION_KEY_OFF value
                     * @property {number} COMMAND_ACTION_DSK_ON=3 COMMAND_ACTION_DSK_ON value
                     * @property {number} COMMAND_ACTION_DSK_OFF=4 COMMAND_ACTION_DSK_OFF value
                     */
                    SonyBVSCommand.CommandAction = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "COMMAND_ACTION_FADE_TO_BLACK"] = 0;
                        values[valuesById[1] = "COMMAND_ACTION_KEY_ON"] = 1;
                        values[valuesById[2] = "COMMAND_ACTION_KEY_OFF"] = 2;
                        values[valuesById[3] = "COMMAND_ACTION_DSK_ON"] = 3;
                        values[valuesById[4] = "COMMAND_ACTION_DSK_OFF"] = 4;
                        return values;
                    })();

                    return SonyBVSCommand;
                })();

                return CommunicationType;
            })();

            Action.MultiScreenType = (function() {

                /**
                 * Properties of a MultiScreenType.
                 * @memberof rv.data.Action
                 * @interface IMultiScreenType
                 * @property {rv.data.ICollectionElementType|null} [identification] MultiScreenType identification
                 */

                /**
                 * Constructs a new MultiScreenType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a MultiScreenType.
                 * @implements IMultiScreenType
                 * @constructor
                 * @param {rv.data.Action.IMultiScreenType=} [properties] Properties to set
                 */
                function MultiScreenType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MultiScreenType identification.
                 * @member {rv.data.ICollectionElementType|null|undefined} identification
                 * @memberof rv.data.Action.MultiScreenType
                 * @instance
                 */
                MultiScreenType.prototype.identification = null;

                /**
                 * Creates a new MultiScreenType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.MultiScreenType
                 * @static
                 * @param {rv.data.Action.IMultiScreenType=} [properties] Properties to set
                 * @returns {rv.data.Action.MultiScreenType} MultiScreenType instance
                 */
                MultiScreenType.create = function create(properties) {
                    return new MultiScreenType(properties);
                };

                /**
                 * Encodes the specified MultiScreenType message. Does not implicitly {@link rv.data.Action.MultiScreenType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.MultiScreenType
                 * @static
                 * @param {rv.data.Action.IMultiScreenType} message MultiScreenType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MultiScreenType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.identification != null && Object.hasOwnProperty.call(message, "identification"))
                        $root.rv.data.CollectionElementType.encode(message.identification, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MultiScreenType message, length delimited. Does not implicitly {@link rv.data.Action.MultiScreenType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.MultiScreenType
                 * @static
                 * @param {rv.data.Action.IMultiScreenType} message MultiScreenType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MultiScreenType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MultiScreenType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.MultiScreenType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.MultiScreenType} MultiScreenType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MultiScreenType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.MultiScreenType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 3: {
                                message.identification = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MultiScreenType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.MultiScreenType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.MultiScreenType} MultiScreenType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MultiScreenType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MultiScreenType message.
                 * @function verify
                 * @memberof rv.data.Action.MultiScreenType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MultiScreenType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.identification != null && message.hasOwnProperty("identification")) {
                        let error = $root.rv.data.CollectionElementType.verify(message.identification);
                        if (error)
                            return "identification." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MultiScreenType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.MultiScreenType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.MultiScreenType} MultiScreenType
                 */
                MultiScreenType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.MultiScreenType)
                        return object;
                    let message = new $root.rv.data.Action.MultiScreenType();
                    if (object.identification != null) {
                        if (typeof object.identification !== "object")
                            throw TypeError(".rv.data.Action.MultiScreenType.identification: object expected");
                        message.identification = $root.rv.data.CollectionElementType.fromObject(object.identification);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MultiScreenType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.MultiScreenType
                 * @static
                 * @param {rv.data.Action.MultiScreenType} message MultiScreenType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MultiScreenType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.identification = null;
                    if (message.identification != null && message.hasOwnProperty("identification"))
                        object.identification = $root.rv.data.CollectionElementType.toObject(message.identification, options);
                    return object;
                };

                /**
                 * Converts this MultiScreenType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.MultiScreenType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MultiScreenType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MultiScreenType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.MultiScreenType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MultiScreenType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.MultiScreenType";
                };

                return MultiScreenType;
            })();

            Action.DocumentType = (function() {

                /**
                 * Properties of a DocumentType.
                 * @memberof rv.data.Action
                 * @interface IDocumentType
                 * @property {rv.data.ICollectionElementType|null} [identification] DocumentType identification
                 * @property {rv.data.IUUID|null} [selectedArrangement] DocumentType selectedArrangement
                 * @property {rv.data.Action.ContentDestination|null} [contentDestination] DocumentType contentDestination
                 */

                /**
                 * Constructs a new DocumentType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a DocumentType.
                 * @implements IDocumentType
                 * @constructor
                 * @param {rv.data.Action.IDocumentType=} [properties] Properties to set
                 */
                function DocumentType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DocumentType identification.
                 * @member {rv.data.ICollectionElementType|null|undefined} identification
                 * @memberof rv.data.Action.DocumentType
                 * @instance
                 */
                DocumentType.prototype.identification = null;

                /**
                 * DocumentType selectedArrangement.
                 * @member {rv.data.IUUID|null|undefined} selectedArrangement
                 * @memberof rv.data.Action.DocumentType
                 * @instance
                 */
                DocumentType.prototype.selectedArrangement = null;

                /**
                 * DocumentType contentDestination.
                 * @member {rv.data.Action.ContentDestination} contentDestination
                 * @memberof rv.data.Action.DocumentType
                 * @instance
                 */
                DocumentType.prototype.contentDestination = 0;

                /**
                 * Creates a new DocumentType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.DocumentType
                 * @static
                 * @param {rv.data.Action.IDocumentType=} [properties] Properties to set
                 * @returns {rv.data.Action.DocumentType} DocumentType instance
                 */
                DocumentType.create = function create(properties) {
                    return new DocumentType(properties);
                };

                /**
                 * Encodes the specified DocumentType message. Does not implicitly {@link rv.data.Action.DocumentType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.DocumentType
                 * @static
                 * @param {rv.data.Action.IDocumentType} message DocumentType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DocumentType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.identification != null && Object.hasOwnProperty.call(message, "identification"))
                        $root.rv.data.CollectionElementType.encode(message.identification, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.selectedArrangement != null && Object.hasOwnProperty.call(message, "selectedArrangement"))
                        $root.rv.data.UUID.encode(message.selectedArrangement, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.contentDestination != null && Object.hasOwnProperty.call(message, "contentDestination"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.contentDestination);
                    return writer;
                };

                /**
                 * Encodes the specified DocumentType message, length delimited. Does not implicitly {@link rv.data.Action.DocumentType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.DocumentType
                 * @static
                 * @param {rv.data.Action.IDocumentType} message DocumentType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DocumentType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DocumentType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.DocumentType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.DocumentType} DocumentType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DocumentType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.DocumentType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.identification = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.selectedArrangement = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.contentDestination = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DocumentType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.DocumentType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.DocumentType} DocumentType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DocumentType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DocumentType message.
                 * @function verify
                 * @memberof rv.data.Action.DocumentType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DocumentType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.identification != null && message.hasOwnProperty("identification")) {
                        let error = $root.rv.data.CollectionElementType.verify(message.identification);
                        if (error)
                            return "identification." + error;
                    }
                    if (message.selectedArrangement != null && message.hasOwnProperty("selectedArrangement")) {
                        let error = $root.rv.data.UUID.verify(message.selectedArrangement);
                        if (error)
                            return "selectedArrangement." + error;
                    }
                    if (message.contentDestination != null && message.hasOwnProperty("contentDestination"))
                        switch (message.contentDestination) {
                        default:
                            return "contentDestination: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a DocumentType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.DocumentType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.DocumentType} DocumentType
                 */
                DocumentType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.DocumentType)
                        return object;
                    let message = new $root.rv.data.Action.DocumentType();
                    if (object.identification != null) {
                        if (typeof object.identification !== "object")
                            throw TypeError(".rv.data.Action.DocumentType.identification: object expected");
                        message.identification = $root.rv.data.CollectionElementType.fromObject(object.identification);
                    }
                    if (object.selectedArrangement != null) {
                        if (typeof object.selectedArrangement !== "object")
                            throw TypeError(".rv.data.Action.DocumentType.selectedArrangement: object expected");
                        message.selectedArrangement = $root.rv.data.UUID.fromObject(object.selectedArrangement);
                    }
                    switch (object.contentDestination) {
                    default:
                        if (typeof object.contentDestination === "number") {
                            message.contentDestination = object.contentDestination;
                            break;
                        }
                        break;
                    case "CONTENT_DESTINATION_GLOBAL":
                    case 0:
                        message.contentDestination = 0;
                        break;
                    case "CONTENT_DESTINATION_ANNOUNCEMENTS":
                    case 1:
                        message.contentDestination = 1;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DocumentType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.DocumentType
                 * @static
                 * @param {rv.data.Action.DocumentType} message DocumentType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DocumentType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.identification = null;
                        object.selectedArrangement = null;
                        object.contentDestination = options.enums === String ? "CONTENT_DESTINATION_GLOBAL" : 0;
                    }
                    if (message.identification != null && message.hasOwnProperty("identification"))
                        object.identification = $root.rv.data.CollectionElementType.toObject(message.identification, options);
                    if (message.selectedArrangement != null && message.hasOwnProperty("selectedArrangement"))
                        object.selectedArrangement = $root.rv.data.UUID.toObject(message.selectedArrangement, options);
                    if (message.contentDestination != null && message.hasOwnProperty("contentDestination"))
                        object.contentDestination = options.enums === String ? $root.rv.data.Action.ContentDestination[message.contentDestination] === undefined ? message.contentDestination : $root.rv.data.Action.ContentDestination[message.contentDestination] : message.contentDestination;
                    return object;
                };

                /**
                 * Converts this DocumentType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.DocumentType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DocumentType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for DocumentType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.DocumentType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                DocumentType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.DocumentType";
                };

                return DocumentType;
            })();

            Action.ExternalPresentationType = (function() {

                /**
                 * Properties of an ExternalPresentationType.
                 * @memberof rv.data.Action
                 * @interface IExternalPresentationType
                 * @property {rv.data.IURL|null} [url] ExternalPresentationType url
                 */

                /**
                 * Constructs a new ExternalPresentationType.
                 * @memberof rv.data.Action
                 * @classdesc Represents an ExternalPresentationType.
                 * @implements IExternalPresentationType
                 * @constructor
                 * @param {rv.data.Action.IExternalPresentationType=} [properties] Properties to set
                 */
                function ExternalPresentationType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExternalPresentationType url.
                 * @member {rv.data.IURL|null|undefined} url
                 * @memberof rv.data.Action.ExternalPresentationType
                 * @instance
                 */
                ExternalPresentationType.prototype.url = null;

                /**
                 * Creates a new ExternalPresentationType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.ExternalPresentationType
                 * @static
                 * @param {rv.data.Action.IExternalPresentationType=} [properties] Properties to set
                 * @returns {rv.data.Action.ExternalPresentationType} ExternalPresentationType instance
                 */
                ExternalPresentationType.create = function create(properties) {
                    return new ExternalPresentationType(properties);
                };

                /**
                 * Encodes the specified ExternalPresentationType message. Does not implicitly {@link rv.data.Action.ExternalPresentationType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.ExternalPresentationType
                 * @static
                 * @param {rv.data.Action.IExternalPresentationType} message ExternalPresentationType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExternalPresentationType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                        $root.rv.data.URL.encode(message.url, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ExternalPresentationType message, length delimited. Does not implicitly {@link rv.data.Action.ExternalPresentationType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.ExternalPresentationType
                 * @static
                 * @param {rv.data.Action.IExternalPresentationType} message ExternalPresentationType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExternalPresentationType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExternalPresentationType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.ExternalPresentationType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.ExternalPresentationType} ExternalPresentationType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExternalPresentationType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.ExternalPresentationType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.url = $root.rv.data.URL.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExternalPresentationType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.ExternalPresentationType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.ExternalPresentationType} ExternalPresentationType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExternalPresentationType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExternalPresentationType message.
                 * @function verify
                 * @memberof rv.data.Action.ExternalPresentationType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExternalPresentationType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.url != null && message.hasOwnProperty("url")) {
                        let error = $root.rv.data.URL.verify(message.url);
                        if (error)
                            return "url." + error;
                    }
                    return null;
                };

                /**
                 * Creates an ExternalPresentationType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.ExternalPresentationType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.ExternalPresentationType} ExternalPresentationType
                 */
                ExternalPresentationType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.ExternalPresentationType)
                        return object;
                    let message = new $root.rv.data.Action.ExternalPresentationType();
                    if (object.url != null) {
                        if (typeof object.url !== "object")
                            throw TypeError(".rv.data.Action.ExternalPresentationType.url: object expected");
                        message.url = $root.rv.data.URL.fromObject(object.url);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ExternalPresentationType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.ExternalPresentationType
                 * @static
                 * @param {rv.data.Action.ExternalPresentationType} message ExternalPresentationType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExternalPresentationType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.url = null;
                    if (message.url != null && message.hasOwnProperty("url"))
                        object.url = $root.rv.data.URL.toObject(message.url, options);
                    return object;
                };

                /**
                 * Converts this ExternalPresentationType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.ExternalPresentationType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExternalPresentationType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ExternalPresentationType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.ExternalPresentationType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ExternalPresentationType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.ExternalPresentationType";
                };

                return ExternalPresentationType;
            })();

            Action.AudienceLookType = (function() {

                /**
                 * Properties of an AudienceLookType.
                 * @memberof rv.data.Action
                 * @interface IAudienceLookType
                 * @property {rv.data.ICollectionElementType|null} [identification] AudienceLookType identification
                 */

                /**
                 * Constructs a new AudienceLookType.
                 * @memberof rv.data.Action
                 * @classdesc Represents an AudienceLookType.
                 * @implements IAudienceLookType
                 * @constructor
                 * @param {rv.data.Action.IAudienceLookType=} [properties] Properties to set
                 */
                function AudienceLookType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AudienceLookType identification.
                 * @member {rv.data.ICollectionElementType|null|undefined} identification
                 * @memberof rv.data.Action.AudienceLookType
                 * @instance
                 */
                AudienceLookType.prototype.identification = null;

                /**
                 * Creates a new AudienceLookType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.AudienceLookType
                 * @static
                 * @param {rv.data.Action.IAudienceLookType=} [properties] Properties to set
                 * @returns {rv.data.Action.AudienceLookType} AudienceLookType instance
                 */
                AudienceLookType.create = function create(properties) {
                    return new AudienceLookType(properties);
                };

                /**
                 * Encodes the specified AudienceLookType message. Does not implicitly {@link rv.data.Action.AudienceLookType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.AudienceLookType
                 * @static
                 * @param {rv.data.Action.IAudienceLookType} message AudienceLookType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AudienceLookType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.identification != null && Object.hasOwnProperty.call(message, "identification"))
                        $root.rv.data.CollectionElementType.encode(message.identification, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified AudienceLookType message, length delimited. Does not implicitly {@link rv.data.Action.AudienceLookType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.AudienceLookType
                 * @static
                 * @param {rv.data.Action.IAudienceLookType} message AudienceLookType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AudienceLookType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AudienceLookType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.AudienceLookType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.AudienceLookType} AudienceLookType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AudienceLookType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.AudienceLookType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.identification = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AudienceLookType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.AudienceLookType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.AudienceLookType} AudienceLookType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AudienceLookType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AudienceLookType message.
                 * @function verify
                 * @memberof rv.data.Action.AudienceLookType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AudienceLookType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.identification != null && message.hasOwnProperty("identification")) {
                        let error = $root.rv.data.CollectionElementType.verify(message.identification);
                        if (error)
                            return "identification." + error;
                    }
                    return null;
                };

                /**
                 * Creates an AudienceLookType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.AudienceLookType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.AudienceLookType} AudienceLookType
                 */
                AudienceLookType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.AudienceLookType)
                        return object;
                    let message = new $root.rv.data.Action.AudienceLookType();
                    if (object.identification != null) {
                        if (typeof object.identification !== "object")
                            throw TypeError(".rv.data.Action.AudienceLookType.identification: object expected");
                        message.identification = $root.rv.data.CollectionElementType.fromObject(object.identification);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an AudienceLookType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.AudienceLookType
                 * @static
                 * @param {rv.data.Action.AudienceLookType} message AudienceLookType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AudienceLookType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.identification = null;
                    if (message.identification != null && message.hasOwnProperty("identification"))
                        object.identification = $root.rv.data.CollectionElementType.toObject(message.identification, options);
                    return object;
                };

                /**
                 * Converts this AudienceLookType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.AudienceLookType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AudienceLookType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for AudienceLookType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.AudienceLookType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                AudienceLookType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.AudienceLookType";
                };

                return AudienceLookType;
            })();

            Action.AudioInputType = (function() {

                /**
                 * Properties of an AudioInputType.
                 * @memberof rv.data.Action
                 * @interface IAudioInputType
                 * @property {number|null} [index] AudioInputType index
                 * @property {boolean|null} [overrideMode] AudioInputType overrideMode
                 * @property {rv.data.AudioInput.IBehaviorMode|null} [behaviorMode] AudioInputType behaviorMode
                 * @property {boolean|null} [overrideVolume] AudioInputType overrideVolume
                 * @property {number|null} [volume] AudioInputType volume
                 */

                /**
                 * Constructs a new AudioInputType.
                 * @memberof rv.data.Action
                 * @classdesc Represents an AudioInputType.
                 * @implements IAudioInputType
                 * @constructor
                 * @param {rv.data.Action.IAudioInputType=} [properties] Properties to set
                 */
                function AudioInputType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AudioInputType index.
                 * @member {number} index
                 * @memberof rv.data.Action.AudioInputType
                 * @instance
                 */
                AudioInputType.prototype.index = 0;

                /**
                 * AudioInputType overrideMode.
                 * @member {boolean} overrideMode
                 * @memberof rv.data.Action.AudioInputType
                 * @instance
                 */
                AudioInputType.prototype.overrideMode = false;

                /**
                 * AudioInputType behaviorMode.
                 * @member {rv.data.AudioInput.IBehaviorMode|null|undefined} behaviorMode
                 * @memberof rv.data.Action.AudioInputType
                 * @instance
                 */
                AudioInputType.prototype.behaviorMode = null;

                /**
                 * AudioInputType overrideVolume.
                 * @member {boolean} overrideVolume
                 * @memberof rv.data.Action.AudioInputType
                 * @instance
                 */
                AudioInputType.prototype.overrideVolume = false;

                /**
                 * AudioInputType volume.
                 * @member {number} volume
                 * @memberof rv.data.Action.AudioInputType
                 * @instance
                 */
                AudioInputType.prototype.volume = 0;

                /**
                 * Creates a new AudioInputType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.AudioInputType
                 * @static
                 * @param {rv.data.Action.IAudioInputType=} [properties] Properties to set
                 * @returns {rv.data.Action.AudioInputType} AudioInputType instance
                 */
                AudioInputType.create = function create(properties) {
                    return new AudioInputType(properties);
                };

                /**
                 * Encodes the specified AudioInputType message. Does not implicitly {@link rv.data.Action.AudioInputType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.AudioInputType
                 * @static
                 * @param {rv.data.Action.IAudioInputType} message AudioInputType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AudioInputType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                    if (message.overrideMode != null && Object.hasOwnProperty.call(message, "overrideMode"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.overrideMode);
                    if (message.behaviorMode != null && Object.hasOwnProperty.call(message, "behaviorMode"))
                        $root.rv.data.AudioInput.BehaviorMode.encode(message.behaviorMode, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.overrideVolume != null && Object.hasOwnProperty.call(message, "overrideVolume"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.overrideVolume);
                    if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.volume);
                    return writer;
                };

                /**
                 * Encodes the specified AudioInputType message, length delimited. Does not implicitly {@link rv.data.Action.AudioInputType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.AudioInputType
                 * @static
                 * @param {rv.data.Action.IAudioInputType} message AudioInputType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AudioInputType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AudioInputType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.AudioInputType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.AudioInputType} AudioInputType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AudioInputType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.AudioInputType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.index = reader.int32();
                                break;
                            }
                        case 2: {
                                message.overrideMode = reader.bool();
                                break;
                            }
                        case 3: {
                                message.behaviorMode = $root.rv.data.AudioInput.BehaviorMode.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.overrideVolume = reader.bool();
                                break;
                            }
                        case 5: {
                                message.volume = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AudioInputType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.AudioInputType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.AudioInputType} AudioInputType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AudioInputType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AudioInputType message.
                 * @function verify
                 * @memberof rv.data.Action.AudioInputType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AudioInputType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.index != null && message.hasOwnProperty("index"))
                        if (!$util.isInteger(message.index))
                            return "index: integer expected";
                    if (message.overrideMode != null && message.hasOwnProperty("overrideMode"))
                        if (typeof message.overrideMode !== "boolean")
                            return "overrideMode: boolean expected";
                    if (message.behaviorMode != null && message.hasOwnProperty("behaviorMode")) {
                        let error = $root.rv.data.AudioInput.BehaviorMode.verify(message.behaviorMode);
                        if (error)
                            return "behaviorMode." + error;
                    }
                    if (message.overrideVolume != null && message.hasOwnProperty("overrideVolume"))
                        if (typeof message.overrideVolume !== "boolean")
                            return "overrideVolume: boolean expected";
                    if (message.volume != null && message.hasOwnProperty("volume"))
                        if (typeof message.volume !== "number")
                            return "volume: number expected";
                    return null;
                };

                /**
                 * Creates an AudioInputType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.AudioInputType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.AudioInputType} AudioInputType
                 */
                AudioInputType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.AudioInputType)
                        return object;
                    let message = new $root.rv.data.Action.AudioInputType();
                    if (object.index != null)
                        message.index = object.index | 0;
                    if (object.overrideMode != null)
                        message.overrideMode = Boolean(object.overrideMode);
                    if (object.behaviorMode != null) {
                        if (typeof object.behaviorMode !== "object")
                            throw TypeError(".rv.data.Action.AudioInputType.behaviorMode: object expected");
                        message.behaviorMode = $root.rv.data.AudioInput.BehaviorMode.fromObject(object.behaviorMode);
                    }
                    if (object.overrideVolume != null)
                        message.overrideVolume = Boolean(object.overrideVolume);
                    if (object.volume != null)
                        message.volume = Number(object.volume);
                    return message;
                };

                /**
                 * Creates a plain object from an AudioInputType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.AudioInputType
                 * @static
                 * @param {rv.data.Action.AudioInputType} message AudioInputType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AudioInputType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.index = 0;
                        object.overrideMode = false;
                        object.behaviorMode = null;
                        object.overrideVolume = false;
                        object.volume = 0;
                    }
                    if (message.index != null && message.hasOwnProperty("index"))
                        object.index = message.index;
                    if (message.overrideMode != null && message.hasOwnProperty("overrideMode"))
                        object.overrideMode = message.overrideMode;
                    if (message.behaviorMode != null && message.hasOwnProperty("behaviorMode"))
                        object.behaviorMode = $root.rv.data.AudioInput.BehaviorMode.toObject(message.behaviorMode, options);
                    if (message.overrideVolume != null && message.hasOwnProperty("overrideVolume"))
                        object.overrideVolume = message.overrideVolume;
                    if (message.volume != null && message.hasOwnProperty("volume"))
                        object.volume = options.json && !isFinite(message.volume) ? String(message.volume) : message.volume;
                    return object;
                };

                /**
                 * Converts this AudioInputType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.AudioInputType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AudioInputType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for AudioInputType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.AudioInputType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                AudioInputType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.AudioInputType";
                };

                return AudioInputType;
            })();

            Action.MacroType = (function() {

                /**
                 * Properties of a MacroType.
                 * @memberof rv.data.Action
                 * @interface IMacroType
                 * @property {rv.data.ICollectionElementType|null} [identification] MacroType identification
                 */

                /**
                 * Constructs a new MacroType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a MacroType.
                 * @implements IMacroType
                 * @constructor
                 * @param {rv.data.Action.IMacroType=} [properties] Properties to set
                 */
                function MacroType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MacroType identification.
                 * @member {rv.data.ICollectionElementType|null|undefined} identification
                 * @memberof rv.data.Action.MacroType
                 * @instance
                 */
                MacroType.prototype.identification = null;

                /**
                 * Creates a new MacroType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.MacroType
                 * @static
                 * @param {rv.data.Action.IMacroType=} [properties] Properties to set
                 * @returns {rv.data.Action.MacroType} MacroType instance
                 */
                MacroType.create = function create(properties) {
                    return new MacroType(properties);
                };

                /**
                 * Encodes the specified MacroType message. Does not implicitly {@link rv.data.Action.MacroType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.MacroType
                 * @static
                 * @param {rv.data.Action.IMacroType} message MacroType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MacroType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.identification != null && Object.hasOwnProperty.call(message, "identification"))
                        $root.rv.data.CollectionElementType.encode(message.identification, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MacroType message, length delimited. Does not implicitly {@link rv.data.Action.MacroType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.MacroType
                 * @static
                 * @param {rv.data.Action.IMacroType} message MacroType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MacroType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MacroType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.MacroType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.MacroType} MacroType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MacroType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.MacroType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.identification = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MacroType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.MacroType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.MacroType} MacroType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MacroType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MacroType message.
                 * @function verify
                 * @memberof rv.data.Action.MacroType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MacroType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.identification != null && message.hasOwnProperty("identification")) {
                        let error = $root.rv.data.CollectionElementType.verify(message.identification);
                        if (error)
                            return "identification." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MacroType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.MacroType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.MacroType} MacroType
                 */
                MacroType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.MacroType)
                        return object;
                    let message = new $root.rv.data.Action.MacroType();
                    if (object.identification != null) {
                        if (typeof object.identification !== "object")
                            throw TypeError(".rv.data.Action.MacroType.identification: object expected");
                        message.identification = $root.rv.data.CollectionElementType.fromObject(object.identification);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MacroType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.MacroType
                 * @static
                 * @param {rv.data.Action.MacroType} message MacroType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MacroType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.identification = null;
                    if (message.identification != null && message.hasOwnProperty("identification"))
                        object.identification = $root.rv.data.CollectionElementType.toObject(message.identification, options);
                    return object;
                };

                /**
                 * Converts this MacroType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.MacroType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MacroType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MacroType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.MacroType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MacroType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.MacroType";
                };

                return MacroType;
            })();

            Action.CaptureType = (function() {

                /**
                 * Properties of a CaptureType.
                 * @memberof rv.data.Action
                 * @interface ICaptureType
                 * @property {rv.data.Action.CaptureType.ICaptureStart|null} [start] CaptureType start
                 * @property {rv.data.Action.CaptureType.ICaptureStop|null} [stop] CaptureType stop
                 */

                /**
                 * Constructs a new CaptureType.
                 * @memberof rv.data.Action
                 * @classdesc Represents a CaptureType.
                 * @implements ICaptureType
                 * @constructor
                 * @param {rv.data.Action.ICaptureType=} [properties] Properties to set
                 */
                function CaptureType(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CaptureType start.
                 * @member {rv.data.Action.CaptureType.ICaptureStart|null|undefined} start
                 * @memberof rv.data.Action.CaptureType
                 * @instance
                 */
                CaptureType.prototype.start = null;

                /**
                 * CaptureType stop.
                 * @member {rv.data.Action.CaptureType.ICaptureStop|null|undefined} stop
                 * @memberof rv.data.Action.CaptureType
                 * @instance
                 */
                CaptureType.prototype.stop = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * CaptureType CaptureAction.
                 * @member {"start"|"stop"|undefined} CaptureAction
                 * @memberof rv.data.Action.CaptureType
                 * @instance
                 */
                Object.defineProperty(CaptureType.prototype, "CaptureAction", {
                    get: $util.oneOfGetter($oneOfFields = ["start", "stop"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new CaptureType instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Action.CaptureType
                 * @static
                 * @param {rv.data.Action.ICaptureType=} [properties] Properties to set
                 * @returns {rv.data.Action.CaptureType} CaptureType instance
                 */
                CaptureType.create = function create(properties) {
                    return new CaptureType(properties);
                };

                /**
                 * Encodes the specified CaptureType message. Does not implicitly {@link rv.data.Action.CaptureType.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Action.CaptureType
                 * @static
                 * @param {rv.data.Action.ICaptureType} message CaptureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CaptureType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        $root.rv.data.Action.CaptureType.CaptureStart.encode(message.start, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.stop != null && Object.hasOwnProperty.call(message, "stop"))
                        $root.rv.data.Action.CaptureType.CaptureStop.encode(message.stop, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CaptureType message, length delimited. Does not implicitly {@link rv.data.Action.CaptureType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Action.CaptureType
                 * @static
                 * @param {rv.data.Action.ICaptureType} message CaptureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CaptureType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CaptureType message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Action.CaptureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Action.CaptureType} CaptureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CaptureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.CaptureType();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.start = $root.rv.data.Action.CaptureType.CaptureStart.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.stop = $root.rv.data.Action.CaptureType.CaptureStop.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CaptureType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Action.CaptureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Action.CaptureType} CaptureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CaptureType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CaptureType message.
                 * @function verify
                 * @memberof rv.data.Action.CaptureType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CaptureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.start != null && message.hasOwnProperty("start")) {
                        properties.CaptureAction = 1;
                        {
                            let error = $root.rv.data.Action.CaptureType.CaptureStart.verify(message.start);
                            if (error)
                                return "start." + error;
                        }
                    }
                    if (message.stop != null && message.hasOwnProperty("stop")) {
                        if (properties.CaptureAction === 1)
                            return "CaptureAction: multiple values";
                        properties.CaptureAction = 1;
                        {
                            let error = $root.rv.data.Action.CaptureType.CaptureStop.verify(message.stop);
                            if (error)
                                return "stop." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a CaptureType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Action.CaptureType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Action.CaptureType} CaptureType
                 */
                CaptureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Action.CaptureType)
                        return object;
                    let message = new $root.rv.data.Action.CaptureType();
                    if (object.start != null) {
                        if (typeof object.start !== "object")
                            throw TypeError(".rv.data.Action.CaptureType.start: object expected");
                        message.start = $root.rv.data.Action.CaptureType.CaptureStart.fromObject(object.start);
                    }
                    if (object.stop != null) {
                        if (typeof object.stop !== "object")
                            throw TypeError(".rv.data.Action.CaptureType.stop: object expected");
                        message.stop = $root.rv.data.Action.CaptureType.CaptureStop.fromObject(object.stop);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CaptureType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Action.CaptureType
                 * @static
                 * @param {rv.data.Action.CaptureType} message CaptureType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CaptureType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.start != null && message.hasOwnProperty("start")) {
                        object.start = $root.rv.data.Action.CaptureType.CaptureStart.toObject(message.start, options);
                        if (options.oneofs)
                            object.CaptureAction = "start";
                    }
                    if (message.stop != null && message.hasOwnProperty("stop")) {
                        object.stop = $root.rv.data.Action.CaptureType.CaptureStop.toObject(message.stop, options);
                        if (options.oneofs)
                            object.CaptureAction = "stop";
                    }
                    return object;
                };

                /**
                 * Converts this CaptureType to JSON.
                 * @function toJSON
                 * @memberof rv.data.Action.CaptureType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CaptureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for CaptureType
                 * @function getTypeUrl
                 * @memberof rv.data.Action.CaptureType
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                CaptureType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Action.CaptureType";
                };

                CaptureType.CaptureStart = (function() {

                    /**
                     * Properties of a CaptureStart.
                     * @memberof rv.data.Action.CaptureType
                     * @interface ICaptureStart
                     * @property {rv.data.ICollectionElementType|null} [presetIdentification] CaptureStart presetIdentification
                     */

                    /**
                     * Constructs a new CaptureStart.
                     * @memberof rv.data.Action.CaptureType
                     * @classdesc Represents a CaptureStart.
                     * @implements ICaptureStart
                     * @constructor
                     * @param {rv.data.Action.CaptureType.ICaptureStart=} [properties] Properties to set
                     */
                    function CaptureStart(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CaptureStart presetIdentification.
                     * @member {rv.data.ICollectionElementType|null|undefined} presetIdentification
                     * @memberof rv.data.Action.CaptureType.CaptureStart
                     * @instance
                     */
                    CaptureStart.prototype.presetIdentification = null;

                    /**
                     * Creates a new CaptureStart instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.CaptureType.CaptureStart
                     * @static
                     * @param {rv.data.Action.CaptureType.ICaptureStart=} [properties] Properties to set
                     * @returns {rv.data.Action.CaptureType.CaptureStart} CaptureStart instance
                     */
                    CaptureStart.create = function create(properties) {
                        return new CaptureStart(properties);
                    };

                    /**
                     * Encodes the specified CaptureStart message. Does not implicitly {@link rv.data.Action.CaptureType.CaptureStart.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.CaptureType.CaptureStart
                     * @static
                     * @param {rv.data.Action.CaptureType.ICaptureStart} message CaptureStart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CaptureStart.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.presetIdentification != null && Object.hasOwnProperty.call(message, "presetIdentification"))
                            $root.rv.data.CollectionElementType.encode(message.presetIdentification, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified CaptureStart message, length delimited. Does not implicitly {@link rv.data.Action.CaptureType.CaptureStart.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.CaptureType.CaptureStart
                     * @static
                     * @param {rv.data.Action.CaptureType.ICaptureStart} message CaptureStart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CaptureStart.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CaptureStart message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.CaptureType.CaptureStart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.CaptureType.CaptureStart} CaptureStart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CaptureStart.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.CaptureType.CaptureStart();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.presetIdentification = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CaptureStart message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.CaptureType.CaptureStart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.CaptureType.CaptureStart} CaptureStart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CaptureStart.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CaptureStart message.
                     * @function verify
                     * @memberof rv.data.Action.CaptureType.CaptureStart
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CaptureStart.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.presetIdentification != null && message.hasOwnProperty("presetIdentification")) {
                            let error = $root.rv.data.CollectionElementType.verify(message.presetIdentification);
                            if (error)
                                return "presetIdentification." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a CaptureStart message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.CaptureType.CaptureStart
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.CaptureType.CaptureStart} CaptureStart
                     */
                    CaptureStart.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.CaptureType.CaptureStart)
                            return object;
                        let message = new $root.rv.data.Action.CaptureType.CaptureStart();
                        if (object.presetIdentification != null) {
                            if (typeof object.presetIdentification !== "object")
                                throw TypeError(".rv.data.Action.CaptureType.CaptureStart.presetIdentification: object expected");
                            message.presetIdentification = $root.rv.data.CollectionElementType.fromObject(object.presetIdentification);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a CaptureStart message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.CaptureType.CaptureStart
                     * @static
                     * @param {rv.data.Action.CaptureType.CaptureStart} message CaptureStart
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CaptureStart.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.presetIdentification = null;
                        if (message.presetIdentification != null && message.hasOwnProperty("presetIdentification"))
                            object.presetIdentification = $root.rv.data.CollectionElementType.toObject(message.presetIdentification, options);
                        return object;
                    };

                    /**
                     * Converts this CaptureStart to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.CaptureType.CaptureStart
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CaptureStart.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for CaptureStart
                     * @function getTypeUrl
                     * @memberof rv.data.Action.CaptureType.CaptureStart
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    CaptureStart.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.CaptureType.CaptureStart";
                    };

                    return CaptureStart;
                })();

                CaptureType.CaptureStop = (function() {

                    /**
                     * Properties of a CaptureStop.
                     * @memberof rv.data.Action.CaptureType
                     * @interface ICaptureStop
                     * @property {boolean|null} [showsAlertBeforeStopping] CaptureStop showsAlertBeforeStopping
                     */

                    /**
                     * Constructs a new CaptureStop.
                     * @memberof rv.data.Action.CaptureType
                     * @classdesc Represents a CaptureStop.
                     * @implements ICaptureStop
                     * @constructor
                     * @param {rv.data.Action.CaptureType.ICaptureStop=} [properties] Properties to set
                     */
                    function CaptureStop(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CaptureStop showsAlertBeforeStopping.
                     * @member {boolean} showsAlertBeforeStopping
                     * @memberof rv.data.Action.CaptureType.CaptureStop
                     * @instance
                     */
                    CaptureStop.prototype.showsAlertBeforeStopping = false;

                    /**
                     * Creates a new CaptureStop instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Action.CaptureType.CaptureStop
                     * @static
                     * @param {rv.data.Action.CaptureType.ICaptureStop=} [properties] Properties to set
                     * @returns {rv.data.Action.CaptureType.CaptureStop} CaptureStop instance
                     */
                    CaptureStop.create = function create(properties) {
                        return new CaptureStop(properties);
                    };

                    /**
                     * Encodes the specified CaptureStop message. Does not implicitly {@link rv.data.Action.CaptureType.CaptureStop.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Action.CaptureType.CaptureStop
                     * @static
                     * @param {rv.data.Action.CaptureType.ICaptureStop} message CaptureStop message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CaptureStop.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.showsAlertBeforeStopping != null && Object.hasOwnProperty.call(message, "showsAlertBeforeStopping"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.showsAlertBeforeStopping);
                        return writer;
                    };

                    /**
                     * Encodes the specified CaptureStop message, length delimited. Does not implicitly {@link rv.data.Action.CaptureType.CaptureStop.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Action.CaptureType.CaptureStop
                     * @static
                     * @param {rv.data.Action.CaptureType.ICaptureStop} message CaptureStop message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CaptureStop.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CaptureStop message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Action.CaptureType.CaptureStop
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Action.CaptureType.CaptureStop} CaptureStop
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CaptureStop.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Action.CaptureType.CaptureStop();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.showsAlertBeforeStopping = reader.bool();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CaptureStop message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Action.CaptureType.CaptureStop
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Action.CaptureType.CaptureStop} CaptureStop
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CaptureStop.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CaptureStop message.
                     * @function verify
                     * @memberof rv.data.Action.CaptureType.CaptureStop
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CaptureStop.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.showsAlertBeforeStopping != null && message.hasOwnProperty("showsAlertBeforeStopping"))
                            if (typeof message.showsAlertBeforeStopping !== "boolean")
                                return "showsAlertBeforeStopping: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a CaptureStop message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Action.CaptureType.CaptureStop
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Action.CaptureType.CaptureStop} CaptureStop
                     */
                    CaptureStop.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Action.CaptureType.CaptureStop)
                            return object;
                        let message = new $root.rv.data.Action.CaptureType.CaptureStop();
                        if (object.showsAlertBeforeStopping != null)
                            message.showsAlertBeforeStopping = Boolean(object.showsAlertBeforeStopping);
                        return message;
                    };

                    /**
                     * Creates a plain object from a CaptureStop message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Action.CaptureType.CaptureStop
                     * @static
                     * @param {rv.data.Action.CaptureType.CaptureStop} message CaptureStop
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CaptureStop.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.showsAlertBeforeStopping = false;
                        if (message.showsAlertBeforeStopping != null && message.hasOwnProperty("showsAlertBeforeStopping"))
                            object.showsAlertBeforeStopping = message.showsAlertBeforeStopping;
                        return object;
                    };

                    /**
                     * Converts this CaptureStop to JSON.
                     * @function toJSON
                     * @memberof rv.data.Action.CaptureType.CaptureStop
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CaptureStop.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for CaptureStop
                     * @function getTypeUrl
                     * @memberof rv.data.Action.CaptureType.CaptureStop
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    CaptureStop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Action.CaptureType.CaptureStop";
                    };

                    return CaptureStop;
                })();

                return CaptureType;
            })();

            /**
             * ContentDestination enum.
             * @name rv.data.Action.ContentDestination
             * @enum {number}
             * @property {number} CONTENT_DESTINATION_GLOBAL=0 CONTENT_DESTINATION_GLOBAL value
             * @property {number} CONTENT_DESTINATION_ANNOUNCEMENTS=1 CONTENT_DESTINATION_ANNOUNCEMENTS value
             */
            Action.ContentDestination = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CONTENT_DESTINATION_GLOBAL"] = 0;
                values[valuesById[1] = "CONTENT_DESTINATION_ANNOUNCEMENTS"] = 1;
                return values;
            })();

            /**
             * LayerType enum.
             * @name rv.data.Action.LayerType
             * @enum {number}
             * @property {number} LAYER_TYPE_BACKGROUND=0 LAYER_TYPE_BACKGROUND value
             * @property {number} LAYER_TYPE_FOREGROUND=1 LAYER_TYPE_FOREGROUND value
             * @property {number} LAYER_TYPE_FILL=2 LAYER_TYPE_FILL value
             * @property {number} LAYER_TYPE_INPUT=3 LAYER_TYPE_INPUT value
             */
            Action.LayerType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "LAYER_TYPE_BACKGROUND"] = 0;
                values[valuesById[1] = "LAYER_TYPE_FOREGROUND"] = 1;
                values[valuesById[2] = "LAYER_TYPE_FILL"] = 2;
                values[valuesById[3] = "LAYER_TYPE_INPUT"] = 3;
                return values;
            })();

            /**
             * ActionType enum.
             * @name rv.data.Action.ActionType
             * @enum {number}
             * @property {number} ACTION_TYPE_UNKNOWN=0 ACTION_TYPE_UNKNOWN value
             * @property {number} ACTION_TYPE_STAGE_LAYOUT=1 ACTION_TYPE_STAGE_LAYOUT value
             * @property {number} ACTION_TYPE_MEDIA=2 ACTION_TYPE_MEDIA value
             * @property {number} ACTION_TYPE_TIMER=3 ACTION_TYPE_TIMER value
             * @property {number} ACTION_TYPE_COMMUNICATION=4 ACTION_TYPE_COMMUNICATION value
             * @property {number} ACTION_TYPE_CLEAR=5 ACTION_TYPE_CLEAR value
             * @property {number} ACTION_TYPE_PROP=6 ACTION_TYPE_PROP value
             * @property {number} ACTION_TYPE_MASK=7 ACTION_TYPE_MASK value
             * @property {number} ACTION_TYPE_MESSAGE=8 ACTION_TYPE_MESSAGE value
             * @property {number} ACTION_TYPE_SOCIAL_MEDIA=9 ACTION_TYPE_SOCIAL_MEDIA value
             * @property {number} ACTION_TYPE_MULTISCREEN=10 ACTION_TYPE_MULTISCREEN value
             * @property {number} ACTION_TYPE_PRESENTATION_SLIDE=11 ACTION_TYPE_PRESENTATION_SLIDE value
             * @property {number} ACTION_TYPE_FOREGROUND_MEDIA=12 ACTION_TYPE_FOREGROUND_MEDIA value
             * @property {number} ACTION_TYPE_BACKGROUND_MEDIA=13 ACTION_TYPE_BACKGROUND_MEDIA value
             * @property {number} ACTION_TYPE_PRESENTATION_DOCUMENT=14 ACTION_TYPE_PRESENTATION_DOCUMENT value
             * @property {number} ACTION_TYPE_PROP_SLIDE=15 ACTION_TYPE_PROP_SLIDE value
             * @property {number} ACTION_TYPE_EXTERNAL_PRESENTATION=17 ACTION_TYPE_EXTERNAL_PRESENTATION value
             * @property {number} ACTION_TYPE_AUDIENCE_LOOK=18 ACTION_TYPE_AUDIENCE_LOOK value
             * @property {number} ACTION_TYPE_AUDIO_INPUT=19 ACTION_TYPE_AUDIO_INPUT value
             * @property {number} ACTION_TYPE_AUDIO_BIN_PLAYLIST=20 ACTION_TYPE_AUDIO_BIN_PLAYLIST value
             * @property {number} ACTION_TYPE_MEDIA_BIN_PLAYLIST=21 ACTION_TYPE_MEDIA_BIN_PLAYLIST value
             * @property {number} ACTION_TYPE_SLIDE_DESTINATION=22 ACTION_TYPE_SLIDE_DESTINATION value
             * @property {number} ACTION_TYPE_MACRO=23 ACTION_TYPE_MACRO value
             * @property {number} ACTION_TYPE_CLEAR_GROUP=24 ACTION_TYPE_CLEAR_GROUP value
             * @property {number} ACTION_TYPE_CAPTURE=25 ACTION_TYPE_CAPTURE value
             * @property {number} ACTION_TYPE_LIBRARY_PLAYLIST=26 ACTION_TYPE_LIBRARY_PLAYLIST value
             */
            Action.ActionType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ACTION_TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "ACTION_TYPE_STAGE_LAYOUT"] = 1;
                values[valuesById[2] = "ACTION_TYPE_MEDIA"] = 2;
                values[valuesById[3] = "ACTION_TYPE_TIMER"] = 3;
                values[valuesById[4] = "ACTION_TYPE_COMMUNICATION"] = 4;
                values[valuesById[5] = "ACTION_TYPE_CLEAR"] = 5;
                values[valuesById[6] = "ACTION_TYPE_PROP"] = 6;
                values[valuesById[7] = "ACTION_TYPE_MASK"] = 7;
                values[valuesById[8] = "ACTION_TYPE_MESSAGE"] = 8;
                values[valuesById[9] = "ACTION_TYPE_SOCIAL_MEDIA"] = 9;
                values[valuesById[10] = "ACTION_TYPE_MULTISCREEN"] = 10;
                values[valuesById[11] = "ACTION_TYPE_PRESENTATION_SLIDE"] = 11;
                values[valuesById[12] = "ACTION_TYPE_FOREGROUND_MEDIA"] = 12;
                values[valuesById[13] = "ACTION_TYPE_BACKGROUND_MEDIA"] = 13;
                values[valuesById[14] = "ACTION_TYPE_PRESENTATION_DOCUMENT"] = 14;
                values[valuesById[15] = "ACTION_TYPE_PROP_SLIDE"] = 15;
                values[valuesById[17] = "ACTION_TYPE_EXTERNAL_PRESENTATION"] = 17;
                values[valuesById[18] = "ACTION_TYPE_AUDIENCE_LOOK"] = 18;
                values[valuesById[19] = "ACTION_TYPE_AUDIO_INPUT"] = 19;
                values[valuesById[20] = "ACTION_TYPE_AUDIO_BIN_PLAYLIST"] = 20;
                values[valuesById[21] = "ACTION_TYPE_MEDIA_BIN_PLAYLIST"] = 21;
                values[valuesById[22] = "ACTION_TYPE_SLIDE_DESTINATION"] = 22;
                values[valuesById[23] = "ACTION_TYPE_MACRO"] = 23;
                values[valuesById[24] = "ACTION_TYPE_CLEAR_GROUP"] = 24;
                values[valuesById[25] = "ACTION_TYPE_CAPTURE"] = 25;
                values[valuesById[26] = "ACTION_TYPE_LIBRARY_PLAYLIST"] = 26;
                return values;
            })();

            return Action;
        })();

        data.Background = (function() {

            /**
             * Properties of a Background.
             * @memberof rv.data
             * @interface IBackground
             * @property {boolean|null} [isEnabled] Background isEnabled
             * @property {rv.data.IColor|null} [color] Background color
             * @property {rv.data.Graphics.IGradient|null} [gradient] Background gradient
             */

            /**
             * Constructs a new Background.
             * @memberof rv.data
             * @classdesc Represents a Background.
             * @implements IBackground
             * @constructor
             * @param {rv.data.IBackground=} [properties] Properties to set
             */
            function Background(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Background isEnabled.
             * @member {boolean} isEnabled
             * @memberof rv.data.Background
             * @instance
             */
            Background.prototype.isEnabled = false;

            /**
             * Background color.
             * @member {rv.data.IColor|null|undefined} color
             * @memberof rv.data.Background
             * @instance
             */
            Background.prototype.color = null;

            /**
             * Background gradient.
             * @member {rv.data.Graphics.IGradient|null|undefined} gradient
             * @memberof rv.data.Background
             * @instance
             */
            Background.prototype.gradient = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Background Fill.
             * @member {"color"|"gradient"|undefined} Fill
             * @memberof rv.data.Background
             * @instance
             */
            Object.defineProperty(Background.prototype, "Fill", {
                get: $util.oneOfGetter($oneOfFields = ["color", "gradient"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Background instance using the specified properties.
             * @function create
             * @memberof rv.data.Background
             * @static
             * @param {rv.data.IBackground=} [properties] Properties to set
             * @returns {rv.data.Background} Background instance
             */
            Background.create = function create(properties) {
                return new Background(properties);
            };

            /**
             * Encodes the specified Background message. Does not implicitly {@link rv.data.Background.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Background
             * @static
             * @param {rv.data.IBackground} message Background message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Background.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    $root.rv.data.Color.encode(message.color, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.gradient != null && Object.hasOwnProperty.call(message, "gradient"))
                    $root.rv.data.Graphics.Gradient.encode(message.gradient, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.isEnabled != null && Object.hasOwnProperty.call(message, "isEnabled"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isEnabled);
                return writer;
            };

            /**
             * Encodes the specified Background message, length delimited. Does not implicitly {@link rv.data.Background.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Background
             * @static
             * @param {rv.data.IBackground} message Background message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Background.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Background message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Background
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Background} Background
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Background.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Background();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 3: {
                            message.isEnabled = reader.bool();
                            break;
                        }
                    case 1: {
                            message.color = $root.rv.data.Color.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.gradient = $root.rv.data.Graphics.Gradient.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Background message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Background
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Background} Background
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Background.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Background message.
             * @function verify
             * @memberof rv.data.Background
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Background.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.isEnabled != null && message.hasOwnProperty("isEnabled"))
                    if (typeof message.isEnabled !== "boolean")
                        return "isEnabled: boolean expected";
                if (message.color != null && message.hasOwnProperty("color")) {
                    properties.Fill = 1;
                    {
                        let error = $root.rv.data.Color.verify(message.color);
                        if (error)
                            return "color." + error;
                    }
                }
                if (message.gradient != null && message.hasOwnProperty("gradient")) {
                    if (properties.Fill === 1)
                        return "Fill: multiple values";
                    properties.Fill = 1;
                    {
                        let error = $root.rv.data.Graphics.Gradient.verify(message.gradient);
                        if (error)
                            return "gradient." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Background message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Background
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Background} Background
             */
            Background.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Background)
                    return object;
                let message = new $root.rv.data.Background();
                if (object.isEnabled != null)
                    message.isEnabled = Boolean(object.isEnabled);
                if (object.color != null) {
                    if (typeof object.color !== "object")
                        throw TypeError(".rv.data.Background.color: object expected");
                    message.color = $root.rv.data.Color.fromObject(object.color);
                }
                if (object.gradient != null) {
                    if (typeof object.gradient !== "object")
                        throw TypeError(".rv.data.Background.gradient: object expected");
                    message.gradient = $root.rv.data.Graphics.Gradient.fromObject(object.gradient);
                }
                return message;
            };

            /**
             * Creates a plain object from a Background message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Background
             * @static
             * @param {rv.data.Background} message Background
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Background.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.isEnabled = false;
                if (message.color != null && message.hasOwnProperty("color")) {
                    object.color = $root.rv.data.Color.toObject(message.color, options);
                    if (options.oneofs)
                        object.Fill = "color";
                }
                if (message.gradient != null && message.hasOwnProperty("gradient")) {
                    object.gradient = $root.rv.data.Graphics.Gradient.toObject(message.gradient, options);
                    if (options.oneofs)
                        object.Fill = "gradient";
                }
                if (message.isEnabled != null && message.hasOwnProperty("isEnabled"))
                    object.isEnabled = message.isEnabled;
                return object;
            };

            /**
             * Converts this Background to JSON.
             * @function toJSON
             * @memberof rv.data.Background
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Background.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Background
             * @function getTypeUrl
             * @memberof rv.data.Background
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Background.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Background";
            };

            return Background;
        })();

        data.Color = (function() {

            /**
             * Properties of a Color.
             * @memberof rv.data
             * @interface IColor
             * @property {number|null} [red] Color red
             * @property {number|null} [green] Color green
             * @property {number|null} [blue] Color blue
             * @property {number|null} [alpha] Color alpha
             */

            /**
             * Constructs a new Color.
             * @memberof rv.data
             * @classdesc Represents a Color.
             * @implements IColor
             * @constructor
             * @param {rv.data.IColor=} [properties] Properties to set
             */
            function Color(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Color red.
             * @member {number} red
             * @memberof rv.data.Color
             * @instance
             */
            Color.prototype.red = 0;

            /**
             * Color green.
             * @member {number} green
             * @memberof rv.data.Color
             * @instance
             */
            Color.prototype.green = 0;

            /**
             * Color blue.
             * @member {number} blue
             * @memberof rv.data.Color
             * @instance
             */
            Color.prototype.blue = 0;

            /**
             * Color alpha.
             * @member {number} alpha
             * @memberof rv.data.Color
             * @instance
             */
            Color.prototype.alpha = 0;

            /**
             * Creates a new Color instance using the specified properties.
             * @function create
             * @memberof rv.data.Color
             * @static
             * @param {rv.data.IColor=} [properties] Properties to set
             * @returns {rv.data.Color} Color instance
             */
            Color.create = function create(properties) {
                return new Color(properties);
            };

            /**
             * Encodes the specified Color message. Does not implicitly {@link rv.data.Color.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Color
             * @static
             * @param {rv.data.IColor} message Color message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Color.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.red != null && Object.hasOwnProperty.call(message, "red"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.red);
                if (message.green != null && Object.hasOwnProperty.call(message, "green"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.green);
                if (message.blue != null && Object.hasOwnProperty.call(message, "blue"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.blue);
                if (message.alpha != null && Object.hasOwnProperty.call(message, "alpha"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.alpha);
                return writer;
            };

            /**
             * Encodes the specified Color message, length delimited. Does not implicitly {@link rv.data.Color.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Color
             * @static
             * @param {rv.data.IColor} message Color message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Color.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Color message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Color
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Color} Color
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Color.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Color();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.red = reader.float();
                            break;
                        }
                    case 2: {
                            message.green = reader.float();
                            break;
                        }
                    case 3: {
                            message.blue = reader.float();
                            break;
                        }
                    case 4: {
                            message.alpha = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Color message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Color
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Color} Color
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Color.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Color message.
             * @function verify
             * @memberof rv.data.Color
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Color.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.red != null && message.hasOwnProperty("red"))
                    if (typeof message.red !== "number")
                        return "red: number expected";
                if (message.green != null && message.hasOwnProperty("green"))
                    if (typeof message.green !== "number")
                        return "green: number expected";
                if (message.blue != null && message.hasOwnProperty("blue"))
                    if (typeof message.blue !== "number")
                        return "blue: number expected";
                if (message.alpha != null && message.hasOwnProperty("alpha"))
                    if (typeof message.alpha !== "number")
                        return "alpha: number expected";
                return null;
            };

            /**
             * Creates a Color message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Color
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Color} Color
             */
            Color.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Color)
                    return object;
                let message = new $root.rv.data.Color();
                if (object.red != null)
                    message.red = Number(object.red);
                if (object.green != null)
                    message.green = Number(object.green);
                if (object.blue != null)
                    message.blue = Number(object.blue);
                if (object.alpha != null)
                    message.alpha = Number(object.alpha);
                return message;
            };

            /**
             * Creates a plain object from a Color message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Color
             * @static
             * @param {rv.data.Color} message Color
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Color.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.red = 0;
                    object.green = 0;
                    object.blue = 0;
                    object.alpha = 0;
                }
                if (message.red != null && message.hasOwnProperty("red"))
                    object.red = options.json && !isFinite(message.red) ? String(message.red) : message.red;
                if (message.green != null && message.hasOwnProperty("green"))
                    object.green = options.json && !isFinite(message.green) ? String(message.green) : message.green;
                if (message.blue != null && message.hasOwnProperty("blue"))
                    object.blue = options.json && !isFinite(message.blue) ? String(message.blue) : message.blue;
                if (message.alpha != null && message.hasOwnProperty("alpha"))
                    object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                return object;
            };

            /**
             * Converts this Color to JSON.
             * @function toJSON
             * @memberof rv.data.Color
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Color.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Color
             * @function getTypeUrl
             * @memberof rv.data.Color
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Color.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Color";
            };

            return Color;
        })();

        data.Graphics = (function() {

            /**
             * Properties of a Graphics.
             * @memberof rv.data
             * @interface IGraphics
             */

            /**
             * Constructs a new Graphics.
             * @memberof rv.data
             * @classdesc Represents a Graphics.
             * @implements IGraphics
             * @constructor
             * @param {rv.data.IGraphics=} [properties] Properties to set
             */
            function Graphics(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Graphics instance using the specified properties.
             * @function create
             * @memberof rv.data.Graphics
             * @static
             * @param {rv.data.IGraphics=} [properties] Properties to set
             * @returns {rv.data.Graphics} Graphics instance
             */
            Graphics.create = function create(properties) {
                return new Graphics(properties);
            };

            /**
             * Encodes the specified Graphics message. Does not implicitly {@link rv.data.Graphics.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Graphics
             * @static
             * @param {rv.data.IGraphics} message Graphics message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Graphics.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Graphics message, length delimited. Does not implicitly {@link rv.data.Graphics.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Graphics
             * @static
             * @param {rv.data.IGraphics} message Graphics message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Graphics.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Graphics message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Graphics
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Graphics} Graphics
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Graphics.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Graphics message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Graphics
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Graphics} Graphics
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Graphics.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Graphics message.
             * @function verify
             * @memberof rv.data.Graphics
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Graphics.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Graphics message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Graphics
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Graphics} Graphics
             */
            Graphics.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Graphics)
                    return object;
                return new $root.rv.data.Graphics();
            };

            /**
             * Creates a plain object from a Graphics message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Graphics
             * @static
             * @param {rv.data.Graphics} message Graphics
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Graphics.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Graphics to JSON.
             * @function toJSON
             * @memberof rv.data.Graphics
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Graphics.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Graphics
             * @function getTypeUrl
             * @memberof rv.data.Graphics
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Graphics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Graphics";
            };

            Graphics.Element = (function() {

                /**
                 * Properties of an Element.
                 * @memberof rv.data.Graphics
                 * @interface IElement
                 * @property {rv.data.IUUID|null} [uuid] Element uuid
                 * @property {string|null} [name] Element name
                 * @property {rv.data.Graphics.IRect|null} [bounds] Element bounds
                 * @property {number|null} [rotation] Element rotation
                 * @property {number|null} [opacity] Element opacity
                 * @property {boolean|null} [locked] Element locked
                 * @property {boolean|null} [aspectRatioLocked] Element aspectRatioLocked
                 * @property {rv.data.Graphics.IPath|null} [path] Element path
                 * @property {rv.data.Graphics.IFill|null} [fill] Element fill
                 * @property {rv.data.Graphics.IStroke|null} [stroke] Element stroke
                 * @property {rv.data.Graphics.IShadow|null} [shadow] Element shadow
                 * @property {rv.data.Graphics.IFeather|null} [feather] Element feather
                 * @property {rv.data.Graphics.IText|null} [text] Element text
                 * @property {rv.data.Graphics.Element.FlipMode|null} [flipMode] Element flipMode
                 * @property {boolean|null} [hidden] Element hidden
                 * @property {rv.data.Graphics.Text.ILineFillMask|null} [textLineMask] Element textLineMask
                 */

                /**
                 * Constructs a new Element.
                 * @memberof rv.data.Graphics
                 * @classdesc Represents an Element.
                 * @implements IElement
                 * @constructor
                 * @param {rv.data.Graphics.IElement=} [properties] Properties to set
                 */
                function Element(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Element uuid.
                 * @member {rv.data.IUUID|null|undefined} uuid
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.uuid = null;

                /**
                 * Element name.
                 * @member {string} name
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.name = "";

                /**
                 * Element bounds.
                 * @member {rv.data.Graphics.IRect|null|undefined} bounds
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.bounds = null;

                /**
                 * Element rotation.
                 * @member {number} rotation
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.rotation = 0;

                /**
                 * Element opacity.
                 * @member {number} opacity
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.opacity = 0;

                /**
                 * Element locked.
                 * @member {boolean} locked
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.locked = false;

                /**
                 * Element aspectRatioLocked.
                 * @member {boolean} aspectRatioLocked
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.aspectRatioLocked = false;

                /**
                 * Element path.
                 * @member {rv.data.Graphics.IPath|null|undefined} path
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.path = null;

                /**
                 * Element fill.
                 * @member {rv.data.Graphics.IFill|null|undefined} fill
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.fill = null;

                /**
                 * Element stroke.
                 * @member {rv.data.Graphics.IStroke|null|undefined} stroke
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.stroke = null;

                /**
                 * Element shadow.
                 * @member {rv.data.Graphics.IShadow|null|undefined} shadow
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.shadow = null;

                /**
                 * Element feather.
                 * @member {rv.data.Graphics.IFeather|null|undefined} feather
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.feather = null;

                /**
                 * Element text.
                 * @member {rv.data.Graphics.IText|null|undefined} text
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.text = null;

                /**
                 * Element flipMode.
                 * @member {rv.data.Graphics.Element.FlipMode} flipMode
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.flipMode = 0;

                /**
                 * Element hidden.
                 * @member {boolean} hidden
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.hidden = false;

                /**
                 * Element textLineMask.
                 * @member {rv.data.Graphics.Text.ILineFillMask|null|undefined} textLineMask
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Element.prototype.textLineMask = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Element Mask.
                 * @member {"textLineMask"|undefined} Mask
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 */
                Object.defineProperty(Element.prototype, "Mask", {
                    get: $util.oneOfGetter($oneOfFields = ["textLineMask"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Element instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Graphics.Element
                 * @static
                 * @param {rv.data.Graphics.IElement=} [properties] Properties to set
                 * @returns {rv.data.Graphics.Element} Element instance
                 */
                Element.create = function create(properties) {
                    return new Element(properties);
                };

                /**
                 * Encodes the specified Element message. Does not implicitly {@link rv.data.Graphics.Element.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Graphics.Element
                 * @static
                 * @param {rv.data.Graphics.IElement} message Element message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Element.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                        $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.bounds != null && Object.hasOwnProperty.call(message, "bounds"))
                        $root.rv.data.Graphics.Rect.encode(message.bounds, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.rotation != null && Object.hasOwnProperty.call(message, "rotation"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.rotation);
                    if (message.opacity != null && Object.hasOwnProperty.call(message, "opacity"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.opacity);
                    if (message.locked != null && Object.hasOwnProperty.call(message, "locked"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.locked);
                    if (message.aspectRatioLocked != null && Object.hasOwnProperty.call(message, "aspectRatioLocked"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.aspectRatioLocked);
                    if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                        $root.rv.data.Graphics.Path.encode(message.path, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.fill != null && Object.hasOwnProperty.call(message, "fill"))
                        $root.rv.data.Graphics.Fill.encode(message.fill, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.stroke != null && Object.hasOwnProperty.call(message, "stroke"))
                        $root.rv.data.Graphics.Stroke.encode(message.stroke, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.shadow != null && Object.hasOwnProperty.call(message, "shadow"))
                        $root.rv.data.Graphics.Shadow.encode(message.shadow, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.feather != null && Object.hasOwnProperty.call(message, "feather"))
                        $root.rv.data.Graphics.Feather.encode(message.feather, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                        $root.rv.data.Graphics.Text.encode(message.text, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if (message.textLineMask != null && Object.hasOwnProperty.call(message, "textLineMask"))
                        $root.rv.data.Graphics.Text.LineFillMask.encode(message.textLineMask, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.flipMode != null && Object.hasOwnProperty.call(message, "flipMode"))
                        writer.uint32(/* id 15, wireType 0 =*/120).int32(message.flipMode);
                    if (message.hidden != null && Object.hasOwnProperty.call(message, "hidden"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.hidden);
                    return writer;
                };

                /**
                 * Encodes the specified Element message, length delimited. Does not implicitly {@link rv.data.Graphics.Element.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Graphics.Element
                 * @static
                 * @param {rv.data.Graphics.IElement} message Element message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Element.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Element message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Graphics.Element
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Graphics.Element} Element
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Element.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Element();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.name = reader.string();
                                break;
                            }
                        case 3: {
                                message.bounds = $root.rv.data.Graphics.Rect.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.rotation = reader.double();
                                break;
                            }
                        case 5: {
                                message.opacity = reader.double();
                                break;
                            }
                        case 6: {
                                message.locked = reader.bool();
                                break;
                            }
                        case 7: {
                                message.aspectRatioLocked = reader.bool();
                                break;
                            }
                        case 8: {
                                message.path = $root.rv.data.Graphics.Path.decode(reader, reader.uint32());
                                break;
                            }
                        case 9: {
                                message.fill = $root.rv.data.Graphics.Fill.decode(reader, reader.uint32());
                                break;
                            }
                        case 10: {
                                message.stroke = $root.rv.data.Graphics.Stroke.decode(reader, reader.uint32());
                                break;
                            }
                        case 11: {
                                message.shadow = $root.rv.data.Graphics.Shadow.decode(reader, reader.uint32());
                                break;
                            }
                        case 12: {
                                message.feather = $root.rv.data.Graphics.Feather.decode(reader, reader.uint32());
                                break;
                            }
                        case 13: {
                                message.text = $root.rv.data.Graphics.Text.decode(reader, reader.uint32());
                                break;
                            }
                        case 15: {
                                message.flipMode = reader.int32();
                                break;
                            }
                        case 16: {
                                message.hidden = reader.bool();
                                break;
                            }
                        case 14: {
                                message.textLineMask = $root.rv.data.Graphics.Text.LineFillMask.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Element message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Graphics.Element
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Graphics.Element} Element
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Element.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Element message.
                 * @function verify
                 * @memberof rv.data.Graphics.Element
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Element.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.uuid != null && message.hasOwnProperty("uuid")) {
                        let error = $root.rv.data.UUID.verify(message.uuid);
                        if (error)
                            return "uuid." + error;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.bounds != null && message.hasOwnProperty("bounds")) {
                        let error = $root.rv.data.Graphics.Rect.verify(message.bounds);
                        if (error)
                            return "bounds." + error;
                    }
                    if (message.rotation != null && message.hasOwnProperty("rotation"))
                        if (typeof message.rotation !== "number")
                            return "rotation: number expected";
                    if (message.opacity != null && message.hasOwnProperty("opacity"))
                        if (typeof message.opacity !== "number")
                            return "opacity: number expected";
                    if (message.locked != null && message.hasOwnProperty("locked"))
                        if (typeof message.locked !== "boolean")
                            return "locked: boolean expected";
                    if (message.aspectRatioLocked != null && message.hasOwnProperty("aspectRatioLocked"))
                        if (typeof message.aspectRatioLocked !== "boolean")
                            return "aspectRatioLocked: boolean expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        let error = $root.rv.data.Graphics.Path.verify(message.path);
                        if (error)
                            return "path." + error;
                    }
                    if (message.fill != null && message.hasOwnProperty("fill")) {
                        let error = $root.rv.data.Graphics.Fill.verify(message.fill);
                        if (error)
                            return "fill." + error;
                    }
                    if (message.stroke != null && message.hasOwnProperty("stroke")) {
                        let error = $root.rv.data.Graphics.Stroke.verify(message.stroke);
                        if (error)
                            return "stroke." + error;
                    }
                    if (message.shadow != null && message.hasOwnProperty("shadow")) {
                        let error = $root.rv.data.Graphics.Shadow.verify(message.shadow);
                        if (error)
                            return "shadow." + error;
                    }
                    if (message.feather != null && message.hasOwnProperty("feather")) {
                        let error = $root.rv.data.Graphics.Feather.verify(message.feather);
                        if (error)
                            return "feather." + error;
                    }
                    if (message.text != null && message.hasOwnProperty("text")) {
                        let error = $root.rv.data.Graphics.Text.verify(message.text);
                        if (error)
                            return "text." + error;
                    }
                    if (message.flipMode != null && message.hasOwnProperty("flipMode"))
                        switch (message.flipMode) {
                        default:
                            return "flipMode: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.hidden != null && message.hasOwnProperty("hidden"))
                        if (typeof message.hidden !== "boolean")
                            return "hidden: boolean expected";
                    if (message.textLineMask != null && message.hasOwnProperty("textLineMask")) {
                        properties.Mask = 1;
                        {
                            let error = $root.rv.data.Graphics.Text.LineFillMask.verify(message.textLineMask);
                            if (error)
                                return "textLineMask." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Element message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Graphics.Element
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Graphics.Element} Element
                 */
                Element.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Graphics.Element)
                        return object;
                    let message = new $root.rv.data.Graphics.Element();
                    if (object.uuid != null) {
                        if (typeof object.uuid !== "object")
                            throw TypeError(".rv.data.Graphics.Element.uuid: object expected");
                        message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.bounds != null) {
                        if (typeof object.bounds !== "object")
                            throw TypeError(".rv.data.Graphics.Element.bounds: object expected");
                        message.bounds = $root.rv.data.Graphics.Rect.fromObject(object.bounds);
                    }
                    if (object.rotation != null)
                        message.rotation = Number(object.rotation);
                    if (object.opacity != null)
                        message.opacity = Number(object.opacity);
                    if (object.locked != null)
                        message.locked = Boolean(object.locked);
                    if (object.aspectRatioLocked != null)
                        message.aspectRatioLocked = Boolean(object.aspectRatioLocked);
                    if (object.path != null) {
                        if (typeof object.path !== "object")
                            throw TypeError(".rv.data.Graphics.Element.path: object expected");
                        message.path = $root.rv.data.Graphics.Path.fromObject(object.path);
                    }
                    if (object.fill != null) {
                        if (typeof object.fill !== "object")
                            throw TypeError(".rv.data.Graphics.Element.fill: object expected");
                        message.fill = $root.rv.data.Graphics.Fill.fromObject(object.fill);
                    }
                    if (object.stroke != null) {
                        if (typeof object.stroke !== "object")
                            throw TypeError(".rv.data.Graphics.Element.stroke: object expected");
                        message.stroke = $root.rv.data.Graphics.Stroke.fromObject(object.stroke);
                    }
                    if (object.shadow != null) {
                        if (typeof object.shadow !== "object")
                            throw TypeError(".rv.data.Graphics.Element.shadow: object expected");
                        message.shadow = $root.rv.data.Graphics.Shadow.fromObject(object.shadow);
                    }
                    if (object.feather != null) {
                        if (typeof object.feather !== "object")
                            throw TypeError(".rv.data.Graphics.Element.feather: object expected");
                        message.feather = $root.rv.data.Graphics.Feather.fromObject(object.feather);
                    }
                    if (object.text != null) {
                        if (typeof object.text !== "object")
                            throw TypeError(".rv.data.Graphics.Element.text: object expected");
                        message.text = $root.rv.data.Graphics.Text.fromObject(object.text);
                    }
                    switch (object.flipMode) {
                    default:
                        if (typeof object.flipMode === "number") {
                            message.flipMode = object.flipMode;
                            break;
                        }
                        break;
                    case "FLIP_MODE_NONE":
                    case 0:
                        message.flipMode = 0;
                        break;
                    case "FLIP_MODE_VERTICAL":
                    case 1:
                        message.flipMode = 1;
                        break;
                    case "FLIP_MODE_HORIZONTAL":
                    case 2:
                        message.flipMode = 2;
                        break;
                    case "FLIP_MODE_BOTH":
                    case 3:
                        message.flipMode = 3;
                        break;
                    }
                    if (object.hidden != null)
                        message.hidden = Boolean(object.hidden);
                    if (object.textLineMask != null) {
                        if (typeof object.textLineMask !== "object")
                            throw TypeError(".rv.data.Graphics.Element.textLineMask: object expected");
                        message.textLineMask = $root.rv.data.Graphics.Text.LineFillMask.fromObject(object.textLineMask);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Element message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Graphics.Element
                 * @static
                 * @param {rv.data.Graphics.Element} message Element
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Element.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.uuid = null;
                        object.name = "";
                        object.bounds = null;
                        object.rotation = 0;
                        object.opacity = 0;
                        object.locked = false;
                        object.aspectRatioLocked = false;
                        object.path = null;
                        object.fill = null;
                        object.stroke = null;
                        object.shadow = null;
                        object.feather = null;
                        object.text = null;
                        object.flipMode = options.enums === String ? "FLIP_MODE_NONE" : 0;
                        object.hidden = false;
                    }
                    if (message.uuid != null && message.hasOwnProperty("uuid"))
                        object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.bounds != null && message.hasOwnProperty("bounds"))
                        object.bounds = $root.rv.data.Graphics.Rect.toObject(message.bounds, options);
                    if (message.rotation != null && message.hasOwnProperty("rotation"))
                        object.rotation = options.json && !isFinite(message.rotation) ? String(message.rotation) : message.rotation;
                    if (message.opacity != null && message.hasOwnProperty("opacity"))
                        object.opacity = options.json && !isFinite(message.opacity) ? String(message.opacity) : message.opacity;
                    if (message.locked != null && message.hasOwnProperty("locked"))
                        object.locked = message.locked;
                    if (message.aspectRatioLocked != null && message.hasOwnProperty("aspectRatioLocked"))
                        object.aspectRatioLocked = message.aspectRatioLocked;
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = $root.rv.data.Graphics.Path.toObject(message.path, options);
                    if (message.fill != null && message.hasOwnProperty("fill"))
                        object.fill = $root.rv.data.Graphics.Fill.toObject(message.fill, options);
                    if (message.stroke != null && message.hasOwnProperty("stroke"))
                        object.stroke = $root.rv.data.Graphics.Stroke.toObject(message.stroke, options);
                    if (message.shadow != null && message.hasOwnProperty("shadow"))
                        object.shadow = $root.rv.data.Graphics.Shadow.toObject(message.shadow, options);
                    if (message.feather != null && message.hasOwnProperty("feather"))
                        object.feather = $root.rv.data.Graphics.Feather.toObject(message.feather, options);
                    if (message.text != null && message.hasOwnProperty("text"))
                        object.text = $root.rv.data.Graphics.Text.toObject(message.text, options);
                    if (message.textLineMask != null && message.hasOwnProperty("textLineMask")) {
                        object.textLineMask = $root.rv.data.Graphics.Text.LineFillMask.toObject(message.textLineMask, options);
                        if (options.oneofs)
                            object.Mask = "textLineMask";
                    }
                    if (message.flipMode != null && message.hasOwnProperty("flipMode"))
                        object.flipMode = options.enums === String ? $root.rv.data.Graphics.Element.FlipMode[message.flipMode] === undefined ? message.flipMode : $root.rv.data.Graphics.Element.FlipMode[message.flipMode] : message.flipMode;
                    if (message.hidden != null && message.hasOwnProperty("hidden"))
                        object.hidden = message.hidden;
                    return object;
                };

                /**
                 * Converts this Element to JSON.
                 * @function toJSON
                 * @memberof rv.data.Graphics.Element
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Element.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Element
                 * @function getTypeUrl
                 * @memberof rv.data.Graphics.Element
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Element.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Graphics.Element";
                };

                /**
                 * FlipMode enum.
                 * @name rv.data.Graphics.Element.FlipMode
                 * @enum {number}
                 * @property {number} FLIP_MODE_NONE=0 FLIP_MODE_NONE value
                 * @property {number} FLIP_MODE_VERTICAL=1 FLIP_MODE_VERTICAL value
                 * @property {number} FLIP_MODE_HORIZONTAL=2 FLIP_MODE_HORIZONTAL value
                 * @property {number} FLIP_MODE_BOTH=3 FLIP_MODE_BOTH value
                 */
                Element.FlipMode = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "FLIP_MODE_NONE"] = 0;
                    values[valuesById[1] = "FLIP_MODE_VERTICAL"] = 1;
                    values[valuesById[2] = "FLIP_MODE_HORIZONTAL"] = 2;
                    values[valuesById[3] = "FLIP_MODE_BOTH"] = 3;
                    return values;
                })();

                return Element;
            })();

            Graphics.Rect = (function() {

                /**
                 * Properties of a Rect.
                 * @memberof rv.data.Graphics
                 * @interface IRect
                 * @property {rv.data.Graphics.IPoint|null} [origin] Rect origin
                 * @property {rv.data.Graphics.ISize|null} [size] Rect size
                 */

                /**
                 * Constructs a new Rect.
                 * @memberof rv.data.Graphics
                 * @classdesc Represents a Rect.
                 * @implements IRect
                 * @constructor
                 * @param {rv.data.Graphics.IRect=} [properties] Properties to set
                 */
                function Rect(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Rect origin.
                 * @member {rv.data.Graphics.IPoint|null|undefined} origin
                 * @memberof rv.data.Graphics.Rect
                 * @instance
                 */
                Rect.prototype.origin = null;

                /**
                 * Rect size.
                 * @member {rv.data.Graphics.ISize|null|undefined} size
                 * @memberof rv.data.Graphics.Rect
                 * @instance
                 */
                Rect.prototype.size = null;

                /**
                 * Creates a new Rect instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Graphics.Rect
                 * @static
                 * @param {rv.data.Graphics.IRect=} [properties] Properties to set
                 * @returns {rv.data.Graphics.Rect} Rect instance
                 */
                Rect.create = function create(properties) {
                    return new Rect(properties);
                };

                /**
                 * Encodes the specified Rect message. Does not implicitly {@link rv.data.Graphics.Rect.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Graphics.Rect
                 * @static
                 * @param {rv.data.Graphics.IRect} message Rect message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Rect.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                        $root.rv.data.Graphics.Point.encode(message.origin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                        $root.rv.data.Graphics.Size.encode(message.size, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Rect message, length delimited. Does not implicitly {@link rv.data.Graphics.Rect.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Graphics.Rect
                 * @static
                 * @param {rv.data.Graphics.IRect} message Rect message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Rect.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Rect message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Graphics.Rect
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Graphics.Rect} Rect
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Rect.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Rect();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.origin = $root.rv.data.Graphics.Point.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.size = $root.rv.data.Graphics.Size.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Rect message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Graphics.Rect
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Graphics.Rect} Rect
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Rect.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Rect message.
                 * @function verify
                 * @memberof rv.data.Graphics.Rect
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Rect.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.origin != null && message.hasOwnProperty("origin")) {
                        let error = $root.rv.data.Graphics.Point.verify(message.origin);
                        if (error)
                            return "origin." + error;
                    }
                    if (message.size != null && message.hasOwnProperty("size")) {
                        let error = $root.rv.data.Graphics.Size.verify(message.size);
                        if (error)
                            return "size." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Rect message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Graphics.Rect
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Graphics.Rect} Rect
                 */
                Rect.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Graphics.Rect)
                        return object;
                    let message = new $root.rv.data.Graphics.Rect();
                    if (object.origin != null) {
                        if (typeof object.origin !== "object")
                            throw TypeError(".rv.data.Graphics.Rect.origin: object expected");
                        message.origin = $root.rv.data.Graphics.Point.fromObject(object.origin);
                    }
                    if (object.size != null) {
                        if (typeof object.size !== "object")
                            throw TypeError(".rv.data.Graphics.Rect.size: object expected");
                        message.size = $root.rv.data.Graphics.Size.fromObject(object.size);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Rect message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Graphics.Rect
                 * @static
                 * @param {rv.data.Graphics.Rect} message Rect
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Rect.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.origin = null;
                        object.size = null;
                    }
                    if (message.origin != null && message.hasOwnProperty("origin"))
                        object.origin = $root.rv.data.Graphics.Point.toObject(message.origin, options);
                    if (message.size != null && message.hasOwnProperty("size"))
                        object.size = $root.rv.data.Graphics.Size.toObject(message.size, options);
                    return object;
                };

                /**
                 * Converts this Rect to JSON.
                 * @function toJSON
                 * @memberof rv.data.Graphics.Rect
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Rect.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Rect
                 * @function getTypeUrl
                 * @memberof rv.data.Graphics.Rect
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Rect.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Graphics.Rect";
                };

                return Rect;
            })();

            Graphics.Point = (function() {

                /**
                 * Properties of a Point.
                 * @memberof rv.data.Graphics
                 * @interface IPoint
                 * @property {number|null} [x] Point x
                 * @property {number|null} [y] Point y
                 */

                /**
                 * Constructs a new Point.
                 * @memberof rv.data.Graphics
                 * @classdesc Represents a Point.
                 * @implements IPoint
                 * @constructor
                 * @param {rv.data.Graphics.IPoint=} [properties] Properties to set
                 */
                function Point(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Point x.
                 * @member {number} x
                 * @memberof rv.data.Graphics.Point
                 * @instance
                 */
                Point.prototype.x = 0;

                /**
                 * Point y.
                 * @member {number} y
                 * @memberof rv.data.Graphics.Point
                 * @instance
                 */
                Point.prototype.y = 0;

                /**
                 * Creates a new Point instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Graphics.Point
                 * @static
                 * @param {rv.data.Graphics.IPoint=} [properties] Properties to set
                 * @returns {rv.data.Graphics.Point} Point instance
                 */
                Point.create = function create(properties) {
                    return new Point(properties);
                };

                /**
                 * Encodes the specified Point message. Does not implicitly {@link rv.data.Graphics.Point.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Graphics.Point
                 * @static
                 * @param {rv.data.Graphics.IPoint} message Point message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Point.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
                    if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
                    return writer;
                };

                /**
                 * Encodes the specified Point message, length delimited. Does not implicitly {@link rv.data.Graphics.Point.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Graphics.Point
                 * @static
                 * @param {rv.data.Graphics.IPoint} message Point message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Point.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Point message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Graphics.Point
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Graphics.Point} Point
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Point.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Point();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.x = reader.double();
                                break;
                            }
                        case 2: {
                                message.y = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Point message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Graphics.Point
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Graphics.Point} Point
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Point.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Point message.
                 * @function verify
                 * @memberof rv.data.Graphics.Point
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Point.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.x != null && message.hasOwnProperty("x"))
                        if (typeof message.x !== "number")
                            return "x: number expected";
                    if (message.y != null && message.hasOwnProperty("y"))
                        if (typeof message.y !== "number")
                            return "y: number expected";
                    return null;
                };

                /**
                 * Creates a Point message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Graphics.Point
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Graphics.Point} Point
                 */
                Point.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Graphics.Point)
                        return object;
                    let message = new $root.rv.data.Graphics.Point();
                    if (object.x != null)
                        message.x = Number(object.x);
                    if (object.y != null)
                        message.y = Number(object.y);
                    return message;
                };

                /**
                 * Creates a plain object from a Point message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Graphics.Point
                 * @static
                 * @param {rv.data.Graphics.Point} message Point
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Point.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.x = 0;
                        object.y = 0;
                    }
                    if (message.x != null && message.hasOwnProperty("x"))
                        object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                    if (message.y != null && message.hasOwnProperty("y"))
                        object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                    return object;
                };

                /**
                 * Converts this Point to JSON.
                 * @function toJSON
                 * @memberof rv.data.Graphics.Point
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Point.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Point
                 * @function getTypeUrl
                 * @memberof rv.data.Graphics.Point
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Point.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Graphics.Point";
                };

                return Point;
            })();

            Graphics.Size = (function() {

                /**
                 * Properties of a Size.
                 * @memberof rv.data.Graphics
                 * @interface ISize
                 * @property {number|null} [width] Size width
                 * @property {number|null} [height] Size height
                 */

                /**
                 * Constructs a new Size.
                 * @memberof rv.data.Graphics
                 * @classdesc Represents a Size.
                 * @implements ISize
                 * @constructor
                 * @param {rv.data.Graphics.ISize=} [properties] Properties to set
                 */
                function Size(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Size width.
                 * @member {number} width
                 * @memberof rv.data.Graphics.Size
                 * @instance
                 */
                Size.prototype.width = 0;

                /**
                 * Size height.
                 * @member {number} height
                 * @memberof rv.data.Graphics.Size
                 * @instance
                 */
                Size.prototype.height = 0;

                /**
                 * Creates a new Size instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Graphics.Size
                 * @static
                 * @param {rv.data.Graphics.ISize=} [properties] Properties to set
                 * @returns {rv.data.Graphics.Size} Size instance
                 */
                Size.create = function create(properties) {
                    return new Size(properties);
                };

                /**
                 * Encodes the specified Size message. Does not implicitly {@link rv.data.Graphics.Size.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Graphics.Size
                 * @static
                 * @param {rv.data.Graphics.ISize} message Size message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Size.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.width);
                    if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.height);
                    return writer;
                };

                /**
                 * Encodes the specified Size message, length delimited. Does not implicitly {@link rv.data.Graphics.Size.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Graphics.Size
                 * @static
                 * @param {rv.data.Graphics.ISize} message Size message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Size.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Size message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Graphics.Size
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Graphics.Size} Size
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Size.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Size();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.width = reader.double();
                                break;
                            }
                        case 2: {
                                message.height = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Size message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Graphics.Size
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Graphics.Size} Size
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Size.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Size message.
                 * @function verify
                 * @memberof rv.data.Graphics.Size
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Size.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.width != null && message.hasOwnProperty("width"))
                        if (typeof message.width !== "number")
                            return "width: number expected";
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (typeof message.height !== "number")
                            return "height: number expected";
                    return null;
                };

                /**
                 * Creates a Size message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Graphics.Size
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Graphics.Size} Size
                 */
                Size.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Graphics.Size)
                        return object;
                    let message = new $root.rv.data.Graphics.Size();
                    if (object.width != null)
                        message.width = Number(object.width);
                    if (object.height != null)
                        message.height = Number(object.height);
                    return message;
                };

                /**
                 * Creates a plain object from a Size message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Graphics.Size
                 * @static
                 * @param {rv.data.Graphics.Size} message Size
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Size.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.width = 0;
                        object.height = 0;
                    }
                    if (message.width != null && message.hasOwnProperty("width"))
                        object.width = options.json && !isFinite(message.width) ? String(message.width) : message.width;
                    if (message.height != null && message.hasOwnProperty("height"))
                        object.height = options.json && !isFinite(message.height) ? String(message.height) : message.height;
                    return object;
                };

                /**
                 * Converts this Size to JSON.
                 * @function toJSON
                 * @memberof rv.data.Graphics.Size
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Size.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Size
                 * @function getTypeUrl
                 * @memberof rv.data.Graphics.Size
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Size.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Graphics.Size";
                };

                return Size;
            })();

            Graphics.EdgeInsets = (function() {

                /**
                 * Properties of an EdgeInsets.
                 * @memberof rv.data.Graphics
                 * @interface IEdgeInsets
                 * @property {number|null} [left] EdgeInsets left
                 * @property {number|null} [right] EdgeInsets right
                 * @property {number|null} [top] EdgeInsets top
                 * @property {number|null} [bottom] EdgeInsets bottom
                 */

                /**
                 * Constructs a new EdgeInsets.
                 * @memberof rv.data.Graphics
                 * @classdesc Represents an EdgeInsets.
                 * @implements IEdgeInsets
                 * @constructor
                 * @param {rv.data.Graphics.IEdgeInsets=} [properties] Properties to set
                 */
                function EdgeInsets(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EdgeInsets left.
                 * @member {number} left
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @instance
                 */
                EdgeInsets.prototype.left = 0;

                /**
                 * EdgeInsets right.
                 * @member {number} right
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @instance
                 */
                EdgeInsets.prototype.right = 0;

                /**
                 * EdgeInsets top.
                 * @member {number} top
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @instance
                 */
                EdgeInsets.prototype.top = 0;

                /**
                 * EdgeInsets bottom.
                 * @member {number} bottom
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @instance
                 */
                EdgeInsets.prototype.bottom = 0;

                /**
                 * Creates a new EdgeInsets instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @static
                 * @param {rv.data.Graphics.IEdgeInsets=} [properties] Properties to set
                 * @returns {rv.data.Graphics.EdgeInsets} EdgeInsets instance
                 */
                EdgeInsets.create = function create(properties) {
                    return new EdgeInsets(properties);
                };

                /**
                 * Encodes the specified EdgeInsets message. Does not implicitly {@link rv.data.Graphics.EdgeInsets.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @static
                 * @param {rv.data.Graphics.IEdgeInsets} message EdgeInsets message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EdgeInsets.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.left != null && Object.hasOwnProperty.call(message, "left"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.left);
                    if (message.right != null && Object.hasOwnProperty.call(message, "right"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.right);
                    if (message.top != null && Object.hasOwnProperty.call(message, "top"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.top);
                    if (message.bottom != null && Object.hasOwnProperty.call(message, "bottom"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.bottom);
                    return writer;
                };

                /**
                 * Encodes the specified EdgeInsets message, length delimited. Does not implicitly {@link rv.data.Graphics.EdgeInsets.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @static
                 * @param {rv.data.Graphics.IEdgeInsets} message EdgeInsets message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EdgeInsets.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EdgeInsets message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Graphics.EdgeInsets} EdgeInsets
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EdgeInsets.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.EdgeInsets();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.left = reader.double();
                                break;
                            }
                        case 2: {
                                message.right = reader.double();
                                break;
                            }
                        case 3: {
                                message.top = reader.double();
                                break;
                            }
                        case 4: {
                                message.bottom = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EdgeInsets message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Graphics.EdgeInsets} EdgeInsets
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EdgeInsets.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EdgeInsets message.
                 * @function verify
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EdgeInsets.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.left != null && message.hasOwnProperty("left"))
                        if (typeof message.left !== "number")
                            return "left: number expected";
                    if (message.right != null && message.hasOwnProperty("right"))
                        if (typeof message.right !== "number")
                            return "right: number expected";
                    if (message.top != null && message.hasOwnProperty("top"))
                        if (typeof message.top !== "number")
                            return "top: number expected";
                    if (message.bottom != null && message.hasOwnProperty("bottom"))
                        if (typeof message.bottom !== "number")
                            return "bottom: number expected";
                    return null;
                };

                /**
                 * Creates an EdgeInsets message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Graphics.EdgeInsets} EdgeInsets
                 */
                EdgeInsets.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Graphics.EdgeInsets)
                        return object;
                    let message = new $root.rv.data.Graphics.EdgeInsets();
                    if (object.left != null)
                        message.left = Number(object.left);
                    if (object.right != null)
                        message.right = Number(object.right);
                    if (object.top != null)
                        message.top = Number(object.top);
                    if (object.bottom != null)
                        message.bottom = Number(object.bottom);
                    return message;
                };

                /**
                 * Creates a plain object from an EdgeInsets message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @static
                 * @param {rv.data.Graphics.EdgeInsets} message EdgeInsets
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EdgeInsets.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.left = 0;
                        object.right = 0;
                        object.top = 0;
                        object.bottom = 0;
                    }
                    if (message.left != null && message.hasOwnProperty("left"))
                        object.left = options.json && !isFinite(message.left) ? String(message.left) : message.left;
                    if (message.right != null && message.hasOwnProperty("right"))
                        object.right = options.json && !isFinite(message.right) ? String(message.right) : message.right;
                    if (message.top != null && message.hasOwnProperty("top"))
                        object.top = options.json && !isFinite(message.top) ? String(message.top) : message.top;
                    if (message.bottom != null && message.hasOwnProperty("bottom"))
                        object.bottom = options.json && !isFinite(message.bottom) ? String(message.bottom) : message.bottom;
                    return object;
                };

                /**
                 * Converts this EdgeInsets to JSON.
                 * @function toJSON
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EdgeInsets.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for EdgeInsets
                 * @function getTypeUrl
                 * @memberof rv.data.Graphics.EdgeInsets
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EdgeInsets.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Graphics.EdgeInsets";
                };

                return EdgeInsets;
            })();

            Graphics.Path = (function() {

                /**
                 * Properties of a Path.
                 * @memberof rv.data.Graphics
                 * @interface IPath
                 * @property {boolean|null} [closed] Path closed
                 * @property {Array.<rv.data.Graphics.Path.IBezierPoint>|null} [points] Path points
                 * @property {rv.data.Graphics.Path.IShape|null} [shape] Path shape
                 */

                /**
                 * Constructs a new Path.
                 * @memberof rv.data.Graphics
                 * @classdesc Represents a Path.
                 * @implements IPath
                 * @constructor
                 * @param {rv.data.Graphics.IPath=} [properties] Properties to set
                 */
                function Path(properties) {
                    this.points = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Path closed.
                 * @member {boolean} closed
                 * @memberof rv.data.Graphics.Path
                 * @instance
                 */
                Path.prototype.closed = false;

                /**
                 * Path points.
                 * @member {Array.<rv.data.Graphics.Path.IBezierPoint>} points
                 * @memberof rv.data.Graphics.Path
                 * @instance
                 */
                Path.prototype.points = $util.emptyArray;

                /**
                 * Path shape.
                 * @member {rv.data.Graphics.Path.IShape|null|undefined} shape
                 * @memberof rv.data.Graphics.Path
                 * @instance
                 */
                Path.prototype.shape = null;

                /**
                 * Creates a new Path instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Graphics.Path
                 * @static
                 * @param {rv.data.Graphics.IPath=} [properties] Properties to set
                 * @returns {rv.data.Graphics.Path} Path instance
                 */
                Path.create = function create(properties) {
                    return new Path(properties);
                };

                /**
                 * Encodes the specified Path message. Does not implicitly {@link rv.data.Graphics.Path.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Graphics.Path
                 * @static
                 * @param {rv.data.Graphics.IPath} message Path message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Path.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.closed != null && Object.hasOwnProperty.call(message, "closed"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.closed);
                    if (message.points != null && message.points.length)
                        for (let i = 0; i < message.points.length; ++i)
                            $root.rv.data.Graphics.Path.BezierPoint.encode(message.points[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.shape != null && Object.hasOwnProperty.call(message, "shape"))
                        $root.rv.data.Graphics.Path.Shape.encode(message.shape, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Path message, length delimited. Does not implicitly {@link rv.data.Graphics.Path.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Graphics.Path
                 * @static
                 * @param {rv.data.Graphics.IPath} message Path message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Path.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Path message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Graphics.Path
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Graphics.Path} Path
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Path.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Path();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.closed = reader.bool();
                                break;
                            }
                        case 2: {
                                if (!(message.points && message.points.length))
                                    message.points = [];
                                message.points.push($root.rv.data.Graphics.Path.BezierPoint.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                message.shape = $root.rv.data.Graphics.Path.Shape.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Path message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Graphics.Path
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Graphics.Path} Path
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Path.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Path message.
                 * @function verify
                 * @memberof rv.data.Graphics.Path
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Path.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.closed != null && message.hasOwnProperty("closed"))
                        if (typeof message.closed !== "boolean")
                            return "closed: boolean expected";
                    if (message.points != null && message.hasOwnProperty("points")) {
                        if (!Array.isArray(message.points))
                            return "points: array expected";
                        for (let i = 0; i < message.points.length; ++i) {
                            let error = $root.rv.data.Graphics.Path.BezierPoint.verify(message.points[i]);
                            if (error)
                                return "points." + error;
                        }
                    }
                    if (message.shape != null && message.hasOwnProperty("shape")) {
                        let error = $root.rv.data.Graphics.Path.Shape.verify(message.shape);
                        if (error)
                            return "shape." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Path message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Graphics.Path
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Graphics.Path} Path
                 */
                Path.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Graphics.Path)
                        return object;
                    let message = new $root.rv.data.Graphics.Path();
                    if (object.closed != null)
                        message.closed = Boolean(object.closed);
                    if (object.points) {
                        if (!Array.isArray(object.points))
                            throw TypeError(".rv.data.Graphics.Path.points: array expected");
                        message.points = [];
                        for (let i = 0; i < object.points.length; ++i) {
                            if (typeof object.points[i] !== "object")
                                throw TypeError(".rv.data.Graphics.Path.points: object expected");
                            message.points[i] = $root.rv.data.Graphics.Path.BezierPoint.fromObject(object.points[i]);
                        }
                    }
                    if (object.shape != null) {
                        if (typeof object.shape !== "object")
                            throw TypeError(".rv.data.Graphics.Path.shape: object expected");
                        message.shape = $root.rv.data.Graphics.Path.Shape.fromObject(object.shape);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Path message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Graphics.Path
                 * @static
                 * @param {rv.data.Graphics.Path} message Path
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Path.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.points = [];
                    if (options.defaults) {
                        object.closed = false;
                        object.shape = null;
                    }
                    if (message.closed != null && message.hasOwnProperty("closed"))
                        object.closed = message.closed;
                    if (message.points && message.points.length) {
                        object.points = [];
                        for (let j = 0; j < message.points.length; ++j)
                            object.points[j] = $root.rv.data.Graphics.Path.BezierPoint.toObject(message.points[j], options);
                    }
                    if (message.shape != null && message.hasOwnProperty("shape"))
                        object.shape = $root.rv.data.Graphics.Path.Shape.toObject(message.shape, options);
                    return object;
                };

                /**
                 * Converts this Path to JSON.
                 * @function toJSON
                 * @memberof rv.data.Graphics.Path
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Path.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Path
                 * @function getTypeUrl
                 * @memberof rv.data.Graphics.Path
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Path.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Graphics.Path";
                };

                Path.BezierPoint = (function() {

                    /**
                     * Properties of a BezierPoint.
                     * @memberof rv.data.Graphics.Path
                     * @interface IBezierPoint
                     * @property {rv.data.Graphics.IPoint|null} [point] BezierPoint point
                     * @property {rv.data.Graphics.IPoint|null} [q0] BezierPoint q0
                     * @property {rv.data.Graphics.IPoint|null} [q1] BezierPoint q1
                     * @property {boolean|null} [curved] BezierPoint curved
                     */

                    /**
                     * Constructs a new BezierPoint.
                     * @memberof rv.data.Graphics.Path
                     * @classdesc Represents a BezierPoint.
                     * @implements IBezierPoint
                     * @constructor
                     * @param {rv.data.Graphics.Path.IBezierPoint=} [properties] Properties to set
                     */
                    function BezierPoint(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * BezierPoint point.
                     * @member {rv.data.Graphics.IPoint|null|undefined} point
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @instance
                     */
                    BezierPoint.prototype.point = null;

                    /**
                     * BezierPoint q0.
                     * @member {rv.data.Graphics.IPoint|null|undefined} q0
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @instance
                     */
                    BezierPoint.prototype.q0 = null;

                    /**
                     * BezierPoint q1.
                     * @member {rv.data.Graphics.IPoint|null|undefined} q1
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @instance
                     */
                    BezierPoint.prototype.q1 = null;

                    /**
                     * BezierPoint curved.
                     * @member {boolean} curved
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @instance
                     */
                    BezierPoint.prototype.curved = false;

                    /**
                     * Creates a new BezierPoint instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @static
                     * @param {rv.data.Graphics.Path.IBezierPoint=} [properties] Properties to set
                     * @returns {rv.data.Graphics.Path.BezierPoint} BezierPoint instance
                     */
                    BezierPoint.create = function create(properties) {
                        return new BezierPoint(properties);
                    };

                    /**
                     * Encodes the specified BezierPoint message. Does not implicitly {@link rv.data.Graphics.Path.BezierPoint.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @static
                     * @param {rv.data.Graphics.Path.IBezierPoint} message BezierPoint message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BezierPoint.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.point != null && Object.hasOwnProperty.call(message, "point"))
                            $root.rv.data.Graphics.Point.encode(message.point, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.q0 != null && Object.hasOwnProperty.call(message, "q0"))
                            $root.rv.data.Graphics.Point.encode(message.q0, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.q1 != null && Object.hasOwnProperty.call(message, "q1"))
                            $root.rv.data.Graphics.Point.encode(message.q1, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.curved != null && Object.hasOwnProperty.call(message, "curved"))
                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.curved);
                        return writer;
                    };

                    /**
                     * Encodes the specified BezierPoint message, length delimited. Does not implicitly {@link rv.data.Graphics.Path.BezierPoint.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @static
                     * @param {rv.data.Graphics.Path.IBezierPoint} message BezierPoint message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BezierPoint.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a BezierPoint message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Graphics.Path.BezierPoint} BezierPoint
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BezierPoint.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Path.BezierPoint();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.point = $root.rv.data.Graphics.Point.decode(reader, reader.uint32());
                                    break;
                                }
                            case 2: {
                                    message.q0 = $root.rv.data.Graphics.Point.decode(reader, reader.uint32());
                                    break;
                                }
                            case 3: {
                                    message.q1 = $root.rv.data.Graphics.Point.decode(reader, reader.uint32());
                                    break;
                                }
                            case 4: {
                                    message.curved = reader.bool();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a BezierPoint message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Graphics.Path.BezierPoint} BezierPoint
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BezierPoint.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a BezierPoint message.
                     * @function verify
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    BezierPoint.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.point != null && message.hasOwnProperty("point")) {
                            let error = $root.rv.data.Graphics.Point.verify(message.point);
                            if (error)
                                return "point." + error;
                        }
                        if (message.q0 != null && message.hasOwnProperty("q0")) {
                            let error = $root.rv.data.Graphics.Point.verify(message.q0);
                            if (error)
                                return "q0." + error;
                        }
                        if (message.q1 != null && message.hasOwnProperty("q1")) {
                            let error = $root.rv.data.Graphics.Point.verify(message.q1);
                            if (error)
                                return "q1." + error;
                        }
                        if (message.curved != null && message.hasOwnProperty("curved"))
                            if (typeof message.curved !== "boolean")
                                return "curved: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a BezierPoint message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Graphics.Path.BezierPoint} BezierPoint
                     */
                    BezierPoint.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Graphics.Path.BezierPoint)
                            return object;
                        let message = new $root.rv.data.Graphics.Path.BezierPoint();
                        if (object.point != null) {
                            if (typeof object.point !== "object")
                                throw TypeError(".rv.data.Graphics.Path.BezierPoint.point: object expected");
                            message.point = $root.rv.data.Graphics.Point.fromObject(object.point);
                        }
                        if (object.q0 != null) {
                            if (typeof object.q0 !== "object")
                                throw TypeError(".rv.data.Graphics.Path.BezierPoint.q0: object expected");
                            message.q0 = $root.rv.data.Graphics.Point.fromObject(object.q0);
                        }
                        if (object.q1 != null) {
                            if (typeof object.q1 !== "object")
                                throw TypeError(".rv.data.Graphics.Path.BezierPoint.q1: object expected");
                            message.q1 = $root.rv.data.Graphics.Point.fromObject(object.q1);
                        }
                        if (object.curved != null)
                            message.curved = Boolean(object.curved);
                        return message;
                    };

                    /**
                     * Creates a plain object from a BezierPoint message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @static
                     * @param {rv.data.Graphics.Path.BezierPoint} message BezierPoint
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    BezierPoint.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.point = null;
                            object.q0 = null;
                            object.q1 = null;
                            object.curved = false;
                        }
                        if (message.point != null && message.hasOwnProperty("point"))
                            object.point = $root.rv.data.Graphics.Point.toObject(message.point, options);
                        if (message.q0 != null && message.hasOwnProperty("q0"))
                            object.q0 = $root.rv.data.Graphics.Point.toObject(message.q0, options);
                        if (message.q1 != null && message.hasOwnProperty("q1"))
                            object.q1 = $root.rv.data.Graphics.Point.toObject(message.q1, options);
                        if (message.curved != null && message.hasOwnProperty("curved"))
                            object.curved = message.curved;
                        return object;
                    };

                    /**
                     * Converts this BezierPoint to JSON.
                     * @function toJSON
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    BezierPoint.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for BezierPoint
                     * @function getTypeUrl
                     * @memberof rv.data.Graphics.Path.BezierPoint
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    BezierPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Graphics.Path.BezierPoint";
                    };

                    return BezierPoint;
                })();

                Path.Shape = (function() {

                    /**
                     * Properties of a Shape.
                     * @memberof rv.data.Graphics.Path
                     * @interface IShape
                     * @property {rv.data.Graphics.Path.Shape.Type|null} [type] Shape type
                     * @property {rv.data.Graphics.Path.Shape.IRoundedRectangle|null} [roundedRectangle] Shape roundedRectangle
                     * @property {rv.data.Graphics.Path.Shape.IPolygon|null} [polygon] Shape polygon
                     * @property {rv.data.Graphics.Path.Shape.IStar|null} [star] Shape star
                     * @property {rv.data.Graphics.Path.Shape.IArrow|null} [arrow] Shape arrow
                     */

                    /**
                     * Constructs a new Shape.
                     * @memberof rv.data.Graphics.Path
                     * @classdesc Represents a Shape.
                     * @implements IShape
                     * @constructor
                     * @param {rv.data.Graphics.Path.IShape=} [properties] Properties to set
                     */
                    function Shape(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Shape type.
                     * @member {rv.data.Graphics.Path.Shape.Type} type
                     * @memberof rv.data.Graphics.Path.Shape
                     * @instance
                     */
                    Shape.prototype.type = 0;

                    /**
                     * Shape roundedRectangle.
                     * @member {rv.data.Graphics.Path.Shape.IRoundedRectangle|null|undefined} roundedRectangle
                     * @memberof rv.data.Graphics.Path.Shape
                     * @instance
                     */
                    Shape.prototype.roundedRectangle = null;

                    /**
                     * Shape polygon.
                     * @member {rv.data.Graphics.Path.Shape.IPolygon|null|undefined} polygon
                     * @memberof rv.data.Graphics.Path.Shape
                     * @instance
                     */
                    Shape.prototype.polygon = null;

                    /**
                     * Shape star.
                     * @member {rv.data.Graphics.Path.Shape.IStar|null|undefined} star
                     * @memberof rv.data.Graphics.Path.Shape
                     * @instance
                     */
                    Shape.prototype.star = null;

                    /**
                     * Shape arrow.
                     * @member {rv.data.Graphics.Path.Shape.IArrow|null|undefined} arrow
                     * @memberof rv.data.Graphics.Path.Shape
                     * @instance
                     */
                    Shape.prototype.arrow = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Shape AdditionalData.
                     * @member {"roundedRectangle"|"polygon"|"star"|"arrow"|undefined} AdditionalData
                     * @memberof rv.data.Graphics.Path.Shape
                     * @instance
                     */
                    Object.defineProperty(Shape.prototype, "AdditionalData", {
                        get: $util.oneOfGetter($oneOfFields = ["roundedRectangle", "polygon", "star", "arrow"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new Shape instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Graphics.Path.Shape
                     * @static
                     * @param {rv.data.Graphics.Path.IShape=} [properties] Properties to set
                     * @returns {rv.data.Graphics.Path.Shape} Shape instance
                     */
                    Shape.create = function create(properties) {
                        return new Shape(properties);
                    };

                    /**
                     * Encodes the specified Shape message. Does not implicitly {@link rv.data.Graphics.Path.Shape.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Graphics.Path.Shape
                     * @static
                     * @param {rv.data.Graphics.Path.IShape} message Shape message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Shape.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                        if (message.roundedRectangle != null && Object.hasOwnProperty.call(message, "roundedRectangle"))
                            $root.rv.data.Graphics.Path.Shape.RoundedRectangle.encode(message.roundedRectangle, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.polygon != null && Object.hasOwnProperty.call(message, "polygon"))
                            $root.rv.data.Graphics.Path.Shape.Polygon.encode(message.polygon, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.star != null && Object.hasOwnProperty.call(message, "star"))
                            $root.rv.data.Graphics.Path.Shape.Star.encode(message.star, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.arrow != null && Object.hasOwnProperty.call(message, "arrow"))
                            $root.rv.data.Graphics.Path.Shape.Arrow.encode(message.arrow, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Shape message, length delimited. Does not implicitly {@link rv.data.Graphics.Path.Shape.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Graphics.Path.Shape
                     * @static
                     * @param {rv.data.Graphics.Path.IShape} message Shape message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Shape.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Shape message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Graphics.Path.Shape
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Graphics.Path.Shape} Shape
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Shape.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Path.Shape();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.type = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.roundedRectangle = $root.rv.data.Graphics.Path.Shape.RoundedRectangle.decode(reader, reader.uint32());
                                    break;
                                }
                            case 3: {
                                    message.polygon = $root.rv.data.Graphics.Path.Shape.Polygon.decode(reader, reader.uint32());
                                    break;
                                }
                            case 4: {
                                    message.star = $root.rv.data.Graphics.Path.Shape.Star.decode(reader, reader.uint32());
                                    break;
                                }
                            case 5: {
                                    message.arrow = $root.rv.data.Graphics.Path.Shape.Arrow.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Shape message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Graphics.Path.Shape
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Graphics.Path.Shape} Shape
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Shape.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Shape message.
                     * @function verify
                     * @memberof rv.data.Graphics.Path.Shape
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Shape.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.type != null && message.hasOwnProperty("type"))
                            switch (message.type) {
                            default:
                                return "type: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                                break;
                            }
                        if (message.roundedRectangle != null && message.hasOwnProperty("roundedRectangle")) {
                            properties.AdditionalData = 1;
                            {
                                let error = $root.rv.data.Graphics.Path.Shape.RoundedRectangle.verify(message.roundedRectangle);
                                if (error)
                                    return "roundedRectangle." + error;
                            }
                        }
                        if (message.polygon != null && message.hasOwnProperty("polygon")) {
                            if (properties.AdditionalData === 1)
                                return "AdditionalData: multiple values";
                            properties.AdditionalData = 1;
                            {
                                let error = $root.rv.data.Graphics.Path.Shape.Polygon.verify(message.polygon);
                                if (error)
                                    return "polygon." + error;
                            }
                        }
                        if (message.star != null && message.hasOwnProperty("star")) {
                            if (properties.AdditionalData === 1)
                                return "AdditionalData: multiple values";
                            properties.AdditionalData = 1;
                            {
                                let error = $root.rv.data.Graphics.Path.Shape.Star.verify(message.star);
                                if (error)
                                    return "star." + error;
                            }
                        }
                        if (message.arrow != null && message.hasOwnProperty("arrow")) {
                            if (properties.AdditionalData === 1)
                                return "AdditionalData: multiple values";
                            properties.AdditionalData = 1;
                            {
                                let error = $root.rv.data.Graphics.Path.Shape.Arrow.verify(message.arrow);
                                if (error)
                                    return "arrow." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Shape message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Graphics.Path.Shape
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Graphics.Path.Shape} Shape
                     */
                    Shape.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Graphics.Path.Shape)
                            return object;
                        let message = new $root.rv.data.Graphics.Path.Shape();
                        switch (object.type) {
                        default:
                            if (typeof object.type === "number") {
                                message.type = object.type;
                                break;
                            }
                            break;
                        case "TYPE_UNKNOWN":
                        case 0:
                            message.type = 0;
                            break;
                        case "TYPE_RECTANGLE":
                        case 1:
                            message.type = 1;
                            break;
                        case "TYPE_ELLIPSE":
                        case 2:
                            message.type = 2;
                            break;
                        case "TYPE_ISOSCELES_TRIANGLE":
                        case 3:
                            message.type = 3;
                            break;
                        case "TYPE_RIGHT_TRIANGLE":
                        case 4:
                            message.type = 4;
                            break;
                        case "TYPE_RHOMBUS":
                        case 5:
                            message.type = 5;
                            break;
                        case "TYPE_STAR":
                        case 6:
                            message.type = 6;
                            break;
                        case "TYPE_POLYGON":
                        case 7:
                            message.type = 7;
                            break;
                        case "TYPE_CUSTOM":
                        case 8:
                            message.type = 8;
                            break;
                        case "TYPE_RIGHT_ARROW":
                        case 9:
                            message.type = 9;
                            break;
                        case "TYPE_DOUBLE_ARROW":
                        case 10:
                            message.type = 10;
                            break;
                        case "TYPE_ROUNDED_RECTANGLE":
                        case 11:
                            message.type = 11;
                            break;
                        }
                        if (object.roundedRectangle != null) {
                            if (typeof object.roundedRectangle !== "object")
                                throw TypeError(".rv.data.Graphics.Path.Shape.roundedRectangle: object expected");
                            message.roundedRectangle = $root.rv.data.Graphics.Path.Shape.RoundedRectangle.fromObject(object.roundedRectangle);
                        }
                        if (object.polygon != null) {
                            if (typeof object.polygon !== "object")
                                throw TypeError(".rv.data.Graphics.Path.Shape.polygon: object expected");
                            message.polygon = $root.rv.data.Graphics.Path.Shape.Polygon.fromObject(object.polygon);
                        }
                        if (object.star != null) {
                            if (typeof object.star !== "object")
                                throw TypeError(".rv.data.Graphics.Path.Shape.star: object expected");
                            message.star = $root.rv.data.Graphics.Path.Shape.Star.fromObject(object.star);
                        }
                        if (object.arrow != null) {
                            if (typeof object.arrow !== "object")
                                throw TypeError(".rv.data.Graphics.Path.Shape.arrow: object expected");
                            message.arrow = $root.rv.data.Graphics.Path.Shape.Arrow.fromObject(object.arrow);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Shape message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Graphics.Path.Shape
                     * @static
                     * @param {rv.data.Graphics.Path.Shape} message Shape
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Shape.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = options.enums === String ? $root.rv.data.Graphics.Path.Shape.Type[message.type] === undefined ? message.type : $root.rv.data.Graphics.Path.Shape.Type[message.type] : message.type;
                        if (message.roundedRectangle != null && message.hasOwnProperty("roundedRectangle")) {
                            object.roundedRectangle = $root.rv.data.Graphics.Path.Shape.RoundedRectangle.toObject(message.roundedRectangle, options);
                            if (options.oneofs)
                                object.AdditionalData = "roundedRectangle";
                        }
                        if (message.polygon != null && message.hasOwnProperty("polygon")) {
                            object.polygon = $root.rv.data.Graphics.Path.Shape.Polygon.toObject(message.polygon, options);
                            if (options.oneofs)
                                object.AdditionalData = "polygon";
                        }
                        if (message.star != null && message.hasOwnProperty("star")) {
                            object.star = $root.rv.data.Graphics.Path.Shape.Star.toObject(message.star, options);
                            if (options.oneofs)
                                object.AdditionalData = "star";
                        }
                        if (message.arrow != null && message.hasOwnProperty("arrow")) {
                            object.arrow = $root.rv.data.Graphics.Path.Shape.Arrow.toObject(message.arrow, options);
                            if (options.oneofs)
                                object.AdditionalData = "arrow";
                        }
                        return object;
                    };

                    /**
                     * Converts this Shape to JSON.
                     * @function toJSON
                     * @memberof rv.data.Graphics.Path.Shape
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Shape.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Shape
                     * @function getTypeUrl
                     * @memberof rv.data.Graphics.Path.Shape
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Shape.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Graphics.Path.Shape";
                    };

                    Shape.RoundedRectangle = (function() {

                        /**
                         * Properties of a RoundedRectangle.
                         * @memberof rv.data.Graphics.Path.Shape
                         * @interface IRoundedRectangle
                         * @property {number|null} [roundness] RoundedRectangle roundness
                         */

                        /**
                         * Constructs a new RoundedRectangle.
                         * @memberof rv.data.Graphics.Path.Shape
                         * @classdesc Represents a RoundedRectangle.
                         * @implements IRoundedRectangle
                         * @constructor
                         * @param {rv.data.Graphics.Path.Shape.IRoundedRectangle=} [properties] Properties to set
                         */
                        function RoundedRectangle(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * RoundedRectangle roundness.
                         * @member {number} roundness
                         * @memberof rv.data.Graphics.Path.Shape.RoundedRectangle
                         * @instance
                         */
                        RoundedRectangle.prototype.roundness = 0;

                        /**
                         * Creates a new RoundedRectangle instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Graphics.Path.Shape.RoundedRectangle
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.IRoundedRectangle=} [properties] Properties to set
                         * @returns {rv.data.Graphics.Path.Shape.RoundedRectangle} RoundedRectangle instance
                         */
                        RoundedRectangle.create = function create(properties) {
                            return new RoundedRectangle(properties);
                        };

                        /**
                         * Encodes the specified RoundedRectangle message. Does not implicitly {@link rv.data.Graphics.Path.Shape.RoundedRectangle.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Graphics.Path.Shape.RoundedRectangle
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.IRoundedRectangle} message RoundedRectangle message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        RoundedRectangle.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.roundness != null && Object.hasOwnProperty.call(message, "roundness"))
                                writer.uint32(/* id 1, wireType 1 =*/9).double(message.roundness);
                            return writer;
                        };

                        /**
                         * Encodes the specified RoundedRectangle message, length delimited. Does not implicitly {@link rv.data.Graphics.Path.Shape.RoundedRectangle.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Graphics.Path.Shape.RoundedRectangle
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.IRoundedRectangle} message RoundedRectangle message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        RoundedRectangle.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a RoundedRectangle message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Graphics.Path.Shape.RoundedRectangle
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Graphics.Path.Shape.RoundedRectangle} RoundedRectangle
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        RoundedRectangle.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Path.Shape.RoundedRectangle();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.roundness = reader.double();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a RoundedRectangle message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Graphics.Path.Shape.RoundedRectangle
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Graphics.Path.Shape.RoundedRectangle} RoundedRectangle
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        RoundedRectangle.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a RoundedRectangle message.
                         * @function verify
                         * @memberof rv.data.Graphics.Path.Shape.RoundedRectangle
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        RoundedRectangle.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.roundness != null && message.hasOwnProperty("roundness"))
                                if (typeof message.roundness !== "number")
                                    return "roundness: number expected";
                            return null;
                        };

                        /**
                         * Creates a RoundedRectangle message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Graphics.Path.Shape.RoundedRectangle
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Graphics.Path.Shape.RoundedRectangle} RoundedRectangle
                         */
                        RoundedRectangle.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Graphics.Path.Shape.RoundedRectangle)
                                return object;
                            let message = new $root.rv.data.Graphics.Path.Shape.RoundedRectangle();
                            if (object.roundness != null)
                                message.roundness = Number(object.roundness);
                            return message;
                        };

                        /**
                         * Creates a plain object from a RoundedRectangle message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Graphics.Path.Shape.RoundedRectangle
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.RoundedRectangle} message RoundedRectangle
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        RoundedRectangle.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.roundness = 0;
                            if (message.roundness != null && message.hasOwnProperty("roundness"))
                                object.roundness = options.json && !isFinite(message.roundness) ? String(message.roundness) : message.roundness;
                            return object;
                        };

                        /**
                         * Converts this RoundedRectangle to JSON.
                         * @function toJSON
                         * @memberof rv.data.Graphics.Path.Shape.RoundedRectangle
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        RoundedRectangle.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for RoundedRectangle
                         * @function getTypeUrl
                         * @memberof rv.data.Graphics.Path.Shape.RoundedRectangle
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        RoundedRectangle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Graphics.Path.Shape.RoundedRectangle";
                        };

                        return RoundedRectangle;
                    })();

                    Shape.Arrow = (function() {

                        /**
                         * Properties of an Arrow.
                         * @memberof rv.data.Graphics.Path.Shape
                         * @interface IArrow
                         * @property {rv.data.Graphics.IPoint|null} [corner] Arrow corner
                         */

                        /**
                         * Constructs a new Arrow.
                         * @memberof rv.data.Graphics.Path.Shape
                         * @classdesc Represents an Arrow.
                         * @implements IArrow
                         * @constructor
                         * @param {rv.data.Graphics.Path.Shape.IArrow=} [properties] Properties to set
                         */
                        function Arrow(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Arrow corner.
                         * @member {rv.data.Graphics.IPoint|null|undefined} corner
                         * @memberof rv.data.Graphics.Path.Shape.Arrow
                         * @instance
                         */
                        Arrow.prototype.corner = null;

                        /**
                         * Creates a new Arrow instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Graphics.Path.Shape.Arrow
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.IArrow=} [properties] Properties to set
                         * @returns {rv.data.Graphics.Path.Shape.Arrow} Arrow instance
                         */
                        Arrow.create = function create(properties) {
                            return new Arrow(properties);
                        };

                        /**
                         * Encodes the specified Arrow message. Does not implicitly {@link rv.data.Graphics.Path.Shape.Arrow.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Graphics.Path.Shape.Arrow
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.IArrow} message Arrow message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Arrow.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.corner != null && Object.hasOwnProperty.call(message, "corner"))
                                $root.rv.data.Graphics.Point.encode(message.corner, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Arrow message, length delimited. Does not implicitly {@link rv.data.Graphics.Path.Shape.Arrow.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Graphics.Path.Shape.Arrow
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.IArrow} message Arrow message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Arrow.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Arrow message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Graphics.Path.Shape.Arrow
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Graphics.Path.Shape.Arrow} Arrow
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Arrow.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Path.Shape.Arrow();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.corner = $root.rv.data.Graphics.Point.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Arrow message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Graphics.Path.Shape.Arrow
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Graphics.Path.Shape.Arrow} Arrow
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Arrow.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Arrow message.
                         * @function verify
                         * @memberof rv.data.Graphics.Path.Shape.Arrow
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Arrow.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.corner != null && message.hasOwnProperty("corner")) {
                                let error = $root.rv.data.Graphics.Point.verify(message.corner);
                                if (error)
                                    return "corner." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates an Arrow message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Graphics.Path.Shape.Arrow
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Graphics.Path.Shape.Arrow} Arrow
                         */
                        Arrow.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Graphics.Path.Shape.Arrow)
                                return object;
                            let message = new $root.rv.data.Graphics.Path.Shape.Arrow();
                            if (object.corner != null) {
                                if (typeof object.corner !== "object")
                                    throw TypeError(".rv.data.Graphics.Path.Shape.Arrow.corner: object expected");
                                message.corner = $root.rv.data.Graphics.Point.fromObject(object.corner);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an Arrow message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Graphics.Path.Shape.Arrow
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.Arrow} message Arrow
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Arrow.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.corner = null;
                            if (message.corner != null && message.hasOwnProperty("corner"))
                                object.corner = $root.rv.data.Graphics.Point.toObject(message.corner, options);
                            return object;
                        };

                        /**
                         * Converts this Arrow to JSON.
                         * @function toJSON
                         * @memberof rv.data.Graphics.Path.Shape.Arrow
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Arrow.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Arrow
                         * @function getTypeUrl
                         * @memberof rv.data.Graphics.Path.Shape.Arrow
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Arrow.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Graphics.Path.Shape.Arrow";
                        };

                        return Arrow;
                    })();

                    Shape.Polygon = (function() {

                        /**
                         * Properties of a Polygon.
                         * @memberof rv.data.Graphics.Path.Shape
                         * @interface IPolygon
                         * @property {number|null} [numberSides] Polygon numberSides
                         */

                        /**
                         * Constructs a new Polygon.
                         * @memberof rv.data.Graphics.Path.Shape
                         * @classdesc Represents a Polygon.
                         * @implements IPolygon
                         * @constructor
                         * @param {rv.data.Graphics.Path.Shape.IPolygon=} [properties] Properties to set
                         */
                        function Polygon(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Polygon numberSides.
                         * @member {number} numberSides
                         * @memberof rv.data.Graphics.Path.Shape.Polygon
                         * @instance
                         */
                        Polygon.prototype.numberSides = 0;

                        /**
                         * Creates a new Polygon instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Graphics.Path.Shape.Polygon
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.IPolygon=} [properties] Properties to set
                         * @returns {rv.data.Graphics.Path.Shape.Polygon} Polygon instance
                         */
                        Polygon.create = function create(properties) {
                            return new Polygon(properties);
                        };

                        /**
                         * Encodes the specified Polygon message. Does not implicitly {@link rv.data.Graphics.Path.Shape.Polygon.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Graphics.Path.Shape.Polygon
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.IPolygon} message Polygon message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Polygon.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.numberSides != null && Object.hasOwnProperty.call(message, "numberSides"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.numberSides);
                            return writer;
                        };

                        /**
                         * Encodes the specified Polygon message, length delimited. Does not implicitly {@link rv.data.Graphics.Path.Shape.Polygon.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Graphics.Path.Shape.Polygon
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.IPolygon} message Polygon message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Polygon.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Polygon message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Graphics.Path.Shape.Polygon
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Graphics.Path.Shape.Polygon} Polygon
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Polygon.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Path.Shape.Polygon();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.numberSides = reader.uint32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Polygon message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Graphics.Path.Shape.Polygon
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Graphics.Path.Shape.Polygon} Polygon
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Polygon.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Polygon message.
                         * @function verify
                         * @memberof rv.data.Graphics.Path.Shape.Polygon
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Polygon.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.numberSides != null && message.hasOwnProperty("numberSides"))
                                if (!$util.isInteger(message.numberSides))
                                    return "numberSides: integer expected";
                            return null;
                        };

                        /**
                         * Creates a Polygon message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Graphics.Path.Shape.Polygon
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Graphics.Path.Shape.Polygon} Polygon
                         */
                        Polygon.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Graphics.Path.Shape.Polygon)
                                return object;
                            let message = new $root.rv.data.Graphics.Path.Shape.Polygon();
                            if (object.numberSides != null)
                                message.numberSides = object.numberSides >>> 0;
                            return message;
                        };

                        /**
                         * Creates a plain object from a Polygon message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Graphics.Path.Shape.Polygon
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.Polygon} message Polygon
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Polygon.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.numberSides = 0;
                            if (message.numberSides != null && message.hasOwnProperty("numberSides"))
                                object.numberSides = message.numberSides;
                            return object;
                        };

                        /**
                         * Converts this Polygon to JSON.
                         * @function toJSON
                         * @memberof rv.data.Graphics.Path.Shape.Polygon
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Polygon.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Polygon
                         * @function getTypeUrl
                         * @memberof rv.data.Graphics.Path.Shape.Polygon
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Polygon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Graphics.Path.Shape.Polygon";
                        };

                        return Polygon;
                    })();

                    Shape.Star = (function() {

                        /**
                         * Properties of a Star.
                         * @memberof rv.data.Graphics.Path.Shape
                         * @interface IStar
                         * @property {number|null} [innerRadius] Star innerRadius
                         * @property {number|null} [numberPoints] Star numberPoints
                         */

                        /**
                         * Constructs a new Star.
                         * @memberof rv.data.Graphics.Path.Shape
                         * @classdesc Represents a Star.
                         * @implements IStar
                         * @constructor
                         * @param {rv.data.Graphics.Path.Shape.IStar=} [properties] Properties to set
                         */
                        function Star(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Star innerRadius.
                         * @member {number} innerRadius
                         * @memberof rv.data.Graphics.Path.Shape.Star
                         * @instance
                         */
                        Star.prototype.innerRadius = 0;

                        /**
                         * Star numberPoints.
                         * @member {number} numberPoints
                         * @memberof rv.data.Graphics.Path.Shape.Star
                         * @instance
                         */
                        Star.prototype.numberPoints = 0;

                        /**
                         * Creates a new Star instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Graphics.Path.Shape.Star
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.IStar=} [properties] Properties to set
                         * @returns {rv.data.Graphics.Path.Shape.Star} Star instance
                         */
                        Star.create = function create(properties) {
                            return new Star(properties);
                        };

                        /**
                         * Encodes the specified Star message. Does not implicitly {@link rv.data.Graphics.Path.Shape.Star.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Graphics.Path.Shape.Star
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.IStar} message Star message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Star.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.innerRadius != null && Object.hasOwnProperty.call(message, "innerRadius"))
                                writer.uint32(/* id 1, wireType 1 =*/9).double(message.innerRadius);
                            if (message.numberPoints != null && Object.hasOwnProperty.call(message, "numberPoints"))
                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.numberPoints);
                            return writer;
                        };

                        /**
                         * Encodes the specified Star message, length delimited. Does not implicitly {@link rv.data.Graphics.Path.Shape.Star.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Graphics.Path.Shape.Star
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.IStar} message Star message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Star.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Star message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Graphics.Path.Shape.Star
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Graphics.Path.Shape.Star} Star
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Star.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Path.Shape.Star();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.innerRadius = reader.double();
                                        break;
                                    }
                                case 2: {
                                        message.numberPoints = reader.uint32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Star message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Graphics.Path.Shape.Star
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Graphics.Path.Shape.Star} Star
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Star.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Star message.
                         * @function verify
                         * @memberof rv.data.Graphics.Path.Shape.Star
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Star.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.innerRadius != null && message.hasOwnProperty("innerRadius"))
                                if (typeof message.innerRadius !== "number")
                                    return "innerRadius: number expected";
                            if (message.numberPoints != null && message.hasOwnProperty("numberPoints"))
                                if (!$util.isInteger(message.numberPoints))
                                    return "numberPoints: integer expected";
                            return null;
                        };

                        /**
                         * Creates a Star message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Graphics.Path.Shape.Star
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Graphics.Path.Shape.Star} Star
                         */
                        Star.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Graphics.Path.Shape.Star)
                                return object;
                            let message = new $root.rv.data.Graphics.Path.Shape.Star();
                            if (object.innerRadius != null)
                                message.innerRadius = Number(object.innerRadius);
                            if (object.numberPoints != null)
                                message.numberPoints = object.numberPoints >>> 0;
                            return message;
                        };

                        /**
                         * Creates a plain object from a Star message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Graphics.Path.Shape.Star
                         * @static
                         * @param {rv.data.Graphics.Path.Shape.Star} message Star
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Star.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.innerRadius = 0;
                                object.numberPoints = 0;
                            }
                            if (message.innerRadius != null && message.hasOwnProperty("innerRadius"))
                                object.innerRadius = options.json && !isFinite(message.innerRadius) ? String(message.innerRadius) : message.innerRadius;
                            if (message.numberPoints != null && message.hasOwnProperty("numberPoints"))
                                object.numberPoints = message.numberPoints;
                            return object;
                        };

                        /**
                         * Converts this Star to JSON.
                         * @function toJSON
                         * @memberof rv.data.Graphics.Path.Shape.Star
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Star.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Star
                         * @function getTypeUrl
                         * @memberof rv.data.Graphics.Path.Shape.Star
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Star.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Graphics.Path.Shape.Star";
                        };

                        return Star;
                    })();

                    /**
                     * Type enum.
                     * @name rv.data.Graphics.Path.Shape.Type
                     * @enum {number}
                     * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
                     * @property {number} TYPE_RECTANGLE=1 TYPE_RECTANGLE value
                     * @property {number} TYPE_ELLIPSE=2 TYPE_ELLIPSE value
                     * @property {number} TYPE_ISOSCELES_TRIANGLE=3 TYPE_ISOSCELES_TRIANGLE value
                     * @property {number} TYPE_RIGHT_TRIANGLE=4 TYPE_RIGHT_TRIANGLE value
                     * @property {number} TYPE_RHOMBUS=5 TYPE_RHOMBUS value
                     * @property {number} TYPE_STAR=6 TYPE_STAR value
                     * @property {number} TYPE_POLYGON=7 TYPE_POLYGON value
                     * @property {number} TYPE_CUSTOM=8 TYPE_CUSTOM value
                     * @property {number} TYPE_RIGHT_ARROW=9 TYPE_RIGHT_ARROW value
                     * @property {number} TYPE_DOUBLE_ARROW=10 TYPE_DOUBLE_ARROW value
                     * @property {number} TYPE_ROUNDED_RECTANGLE=11 TYPE_ROUNDED_RECTANGLE value
                     */
                    Shape.Type = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
                        values[valuesById[1] = "TYPE_RECTANGLE"] = 1;
                        values[valuesById[2] = "TYPE_ELLIPSE"] = 2;
                        values[valuesById[3] = "TYPE_ISOSCELES_TRIANGLE"] = 3;
                        values[valuesById[4] = "TYPE_RIGHT_TRIANGLE"] = 4;
                        values[valuesById[5] = "TYPE_RHOMBUS"] = 5;
                        values[valuesById[6] = "TYPE_STAR"] = 6;
                        values[valuesById[7] = "TYPE_POLYGON"] = 7;
                        values[valuesById[8] = "TYPE_CUSTOM"] = 8;
                        values[valuesById[9] = "TYPE_RIGHT_ARROW"] = 9;
                        values[valuesById[10] = "TYPE_DOUBLE_ARROW"] = 10;
                        values[valuesById[11] = "TYPE_ROUNDED_RECTANGLE"] = 11;
                        return values;
                    })();

                    return Shape;
                })();

                return Path;
            })();

            Graphics.Fill = (function() {

                /**
                 * Properties of a Fill.
                 * @memberof rv.data.Graphics
                 * @interface IFill
                 * @property {boolean|null} [enable] Fill enable
                 * @property {rv.data.IColor|null} [color] Fill color
                 * @property {rv.data.Graphics.IGradient|null} [gradient] Fill gradient
                 * @property {rv.data.IMedia|null} [media] Fill media
                 * @property {rv.data.Graphics.IBackgroundEffect|null} [backgroundEffect] Fill backgroundEffect
                 */

                /**
                 * Constructs a new Fill.
                 * @memberof rv.data.Graphics
                 * @classdesc Represents a Fill.
                 * @implements IFill
                 * @constructor
                 * @param {rv.data.Graphics.IFill=} [properties] Properties to set
                 */
                function Fill(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Fill enable.
                 * @member {boolean} enable
                 * @memberof rv.data.Graphics.Fill
                 * @instance
                 */
                Fill.prototype.enable = false;

                /**
                 * Fill color.
                 * @member {rv.data.IColor|null|undefined} color
                 * @memberof rv.data.Graphics.Fill
                 * @instance
                 */
                Fill.prototype.color = null;

                /**
                 * Fill gradient.
                 * @member {rv.data.Graphics.IGradient|null|undefined} gradient
                 * @memberof rv.data.Graphics.Fill
                 * @instance
                 */
                Fill.prototype.gradient = null;

                /**
                 * Fill media.
                 * @member {rv.data.IMedia|null|undefined} media
                 * @memberof rv.data.Graphics.Fill
                 * @instance
                 */
                Fill.prototype.media = null;

                /**
                 * Fill backgroundEffect.
                 * @member {rv.data.Graphics.IBackgroundEffect|null|undefined} backgroundEffect
                 * @memberof rv.data.Graphics.Fill
                 * @instance
                 */
                Fill.prototype.backgroundEffect = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Fill FillType.
                 * @member {"color"|"gradient"|"media"|"backgroundEffect"|undefined} FillType
                 * @memberof rv.data.Graphics.Fill
                 * @instance
                 */
                Object.defineProperty(Fill.prototype, "FillType", {
                    get: $util.oneOfGetter($oneOfFields = ["color", "gradient", "media", "backgroundEffect"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Fill instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Graphics.Fill
                 * @static
                 * @param {rv.data.Graphics.IFill=} [properties] Properties to set
                 * @returns {rv.data.Graphics.Fill} Fill instance
                 */
                Fill.create = function create(properties) {
                    return new Fill(properties);
                };

                /**
                 * Encodes the specified Fill message. Does not implicitly {@link rv.data.Graphics.Fill.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Graphics.Fill
                 * @static
                 * @param {rv.data.Graphics.IFill} message Fill message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Fill.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                        $root.rv.data.Color.encode(message.color, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.gradient != null && Object.hasOwnProperty.call(message, "gradient"))
                        $root.rv.data.Graphics.Gradient.encode(message.gradient, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.media != null && Object.hasOwnProperty.call(message, "media"))
                        $root.rv.data.Media.encode(message.media, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enable != null && Object.hasOwnProperty.call(message, "enable"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.enable);
                    if (message.backgroundEffect != null && Object.hasOwnProperty.call(message, "backgroundEffect"))
                        $root.rv.data.Graphics.BackgroundEffect.encode(message.backgroundEffect, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Fill message, length delimited. Does not implicitly {@link rv.data.Graphics.Fill.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Graphics.Fill
                 * @static
                 * @param {rv.data.Graphics.IFill} message Fill message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Fill.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Fill message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Graphics.Fill
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Graphics.Fill} Fill
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Fill.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Fill();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 4: {
                                message.enable = reader.bool();
                                break;
                            }
                        case 1: {
                                message.color = $root.rv.data.Color.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.gradient = $root.rv.data.Graphics.Gradient.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.media = $root.rv.data.Media.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.backgroundEffect = $root.rv.data.Graphics.BackgroundEffect.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Fill message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Graphics.Fill
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Graphics.Fill} Fill
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Fill.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Fill message.
                 * @function verify
                 * @memberof rv.data.Graphics.Fill
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Fill.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.enable != null && message.hasOwnProperty("enable"))
                        if (typeof message.enable !== "boolean")
                            return "enable: boolean expected";
                    if (message.color != null && message.hasOwnProperty("color")) {
                        properties.FillType = 1;
                        {
                            let error = $root.rv.data.Color.verify(message.color);
                            if (error)
                                return "color." + error;
                        }
                    }
                    if (message.gradient != null && message.hasOwnProperty("gradient")) {
                        if (properties.FillType === 1)
                            return "FillType: multiple values";
                        properties.FillType = 1;
                        {
                            let error = $root.rv.data.Graphics.Gradient.verify(message.gradient);
                            if (error)
                                return "gradient." + error;
                        }
                    }
                    if (message.media != null && message.hasOwnProperty("media")) {
                        if (properties.FillType === 1)
                            return "FillType: multiple values";
                        properties.FillType = 1;
                        {
                            let error = $root.rv.data.Media.verify(message.media);
                            if (error)
                                return "media." + error;
                        }
                    }
                    if (message.backgroundEffect != null && message.hasOwnProperty("backgroundEffect")) {
                        if (properties.FillType === 1)
                            return "FillType: multiple values";
                        properties.FillType = 1;
                        {
                            let error = $root.rv.data.Graphics.BackgroundEffect.verify(message.backgroundEffect);
                            if (error)
                                return "backgroundEffect." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Fill message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Graphics.Fill
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Graphics.Fill} Fill
                 */
                Fill.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Graphics.Fill)
                        return object;
                    let message = new $root.rv.data.Graphics.Fill();
                    if (object.enable != null)
                        message.enable = Boolean(object.enable);
                    if (object.color != null) {
                        if (typeof object.color !== "object")
                            throw TypeError(".rv.data.Graphics.Fill.color: object expected");
                        message.color = $root.rv.data.Color.fromObject(object.color);
                    }
                    if (object.gradient != null) {
                        if (typeof object.gradient !== "object")
                            throw TypeError(".rv.data.Graphics.Fill.gradient: object expected");
                        message.gradient = $root.rv.data.Graphics.Gradient.fromObject(object.gradient);
                    }
                    if (object.media != null) {
                        if (typeof object.media !== "object")
                            throw TypeError(".rv.data.Graphics.Fill.media: object expected");
                        message.media = $root.rv.data.Media.fromObject(object.media);
                    }
                    if (object.backgroundEffect != null) {
                        if (typeof object.backgroundEffect !== "object")
                            throw TypeError(".rv.data.Graphics.Fill.backgroundEffect: object expected");
                        message.backgroundEffect = $root.rv.data.Graphics.BackgroundEffect.fromObject(object.backgroundEffect);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Fill message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Graphics.Fill
                 * @static
                 * @param {rv.data.Graphics.Fill} message Fill
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Fill.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.enable = false;
                    if (message.color != null && message.hasOwnProperty("color")) {
                        object.color = $root.rv.data.Color.toObject(message.color, options);
                        if (options.oneofs)
                            object.FillType = "color";
                    }
                    if (message.gradient != null && message.hasOwnProperty("gradient")) {
                        object.gradient = $root.rv.data.Graphics.Gradient.toObject(message.gradient, options);
                        if (options.oneofs)
                            object.FillType = "gradient";
                    }
                    if (message.media != null && message.hasOwnProperty("media")) {
                        object.media = $root.rv.data.Media.toObject(message.media, options);
                        if (options.oneofs)
                            object.FillType = "media";
                    }
                    if (message.enable != null && message.hasOwnProperty("enable"))
                        object.enable = message.enable;
                    if (message.backgroundEffect != null && message.hasOwnProperty("backgroundEffect")) {
                        object.backgroundEffect = $root.rv.data.Graphics.BackgroundEffect.toObject(message.backgroundEffect, options);
                        if (options.oneofs)
                            object.FillType = "backgroundEffect";
                    }
                    return object;
                };

                /**
                 * Converts this Fill to JSON.
                 * @function toJSON
                 * @memberof rv.data.Graphics.Fill
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Fill.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Fill
                 * @function getTypeUrl
                 * @memberof rv.data.Graphics.Fill
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Fill.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Graphics.Fill";
                };

                return Fill;
            })();

            Graphics.BackgroundEffect = (function() {

                /**
                 * Properties of a BackgroundEffect.
                 * @memberof rv.data.Graphics
                 * @interface IBackgroundEffect
                 * @property {rv.data.Graphics.BackgroundEffect.IBackgroundEffectBlur|null} [backgroundBlur] BackgroundEffect backgroundBlur
                 * @property {rv.data.Graphics.BackgroundEffect.IBackgroundEffectInvert|null} [backgroundInvert] BackgroundEffect backgroundInvert
                 */

                /**
                 * Constructs a new BackgroundEffect.
                 * @memberof rv.data.Graphics
                 * @classdesc Represents a BackgroundEffect.
                 * @implements IBackgroundEffect
                 * @constructor
                 * @param {rv.data.Graphics.IBackgroundEffect=} [properties] Properties to set
                 */
                function BackgroundEffect(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BackgroundEffect backgroundBlur.
                 * @member {rv.data.Graphics.BackgroundEffect.IBackgroundEffectBlur|null|undefined} backgroundBlur
                 * @memberof rv.data.Graphics.BackgroundEffect
                 * @instance
                 */
                BackgroundEffect.prototype.backgroundBlur = null;

                /**
                 * BackgroundEffect backgroundInvert.
                 * @member {rv.data.Graphics.BackgroundEffect.IBackgroundEffectInvert|null|undefined} backgroundInvert
                 * @memberof rv.data.Graphics.BackgroundEffect
                 * @instance
                 */
                BackgroundEffect.prototype.backgroundInvert = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * BackgroundEffect EffectType.
                 * @member {"backgroundBlur"|"backgroundInvert"|undefined} EffectType
                 * @memberof rv.data.Graphics.BackgroundEffect
                 * @instance
                 */
                Object.defineProperty(BackgroundEffect.prototype, "EffectType", {
                    get: $util.oneOfGetter($oneOfFields = ["backgroundBlur", "backgroundInvert"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new BackgroundEffect instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Graphics.BackgroundEffect
                 * @static
                 * @param {rv.data.Graphics.IBackgroundEffect=} [properties] Properties to set
                 * @returns {rv.data.Graphics.BackgroundEffect} BackgroundEffect instance
                 */
                BackgroundEffect.create = function create(properties) {
                    return new BackgroundEffect(properties);
                };

                /**
                 * Encodes the specified BackgroundEffect message. Does not implicitly {@link rv.data.Graphics.BackgroundEffect.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Graphics.BackgroundEffect
                 * @static
                 * @param {rv.data.Graphics.IBackgroundEffect} message BackgroundEffect message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BackgroundEffect.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.backgroundBlur != null && Object.hasOwnProperty.call(message, "backgroundBlur"))
                        $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur.encode(message.backgroundBlur, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.backgroundInvert != null && Object.hasOwnProperty.call(message, "backgroundInvert"))
                        $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert.encode(message.backgroundInvert, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified BackgroundEffect message, length delimited. Does not implicitly {@link rv.data.Graphics.BackgroundEffect.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Graphics.BackgroundEffect
                 * @static
                 * @param {rv.data.Graphics.IBackgroundEffect} message BackgroundEffect message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BackgroundEffect.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BackgroundEffect message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Graphics.BackgroundEffect
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Graphics.BackgroundEffect} BackgroundEffect
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BackgroundEffect.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.BackgroundEffect();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2: {
                                message.backgroundBlur = $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.backgroundInvert = $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BackgroundEffect message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Graphics.BackgroundEffect
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Graphics.BackgroundEffect} BackgroundEffect
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BackgroundEffect.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BackgroundEffect message.
                 * @function verify
                 * @memberof rv.data.Graphics.BackgroundEffect
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BackgroundEffect.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.backgroundBlur != null && message.hasOwnProperty("backgroundBlur")) {
                        properties.EffectType = 1;
                        {
                            let error = $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur.verify(message.backgroundBlur);
                            if (error)
                                return "backgroundBlur." + error;
                        }
                    }
                    if (message.backgroundInvert != null && message.hasOwnProperty("backgroundInvert")) {
                        if (properties.EffectType === 1)
                            return "EffectType: multiple values";
                        properties.EffectType = 1;
                        {
                            let error = $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert.verify(message.backgroundInvert);
                            if (error)
                                return "backgroundInvert." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a BackgroundEffect message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Graphics.BackgroundEffect
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Graphics.BackgroundEffect} BackgroundEffect
                 */
                BackgroundEffect.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Graphics.BackgroundEffect)
                        return object;
                    let message = new $root.rv.data.Graphics.BackgroundEffect();
                    if (object.backgroundBlur != null) {
                        if (typeof object.backgroundBlur !== "object")
                            throw TypeError(".rv.data.Graphics.BackgroundEffect.backgroundBlur: object expected");
                        message.backgroundBlur = $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur.fromObject(object.backgroundBlur);
                    }
                    if (object.backgroundInvert != null) {
                        if (typeof object.backgroundInvert !== "object")
                            throw TypeError(".rv.data.Graphics.BackgroundEffect.backgroundInvert: object expected");
                        message.backgroundInvert = $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert.fromObject(object.backgroundInvert);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BackgroundEffect message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Graphics.BackgroundEffect
                 * @static
                 * @param {rv.data.Graphics.BackgroundEffect} message BackgroundEffect
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BackgroundEffect.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.backgroundBlur != null && message.hasOwnProperty("backgroundBlur")) {
                        object.backgroundBlur = $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur.toObject(message.backgroundBlur, options);
                        if (options.oneofs)
                            object.EffectType = "backgroundBlur";
                    }
                    if (message.backgroundInvert != null && message.hasOwnProperty("backgroundInvert")) {
                        object.backgroundInvert = $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert.toObject(message.backgroundInvert, options);
                        if (options.oneofs)
                            object.EffectType = "backgroundInvert";
                    }
                    return object;
                };

                /**
                 * Converts this BackgroundEffect to JSON.
                 * @function toJSON
                 * @memberof rv.data.Graphics.BackgroundEffect
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BackgroundEffect.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BackgroundEffect
                 * @function getTypeUrl
                 * @memberof rv.data.Graphics.BackgroundEffect
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BackgroundEffect.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Graphics.BackgroundEffect";
                };

                BackgroundEffect.BackgroundEffectBlur = (function() {

                    /**
                     * Properties of a BackgroundEffectBlur.
                     * @memberof rv.data.Graphics.BackgroundEffect
                     * @interface IBackgroundEffectBlur
                     * @property {number|null} [saturation] BackgroundEffectBlur saturation
                     * @property {number|null} [blurAmount] BackgroundEffectBlur blurAmount
                     */

                    /**
                     * Constructs a new BackgroundEffectBlur.
                     * @memberof rv.data.Graphics.BackgroundEffect
                     * @classdesc Represents a BackgroundEffectBlur.
                     * @implements IBackgroundEffectBlur
                     * @constructor
                     * @param {rv.data.Graphics.BackgroundEffect.IBackgroundEffectBlur=} [properties] Properties to set
                     */
                    function BackgroundEffectBlur(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * BackgroundEffectBlur saturation.
                     * @member {number} saturation
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur
                     * @instance
                     */
                    BackgroundEffectBlur.prototype.saturation = 0;

                    /**
                     * BackgroundEffectBlur blurAmount.
                     * @member {number} blurAmount
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur
                     * @instance
                     */
                    BackgroundEffectBlur.prototype.blurAmount = 0;

                    /**
                     * Creates a new BackgroundEffectBlur instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur
                     * @static
                     * @param {rv.data.Graphics.BackgroundEffect.IBackgroundEffectBlur=} [properties] Properties to set
                     * @returns {rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur} BackgroundEffectBlur instance
                     */
                    BackgroundEffectBlur.create = function create(properties) {
                        return new BackgroundEffectBlur(properties);
                    };

                    /**
                     * Encodes the specified BackgroundEffectBlur message. Does not implicitly {@link rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur
                     * @static
                     * @param {rv.data.Graphics.BackgroundEffect.IBackgroundEffectBlur} message BackgroundEffectBlur message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BackgroundEffectBlur.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.saturation != null && Object.hasOwnProperty.call(message, "saturation"))
                            writer.uint32(/* id 1, wireType 1 =*/9).double(message.saturation);
                        if (message.blurAmount != null && Object.hasOwnProperty.call(message, "blurAmount"))
                            writer.uint32(/* id 2, wireType 1 =*/17).double(message.blurAmount);
                        return writer;
                    };

                    /**
                     * Encodes the specified BackgroundEffectBlur message, length delimited. Does not implicitly {@link rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur
                     * @static
                     * @param {rv.data.Graphics.BackgroundEffect.IBackgroundEffectBlur} message BackgroundEffectBlur message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BackgroundEffectBlur.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a BackgroundEffectBlur message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur} BackgroundEffectBlur
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BackgroundEffectBlur.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.saturation = reader.double();
                                    break;
                                }
                            case 2: {
                                    message.blurAmount = reader.double();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a BackgroundEffectBlur message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur} BackgroundEffectBlur
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BackgroundEffectBlur.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a BackgroundEffectBlur message.
                     * @function verify
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    BackgroundEffectBlur.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.saturation != null && message.hasOwnProperty("saturation"))
                            if (typeof message.saturation !== "number")
                                return "saturation: number expected";
                        if (message.blurAmount != null && message.hasOwnProperty("blurAmount"))
                            if (typeof message.blurAmount !== "number")
                                return "blurAmount: number expected";
                        return null;
                    };

                    /**
                     * Creates a BackgroundEffectBlur message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur} BackgroundEffectBlur
                     */
                    BackgroundEffectBlur.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur)
                            return object;
                        let message = new $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur();
                        if (object.saturation != null)
                            message.saturation = Number(object.saturation);
                        if (object.blurAmount != null)
                            message.blurAmount = Number(object.blurAmount);
                        return message;
                    };

                    /**
                     * Creates a plain object from a BackgroundEffectBlur message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur
                     * @static
                     * @param {rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur} message BackgroundEffectBlur
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    BackgroundEffectBlur.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.saturation = 0;
                            object.blurAmount = 0;
                        }
                        if (message.saturation != null && message.hasOwnProperty("saturation"))
                            object.saturation = options.json && !isFinite(message.saturation) ? String(message.saturation) : message.saturation;
                        if (message.blurAmount != null && message.hasOwnProperty("blurAmount"))
                            object.blurAmount = options.json && !isFinite(message.blurAmount) ? String(message.blurAmount) : message.blurAmount;
                        return object;
                    };

                    /**
                     * Converts this BackgroundEffectBlur to JSON.
                     * @function toJSON
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    BackgroundEffectBlur.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for BackgroundEffectBlur
                     * @function getTypeUrl
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    BackgroundEffectBlur.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Graphics.BackgroundEffect.BackgroundEffectBlur";
                    };

                    return BackgroundEffectBlur;
                })();

                BackgroundEffect.BackgroundEffectInvert = (function() {

                    /**
                     * Properties of a BackgroundEffectInvert.
                     * @memberof rv.data.Graphics.BackgroundEffect
                     * @interface IBackgroundEffectInvert
                     */

                    /**
                     * Constructs a new BackgroundEffectInvert.
                     * @memberof rv.data.Graphics.BackgroundEffect
                     * @classdesc Represents a BackgroundEffectInvert.
                     * @implements IBackgroundEffectInvert
                     * @constructor
                     * @param {rv.data.Graphics.BackgroundEffect.IBackgroundEffectInvert=} [properties] Properties to set
                     */
                    function BackgroundEffectInvert(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new BackgroundEffectInvert instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert
                     * @static
                     * @param {rv.data.Graphics.BackgroundEffect.IBackgroundEffectInvert=} [properties] Properties to set
                     * @returns {rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert} BackgroundEffectInvert instance
                     */
                    BackgroundEffectInvert.create = function create(properties) {
                        return new BackgroundEffectInvert(properties);
                    };

                    /**
                     * Encodes the specified BackgroundEffectInvert message. Does not implicitly {@link rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert
                     * @static
                     * @param {rv.data.Graphics.BackgroundEffect.IBackgroundEffectInvert} message BackgroundEffectInvert message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BackgroundEffectInvert.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified BackgroundEffectInvert message, length delimited. Does not implicitly {@link rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert
                     * @static
                     * @param {rv.data.Graphics.BackgroundEffect.IBackgroundEffectInvert} message BackgroundEffectInvert message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BackgroundEffectInvert.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a BackgroundEffectInvert message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert} BackgroundEffectInvert
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BackgroundEffectInvert.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a BackgroundEffectInvert message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert} BackgroundEffectInvert
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BackgroundEffectInvert.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a BackgroundEffectInvert message.
                     * @function verify
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    BackgroundEffectInvert.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a BackgroundEffectInvert message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert} BackgroundEffectInvert
                     */
                    BackgroundEffectInvert.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert)
                            return object;
                        return new $root.rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert();
                    };

                    /**
                     * Creates a plain object from a BackgroundEffectInvert message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert
                     * @static
                     * @param {rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert} message BackgroundEffectInvert
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    BackgroundEffectInvert.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this BackgroundEffectInvert to JSON.
                     * @function toJSON
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    BackgroundEffectInvert.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for BackgroundEffectInvert
                     * @function getTypeUrl
                     * @memberof rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    BackgroundEffectInvert.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Graphics.BackgroundEffect.BackgroundEffectInvert";
                    };

                    return BackgroundEffectInvert;
                })();

                return BackgroundEffect;
            })();

            Graphics.Gradient = (function() {

                /**
                 * Properties of a Gradient.
                 * @memberof rv.data.Graphics
                 * @interface IGradient
                 * @property {rv.data.Graphics.Gradient.Type|null} [type] Gradient type
                 * @property {number|null} [angle] Gradient angle
                 * @property {number|null} [length] Gradient length
                 * @property {Array.<rv.data.Graphics.Gradient.IColorStop>|null} [stops] Gradient stops
                 */

                /**
                 * Constructs a new Gradient.
                 * @memberof rv.data.Graphics
                 * @classdesc Represents a Gradient.
                 * @implements IGradient
                 * @constructor
                 * @param {rv.data.Graphics.IGradient=} [properties] Properties to set
                 */
                function Gradient(properties) {
                    this.stops = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Gradient type.
                 * @member {rv.data.Graphics.Gradient.Type} type
                 * @memberof rv.data.Graphics.Gradient
                 * @instance
                 */
                Gradient.prototype.type = 0;

                /**
                 * Gradient angle.
                 * @member {number} angle
                 * @memberof rv.data.Graphics.Gradient
                 * @instance
                 */
                Gradient.prototype.angle = 0;

                /**
                 * Gradient length.
                 * @member {number} length
                 * @memberof rv.data.Graphics.Gradient
                 * @instance
                 */
                Gradient.prototype.length = 0;

                /**
                 * Gradient stops.
                 * @member {Array.<rv.data.Graphics.Gradient.IColorStop>} stops
                 * @memberof rv.data.Graphics.Gradient
                 * @instance
                 */
                Gradient.prototype.stops = $util.emptyArray;

                /**
                 * Creates a new Gradient instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Graphics.Gradient
                 * @static
                 * @param {rv.data.Graphics.IGradient=} [properties] Properties to set
                 * @returns {rv.data.Graphics.Gradient} Gradient instance
                 */
                Gradient.create = function create(properties) {
                    return new Gradient(properties);
                };

                /**
                 * Encodes the specified Gradient message. Does not implicitly {@link rv.data.Graphics.Gradient.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Graphics.Gradient
                 * @static
                 * @param {rv.data.Graphics.IGradient} message Gradient message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Gradient.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.angle);
                    if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.length);
                    if (message.stops != null && message.stops.length)
                        for (let i = 0; i < message.stops.length; ++i)
                            $root.rv.data.Graphics.Gradient.ColorStop.encode(message.stops[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Gradient message, length delimited. Does not implicitly {@link rv.data.Graphics.Gradient.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Graphics.Gradient
                 * @static
                 * @param {rv.data.Graphics.IGradient} message Gradient message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Gradient.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Gradient message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Graphics.Gradient
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Graphics.Gradient} Gradient
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Gradient.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Gradient();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.type = reader.int32();
                                break;
                            }
                        case 2: {
                                message.angle = reader.double();
                                break;
                            }
                        case 3: {
                                message.length = reader.double();
                                break;
                            }
                        case 4: {
                                if (!(message.stops && message.stops.length))
                                    message.stops = [];
                                message.stops.push($root.rv.data.Graphics.Gradient.ColorStop.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Gradient message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Graphics.Gradient
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Graphics.Gradient} Gradient
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Gradient.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Gradient message.
                 * @function verify
                 * @memberof rv.data.Graphics.Gradient
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Gradient.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.angle != null && message.hasOwnProperty("angle"))
                        if (typeof message.angle !== "number")
                            return "angle: number expected";
                    if (message.length != null && message.hasOwnProperty("length"))
                        if (typeof message.length !== "number")
                            return "length: number expected";
                    if (message.stops != null && message.hasOwnProperty("stops")) {
                        if (!Array.isArray(message.stops))
                            return "stops: array expected";
                        for (let i = 0; i < message.stops.length; ++i) {
                            let error = $root.rv.data.Graphics.Gradient.ColorStop.verify(message.stops[i]);
                            if (error)
                                return "stops." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Gradient message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Graphics.Gradient
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Graphics.Gradient} Gradient
                 */
                Gradient.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Graphics.Gradient)
                        return object;
                    let message = new $root.rv.data.Graphics.Gradient();
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "TYPE_LINEAR":
                    case 0:
                        message.type = 0;
                        break;
                    case "TYPE_RADIAL":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_ANGLE":
                    case 2:
                        message.type = 2;
                        break;
                    }
                    if (object.angle != null)
                        message.angle = Number(object.angle);
                    if (object.length != null)
                        message.length = Number(object.length);
                    if (object.stops) {
                        if (!Array.isArray(object.stops))
                            throw TypeError(".rv.data.Graphics.Gradient.stops: array expected");
                        message.stops = [];
                        for (let i = 0; i < object.stops.length; ++i) {
                            if (typeof object.stops[i] !== "object")
                                throw TypeError(".rv.data.Graphics.Gradient.stops: object expected");
                            message.stops[i] = $root.rv.data.Graphics.Gradient.ColorStop.fromObject(object.stops[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Gradient message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Graphics.Gradient
                 * @static
                 * @param {rv.data.Graphics.Gradient} message Gradient
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Gradient.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.stops = [];
                    if (options.defaults) {
                        object.type = options.enums === String ? "TYPE_LINEAR" : 0;
                        object.angle = 0;
                        object.length = 0;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.rv.data.Graphics.Gradient.Type[message.type] === undefined ? message.type : $root.rv.data.Graphics.Gradient.Type[message.type] : message.type;
                    if (message.angle != null && message.hasOwnProperty("angle"))
                        object.angle = options.json && !isFinite(message.angle) ? String(message.angle) : message.angle;
                    if (message.length != null && message.hasOwnProperty("length"))
                        object.length = options.json && !isFinite(message.length) ? String(message.length) : message.length;
                    if (message.stops && message.stops.length) {
                        object.stops = [];
                        for (let j = 0; j < message.stops.length; ++j)
                            object.stops[j] = $root.rv.data.Graphics.Gradient.ColorStop.toObject(message.stops[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Gradient to JSON.
                 * @function toJSON
                 * @memberof rv.data.Graphics.Gradient
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Gradient.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Gradient
                 * @function getTypeUrl
                 * @memberof rv.data.Graphics.Gradient
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Gradient.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Graphics.Gradient";
                };

                Gradient.ColorStop = (function() {

                    /**
                     * Properties of a ColorStop.
                     * @memberof rv.data.Graphics.Gradient
                     * @interface IColorStop
                     * @property {rv.data.IColor|null} [color] ColorStop color
                     * @property {number|null} [position] ColorStop position
                     * @property {number|null} [blendPoint] ColorStop blendPoint
                     */

                    /**
                     * Constructs a new ColorStop.
                     * @memberof rv.data.Graphics.Gradient
                     * @classdesc Represents a ColorStop.
                     * @implements IColorStop
                     * @constructor
                     * @param {rv.data.Graphics.Gradient.IColorStop=} [properties] Properties to set
                     */
                    function ColorStop(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ColorStop color.
                     * @member {rv.data.IColor|null|undefined} color
                     * @memberof rv.data.Graphics.Gradient.ColorStop
                     * @instance
                     */
                    ColorStop.prototype.color = null;

                    /**
                     * ColorStop position.
                     * @member {number} position
                     * @memberof rv.data.Graphics.Gradient.ColorStop
                     * @instance
                     */
                    ColorStop.prototype.position = 0;

                    /**
                     * ColorStop blendPoint.
                     * @member {number} blendPoint
                     * @memberof rv.data.Graphics.Gradient.ColorStop
                     * @instance
                     */
                    ColorStop.prototype.blendPoint = 0;

                    /**
                     * Creates a new ColorStop instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Graphics.Gradient.ColorStop
                     * @static
                     * @param {rv.data.Graphics.Gradient.IColorStop=} [properties] Properties to set
                     * @returns {rv.data.Graphics.Gradient.ColorStop} ColorStop instance
                     */
                    ColorStop.create = function create(properties) {
                        return new ColorStop(properties);
                    };

                    /**
                     * Encodes the specified ColorStop message. Does not implicitly {@link rv.data.Graphics.Gradient.ColorStop.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Graphics.Gradient.ColorStop
                     * @static
                     * @param {rv.data.Graphics.Gradient.IColorStop} message ColorStop message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ColorStop.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                            $root.rv.data.Color.encode(message.color, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                            writer.uint32(/* id 2, wireType 1 =*/17).double(message.position);
                        if (message.blendPoint != null && Object.hasOwnProperty.call(message, "blendPoint"))
                            writer.uint32(/* id 3, wireType 1 =*/25).double(message.blendPoint);
                        return writer;
                    };

                    /**
                     * Encodes the specified ColorStop message, length delimited. Does not implicitly {@link rv.data.Graphics.Gradient.ColorStop.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Graphics.Gradient.ColorStop
                     * @static
                     * @param {rv.data.Graphics.Gradient.IColorStop} message ColorStop message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ColorStop.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ColorStop message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Graphics.Gradient.ColorStop
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Graphics.Gradient.ColorStop} ColorStop
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ColorStop.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Gradient.ColorStop();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.color = $root.rv.data.Color.decode(reader, reader.uint32());
                                    break;
                                }
                            case 2: {
                                    message.position = reader.double();
                                    break;
                                }
                            case 3: {
                                    message.blendPoint = reader.double();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ColorStop message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Graphics.Gradient.ColorStop
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Graphics.Gradient.ColorStop} ColorStop
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ColorStop.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ColorStop message.
                     * @function verify
                     * @memberof rv.data.Graphics.Gradient.ColorStop
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ColorStop.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.color != null && message.hasOwnProperty("color")) {
                            let error = $root.rv.data.Color.verify(message.color);
                            if (error)
                                return "color." + error;
                        }
                        if (message.position != null && message.hasOwnProperty("position"))
                            if (typeof message.position !== "number")
                                return "position: number expected";
                        if (message.blendPoint != null && message.hasOwnProperty("blendPoint"))
                            if (typeof message.blendPoint !== "number")
                                return "blendPoint: number expected";
                        return null;
                    };

                    /**
                     * Creates a ColorStop message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Graphics.Gradient.ColorStop
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Graphics.Gradient.ColorStop} ColorStop
                     */
                    ColorStop.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Graphics.Gradient.ColorStop)
                            return object;
                        let message = new $root.rv.data.Graphics.Gradient.ColorStop();
                        if (object.color != null) {
                            if (typeof object.color !== "object")
                                throw TypeError(".rv.data.Graphics.Gradient.ColorStop.color: object expected");
                            message.color = $root.rv.data.Color.fromObject(object.color);
                        }
                        if (object.position != null)
                            message.position = Number(object.position);
                        if (object.blendPoint != null)
                            message.blendPoint = Number(object.blendPoint);
                        return message;
                    };

                    /**
                     * Creates a plain object from a ColorStop message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Graphics.Gradient.ColorStop
                     * @static
                     * @param {rv.data.Graphics.Gradient.ColorStop} message ColorStop
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ColorStop.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.color = null;
                            object.position = 0;
                            object.blendPoint = 0;
                        }
                        if (message.color != null && message.hasOwnProperty("color"))
                            object.color = $root.rv.data.Color.toObject(message.color, options);
                        if (message.position != null && message.hasOwnProperty("position"))
                            object.position = options.json && !isFinite(message.position) ? String(message.position) : message.position;
                        if (message.blendPoint != null && message.hasOwnProperty("blendPoint"))
                            object.blendPoint = options.json && !isFinite(message.blendPoint) ? String(message.blendPoint) : message.blendPoint;
                        return object;
                    };

                    /**
                     * Converts this ColorStop to JSON.
                     * @function toJSON
                     * @memberof rv.data.Graphics.Gradient.ColorStop
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ColorStop.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ColorStop
                     * @function getTypeUrl
                     * @memberof rv.data.Graphics.Gradient.ColorStop
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ColorStop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Graphics.Gradient.ColorStop";
                    };

                    return ColorStop;
                })();

                /**
                 * Type enum.
                 * @name rv.data.Graphics.Gradient.Type
                 * @enum {number}
                 * @property {number} TYPE_LINEAR=0 TYPE_LINEAR value
                 * @property {number} TYPE_RADIAL=1 TYPE_RADIAL value
                 * @property {number} TYPE_ANGLE=2 TYPE_ANGLE value
                 */
                Gradient.Type = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "TYPE_LINEAR"] = 0;
                    values[valuesById[1] = "TYPE_RADIAL"] = 1;
                    values[valuesById[2] = "TYPE_ANGLE"] = 2;
                    return values;
                })();

                return Gradient;
            })();

            Graphics.Shadow = (function() {

                /**
                 * Properties of a Shadow.
                 * @memberof rv.data.Graphics
                 * @interface IShadow
                 * @property {rv.data.Graphics.Shadow.Style|null} [style] Shadow style
                 * @property {number|null} [angle] Shadow angle
                 * @property {number|null} [offset] Shadow offset
                 * @property {number|null} [radius] Shadow radius
                 * @property {rv.data.IColor|null} [color] Shadow color
                 * @property {number|null} [opacity] Shadow opacity
                 * @property {boolean|null} [enable] Shadow enable
                 */

                /**
                 * Constructs a new Shadow.
                 * @memberof rv.data.Graphics
                 * @classdesc Represents a Shadow.
                 * @implements IShadow
                 * @constructor
                 * @param {rv.data.Graphics.IShadow=} [properties] Properties to set
                 */
                function Shadow(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Shadow style.
                 * @member {rv.data.Graphics.Shadow.Style} style
                 * @memberof rv.data.Graphics.Shadow
                 * @instance
                 */
                Shadow.prototype.style = 0;

                /**
                 * Shadow angle.
                 * @member {number} angle
                 * @memberof rv.data.Graphics.Shadow
                 * @instance
                 */
                Shadow.prototype.angle = 0;

                /**
                 * Shadow offset.
                 * @member {number} offset
                 * @memberof rv.data.Graphics.Shadow
                 * @instance
                 */
                Shadow.prototype.offset = 0;

                /**
                 * Shadow radius.
                 * @member {number} radius
                 * @memberof rv.data.Graphics.Shadow
                 * @instance
                 */
                Shadow.prototype.radius = 0;

                /**
                 * Shadow color.
                 * @member {rv.data.IColor|null|undefined} color
                 * @memberof rv.data.Graphics.Shadow
                 * @instance
                 */
                Shadow.prototype.color = null;

                /**
                 * Shadow opacity.
                 * @member {number} opacity
                 * @memberof rv.data.Graphics.Shadow
                 * @instance
                 */
                Shadow.prototype.opacity = 0;

                /**
                 * Shadow enable.
                 * @member {boolean} enable
                 * @memberof rv.data.Graphics.Shadow
                 * @instance
                 */
                Shadow.prototype.enable = false;

                /**
                 * Creates a new Shadow instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Graphics.Shadow
                 * @static
                 * @param {rv.data.Graphics.IShadow=} [properties] Properties to set
                 * @returns {rv.data.Graphics.Shadow} Shadow instance
                 */
                Shadow.create = function create(properties) {
                    return new Shadow(properties);
                };

                /**
                 * Encodes the specified Shadow message. Does not implicitly {@link rv.data.Graphics.Shadow.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Graphics.Shadow
                 * @static
                 * @param {rv.data.Graphics.IShadow} message Shadow message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Shadow.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.style);
                    if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.angle);
                    if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.offset);
                    if (message.radius != null && Object.hasOwnProperty.call(message, "radius"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.radius);
                    if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                        $root.rv.data.Color.encode(message.color, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.opacity != null && Object.hasOwnProperty.call(message, "opacity"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.opacity);
                    if (message.enable != null && Object.hasOwnProperty.call(message, "enable"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.enable);
                    return writer;
                };

                /**
                 * Encodes the specified Shadow message, length delimited. Does not implicitly {@link rv.data.Graphics.Shadow.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Graphics.Shadow
                 * @static
                 * @param {rv.data.Graphics.IShadow} message Shadow message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Shadow.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Shadow message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Graphics.Shadow
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Graphics.Shadow} Shadow
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Shadow.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Shadow();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.style = reader.int32();
                                break;
                            }
                        case 2: {
                                message.angle = reader.double();
                                break;
                            }
                        case 3: {
                                message.offset = reader.double();
                                break;
                            }
                        case 4: {
                                message.radius = reader.double();
                                break;
                            }
                        case 5: {
                                message.color = $root.rv.data.Color.decode(reader, reader.uint32());
                                break;
                            }
                        case 6: {
                                message.opacity = reader.double();
                                break;
                            }
                        case 7: {
                                message.enable = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Shadow message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Graphics.Shadow
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Graphics.Shadow} Shadow
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Shadow.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Shadow message.
                 * @function verify
                 * @memberof rv.data.Graphics.Shadow
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Shadow.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.style != null && message.hasOwnProperty("style"))
                        switch (message.style) {
                        default:
                            return "style: enum value expected";
                        case 0:
                            break;
                        }
                    if (message.angle != null && message.hasOwnProperty("angle"))
                        if (typeof message.angle !== "number")
                            return "angle: number expected";
                    if (message.offset != null && message.hasOwnProperty("offset"))
                        if (typeof message.offset !== "number")
                            return "offset: number expected";
                    if (message.radius != null && message.hasOwnProperty("radius"))
                        if (typeof message.radius !== "number")
                            return "radius: number expected";
                    if (message.color != null && message.hasOwnProperty("color")) {
                        let error = $root.rv.data.Color.verify(message.color);
                        if (error)
                            return "color." + error;
                    }
                    if (message.opacity != null && message.hasOwnProperty("opacity"))
                        if (typeof message.opacity !== "number")
                            return "opacity: number expected";
                    if (message.enable != null && message.hasOwnProperty("enable"))
                        if (typeof message.enable !== "boolean")
                            return "enable: boolean expected";
                    return null;
                };

                /**
                 * Creates a Shadow message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Graphics.Shadow
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Graphics.Shadow} Shadow
                 */
                Shadow.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Graphics.Shadow)
                        return object;
                    let message = new $root.rv.data.Graphics.Shadow();
                    switch (object.style) {
                    default:
                        if (typeof object.style === "number") {
                            message.style = object.style;
                            break;
                        }
                        break;
                    case "STYLE_DROP":
                    case 0:
                        message.style = 0;
                        break;
                    }
                    if (object.angle != null)
                        message.angle = Number(object.angle);
                    if (object.offset != null)
                        message.offset = Number(object.offset);
                    if (object.radius != null)
                        message.radius = Number(object.radius);
                    if (object.color != null) {
                        if (typeof object.color !== "object")
                            throw TypeError(".rv.data.Graphics.Shadow.color: object expected");
                        message.color = $root.rv.data.Color.fromObject(object.color);
                    }
                    if (object.opacity != null)
                        message.opacity = Number(object.opacity);
                    if (object.enable != null)
                        message.enable = Boolean(object.enable);
                    return message;
                };

                /**
                 * Creates a plain object from a Shadow message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Graphics.Shadow
                 * @static
                 * @param {rv.data.Graphics.Shadow} message Shadow
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Shadow.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.style = options.enums === String ? "STYLE_DROP" : 0;
                        object.angle = 0;
                        object.offset = 0;
                        object.radius = 0;
                        object.color = null;
                        object.opacity = 0;
                        object.enable = false;
                    }
                    if (message.style != null && message.hasOwnProperty("style"))
                        object.style = options.enums === String ? $root.rv.data.Graphics.Shadow.Style[message.style] === undefined ? message.style : $root.rv.data.Graphics.Shadow.Style[message.style] : message.style;
                    if (message.angle != null && message.hasOwnProperty("angle"))
                        object.angle = options.json && !isFinite(message.angle) ? String(message.angle) : message.angle;
                    if (message.offset != null && message.hasOwnProperty("offset"))
                        object.offset = options.json && !isFinite(message.offset) ? String(message.offset) : message.offset;
                    if (message.radius != null && message.hasOwnProperty("radius"))
                        object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
                    if (message.color != null && message.hasOwnProperty("color"))
                        object.color = $root.rv.data.Color.toObject(message.color, options);
                    if (message.opacity != null && message.hasOwnProperty("opacity"))
                        object.opacity = options.json && !isFinite(message.opacity) ? String(message.opacity) : message.opacity;
                    if (message.enable != null && message.hasOwnProperty("enable"))
                        object.enable = message.enable;
                    return object;
                };

                /**
                 * Converts this Shadow to JSON.
                 * @function toJSON
                 * @memberof rv.data.Graphics.Shadow
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Shadow.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Shadow
                 * @function getTypeUrl
                 * @memberof rv.data.Graphics.Shadow
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Shadow.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Graphics.Shadow";
                };

                /**
                 * Style enum.
                 * @name rv.data.Graphics.Shadow.Style
                 * @enum {number}
                 * @property {number} STYLE_DROP=0 STYLE_DROP value
                 */
                Shadow.Style = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STYLE_DROP"] = 0;
                    return values;
                })();

                return Shadow;
            })();

            Graphics.Stroke = (function() {

                /**
                 * Properties of a Stroke.
                 * @memberof rv.data.Graphics
                 * @interface IStroke
                 * @property {rv.data.Graphics.Stroke.Style|null} [style] Stroke style
                 * @property {number|null} [width] Stroke width
                 * @property {rv.data.IColor|null} [color] Stroke color
                 * @property {Array.<number>|null} [pattern] Stroke pattern
                 * @property {boolean|null} [enable] Stroke enable
                 */

                /**
                 * Constructs a new Stroke.
                 * @memberof rv.data.Graphics
                 * @classdesc Represents a Stroke.
                 * @implements IStroke
                 * @constructor
                 * @param {rv.data.Graphics.IStroke=} [properties] Properties to set
                 */
                function Stroke(properties) {
                    this.pattern = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Stroke style.
                 * @member {rv.data.Graphics.Stroke.Style} style
                 * @memberof rv.data.Graphics.Stroke
                 * @instance
                 */
                Stroke.prototype.style = 0;

                /**
                 * Stroke width.
                 * @member {number} width
                 * @memberof rv.data.Graphics.Stroke
                 * @instance
                 */
                Stroke.prototype.width = 0;

                /**
                 * Stroke color.
                 * @member {rv.data.IColor|null|undefined} color
                 * @memberof rv.data.Graphics.Stroke
                 * @instance
                 */
                Stroke.prototype.color = null;

                /**
                 * Stroke pattern.
                 * @member {Array.<number>} pattern
                 * @memberof rv.data.Graphics.Stroke
                 * @instance
                 */
                Stroke.prototype.pattern = $util.emptyArray;

                /**
                 * Stroke enable.
                 * @member {boolean} enable
                 * @memberof rv.data.Graphics.Stroke
                 * @instance
                 */
                Stroke.prototype.enable = false;

                /**
                 * Creates a new Stroke instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Graphics.Stroke
                 * @static
                 * @param {rv.data.Graphics.IStroke=} [properties] Properties to set
                 * @returns {rv.data.Graphics.Stroke} Stroke instance
                 */
                Stroke.create = function create(properties) {
                    return new Stroke(properties);
                };

                /**
                 * Encodes the specified Stroke message. Does not implicitly {@link rv.data.Graphics.Stroke.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Graphics.Stroke
                 * @static
                 * @param {rv.data.Graphics.IStroke} message Stroke message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Stroke.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.style);
                    if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.width);
                    if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                        $root.rv.data.Color.encode(message.color, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.pattern != null && message.pattern.length) {
                        writer.uint32(/* id 4, wireType 2 =*/34).fork();
                        for (let i = 0; i < message.pattern.length; ++i)
                            writer.double(message.pattern[i]);
                        writer.ldelim();
                    }
                    if (message.enable != null && Object.hasOwnProperty.call(message, "enable"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.enable);
                    return writer;
                };

                /**
                 * Encodes the specified Stroke message, length delimited. Does not implicitly {@link rv.data.Graphics.Stroke.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Graphics.Stroke
                 * @static
                 * @param {rv.data.Graphics.IStroke} message Stroke message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Stroke.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Stroke message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Graphics.Stroke
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Graphics.Stroke} Stroke
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Stroke.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Stroke();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.style = reader.int32();
                                break;
                            }
                        case 2: {
                                message.width = reader.double();
                                break;
                            }
                        case 3: {
                                message.color = $root.rv.data.Color.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                if (!(message.pattern && message.pattern.length))
                                    message.pattern = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.pattern.push(reader.double());
                                } else
                                    message.pattern.push(reader.double());
                                break;
                            }
                        case 5: {
                                message.enable = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Stroke message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Graphics.Stroke
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Graphics.Stroke} Stroke
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Stroke.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Stroke message.
                 * @function verify
                 * @memberof rv.data.Graphics.Stroke
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Stroke.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.style != null && message.hasOwnProperty("style"))
                        switch (message.style) {
                        default:
                            return "style: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.width != null && message.hasOwnProperty("width"))
                        if (typeof message.width !== "number")
                            return "width: number expected";
                    if (message.color != null && message.hasOwnProperty("color")) {
                        let error = $root.rv.data.Color.verify(message.color);
                        if (error)
                            return "color." + error;
                    }
                    if (message.pattern != null && message.hasOwnProperty("pattern")) {
                        if (!Array.isArray(message.pattern))
                            return "pattern: array expected";
                        for (let i = 0; i < message.pattern.length; ++i)
                            if (typeof message.pattern[i] !== "number")
                                return "pattern: number[] expected";
                    }
                    if (message.enable != null && message.hasOwnProperty("enable"))
                        if (typeof message.enable !== "boolean")
                            return "enable: boolean expected";
                    return null;
                };

                /**
                 * Creates a Stroke message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Graphics.Stroke
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Graphics.Stroke} Stroke
                 */
                Stroke.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Graphics.Stroke)
                        return object;
                    let message = new $root.rv.data.Graphics.Stroke();
                    switch (object.style) {
                    default:
                        if (typeof object.style === "number") {
                            message.style = object.style;
                            break;
                        }
                        break;
                    case "STYLE_SOLID_LINE":
                    case 0:
                        message.style = 0;
                        break;
                    case "STYLE_SQUARE_DASH":
                    case 1:
                        message.style = 1;
                        break;
                    case "STYLE_SHORT_DASH":
                    case 2:
                        message.style = 2;
                        break;
                    case "STYLE_LONG_DASH":
                    case 3:
                        message.style = 3;
                        break;
                    }
                    if (object.width != null)
                        message.width = Number(object.width);
                    if (object.color != null) {
                        if (typeof object.color !== "object")
                            throw TypeError(".rv.data.Graphics.Stroke.color: object expected");
                        message.color = $root.rv.data.Color.fromObject(object.color);
                    }
                    if (object.pattern) {
                        if (!Array.isArray(object.pattern))
                            throw TypeError(".rv.data.Graphics.Stroke.pattern: array expected");
                        message.pattern = [];
                        for (let i = 0; i < object.pattern.length; ++i)
                            message.pattern[i] = Number(object.pattern[i]);
                    }
                    if (object.enable != null)
                        message.enable = Boolean(object.enable);
                    return message;
                };

                /**
                 * Creates a plain object from a Stroke message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Graphics.Stroke
                 * @static
                 * @param {rv.data.Graphics.Stroke} message Stroke
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Stroke.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.pattern = [];
                    if (options.defaults) {
                        object.style = options.enums === String ? "STYLE_SOLID_LINE" : 0;
                        object.width = 0;
                        object.color = null;
                        object.enable = false;
                    }
                    if (message.style != null && message.hasOwnProperty("style"))
                        object.style = options.enums === String ? $root.rv.data.Graphics.Stroke.Style[message.style] === undefined ? message.style : $root.rv.data.Graphics.Stroke.Style[message.style] : message.style;
                    if (message.width != null && message.hasOwnProperty("width"))
                        object.width = options.json && !isFinite(message.width) ? String(message.width) : message.width;
                    if (message.color != null && message.hasOwnProperty("color"))
                        object.color = $root.rv.data.Color.toObject(message.color, options);
                    if (message.pattern && message.pattern.length) {
                        object.pattern = [];
                        for (let j = 0; j < message.pattern.length; ++j)
                            object.pattern[j] = options.json && !isFinite(message.pattern[j]) ? String(message.pattern[j]) : message.pattern[j];
                    }
                    if (message.enable != null && message.hasOwnProperty("enable"))
                        object.enable = message.enable;
                    return object;
                };

                /**
                 * Converts this Stroke to JSON.
                 * @function toJSON
                 * @memberof rv.data.Graphics.Stroke
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Stroke.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Stroke
                 * @function getTypeUrl
                 * @memberof rv.data.Graphics.Stroke
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Stroke.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Graphics.Stroke";
                };

                /**
                 * Style enum.
                 * @name rv.data.Graphics.Stroke.Style
                 * @enum {number}
                 * @property {number} STYLE_SOLID_LINE=0 STYLE_SOLID_LINE value
                 * @property {number} STYLE_SQUARE_DASH=1 STYLE_SQUARE_DASH value
                 * @property {number} STYLE_SHORT_DASH=2 STYLE_SHORT_DASH value
                 * @property {number} STYLE_LONG_DASH=3 STYLE_LONG_DASH value
                 */
                Stroke.Style = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STYLE_SOLID_LINE"] = 0;
                    values[valuesById[1] = "STYLE_SQUARE_DASH"] = 1;
                    values[valuesById[2] = "STYLE_SHORT_DASH"] = 2;
                    values[valuesById[3] = "STYLE_LONG_DASH"] = 3;
                    return values;
                })();

                return Stroke;
            })();

            Graphics.Feather = (function() {

                /**
                 * Properties of a Feather.
                 * @memberof rv.data.Graphics
                 * @interface IFeather
                 * @property {rv.data.Graphics.Feather.Style|null} [style] Feather style
                 * @property {number|null} [radius] Feather radius
                 * @property {boolean|null} [enable] Feather enable
                 */

                /**
                 * Constructs a new Feather.
                 * @memberof rv.data.Graphics
                 * @classdesc Represents a Feather.
                 * @implements IFeather
                 * @constructor
                 * @param {rv.data.Graphics.IFeather=} [properties] Properties to set
                 */
                function Feather(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Feather style.
                 * @member {rv.data.Graphics.Feather.Style} style
                 * @memberof rv.data.Graphics.Feather
                 * @instance
                 */
                Feather.prototype.style = 0;

                /**
                 * Feather radius.
                 * @member {number} radius
                 * @memberof rv.data.Graphics.Feather
                 * @instance
                 */
                Feather.prototype.radius = 0;

                /**
                 * Feather enable.
                 * @member {boolean} enable
                 * @memberof rv.data.Graphics.Feather
                 * @instance
                 */
                Feather.prototype.enable = false;

                /**
                 * Creates a new Feather instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Graphics.Feather
                 * @static
                 * @param {rv.data.Graphics.IFeather=} [properties] Properties to set
                 * @returns {rv.data.Graphics.Feather} Feather instance
                 */
                Feather.create = function create(properties) {
                    return new Feather(properties);
                };

                /**
                 * Encodes the specified Feather message. Does not implicitly {@link rv.data.Graphics.Feather.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Graphics.Feather
                 * @static
                 * @param {rv.data.Graphics.IFeather} message Feather message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Feather.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.style);
                    if (message.radius != null && Object.hasOwnProperty.call(message, "radius"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.radius);
                    if (message.enable != null && Object.hasOwnProperty.call(message, "enable"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.enable);
                    return writer;
                };

                /**
                 * Encodes the specified Feather message, length delimited. Does not implicitly {@link rv.data.Graphics.Feather.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Graphics.Feather
                 * @static
                 * @param {rv.data.Graphics.IFeather} message Feather message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Feather.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Feather message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Graphics.Feather
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Graphics.Feather} Feather
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Feather.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Feather();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.style = reader.int32();
                                break;
                            }
                        case 2: {
                                message.radius = reader.double();
                                break;
                            }
                        case 3: {
                                message.enable = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Feather message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Graphics.Feather
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Graphics.Feather} Feather
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Feather.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Feather message.
                 * @function verify
                 * @memberof rv.data.Graphics.Feather
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Feather.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.style != null && message.hasOwnProperty("style"))
                        switch (message.style) {
                        default:
                            return "style: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.radius != null && message.hasOwnProperty("radius"))
                        if (typeof message.radius !== "number")
                            return "radius: number expected";
                    if (message.enable != null && message.hasOwnProperty("enable"))
                        if (typeof message.enable !== "boolean")
                            return "enable: boolean expected";
                    return null;
                };

                /**
                 * Creates a Feather message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Graphics.Feather
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Graphics.Feather} Feather
                 */
                Feather.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Graphics.Feather)
                        return object;
                    let message = new $root.rv.data.Graphics.Feather();
                    switch (object.style) {
                    default:
                        if (typeof object.style === "number") {
                            message.style = object.style;
                            break;
                        }
                        break;
                    case "STYLE_INSIDE":
                    case 0:
                        message.style = 0;
                        break;
                    case "STYLE_CENTER":
                    case 1:
                        message.style = 1;
                        break;
                    case "STYLE_OUTSIDE":
                    case 2:
                        message.style = 2;
                        break;
                    }
                    if (object.radius != null)
                        message.radius = Number(object.radius);
                    if (object.enable != null)
                        message.enable = Boolean(object.enable);
                    return message;
                };

                /**
                 * Creates a plain object from a Feather message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Graphics.Feather
                 * @static
                 * @param {rv.data.Graphics.Feather} message Feather
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Feather.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.style = options.enums === String ? "STYLE_INSIDE" : 0;
                        object.radius = 0;
                        object.enable = false;
                    }
                    if (message.style != null && message.hasOwnProperty("style"))
                        object.style = options.enums === String ? $root.rv.data.Graphics.Feather.Style[message.style] === undefined ? message.style : $root.rv.data.Graphics.Feather.Style[message.style] : message.style;
                    if (message.radius != null && message.hasOwnProperty("radius"))
                        object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
                    if (message.enable != null && message.hasOwnProperty("enable"))
                        object.enable = message.enable;
                    return object;
                };

                /**
                 * Converts this Feather to JSON.
                 * @function toJSON
                 * @memberof rv.data.Graphics.Feather
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Feather.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Feather
                 * @function getTypeUrl
                 * @memberof rv.data.Graphics.Feather
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Feather.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Graphics.Feather";
                };

                /**
                 * Style enum.
                 * @name rv.data.Graphics.Feather.Style
                 * @enum {number}
                 * @property {number} STYLE_INSIDE=0 STYLE_INSIDE value
                 * @property {number} STYLE_CENTER=1 STYLE_CENTER value
                 * @property {number} STYLE_OUTSIDE=2 STYLE_OUTSIDE value
                 */
                Feather.Style = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STYLE_INSIDE"] = 0;
                    values[valuesById[1] = "STYLE_CENTER"] = 1;
                    values[valuesById[2] = "STYLE_OUTSIDE"] = 2;
                    return values;
                })();

                return Feather;
            })();

            Graphics.Text = (function() {

                /**
                 * Properties of a Text.
                 * @memberof rv.data.Graphics
                 * @interface IText
                 * @property {rv.data.Graphics.Text.IAttributes|null} [attributes] Text attributes
                 * @property {rv.data.Graphics.IShadow|null} [shadow] Text shadow
                 * @property {Uint8Array|null} [rtfData] Text rtfData
                 * @property {rv.data.Graphics.Text.VerticalAlignment|null} [verticalAlignment] Text verticalAlignment
                 * @property {rv.data.Graphics.Text.ScaleBehavior|null} [scaleBehavior] Text scaleBehavior
                 * @property {rv.data.Graphics.IEdgeInsets|null} [margins] Text margins
                 * @property {boolean|null} [isSuperscriptStandardized] Text isSuperscriptStandardized
                 * @property {rv.data.Graphics.Text.Transform|null} [transform] Text transform
                 * @property {string|null} [transformDelimiter] Text transformDelimiter
                 * @property {rv.data.Graphics.Text.IChordPro|null} [chordPro] Text chordPro
                 */

                /**
                 * Constructs a new Text.
                 * @memberof rv.data.Graphics
                 * @classdesc Represents a Text.
                 * @implements IText
                 * @constructor
                 * @param {rv.data.Graphics.IText=} [properties] Properties to set
                 */
                function Text(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Text attributes.
                 * @member {rv.data.Graphics.Text.IAttributes|null|undefined} attributes
                 * @memberof rv.data.Graphics.Text
                 * @instance
                 */
                Text.prototype.attributes = null;

                /**
                 * Text shadow.
                 * @member {rv.data.Graphics.IShadow|null|undefined} shadow
                 * @memberof rv.data.Graphics.Text
                 * @instance
                 */
                Text.prototype.shadow = null;

                /**
                 * Text rtfData.
                 * @member {Uint8Array} rtfData
                 * @memberof rv.data.Graphics.Text
                 * @instance
                 */
                Text.prototype.rtfData = $util.newBuffer([]);

                /**
                 * Text verticalAlignment.
                 * @member {rv.data.Graphics.Text.VerticalAlignment} verticalAlignment
                 * @memberof rv.data.Graphics.Text
                 * @instance
                 */
                Text.prototype.verticalAlignment = 0;

                /**
                 * Text scaleBehavior.
                 * @member {rv.data.Graphics.Text.ScaleBehavior} scaleBehavior
                 * @memberof rv.data.Graphics.Text
                 * @instance
                 */
                Text.prototype.scaleBehavior = 0;

                /**
                 * Text margins.
                 * @member {rv.data.Graphics.IEdgeInsets|null|undefined} margins
                 * @memberof rv.data.Graphics.Text
                 * @instance
                 */
                Text.prototype.margins = null;

                /**
                 * Text isSuperscriptStandardized.
                 * @member {boolean} isSuperscriptStandardized
                 * @memberof rv.data.Graphics.Text
                 * @instance
                 */
                Text.prototype.isSuperscriptStandardized = false;

                /**
                 * Text transform.
                 * @member {rv.data.Graphics.Text.Transform} transform
                 * @memberof rv.data.Graphics.Text
                 * @instance
                 */
                Text.prototype.transform = 0;

                /**
                 * Text transformDelimiter.
                 * @member {string} transformDelimiter
                 * @memberof rv.data.Graphics.Text
                 * @instance
                 */
                Text.prototype.transformDelimiter = "";

                /**
                 * Text chordPro.
                 * @member {rv.data.Graphics.Text.IChordPro|null|undefined} chordPro
                 * @memberof rv.data.Graphics.Text
                 * @instance
                 */
                Text.prototype.chordPro = null;

                /**
                 * Creates a new Text instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Graphics.Text
                 * @static
                 * @param {rv.data.Graphics.IText=} [properties] Properties to set
                 * @returns {rv.data.Graphics.Text} Text instance
                 */
                Text.create = function create(properties) {
                    return new Text(properties);
                };

                /**
                 * Encodes the specified Text message. Does not implicitly {@link rv.data.Graphics.Text.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Graphics.Text
                 * @static
                 * @param {rv.data.Graphics.IText} message Text message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Text.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                        $root.rv.data.Graphics.Text.Attributes.encode(message.attributes, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.shadow != null && Object.hasOwnProperty.call(message, "shadow"))
                        $root.rv.data.Graphics.Shadow.encode(message.shadow, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.rtfData != null && Object.hasOwnProperty.call(message, "rtfData"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.rtfData);
                    if (message.verticalAlignment != null && Object.hasOwnProperty.call(message, "verticalAlignment"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.verticalAlignment);
                    if (message.scaleBehavior != null && Object.hasOwnProperty.call(message, "scaleBehavior"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.scaleBehavior);
                    if (message.margins != null && Object.hasOwnProperty.call(message, "margins"))
                        $root.rv.data.Graphics.EdgeInsets.encode(message.margins, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.isSuperscriptStandardized != null && Object.hasOwnProperty.call(message, "isSuperscriptStandardized"))
                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isSuperscriptStandardized);
                    if (message.transform != null && Object.hasOwnProperty.call(message, "transform"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.transform);
                    if (message.transformDelimiter != null && Object.hasOwnProperty.call(message, "transformDelimiter"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.transformDelimiter);
                    if (message.chordPro != null && Object.hasOwnProperty.call(message, "chordPro"))
                        $root.rv.data.Graphics.Text.ChordPro.encode(message.chordPro, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Text message, length delimited. Does not implicitly {@link rv.data.Graphics.Text.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Graphics.Text
                 * @static
                 * @param {rv.data.Graphics.IText} message Text message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Text.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Text message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Graphics.Text
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Graphics.Text} Text
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Text.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Text();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 3: {
                                message.attributes = $root.rv.data.Graphics.Text.Attributes.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.shadow = $root.rv.data.Graphics.Shadow.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.rtfData = reader.bytes();
                                break;
                            }
                        case 6: {
                                message.verticalAlignment = reader.int32();
                                break;
                            }
                        case 7: {
                                message.scaleBehavior = reader.int32();
                                break;
                            }
                        case 8: {
                                message.margins = $root.rv.data.Graphics.EdgeInsets.decode(reader, reader.uint32());
                                break;
                            }
                        case 9: {
                                message.isSuperscriptStandardized = reader.bool();
                                break;
                            }
                        case 10: {
                                message.transform = reader.int32();
                                break;
                            }
                        case 11: {
                                message.transformDelimiter = reader.string();
                                break;
                            }
                        case 12: {
                                message.chordPro = $root.rv.data.Graphics.Text.ChordPro.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Text message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Graphics.Text
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Graphics.Text} Text
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Text.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Text message.
                 * @function verify
                 * @memberof rv.data.Graphics.Text
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Text.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.attributes != null && message.hasOwnProperty("attributes")) {
                        let error = $root.rv.data.Graphics.Text.Attributes.verify(message.attributes);
                        if (error)
                            return "attributes." + error;
                    }
                    if (message.shadow != null && message.hasOwnProperty("shadow")) {
                        let error = $root.rv.data.Graphics.Shadow.verify(message.shadow);
                        if (error)
                            return "shadow." + error;
                    }
                    if (message.rtfData != null && message.hasOwnProperty("rtfData"))
                        if (!(message.rtfData && typeof message.rtfData.length === "number" || $util.isString(message.rtfData)))
                            return "rtfData: buffer expected";
                    if (message.verticalAlignment != null && message.hasOwnProperty("verticalAlignment"))
                        switch (message.verticalAlignment) {
                        default:
                            return "verticalAlignment: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.scaleBehavior != null && message.hasOwnProperty("scaleBehavior"))
                        switch (message.scaleBehavior) {
                        default:
                            return "scaleBehavior: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.margins != null && message.hasOwnProperty("margins")) {
                        let error = $root.rv.data.Graphics.EdgeInsets.verify(message.margins);
                        if (error)
                            return "margins." + error;
                    }
                    if (message.isSuperscriptStandardized != null && message.hasOwnProperty("isSuperscriptStandardized"))
                        if (typeof message.isSuperscriptStandardized !== "boolean")
                            return "isSuperscriptStandardized: boolean expected";
                    if (message.transform != null && message.hasOwnProperty("transform"))
                        switch (message.transform) {
                        default:
                            return "transform: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.transformDelimiter != null && message.hasOwnProperty("transformDelimiter"))
                        if (!$util.isString(message.transformDelimiter))
                            return "transformDelimiter: string expected";
                    if (message.chordPro != null && message.hasOwnProperty("chordPro")) {
                        let error = $root.rv.data.Graphics.Text.ChordPro.verify(message.chordPro);
                        if (error)
                            return "chordPro." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Text message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Graphics.Text
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Graphics.Text} Text
                 */
                Text.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Graphics.Text)
                        return object;
                    let message = new $root.rv.data.Graphics.Text();
                    if (object.attributes != null) {
                        if (typeof object.attributes !== "object")
                            throw TypeError(".rv.data.Graphics.Text.attributes: object expected");
                        message.attributes = $root.rv.data.Graphics.Text.Attributes.fromObject(object.attributes);
                    }
                    if (object.shadow != null) {
                        if (typeof object.shadow !== "object")
                            throw TypeError(".rv.data.Graphics.Text.shadow: object expected");
                        message.shadow = $root.rv.data.Graphics.Shadow.fromObject(object.shadow);
                    }
                    if (object.rtfData != null)
                        if (typeof object.rtfData === "string")
                            $util.base64.decode(object.rtfData, message.rtfData = $util.newBuffer($util.base64.length(object.rtfData)), 0);
                        else if (object.rtfData.length >= 0)
                            message.rtfData = object.rtfData;
                    switch (object.verticalAlignment) {
                    default:
                        if (typeof object.verticalAlignment === "number") {
                            message.verticalAlignment = object.verticalAlignment;
                            break;
                        }
                        break;
                    case "VERTICAL_ALIGNMENT_TOP":
                    case 0:
                        message.verticalAlignment = 0;
                        break;
                    case "VERTICAL_ALIGNMENT_MIDDLE":
                    case 1:
                        message.verticalAlignment = 1;
                        break;
                    case "VERTICAL_ALIGNMENT_BOTTOM":
                    case 2:
                        message.verticalAlignment = 2;
                        break;
                    }
                    switch (object.scaleBehavior) {
                    default:
                        if (typeof object.scaleBehavior === "number") {
                            message.scaleBehavior = object.scaleBehavior;
                            break;
                        }
                        break;
                    case "SCALE_BEHAVIOR_NONE":
                    case 0:
                        message.scaleBehavior = 0;
                        break;
                    case "SCALE_BEHAVIOR_ADJUST_CONTAINER_HEIGHT":
                    case 1:
                        message.scaleBehavior = 1;
                        break;
                    case "SCALE_BEHAVIOR_SCALE_FONT_DOWN":
                    case 2:
                        message.scaleBehavior = 2;
                        break;
                    case "SCALE_BEHAVIOR_SCALE_FONT_UP":
                    case 3:
                        message.scaleBehavior = 3;
                        break;
                    case "SCALE_BEHAVIOR_SCALE_FONT_UP_DOWN":
                    case 4:
                        message.scaleBehavior = 4;
                        break;
                    }
                    if (object.margins != null) {
                        if (typeof object.margins !== "object")
                            throw TypeError(".rv.data.Graphics.Text.margins: object expected");
                        message.margins = $root.rv.data.Graphics.EdgeInsets.fromObject(object.margins);
                    }
                    if (object.isSuperscriptStandardized != null)
                        message.isSuperscriptStandardized = Boolean(object.isSuperscriptStandardized);
                    switch (object.transform) {
                    default:
                        if (typeof object.transform === "number") {
                            message.transform = object.transform;
                            break;
                        }
                        break;
                    case "TRANSFORM_NONE":
                    case 0:
                        message.transform = 0;
                        break;
                    case "TRANSFORM_SINGLE_LINE":
                    case 1:
                        message.transform = 1;
                        break;
                    case "TRANSFORM_ONE_WORD_PER_LINE":
                    case 2:
                        message.transform = 2;
                        break;
                    case "TRANSFORM_ONE_CHARACTER_PER_LINE":
                    case 3:
                        message.transform = 3;
                        break;
                    case "TRANSFORM_REPLACE_LINE_RETURNS":
                    case 4:
                        message.transform = 4;
                        break;
                    }
                    if (object.transformDelimiter != null)
                        message.transformDelimiter = String(object.transformDelimiter);
                    if (object.chordPro != null) {
                        if (typeof object.chordPro !== "object")
                            throw TypeError(".rv.data.Graphics.Text.chordPro: object expected");
                        message.chordPro = $root.rv.data.Graphics.Text.ChordPro.fromObject(object.chordPro);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Text message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Graphics.Text
                 * @static
                 * @param {rv.data.Graphics.Text} message Text
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Text.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.attributes = null;
                        object.shadow = null;
                        if (options.bytes === String)
                            object.rtfData = "";
                        else {
                            object.rtfData = [];
                            if (options.bytes !== Array)
                                object.rtfData = $util.newBuffer(object.rtfData);
                        }
                        object.verticalAlignment = options.enums === String ? "VERTICAL_ALIGNMENT_TOP" : 0;
                        object.scaleBehavior = options.enums === String ? "SCALE_BEHAVIOR_NONE" : 0;
                        object.margins = null;
                        object.isSuperscriptStandardized = false;
                        object.transform = options.enums === String ? "TRANSFORM_NONE" : 0;
                        object.transformDelimiter = "";
                        object.chordPro = null;
                    }
                    if (message.attributes != null && message.hasOwnProperty("attributes"))
                        object.attributes = $root.rv.data.Graphics.Text.Attributes.toObject(message.attributes, options);
                    if (message.shadow != null && message.hasOwnProperty("shadow"))
                        object.shadow = $root.rv.data.Graphics.Shadow.toObject(message.shadow, options);
                    if (message.rtfData != null && message.hasOwnProperty("rtfData"))
                        object.rtfData = options.bytes === String ? $util.base64.encode(message.rtfData, 0, message.rtfData.length) : options.bytes === Array ? Array.prototype.slice.call(message.rtfData) : message.rtfData;
                    if (message.verticalAlignment != null && message.hasOwnProperty("verticalAlignment"))
                        object.verticalAlignment = options.enums === String ? $root.rv.data.Graphics.Text.VerticalAlignment[message.verticalAlignment] === undefined ? message.verticalAlignment : $root.rv.data.Graphics.Text.VerticalAlignment[message.verticalAlignment] : message.verticalAlignment;
                    if (message.scaleBehavior != null && message.hasOwnProperty("scaleBehavior"))
                        object.scaleBehavior = options.enums === String ? $root.rv.data.Graphics.Text.ScaleBehavior[message.scaleBehavior] === undefined ? message.scaleBehavior : $root.rv.data.Graphics.Text.ScaleBehavior[message.scaleBehavior] : message.scaleBehavior;
                    if (message.margins != null && message.hasOwnProperty("margins"))
                        object.margins = $root.rv.data.Graphics.EdgeInsets.toObject(message.margins, options);
                    if (message.isSuperscriptStandardized != null && message.hasOwnProperty("isSuperscriptStandardized"))
                        object.isSuperscriptStandardized = message.isSuperscriptStandardized;
                    if (message.transform != null && message.hasOwnProperty("transform"))
                        object.transform = options.enums === String ? $root.rv.data.Graphics.Text.Transform[message.transform] === undefined ? message.transform : $root.rv.data.Graphics.Text.Transform[message.transform] : message.transform;
                    if (message.transformDelimiter != null && message.hasOwnProperty("transformDelimiter"))
                        object.transformDelimiter = message.transformDelimiter;
                    if (message.chordPro != null && message.hasOwnProperty("chordPro"))
                        object.chordPro = $root.rv.data.Graphics.Text.ChordPro.toObject(message.chordPro, options);
                    return object;
                };

                /**
                 * Converts this Text to JSON.
                 * @function toJSON
                 * @memberof rv.data.Graphics.Text
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Text.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Text
                 * @function getTypeUrl
                 * @memberof rv.data.Graphics.Text
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Text.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Graphics.Text";
                };

                Text.LineFillMask = (function() {

                    /**
                     * Properties of a LineFillMask.
                     * @memberof rv.data.Graphics.Text
                     * @interface ILineFillMask
                     * @property {boolean|null} [enabled] LineFillMask enabled
                     * @property {number|null} [heightOffset] LineFillMask heightOffset
                     * @property {number|null} [verticalOffset] LineFillMask verticalOffset
                     * @property {rv.data.Graphics.Text.LineFillMask.LineMaskStyle|null} [maskStyle] LineFillMask maskStyle
                     * @property {number|null} [widthOffset] LineFillMask widthOffset
                     * @property {number|null} [horizontalOffset] LineFillMask horizontalOffset
                     */

                    /**
                     * Constructs a new LineFillMask.
                     * @memberof rv.data.Graphics.Text
                     * @classdesc Represents a LineFillMask.
                     * @implements ILineFillMask
                     * @constructor
                     * @param {rv.data.Graphics.Text.ILineFillMask=} [properties] Properties to set
                     */
                    function LineFillMask(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * LineFillMask enabled.
                     * @member {boolean} enabled
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @instance
                     */
                    LineFillMask.prototype.enabled = false;

                    /**
                     * LineFillMask heightOffset.
                     * @member {number} heightOffset
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @instance
                     */
                    LineFillMask.prototype.heightOffset = 0;

                    /**
                     * LineFillMask verticalOffset.
                     * @member {number} verticalOffset
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @instance
                     */
                    LineFillMask.prototype.verticalOffset = 0;

                    /**
                     * LineFillMask maskStyle.
                     * @member {rv.data.Graphics.Text.LineFillMask.LineMaskStyle} maskStyle
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @instance
                     */
                    LineFillMask.prototype.maskStyle = 0;

                    /**
                     * LineFillMask widthOffset.
                     * @member {number} widthOffset
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @instance
                     */
                    LineFillMask.prototype.widthOffset = 0;

                    /**
                     * LineFillMask horizontalOffset.
                     * @member {number} horizontalOffset
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @instance
                     */
                    LineFillMask.prototype.horizontalOffset = 0;

                    /**
                     * Creates a new LineFillMask instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @static
                     * @param {rv.data.Graphics.Text.ILineFillMask=} [properties] Properties to set
                     * @returns {rv.data.Graphics.Text.LineFillMask} LineFillMask instance
                     */
                    LineFillMask.create = function create(properties) {
                        return new LineFillMask(properties);
                    };

                    /**
                     * Encodes the specified LineFillMask message. Does not implicitly {@link rv.data.Graphics.Text.LineFillMask.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @static
                     * @param {rv.data.Graphics.Text.ILineFillMask} message LineFillMask message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LineFillMask.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                        if (message.heightOffset != null && Object.hasOwnProperty.call(message, "heightOffset"))
                            writer.uint32(/* id 2, wireType 1 =*/17).double(message.heightOffset);
                        if (message.verticalOffset != null && Object.hasOwnProperty.call(message, "verticalOffset"))
                            writer.uint32(/* id 3, wireType 1 =*/25).double(message.verticalOffset);
                        if (message.maskStyle != null && Object.hasOwnProperty.call(message, "maskStyle"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maskStyle);
                        if (message.widthOffset != null && Object.hasOwnProperty.call(message, "widthOffset"))
                            writer.uint32(/* id 5, wireType 1 =*/41).double(message.widthOffset);
                        if (message.horizontalOffset != null && Object.hasOwnProperty.call(message, "horizontalOffset"))
                            writer.uint32(/* id 6, wireType 1 =*/49).double(message.horizontalOffset);
                        return writer;
                    };

                    /**
                     * Encodes the specified LineFillMask message, length delimited. Does not implicitly {@link rv.data.Graphics.Text.LineFillMask.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @static
                     * @param {rv.data.Graphics.Text.ILineFillMask} message LineFillMask message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LineFillMask.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a LineFillMask message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Graphics.Text.LineFillMask} LineFillMask
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LineFillMask.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Text.LineFillMask();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.enabled = reader.bool();
                                    break;
                                }
                            case 2: {
                                    message.heightOffset = reader.double();
                                    break;
                                }
                            case 3: {
                                    message.verticalOffset = reader.double();
                                    break;
                                }
                            case 4: {
                                    message.maskStyle = reader.int32();
                                    break;
                                }
                            case 5: {
                                    message.widthOffset = reader.double();
                                    break;
                                }
                            case 6: {
                                    message.horizontalOffset = reader.double();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a LineFillMask message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Graphics.Text.LineFillMask} LineFillMask
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LineFillMask.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a LineFillMask message.
                     * @function verify
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    LineFillMask.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.enabled != null && message.hasOwnProperty("enabled"))
                            if (typeof message.enabled !== "boolean")
                                return "enabled: boolean expected";
                        if (message.heightOffset != null && message.hasOwnProperty("heightOffset"))
                            if (typeof message.heightOffset !== "number")
                                return "heightOffset: number expected";
                        if (message.verticalOffset != null && message.hasOwnProperty("verticalOffset"))
                            if (typeof message.verticalOffset !== "number")
                                return "verticalOffset: number expected";
                        if (message.maskStyle != null && message.hasOwnProperty("maskStyle"))
                            switch (message.maskStyle) {
                            default:
                                return "maskStyle: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        if (message.widthOffset != null && message.hasOwnProperty("widthOffset"))
                            if (typeof message.widthOffset !== "number")
                                return "widthOffset: number expected";
                        if (message.horizontalOffset != null && message.hasOwnProperty("horizontalOffset"))
                            if (typeof message.horizontalOffset !== "number")
                                return "horizontalOffset: number expected";
                        return null;
                    };

                    /**
                     * Creates a LineFillMask message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Graphics.Text.LineFillMask} LineFillMask
                     */
                    LineFillMask.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Graphics.Text.LineFillMask)
                            return object;
                        let message = new $root.rv.data.Graphics.Text.LineFillMask();
                        if (object.enabled != null)
                            message.enabled = Boolean(object.enabled);
                        if (object.heightOffset != null)
                            message.heightOffset = Number(object.heightOffset);
                        if (object.verticalOffset != null)
                            message.verticalOffset = Number(object.verticalOffset);
                        switch (object.maskStyle) {
                        default:
                            if (typeof object.maskStyle === "number") {
                                message.maskStyle = object.maskStyle;
                                break;
                            }
                            break;
                        case "LINE_MASK_STYLE_FULL_WIDTH":
                        case 0:
                            message.maskStyle = 0;
                            break;
                        case "LINE_MASK_STYLE_LINE_WIDTH":
                        case 1:
                            message.maskStyle = 1;
                            break;
                        case "LINE_MASK_STYLE_MAX_LINE_WIDTH":
                        case 2:
                            message.maskStyle = 2;
                            break;
                        }
                        if (object.widthOffset != null)
                            message.widthOffset = Number(object.widthOffset);
                        if (object.horizontalOffset != null)
                            message.horizontalOffset = Number(object.horizontalOffset);
                        return message;
                    };

                    /**
                     * Creates a plain object from a LineFillMask message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @static
                     * @param {rv.data.Graphics.Text.LineFillMask} message LineFillMask
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    LineFillMask.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.enabled = false;
                            object.heightOffset = 0;
                            object.verticalOffset = 0;
                            object.maskStyle = options.enums === String ? "LINE_MASK_STYLE_FULL_WIDTH" : 0;
                            object.widthOffset = 0;
                            object.horizontalOffset = 0;
                        }
                        if (message.enabled != null && message.hasOwnProperty("enabled"))
                            object.enabled = message.enabled;
                        if (message.heightOffset != null && message.hasOwnProperty("heightOffset"))
                            object.heightOffset = options.json && !isFinite(message.heightOffset) ? String(message.heightOffset) : message.heightOffset;
                        if (message.verticalOffset != null && message.hasOwnProperty("verticalOffset"))
                            object.verticalOffset = options.json && !isFinite(message.verticalOffset) ? String(message.verticalOffset) : message.verticalOffset;
                        if (message.maskStyle != null && message.hasOwnProperty("maskStyle"))
                            object.maskStyle = options.enums === String ? $root.rv.data.Graphics.Text.LineFillMask.LineMaskStyle[message.maskStyle] === undefined ? message.maskStyle : $root.rv.data.Graphics.Text.LineFillMask.LineMaskStyle[message.maskStyle] : message.maskStyle;
                        if (message.widthOffset != null && message.hasOwnProperty("widthOffset"))
                            object.widthOffset = options.json && !isFinite(message.widthOffset) ? String(message.widthOffset) : message.widthOffset;
                        if (message.horizontalOffset != null && message.hasOwnProperty("horizontalOffset"))
                            object.horizontalOffset = options.json && !isFinite(message.horizontalOffset) ? String(message.horizontalOffset) : message.horizontalOffset;
                        return object;
                    };

                    /**
                     * Converts this LineFillMask to JSON.
                     * @function toJSON
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    LineFillMask.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for LineFillMask
                     * @function getTypeUrl
                     * @memberof rv.data.Graphics.Text.LineFillMask
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    LineFillMask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Graphics.Text.LineFillMask";
                    };

                    /**
                     * LineMaskStyle enum.
                     * @name rv.data.Graphics.Text.LineFillMask.LineMaskStyle
                     * @enum {number}
                     * @property {number} LINE_MASK_STYLE_FULL_WIDTH=0 LINE_MASK_STYLE_FULL_WIDTH value
                     * @property {number} LINE_MASK_STYLE_LINE_WIDTH=1 LINE_MASK_STYLE_LINE_WIDTH value
                     * @property {number} LINE_MASK_STYLE_MAX_LINE_WIDTH=2 LINE_MASK_STYLE_MAX_LINE_WIDTH value
                     */
                    LineFillMask.LineMaskStyle = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "LINE_MASK_STYLE_FULL_WIDTH"] = 0;
                        values[valuesById[1] = "LINE_MASK_STYLE_LINE_WIDTH"] = 1;
                        values[valuesById[2] = "LINE_MASK_STYLE_MAX_LINE_WIDTH"] = 2;
                        return values;
                    })();

                    return LineFillMask;
                })();

                Text.GradientFill = (function() {

                    /**
                     * Properties of a GradientFill.
                     * @memberof rv.data.Graphics.Text
                     * @interface IGradientFill
                     * @property {rv.data.Graphics.IGradient|null} [gradient] GradientFill gradient
                     * @property {boolean|null} [stretchToDocumentBounds] GradientFill stretchToDocumentBounds
                     */

                    /**
                     * Constructs a new GradientFill.
                     * @memberof rv.data.Graphics.Text
                     * @classdesc Represents a GradientFill.
                     * @implements IGradientFill
                     * @constructor
                     * @param {rv.data.Graphics.Text.IGradientFill=} [properties] Properties to set
                     */
                    function GradientFill(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GradientFill gradient.
                     * @member {rv.data.Graphics.IGradient|null|undefined} gradient
                     * @memberof rv.data.Graphics.Text.GradientFill
                     * @instance
                     */
                    GradientFill.prototype.gradient = null;

                    /**
                     * GradientFill stretchToDocumentBounds.
                     * @member {boolean} stretchToDocumentBounds
                     * @memberof rv.data.Graphics.Text.GradientFill
                     * @instance
                     */
                    GradientFill.prototype.stretchToDocumentBounds = false;

                    /**
                     * Creates a new GradientFill instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Graphics.Text.GradientFill
                     * @static
                     * @param {rv.data.Graphics.Text.IGradientFill=} [properties] Properties to set
                     * @returns {rv.data.Graphics.Text.GradientFill} GradientFill instance
                     */
                    GradientFill.create = function create(properties) {
                        return new GradientFill(properties);
                    };

                    /**
                     * Encodes the specified GradientFill message. Does not implicitly {@link rv.data.Graphics.Text.GradientFill.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Graphics.Text.GradientFill
                     * @static
                     * @param {rv.data.Graphics.Text.IGradientFill} message GradientFill message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GradientFill.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.gradient != null && Object.hasOwnProperty.call(message, "gradient"))
                            $root.rv.data.Graphics.Gradient.encode(message.gradient, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.stretchToDocumentBounds != null && Object.hasOwnProperty.call(message, "stretchToDocumentBounds"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.stretchToDocumentBounds);
                        return writer;
                    };

                    /**
                     * Encodes the specified GradientFill message, length delimited. Does not implicitly {@link rv.data.Graphics.Text.GradientFill.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Graphics.Text.GradientFill
                     * @static
                     * @param {rv.data.Graphics.Text.IGradientFill} message GradientFill message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GradientFill.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GradientFill message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Graphics.Text.GradientFill
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Graphics.Text.GradientFill} GradientFill
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GradientFill.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Text.GradientFill();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.gradient = $root.rv.data.Graphics.Gradient.decode(reader, reader.uint32());
                                    break;
                                }
                            case 2: {
                                    message.stretchToDocumentBounds = reader.bool();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GradientFill message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Graphics.Text.GradientFill
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Graphics.Text.GradientFill} GradientFill
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GradientFill.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GradientFill message.
                     * @function verify
                     * @memberof rv.data.Graphics.Text.GradientFill
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GradientFill.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.gradient != null && message.hasOwnProperty("gradient")) {
                            let error = $root.rv.data.Graphics.Gradient.verify(message.gradient);
                            if (error)
                                return "gradient." + error;
                        }
                        if (message.stretchToDocumentBounds != null && message.hasOwnProperty("stretchToDocumentBounds"))
                            if (typeof message.stretchToDocumentBounds !== "boolean")
                                return "stretchToDocumentBounds: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a GradientFill message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Graphics.Text.GradientFill
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Graphics.Text.GradientFill} GradientFill
                     */
                    GradientFill.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Graphics.Text.GradientFill)
                            return object;
                        let message = new $root.rv.data.Graphics.Text.GradientFill();
                        if (object.gradient != null) {
                            if (typeof object.gradient !== "object")
                                throw TypeError(".rv.data.Graphics.Text.GradientFill.gradient: object expected");
                            message.gradient = $root.rv.data.Graphics.Gradient.fromObject(object.gradient);
                        }
                        if (object.stretchToDocumentBounds != null)
                            message.stretchToDocumentBounds = Boolean(object.stretchToDocumentBounds);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GradientFill message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Graphics.Text.GradientFill
                     * @static
                     * @param {rv.data.Graphics.Text.GradientFill} message GradientFill
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GradientFill.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.gradient = null;
                            object.stretchToDocumentBounds = false;
                        }
                        if (message.gradient != null && message.hasOwnProperty("gradient"))
                            object.gradient = $root.rv.data.Graphics.Gradient.toObject(message.gradient, options);
                        if (message.stretchToDocumentBounds != null && message.hasOwnProperty("stretchToDocumentBounds"))
                            object.stretchToDocumentBounds = message.stretchToDocumentBounds;
                        return object;
                    };

                    /**
                     * Converts this GradientFill to JSON.
                     * @function toJSON
                     * @memberof rv.data.Graphics.Text.GradientFill
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GradientFill.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for GradientFill
                     * @function getTypeUrl
                     * @memberof rv.data.Graphics.Text.GradientFill
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    GradientFill.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Graphics.Text.GradientFill";
                    };

                    return GradientFill;
                })();

                Text.CutOutFill = (function() {

                    /**
                     * Properties of a CutOutFill.
                     * @memberof rv.data.Graphics.Text
                     * @interface ICutOutFill
                     */

                    /**
                     * Constructs a new CutOutFill.
                     * @memberof rv.data.Graphics.Text
                     * @classdesc Represents a CutOutFill.
                     * @implements ICutOutFill
                     * @constructor
                     * @param {rv.data.Graphics.Text.ICutOutFill=} [properties] Properties to set
                     */
                    function CutOutFill(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new CutOutFill instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Graphics.Text.CutOutFill
                     * @static
                     * @param {rv.data.Graphics.Text.ICutOutFill=} [properties] Properties to set
                     * @returns {rv.data.Graphics.Text.CutOutFill} CutOutFill instance
                     */
                    CutOutFill.create = function create(properties) {
                        return new CutOutFill(properties);
                    };

                    /**
                     * Encodes the specified CutOutFill message. Does not implicitly {@link rv.data.Graphics.Text.CutOutFill.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Graphics.Text.CutOutFill
                     * @static
                     * @param {rv.data.Graphics.Text.ICutOutFill} message CutOutFill message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CutOutFill.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified CutOutFill message, length delimited. Does not implicitly {@link rv.data.Graphics.Text.CutOutFill.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Graphics.Text.CutOutFill
                     * @static
                     * @param {rv.data.Graphics.Text.ICutOutFill} message CutOutFill message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CutOutFill.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CutOutFill message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Graphics.Text.CutOutFill
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Graphics.Text.CutOutFill} CutOutFill
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CutOutFill.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Text.CutOutFill();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CutOutFill message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Graphics.Text.CutOutFill
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Graphics.Text.CutOutFill} CutOutFill
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CutOutFill.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CutOutFill message.
                     * @function verify
                     * @memberof rv.data.Graphics.Text.CutOutFill
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CutOutFill.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a CutOutFill message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Graphics.Text.CutOutFill
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Graphics.Text.CutOutFill} CutOutFill
                     */
                    CutOutFill.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Graphics.Text.CutOutFill)
                            return object;
                        return new $root.rv.data.Graphics.Text.CutOutFill();
                    };

                    /**
                     * Creates a plain object from a CutOutFill message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Graphics.Text.CutOutFill
                     * @static
                     * @param {rv.data.Graphics.Text.CutOutFill} message CutOutFill
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CutOutFill.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this CutOutFill to JSON.
                     * @function toJSON
                     * @memberof rv.data.Graphics.Text.CutOutFill
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CutOutFill.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for CutOutFill
                     * @function getTypeUrl
                     * @memberof rv.data.Graphics.Text.CutOutFill
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    CutOutFill.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Graphics.Text.CutOutFill";
                    };

                    return CutOutFill;
                })();

                Text.MediaFill = (function() {

                    /**
                     * Properties of a MediaFill.
                     * @memberof rv.data.Graphics.Text
                     * @interface IMediaFill
                     * @property {rv.data.IMedia|null} [media] MediaFill media
                     */

                    /**
                     * Constructs a new MediaFill.
                     * @memberof rv.data.Graphics.Text
                     * @classdesc Represents a MediaFill.
                     * @implements IMediaFill
                     * @constructor
                     * @param {rv.data.Graphics.Text.IMediaFill=} [properties] Properties to set
                     */
                    function MediaFill(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MediaFill media.
                     * @member {rv.data.IMedia|null|undefined} media
                     * @memberof rv.data.Graphics.Text.MediaFill
                     * @instance
                     */
                    MediaFill.prototype.media = null;

                    /**
                     * Creates a new MediaFill instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Graphics.Text.MediaFill
                     * @static
                     * @param {rv.data.Graphics.Text.IMediaFill=} [properties] Properties to set
                     * @returns {rv.data.Graphics.Text.MediaFill} MediaFill instance
                     */
                    MediaFill.create = function create(properties) {
                        return new MediaFill(properties);
                    };

                    /**
                     * Encodes the specified MediaFill message. Does not implicitly {@link rv.data.Graphics.Text.MediaFill.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Graphics.Text.MediaFill
                     * @static
                     * @param {rv.data.Graphics.Text.IMediaFill} message MediaFill message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MediaFill.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.media != null && Object.hasOwnProperty.call(message, "media"))
                            $root.rv.data.Media.encode(message.media, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified MediaFill message, length delimited. Does not implicitly {@link rv.data.Graphics.Text.MediaFill.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Graphics.Text.MediaFill
                     * @static
                     * @param {rv.data.Graphics.Text.IMediaFill} message MediaFill message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MediaFill.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MediaFill message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Graphics.Text.MediaFill
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Graphics.Text.MediaFill} MediaFill
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MediaFill.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Text.MediaFill();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.media = $root.rv.data.Media.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a MediaFill message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Graphics.Text.MediaFill
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Graphics.Text.MediaFill} MediaFill
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MediaFill.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MediaFill message.
                     * @function verify
                     * @memberof rv.data.Graphics.Text.MediaFill
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MediaFill.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.media != null && message.hasOwnProperty("media")) {
                            let error = $root.rv.data.Media.verify(message.media);
                            if (error)
                                return "media." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a MediaFill message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Graphics.Text.MediaFill
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Graphics.Text.MediaFill} MediaFill
                     */
                    MediaFill.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Graphics.Text.MediaFill)
                            return object;
                        let message = new $root.rv.data.Graphics.Text.MediaFill();
                        if (object.media != null) {
                            if (typeof object.media !== "object")
                                throw TypeError(".rv.data.Graphics.Text.MediaFill.media: object expected");
                            message.media = $root.rv.data.Media.fromObject(object.media);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a MediaFill message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Graphics.Text.MediaFill
                     * @static
                     * @param {rv.data.Graphics.Text.MediaFill} message MediaFill
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MediaFill.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.media = null;
                        if (message.media != null && message.hasOwnProperty("media"))
                            object.media = $root.rv.data.Media.toObject(message.media, options);
                        return object;
                    };

                    /**
                     * Converts this MediaFill to JSON.
                     * @function toJSON
                     * @memberof rv.data.Graphics.Text.MediaFill
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MediaFill.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for MediaFill
                     * @function getTypeUrl
                     * @memberof rv.data.Graphics.Text.MediaFill
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    MediaFill.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Graphics.Text.MediaFill";
                    };

                    return MediaFill;
                })();

                Text.ChordPro = (function() {

                    /**
                     * Properties of a ChordPro.
                     * @memberof rv.data.Graphics.Text
                     * @interface IChordPro
                     * @property {boolean|null} [enabled] ChordPro enabled
                     * @property {rv.data.Graphics.Text.ChordPro.Notation|null} [notation] ChordPro notation
                     * @property {rv.data.IColor|null} [color] ChordPro color
                     */

                    /**
                     * Constructs a new ChordPro.
                     * @memberof rv.data.Graphics.Text
                     * @classdesc Represents a ChordPro.
                     * @implements IChordPro
                     * @constructor
                     * @param {rv.data.Graphics.Text.IChordPro=} [properties] Properties to set
                     */
                    function ChordPro(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ChordPro enabled.
                     * @member {boolean} enabled
                     * @memberof rv.data.Graphics.Text.ChordPro
                     * @instance
                     */
                    ChordPro.prototype.enabled = false;

                    /**
                     * ChordPro notation.
                     * @member {rv.data.Graphics.Text.ChordPro.Notation} notation
                     * @memberof rv.data.Graphics.Text.ChordPro
                     * @instance
                     */
                    ChordPro.prototype.notation = 0;

                    /**
                     * ChordPro color.
                     * @member {rv.data.IColor|null|undefined} color
                     * @memberof rv.data.Graphics.Text.ChordPro
                     * @instance
                     */
                    ChordPro.prototype.color = null;

                    /**
                     * Creates a new ChordPro instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Graphics.Text.ChordPro
                     * @static
                     * @param {rv.data.Graphics.Text.IChordPro=} [properties] Properties to set
                     * @returns {rv.data.Graphics.Text.ChordPro} ChordPro instance
                     */
                    ChordPro.create = function create(properties) {
                        return new ChordPro(properties);
                    };

                    /**
                     * Encodes the specified ChordPro message. Does not implicitly {@link rv.data.Graphics.Text.ChordPro.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Graphics.Text.ChordPro
                     * @static
                     * @param {rv.data.Graphics.Text.IChordPro} message ChordPro message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChordPro.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                        if (message.notation != null && Object.hasOwnProperty.call(message, "notation"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.notation);
                        if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                            $root.rv.data.Color.encode(message.color, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ChordPro message, length delimited. Does not implicitly {@link rv.data.Graphics.Text.ChordPro.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Graphics.Text.ChordPro
                     * @static
                     * @param {rv.data.Graphics.Text.IChordPro} message ChordPro message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChordPro.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChordPro message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Graphics.Text.ChordPro
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Graphics.Text.ChordPro} ChordPro
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChordPro.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Text.ChordPro();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.enabled = reader.bool();
                                    break;
                                }
                            case 2: {
                                    message.notation = reader.int32();
                                    break;
                                }
                            case 3: {
                                    message.color = $root.rv.data.Color.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChordPro message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Graphics.Text.ChordPro
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Graphics.Text.ChordPro} ChordPro
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChordPro.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChordPro message.
                     * @function verify
                     * @memberof rv.data.Graphics.Text.ChordPro
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChordPro.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.enabled != null && message.hasOwnProperty("enabled"))
                            if (typeof message.enabled !== "boolean")
                                return "enabled: boolean expected";
                        if (message.notation != null && message.hasOwnProperty("notation"))
                            switch (message.notation) {
                            default:
                                return "notation: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.color != null && message.hasOwnProperty("color")) {
                            let error = $root.rv.data.Color.verify(message.color);
                            if (error)
                                return "color." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a ChordPro message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Graphics.Text.ChordPro
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Graphics.Text.ChordPro} ChordPro
                     */
                    ChordPro.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Graphics.Text.ChordPro)
                            return object;
                        let message = new $root.rv.data.Graphics.Text.ChordPro();
                        if (object.enabled != null)
                            message.enabled = Boolean(object.enabled);
                        switch (object.notation) {
                        default:
                            if (typeof object.notation === "number") {
                                message.notation = object.notation;
                                break;
                            }
                            break;
                        case "NOTATION_CHORDS":
                        case 0:
                            message.notation = 0;
                            break;
                        case "NOTATION_NUMBERS":
                        case 1:
                            message.notation = 1;
                            break;
                        case "NOTATION_NUMERALS":
                        case 2:
                            message.notation = 2;
                            break;
                        case "NOTATION_DO_RE_MI":
                        case 3:
                            message.notation = 3;
                            break;
                        }
                        if (object.color != null) {
                            if (typeof object.color !== "object")
                                throw TypeError(".rv.data.Graphics.Text.ChordPro.color: object expected");
                            message.color = $root.rv.data.Color.fromObject(object.color);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ChordPro message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Graphics.Text.ChordPro
                     * @static
                     * @param {rv.data.Graphics.Text.ChordPro} message ChordPro
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChordPro.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.enabled = false;
                            object.notation = options.enums === String ? "NOTATION_CHORDS" : 0;
                            object.color = null;
                        }
                        if (message.enabled != null && message.hasOwnProperty("enabled"))
                            object.enabled = message.enabled;
                        if (message.notation != null && message.hasOwnProperty("notation"))
                            object.notation = options.enums === String ? $root.rv.data.Graphics.Text.ChordPro.Notation[message.notation] === undefined ? message.notation : $root.rv.data.Graphics.Text.ChordPro.Notation[message.notation] : message.notation;
                        if (message.color != null && message.hasOwnProperty("color"))
                            object.color = $root.rv.data.Color.toObject(message.color, options);
                        return object;
                    };

                    /**
                     * Converts this ChordPro to JSON.
                     * @function toJSON
                     * @memberof rv.data.Graphics.Text.ChordPro
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChordPro.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ChordPro
                     * @function getTypeUrl
                     * @memberof rv.data.Graphics.Text.ChordPro
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ChordPro.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Graphics.Text.ChordPro";
                    };

                    /**
                     * Notation enum.
                     * @name rv.data.Graphics.Text.ChordPro.Notation
                     * @enum {number}
                     * @property {number} NOTATION_CHORDS=0 NOTATION_CHORDS value
                     * @property {number} NOTATION_NUMBERS=1 NOTATION_NUMBERS value
                     * @property {number} NOTATION_NUMERALS=2 NOTATION_NUMERALS value
                     * @property {number} NOTATION_DO_RE_MI=3 NOTATION_DO_RE_MI value
                     */
                    ChordPro.Notation = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "NOTATION_CHORDS"] = 0;
                        values[valuesById[1] = "NOTATION_NUMBERS"] = 1;
                        values[valuesById[2] = "NOTATION_NUMERALS"] = 2;
                        values[valuesById[3] = "NOTATION_DO_RE_MI"] = 3;
                        return values;
                    })();

                    return ChordPro;
                })();

                Text.Attributes = (function() {

                    /**
                     * Properties of an Attributes.
                     * @memberof rv.data.Graphics.Text
                     * @interface IAttributes
                     * @property {rv.data.IFont|null} [font] Attributes font
                     * @property {rv.data.Graphics.Text.Attributes.Capitalization|null} [capitalization] Attributes capitalization
                     * @property {rv.data.Graphics.Text.Attributes.IUnderline|null} [underlineStyle] Attributes underlineStyle
                     * @property {rv.data.IColor|null} [underlineColor] Attributes underlineColor
                     * @property {rv.data.Graphics.Text.Attributes.IParagraph|null} [paragraphStyle] Attributes paragraphStyle
                     * @property {number|null} [kerning] Attributes kerning
                     * @property {number|null} [superscript] Attributes superscript
                     * @property {rv.data.Graphics.Text.Attributes.IUnderline|null} [strikethroughStyle] Attributes strikethroughStyle
                     * @property {rv.data.IColor|null} [strikethroughColor] Attributes strikethroughColor
                     * @property {number|null} [strokeWidth] Attributes strokeWidth
                     * @property {rv.data.IColor|null} [strokeColor] Attributes strokeColor
                     * @property {Array.<rv.data.Graphics.Text.Attributes.ICustomAttribute>|null} [customAttributes] Attributes customAttributes
                     * @property {rv.data.IColor|null} [backgroundColor] Attributes backgroundColor
                     * @property {rv.data.IColor|null} [textSolidFill] Attributes textSolidFill
                     * @property {rv.data.Graphics.Text.IGradientFill|null} [textGradientFill] Attributes textGradientFill
                     * @property {rv.data.Graphics.Text.ICutOutFill|null} [cutOutFill] Attributes cutOutFill
                     * @property {rv.data.Graphics.Text.IMediaFill|null} [mediaFill] Attributes mediaFill
                     * @property {rv.data.Graphics.IBackgroundEffect|null} [backgroundEffect] Attributes backgroundEffect
                     */

                    /**
                     * Constructs a new Attributes.
                     * @memberof rv.data.Graphics.Text
                     * @classdesc Represents an Attributes.
                     * @implements IAttributes
                     * @constructor
                     * @param {rv.data.Graphics.Text.IAttributes=} [properties] Properties to set
                     */
                    function Attributes(properties) {
                        this.customAttributes = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Attributes font.
                     * @member {rv.data.IFont|null|undefined} font
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.font = null;

                    /**
                     * Attributes capitalization.
                     * @member {rv.data.Graphics.Text.Attributes.Capitalization} capitalization
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.capitalization = 0;

                    /**
                     * Attributes underlineStyle.
                     * @member {rv.data.Graphics.Text.Attributes.IUnderline|null|undefined} underlineStyle
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.underlineStyle = null;

                    /**
                     * Attributes underlineColor.
                     * @member {rv.data.IColor|null|undefined} underlineColor
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.underlineColor = null;

                    /**
                     * Attributes paragraphStyle.
                     * @member {rv.data.Graphics.Text.Attributes.IParagraph|null|undefined} paragraphStyle
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.paragraphStyle = null;

                    /**
                     * Attributes kerning.
                     * @member {number} kerning
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.kerning = 0;

                    /**
                     * Attributes superscript.
                     * @member {number} superscript
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.superscript = 0;

                    /**
                     * Attributes strikethroughStyle.
                     * @member {rv.data.Graphics.Text.Attributes.IUnderline|null|undefined} strikethroughStyle
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.strikethroughStyle = null;

                    /**
                     * Attributes strikethroughColor.
                     * @member {rv.data.IColor|null|undefined} strikethroughColor
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.strikethroughColor = null;

                    /**
                     * Attributes strokeWidth.
                     * @member {number} strokeWidth
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.strokeWidth = 0;

                    /**
                     * Attributes strokeColor.
                     * @member {rv.data.IColor|null|undefined} strokeColor
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.strokeColor = null;

                    /**
                     * Attributes customAttributes.
                     * @member {Array.<rv.data.Graphics.Text.Attributes.ICustomAttribute>} customAttributes
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.customAttributes = $util.emptyArray;

                    /**
                     * Attributes backgroundColor.
                     * @member {rv.data.IColor|null|undefined} backgroundColor
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.backgroundColor = null;

                    /**
                     * Attributes textSolidFill.
                     * @member {rv.data.IColor|null|undefined} textSolidFill
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.textSolidFill = null;

                    /**
                     * Attributes textGradientFill.
                     * @member {rv.data.Graphics.Text.IGradientFill|null|undefined} textGradientFill
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.textGradientFill = null;

                    /**
                     * Attributes cutOutFill.
                     * @member {rv.data.Graphics.Text.ICutOutFill|null|undefined} cutOutFill
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.cutOutFill = null;

                    /**
                     * Attributes mediaFill.
                     * @member {rv.data.Graphics.Text.IMediaFill|null|undefined} mediaFill
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.mediaFill = null;

                    /**
                     * Attributes backgroundEffect.
                     * @member {rv.data.Graphics.IBackgroundEffect|null|undefined} backgroundEffect
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Attributes.prototype.backgroundEffect = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Attributes fill.
                     * @member {"textSolidFill"|"textGradientFill"|"cutOutFill"|"mediaFill"|"backgroundEffect"|undefined} fill
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     */
                    Object.defineProperty(Attributes.prototype, "fill", {
                        get: $util.oneOfGetter($oneOfFields = ["textSolidFill", "textGradientFill", "cutOutFill", "mediaFill", "backgroundEffect"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new Attributes instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @static
                     * @param {rv.data.Graphics.Text.IAttributes=} [properties] Properties to set
                     * @returns {rv.data.Graphics.Text.Attributes} Attributes instance
                     */
                    Attributes.create = function create(properties) {
                        return new Attributes(properties);
                    };

                    /**
                     * Encodes the specified Attributes message. Does not implicitly {@link rv.data.Graphics.Text.Attributes.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @static
                     * @param {rv.data.Graphics.Text.IAttributes} message Attributes message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Attributes.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.font != null && Object.hasOwnProperty.call(message, "font"))
                            $root.rv.data.Font.encode(message.font, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.capitalization != null && Object.hasOwnProperty.call(message, "capitalization"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.capitalization);
                        if (message.textSolidFill != null && Object.hasOwnProperty.call(message, "textSolidFill"))
                            $root.rv.data.Color.encode(message.textSolidFill, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.underlineStyle != null && Object.hasOwnProperty.call(message, "underlineStyle"))
                            $root.rv.data.Graphics.Text.Attributes.Underline.encode(message.underlineStyle, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.underlineColor != null && Object.hasOwnProperty.call(message, "underlineColor"))
                            $root.rv.data.Color.encode(message.underlineColor, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.paragraphStyle != null && Object.hasOwnProperty.call(message, "paragraphStyle"))
                            $root.rv.data.Graphics.Text.Attributes.Paragraph.encode(message.paragraphStyle, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.kerning != null && Object.hasOwnProperty.call(message, "kerning"))
                            writer.uint32(/* id 7, wireType 1 =*/57).double(message.kerning);
                        if (message.superscript != null && Object.hasOwnProperty.call(message, "superscript"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.superscript);
                        if (message.strikethroughStyle != null && Object.hasOwnProperty.call(message, "strikethroughStyle"))
                            $root.rv.data.Graphics.Text.Attributes.Underline.encode(message.strikethroughStyle, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.strikethroughColor != null && Object.hasOwnProperty.call(message, "strikethroughColor"))
                            $root.rv.data.Color.encode(message.strikethroughColor, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.strokeWidth != null && Object.hasOwnProperty.call(message, "strokeWidth"))
                            writer.uint32(/* id 11, wireType 1 =*/89).double(message.strokeWidth);
                        if (message.strokeColor != null && Object.hasOwnProperty.call(message, "strokeColor"))
                            $root.rv.data.Color.encode(message.strokeColor, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        if (message.customAttributes != null && message.customAttributes.length)
                            for (let i = 0; i < message.customAttributes.length; ++i)
                                $root.rv.data.Graphics.Text.Attributes.CustomAttribute.encode(message.customAttributes[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                        if (message.textGradientFill != null && Object.hasOwnProperty.call(message, "textGradientFill"))
                            $root.rv.data.Graphics.Text.GradientFill.encode(message.textGradientFill, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                        if (message.backgroundColor != null && Object.hasOwnProperty.call(message, "backgroundColor"))
                            $root.rv.data.Color.encode(message.backgroundColor, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                        if (message.cutOutFill != null && Object.hasOwnProperty.call(message, "cutOutFill"))
                            $root.rv.data.Graphics.Text.CutOutFill.encode(message.cutOutFill, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                        if (message.mediaFill != null && Object.hasOwnProperty.call(message, "mediaFill"))
                            $root.rv.data.Graphics.Text.MediaFill.encode(message.mediaFill, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                        if (message.backgroundEffect != null && Object.hasOwnProperty.call(message, "backgroundEffect"))
                            $root.rv.data.Graphics.BackgroundEffect.encode(message.backgroundEffect, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Attributes message, length delimited. Does not implicitly {@link rv.data.Graphics.Text.Attributes.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @static
                     * @param {rv.data.Graphics.Text.IAttributes} message Attributes message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Attributes.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Attributes message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Graphics.Text.Attributes} Attributes
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Attributes.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Text.Attributes();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.font = $root.rv.data.Font.decode(reader, reader.uint32());
                                    break;
                                }
                            case 2: {
                                    message.capitalization = reader.int32();
                                    break;
                                }
                            case 4: {
                                    message.underlineStyle = $root.rv.data.Graphics.Text.Attributes.Underline.decode(reader, reader.uint32());
                                    break;
                                }
                            case 5: {
                                    message.underlineColor = $root.rv.data.Color.decode(reader, reader.uint32());
                                    break;
                                }
                            case 6: {
                                    message.paragraphStyle = $root.rv.data.Graphics.Text.Attributes.Paragraph.decode(reader, reader.uint32());
                                    break;
                                }
                            case 7: {
                                    message.kerning = reader.double();
                                    break;
                                }
                            case 8: {
                                    message.superscript = reader.int32();
                                    break;
                                }
                            case 9: {
                                    message.strikethroughStyle = $root.rv.data.Graphics.Text.Attributes.Underline.decode(reader, reader.uint32());
                                    break;
                                }
                            case 10: {
                                    message.strikethroughColor = $root.rv.data.Color.decode(reader, reader.uint32());
                                    break;
                                }
                            case 11: {
                                    message.strokeWidth = reader.double();
                                    break;
                                }
                            case 12: {
                                    message.strokeColor = $root.rv.data.Color.decode(reader, reader.uint32());
                                    break;
                                }
                            case 13: {
                                    if (!(message.customAttributes && message.customAttributes.length))
                                        message.customAttributes = [];
                                    message.customAttributes.push($root.rv.data.Graphics.Text.Attributes.CustomAttribute.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 15: {
                                    message.backgroundColor = $root.rv.data.Color.decode(reader, reader.uint32());
                                    break;
                                }
                            case 3: {
                                    message.textSolidFill = $root.rv.data.Color.decode(reader, reader.uint32());
                                    break;
                                }
                            case 14: {
                                    message.textGradientFill = $root.rv.data.Graphics.Text.GradientFill.decode(reader, reader.uint32());
                                    break;
                                }
                            case 16: {
                                    message.cutOutFill = $root.rv.data.Graphics.Text.CutOutFill.decode(reader, reader.uint32());
                                    break;
                                }
                            case 17: {
                                    message.mediaFill = $root.rv.data.Graphics.Text.MediaFill.decode(reader, reader.uint32());
                                    break;
                                }
                            case 18: {
                                    message.backgroundEffect = $root.rv.data.Graphics.BackgroundEffect.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Attributes message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Graphics.Text.Attributes} Attributes
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Attributes.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Attributes message.
                     * @function verify
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Attributes.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.font != null && message.hasOwnProperty("font")) {
                            let error = $root.rv.data.Font.verify(message.font);
                            if (error)
                                return "font." + error;
                        }
                        if (message.capitalization != null && message.hasOwnProperty("capitalization"))
                            switch (message.capitalization) {
                            default:
                                return "capitalization: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                        if (message.underlineStyle != null && message.hasOwnProperty("underlineStyle")) {
                            let error = $root.rv.data.Graphics.Text.Attributes.Underline.verify(message.underlineStyle);
                            if (error)
                                return "underlineStyle." + error;
                        }
                        if (message.underlineColor != null && message.hasOwnProperty("underlineColor")) {
                            let error = $root.rv.data.Color.verify(message.underlineColor);
                            if (error)
                                return "underlineColor." + error;
                        }
                        if (message.paragraphStyle != null && message.hasOwnProperty("paragraphStyle")) {
                            let error = $root.rv.data.Graphics.Text.Attributes.Paragraph.verify(message.paragraphStyle);
                            if (error)
                                return "paragraphStyle." + error;
                        }
                        if (message.kerning != null && message.hasOwnProperty("kerning"))
                            if (typeof message.kerning !== "number")
                                return "kerning: number expected";
                        if (message.superscript != null && message.hasOwnProperty("superscript"))
                            if (!$util.isInteger(message.superscript))
                                return "superscript: integer expected";
                        if (message.strikethroughStyle != null && message.hasOwnProperty("strikethroughStyle")) {
                            let error = $root.rv.data.Graphics.Text.Attributes.Underline.verify(message.strikethroughStyle);
                            if (error)
                                return "strikethroughStyle." + error;
                        }
                        if (message.strikethroughColor != null && message.hasOwnProperty("strikethroughColor")) {
                            let error = $root.rv.data.Color.verify(message.strikethroughColor);
                            if (error)
                                return "strikethroughColor." + error;
                        }
                        if (message.strokeWidth != null && message.hasOwnProperty("strokeWidth"))
                            if (typeof message.strokeWidth !== "number")
                                return "strokeWidth: number expected";
                        if (message.strokeColor != null && message.hasOwnProperty("strokeColor")) {
                            let error = $root.rv.data.Color.verify(message.strokeColor);
                            if (error)
                                return "strokeColor." + error;
                        }
                        if (message.customAttributes != null && message.hasOwnProperty("customAttributes")) {
                            if (!Array.isArray(message.customAttributes))
                                return "customAttributes: array expected";
                            for (let i = 0; i < message.customAttributes.length; ++i) {
                                let error = $root.rv.data.Graphics.Text.Attributes.CustomAttribute.verify(message.customAttributes[i]);
                                if (error)
                                    return "customAttributes." + error;
                            }
                        }
                        if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor")) {
                            let error = $root.rv.data.Color.verify(message.backgroundColor);
                            if (error)
                                return "backgroundColor." + error;
                        }
                        if (message.textSolidFill != null && message.hasOwnProperty("textSolidFill")) {
                            properties.fill = 1;
                            {
                                let error = $root.rv.data.Color.verify(message.textSolidFill);
                                if (error)
                                    return "textSolidFill." + error;
                            }
                        }
                        if (message.textGradientFill != null && message.hasOwnProperty("textGradientFill")) {
                            if (properties.fill === 1)
                                return "fill: multiple values";
                            properties.fill = 1;
                            {
                                let error = $root.rv.data.Graphics.Text.GradientFill.verify(message.textGradientFill);
                                if (error)
                                    return "textGradientFill." + error;
                            }
                        }
                        if (message.cutOutFill != null && message.hasOwnProperty("cutOutFill")) {
                            if (properties.fill === 1)
                                return "fill: multiple values";
                            properties.fill = 1;
                            {
                                let error = $root.rv.data.Graphics.Text.CutOutFill.verify(message.cutOutFill);
                                if (error)
                                    return "cutOutFill." + error;
                            }
                        }
                        if (message.mediaFill != null && message.hasOwnProperty("mediaFill")) {
                            if (properties.fill === 1)
                                return "fill: multiple values";
                            properties.fill = 1;
                            {
                                let error = $root.rv.data.Graphics.Text.MediaFill.verify(message.mediaFill);
                                if (error)
                                    return "mediaFill." + error;
                            }
                        }
                        if (message.backgroundEffect != null && message.hasOwnProperty("backgroundEffect")) {
                            if (properties.fill === 1)
                                return "fill: multiple values";
                            properties.fill = 1;
                            {
                                let error = $root.rv.data.Graphics.BackgroundEffect.verify(message.backgroundEffect);
                                if (error)
                                    return "backgroundEffect." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates an Attributes message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Graphics.Text.Attributes} Attributes
                     */
                    Attributes.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Graphics.Text.Attributes)
                            return object;
                        let message = new $root.rv.data.Graphics.Text.Attributes();
                        if (object.font != null) {
                            if (typeof object.font !== "object")
                                throw TypeError(".rv.data.Graphics.Text.Attributes.font: object expected");
                            message.font = $root.rv.data.Font.fromObject(object.font);
                        }
                        switch (object.capitalization) {
                        default:
                            if (typeof object.capitalization === "number") {
                                message.capitalization = object.capitalization;
                                break;
                            }
                            break;
                        case "CAPITALIZATION_NONE":
                        case 0:
                            message.capitalization = 0;
                            break;
                        case "CAPITALIZATION_ALL_CAPS":
                        case 1:
                            message.capitalization = 1;
                            break;
                        case "CAPITALIZATION_SMALL_CAPS":
                        case 2:
                            message.capitalization = 2;
                            break;
                        case "CAPITALIZATION_TITLE_CASE":
                        case 3:
                            message.capitalization = 3;
                            break;
                        case "CAPITALIZATION_START_CASE":
                        case 4:
                            message.capitalization = 4;
                            break;
                        }
                        if (object.underlineStyle != null) {
                            if (typeof object.underlineStyle !== "object")
                                throw TypeError(".rv.data.Graphics.Text.Attributes.underlineStyle: object expected");
                            message.underlineStyle = $root.rv.data.Graphics.Text.Attributes.Underline.fromObject(object.underlineStyle);
                        }
                        if (object.underlineColor != null) {
                            if (typeof object.underlineColor !== "object")
                                throw TypeError(".rv.data.Graphics.Text.Attributes.underlineColor: object expected");
                            message.underlineColor = $root.rv.data.Color.fromObject(object.underlineColor);
                        }
                        if (object.paragraphStyle != null) {
                            if (typeof object.paragraphStyle !== "object")
                                throw TypeError(".rv.data.Graphics.Text.Attributes.paragraphStyle: object expected");
                            message.paragraphStyle = $root.rv.data.Graphics.Text.Attributes.Paragraph.fromObject(object.paragraphStyle);
                        }
                        if (object.kerning != null)
                            message.kerning = Number(object.kerning);
                        if (object.superscript != null)
                            message.superscript = object.superscript | 0;
                        if (object.strikethroughStyle != null) {
                            if (typeof object.strikethroughStyle !== "object")
                                throw TypeError(".rv.data.Graphics.Text.Attributes.strikethroughStyle: object expected");
                            message.strikethroughStyle = $root.rv.data.Graphics.Text.Attributes.Underline.fromObject(object.strikethroughStyle);
                        }
                        if (object.strikethroughColor != null) {
                            if (typeof object.strikethroughColor !== "object")
                                throw TypeError(".rv.data.Graphics.Text.Attributes.strikethroughColor: object expected");
                            message.strikethroughColor = $root.rv.data.Color.fromObject(object.strikethroughColor);
                        }
                        if (object.strokeWidth != null)
                            message.strokeWidth = Number(object.strokeWidth);
                        if (object.strokeColor != null) {
                            if (typeof object.strokeColor !== "object")
                                throw TypeError(".rv.data.Graphics.Text.Attributes.strokeColor: object expected");
                            message.strokeColor = $root.rv.data.Color.fromObject(object.strokeColor);
                        }
                        if (object.customAttributes) {
                            if (!Array.isArray(object.customAttributes))
                                throw TypeError(".rv.data.Graphics.Text.Attributes.customAttributes: array expected");
                            message.customAttributes = [];
                            for (let i = 0; i < object.customAttributes.length; ++i) {
                                if (typeof object.customAttributes[i] !== "object")
                                    throw TypeError(".rv.data.Graphics.Text.Attributes.customAttributes: object expected");
                                message.customAttributes[i] = $root.rv.data.Graphics.Text.Attributes.CustomAttribute.fromObject(object.customAttributes[i]);
                            }
                        }
                        if (object.backgroundColor != null) {
                            if (typeof object.backgroundColor !== "object")
                                throw TypeError(".rv.data.Graphics.Text.Attributes.backgroundColor: object expected");
                            message.backgroundColor = $root.rv.data.Color.fromObject(object.backgroundColor);
                        }
                        if (object.textSolidFill != null) {
                            if (typeof object.textSolidFill !== "object")
                                throw TypeError(".rv.data.Graphics.Text.Attributes.textSolidFill: object expected");
                            message.textSolidFill = $root.rv.data.Color.fromObject(object.textSolidFill);
                        }
                        if (object.textGradientFill != null) {
                            if (typeof object.textGradientFill !== "object")
                                throw TypeError(".rv.data.Graphics.Text.Attributes.textGradientFill: object expected");
                            message.textGradientFill = $root.rv.data.Graphics.Text.GradientFill.fromObject(object.textGradientFill);
                        }
                        if (object.cutOutFill != null) {
                            if (typeof object.cutOutFill !== "object")
                                throw TypeError(".rv.data.Graphics.Text.Attributes.cutOutFill: object expected");
                            message.cutOutFill = $root.rv.data.Graphics.Text.CutOutFill.fromObject(object.cutOutFill);
                        }
                        if (object.mediaFill != null) {
                            if (typeof object.mediaFill !== "object")
                                throw TypeError(".rv.data.Graphics.Text.Attributes.mediaFill: object expected");
                            message.mediaFill = $root.rv.data.Graphics.Text.MediaFill.fromObject(object.mediaFill);
                        }
                        if (object.backgroundEffect != null) {
                            if (typeof object.backgroundEffect !== "object")
                                throw TypeError(".rv.data.Graphics.Text.Attributes.backgroundEffect: object expected");
                            message.backgroundEffect = $root.rv.data.Graphics.BackgroundEffect.fromObject(object.backgroundEffect);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an Attributes message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @static
                     * @param {rv.data.Graphics.Text.Attributes} message Attributes
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Attributes.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.customAttributes = [];
                        if (options.defaults) {
                            object.font = null;
                            object.capitalization = options.enums === String ? "CAPITALIZATION_NONE" : 0;
                            object.underlineStyle = null;
                            object.underlineColor = null;
                            object.paragraphStyle = null;
                            object.kerning = 0;
                            object.superscript = 0;
                            object.strikethroughStyle = null;
                            object.strikethroughColor = null;
                            object.strokeWidth = 0;
                            object.strokeColor = null;
                            object.backgroundColor = null;
                        }
                        if (message.font != null && message.hasOwnProperty("font"))
                            object.font = $root.rv.data.Font.toObject(message.font, options);
                        if (message.capitalization != null && message.hasOwnProperty("capitalization"))
                            object.capitalization = options.enums === String ? $root.rv.data.Graphics.Text.Attributes.Capitalization[message.capitalization] === undefined ? message.capitalization : $root.rv.data.Graphics.Text.Attributes.Capitalization[message.capitalization] : message.capitalization;
                        if (message.textSolidFill != null && message.hasOwnProperty("textSolidFill")) {
                            object.textSolidFill = $root.rv.data.Color.toObject(message.textSolidFill, options);
                            if (options.oneofs)
                                object.fill = "textSolidFill";
                        }
                        if (message.underlineStyle != null && message.hasOwnProperty("underlineStyle"))
                            object.underlineStyle = $root.rv.data.Graphics.Text.Attributes.Underline.toObject(message.underlineStyle, options);
                        if (message.underlineColor != null && message.hasOwnProperty("underlineColor"))
                            object.underlineColor = $root.rv.data.Color.toObject(message.underlineColor, options);
                        if (message.paragraphStyle != null && message.hasOwnProperty("paragraphStyle"))
                            object.paragraphStyle = $root.rv.data.Graphics.Text.Attributes.Paragraph.toObject(message.paragraphStyle, options);
                        if (message.kerning != null && message.hasOwnProperty("kerning"))
                            object.kerning = options.json && !isFinite(message.kerning) ? String(message.kerning) : message.kerning;
                        if (message.superscript != null && message.hasOwnProperty("superscript"))
                            object.superscript = message.superscript;
                        if (message.strikethroughStyle != null && message.hasOwnProperty("strikethroughStyle"))
                            object.strikethroughStyle = $root.rv.data.Graphics.Text.Attributes.Underline.toObject(message.strikethroughStyle, options);
                        if (message.strikethroughColor != null && message.hasOwnProperty("strikethroughColor"))
                            object.strikethroughColor = $root.rv.data.Color.toObject(message.strikethroughColor, options);
                        if (message.strokeWidth != null && message.hasOwnProperty("strokeWidth"))
                            object.strokeWidth = options.json && !isFinite(message.strokeWidth) ? String(message.strokeWidth) : message.strokeWidth;
                        if (message.strokeColor != null && message.hasOwnProperty("strokeColor"))
                            object.strokeColor = $root.rv.data.Color.toObject(message.strokeColor, options);
                        if (message.customAttributes && message.customAttributes.length) {
                            object.customAttributes = [];
                            for (let j = 0; j < message.customAttributes.length; ++j)
                                object.customAttributes[j] = $root.rv.data.Graphics.Text.Attributes.CustomAttribute.toObject(message.customAttributes[j], options);
                        }
                        if (message.textGradientFill != null && message.hasOwnProperty("textGradientFill")) {
                            object.textGradientFill = $root.rv.data.Graphics.Text.GradientFill.toObject(message.textGradientFill, options);
                            if (options.oneofs)
                                object.fill = "textGradientFill";
                        }
                        if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor"))
                            object.backgroundColor = $root.rv.data.Color.toObject(message.backgroundColor, options);
                        if (message.cutOutFill != null && message.hasOwnProperty("cutOutFill")) {
                            object.cutOutFill = $root.rv.data.Graphics.Text.CutOutFill.toObject(message.cutOutFill, options);
                            if (options.oneofs)
                                object.fill = "cutOutFill";
                        }
                        if (message.mediaFill != null && message.hasOwnProperty("mediaFill")) {
                            object.mediaFill = $root.rv.data.Graphics.Text.MediaFill.toObject(message.mediaFill, options);
                            if (options.oneofs)
                                object.fill = "mediaFill";
                        }
                        if (message.backgroundEffect != null && message.hasOwnProperty("backgroundEffect")) {
                            object.backgroundEffect = $root.rv.data.Graphics.BackgroundEffect.toObject(message.backgroundEffect, options);
                            if (options.oneofs)
                                object.fill = "backgroundEffect";
                        }
                        return object;
                    };

                    /**
                     * Converts this Attributes to JSON.
                     * @function toJSON
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Attributes.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Attributes
                     * @function getTypeUrl
                     * @memberof rv.data.Graphics.Text.Attributes
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Attributes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Graphics.Text.Attributes";
                    };

                    Attributes.Underline = (function() {

                        /**
                         * Properties of an Underline.
                         * @memberof rv.data.Graphics.Text.Attributes
                         * @interface IUnderline
                         * @property {rv.data.Graphics.Text.Attributes.Underline.Style|null} [style] Underline style
                         * @property {rv.data.Graphics.Text.Attributes.Underline.Pattern|null} [pattern] Underline pattern
                         * @property {boolean|null} [byWord] Underline byWord
                         */

                        /**
                         * Constructs a new Underline.
                         * @memberof rv.data.Graphics.Text.Attributes
                         * @classdesc Represents an Underline.
                         * @implements IUnderline
                         * @constructor
                         * @param {rv.data.Graphics.Text.Attributes.IUnderline=} [properties] Properties to set
                         */
                        function Underline(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Underline style.
                         * @member {rv.data.Graphics.Text.Attributes.Underline.Style} style
                         * @memberof rv.data.Graphics.Text.Attributes.Underline
                         * @instance
                         */
                        Underline.prototype.style = 0;

                        /**
                         * Underline pattern.
                         * @member {rv.data.Graphics.Text.Attributes.Underline.Pattern} pattern
                         * @memberof rv.data.Graphics.Text.Attributes.Underline
                         * @instance
                         */
                        Underline.prototype.pattern = 0;

                        /**
                         * Underline byWord.
                         * @member {boolean} byWord
                         * @memberof rv.data.Graphics.Text.Attributes.Underline
                         * @instance
                         */
                        Underline.prototype.byWord = false;

                        /**
                         * Creates a new Underline instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Graphics.Text.Attributes.Underline
                         * @static
                         * @param {rv.data.Graphics.Text.Attributes.IUnderline=} [properties] Properties to set
                         * @returns {rv.data.Graphics.Text.Attributes.Underline} Underline instance
                         */
                        Underline.create = function create(properties) {
                            return new Underline(properties);
                        };

                        /**
                         * Encodes the specified Underline message. Does not implicitly {@link rv.data.Graphics.Text.Attributes.Underline.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Graphics.Text.Attributes.Underline
                         * @static
                         * @param {rv.data.Graphics.Text.Attributes.IUnderline} message Underline message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Underline.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.style);
                            if (message.pattern != null && Object.hasOwnProperty.call(message, "pattern"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pattern);
                            if (message.byWord != null && Object.hasOwnProperty.call(message, "byWord"))
                                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.byWord);
                            return writer;
                        };

                        /**
                         * Encodes the specified Underline message, length delimited. Does not implicitly {@link rv.data.Graphics.Text.Attributes.Underline.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Graphics.Text.Attributes.Underline
                         * @static
                         * @param {rv.data.Graphics.Text.Attributes.IUnderline} message Underline message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Underline.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Underline message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Graphics.Text.Attributes.Underline
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Graphics.Text.Attributes.Underline} Underline
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Underline.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Text.Attributes.Underline();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.style = reader.int32();
                                        break;
                                    }
                                case 2: {
                                        message.pattern = reader.int32();
                                        break;
                                    }
                                case 3: {
                                        message.byWord = reader.bool();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Underline message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Graphics.Text.Attributes.Underline
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Graphics.Text.Attributes.Underline} Underline
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Underline.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Underline message.
                         * @function verify
                         * @memberof rv.data.Graphics.Text.Attributes.Underline
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Underline.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.style != null && message.hasOwnProperty("style"))
                                switch (message.style) {
                                default:
                                    return "style: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                    break;
                                }
                            if (message.pattern != null && message.hasOwnProperty("pattern"))
                                switch (message.pattern) {
                                default:
                                    return "pattern: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                    break;
                                }
                            if (message.byWord != null && message.hasOwnProperty("byWord"))
                                if (typeof message.byWord !== "boolean")
                                    return "byWord: boolean expected";
                            return null;
                        };

                        /**
                         * Creates an Underline message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Graphics.Text.Attributes.Underline
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Graphics.Text.Attributes.Underline} Underline
                         */
                        Underline.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Graphics.Text.Attributes.Underline)
                                return object;
                            let message = new $root.rv.data.Graphics.Text.Attributes.Underline();
                            switch (object.style) {
                            default:
                                if (typeof object.style === "number") {
                                    message.style = object.style;
                                    break;
                                }
                                break;
                            case "STYLE_NONE":
                            case 0:
                                message.style = 0;
                                break;
                            case "STYLE_SINGLE":
                            case 1:
                                message.style = 1;
                                break;
                            case "STYLE_THICK":
                            case 2:
                                message.style = 2;
                                break;
                            case "STYLE_DOUBLE":
                            case 3:
                                message.style = 3;
                                break;
                            }
                            switch (object.pattern) {
                            default:
                                if (typeof object.pattern === "number") {
                                    message.pattern = object.pattern;
                                    break;
                                }
                                break;
                            case "PATTERN_SOLID":
                            case 0:
                                message.pattern = 0;
                                break;
                            case "PATTERN_DOT":
                            case 1:
                                message.pattern = 1;
                                break;
                            case "PATTERN_DASH":
                            case 2:
                                message.pattern = 2;
                                break;
                            case "PATTERN_DASH_DOT":
                            case 3:
                                message.pattern = 3;
                                break;
                            case "PATTERN_DASH_DOT_DOT":
                            case 4:
                                message.pattern = 4;
                                break;
                            }
                            if (object.byWord != null)
                                message.byWord = Boolean(object.byWord);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Underline message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Graphics.Text.Attributes.Underline
                         * @static
                         * @param {rv.data.Graphics.Text.Attributes.Underline} message Underline
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Underline.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.style = options.enums === String ? "STYLE_NONE" : 0;
                                object.pattern = options.enums === String ? "PATTERN_SOLID" : 0;
                                object.byWord = false;
                            }
                            if (message.style != null && message.hasOwnProperty("style"))
                                object.style = options.enums === String ? $root.rv.data.Graphics.Text.Attributes.Underline.Style[message.style] === undefined ? message.style : $root.rv.data.Graphics.Text.Attributes.Underline.Style[message.style] : message.style;
                            if (message.pattern != null && message.hasOwnProperty("pattern"))
                                object.pattern = options.enums === String ? $root.rv.data.Graphics.Text.Attributes.Underline.Pattern[message.pattern] === undefined ? message.pattern : $root.rv.data.Graphics.Text.Attributes.Underline.Pattern[message.pattern] : message.pattern;
                            if (message.byWord != null && message.hasOwnProperty("byWord"))
                                object.byWord = message.byWord;
                            return object;
                        };

                        /**
                         * Converts this Underline to JSON.
                         * @function toJSON
                         * @memberof rv.data.Graphics.Text.Attributes.Underline
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Underline.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Underline
                         * @function getTypeUrl
                         * @memberof rv.data.Graphics.Text.Attributes.Underline
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Underline.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Graphics.Text.Attributes.Underline";
                        };

                        /**
                         * Style enum.
                         * @name rv.data.Graphics.Text.Attributes.Underline.Style
                         * @enum {number}
                         * @property {number} STYLE_NONE=0 STYLE_NONE value
                         * @property {number} STYLE_SINGLE=1 STYLE_SINGLE value
                         * @property {number} STYLE_THICK=2 STYLE_THICK value
                         * @property {number} STYLE_DOUBLE=3 STYLE_DOUBLE value
                         */
                        Underline.Style = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "STYLE_NONE"] = 0;
                            values[valuesById[1] = "STYLE_SINGLE"] = 1;
                            values[valuesById[2] = "STYLE_THICK"] = 2;
                            values[valuesById[3] = "STYLE_DOUBLE"] = 3;
                            return values;
                        })();

                        /**
                         * Pattern enum.
                         * @name rv.data.Graphics.Text.Attributes.Underline.Pattern
                         * @enum {number}
                         * @property {number} PATTERN_SOLID=0 PATTERN_SOLID value
                         * @property {number} PATTERN_DOT=1 PATTERN_DOT value
                         * @property {number} PATTERN_DASH=2 PATTERN_DASH value
                         * @property {number} PATTERN_DASH_DOT=3 PATTERN_DASH_DOT value
                         * @property {number} PATTERN_DASH_DOT_DOT=4 PATTERN_DASH_DOT_DOT value
                         */
                        Underline.Pattern = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "PATTERN_SOLID"] = 0;
                            values[valuesById[1] = "PATTERN_DOT"] = 1;
                            values[valuesById[2] = "PATTERN_DASH"] = 2;
                            values[valuesById[3] = "PATTERN_DASH_DOT"] = 3;
                            values[valuesById[4] = "PATTERN_DASH_DOT_DOT"] = 4;
                            return values;
                        })();

                        return Underline;
                    })();

                    Attributes.Paragraph = (function() {

                        /**
                         * Properties of a Paragraph.
                         * @memberof rv.data.Graphics.Text.Attributes
                         * @interface IParagraph
                         * @property {rv.data.Graphics.Text.Attributes.Alignment|null} [alignment] Paragraph alignment
                         * @property {number|null} [firstLineHeadIndent] Paragraph firstLineHeadIndent
                         * @property {number|null} [headIndent] Paragraph headIndent
                         * @property {number|null} [tailIndent] Paragraph tailIndent
                         * @property {number|null} [lineHeightMultiple] Paragraph lineHeightMultiple
                         * @property {number|null} [maximumLineHeight] Paragraph maximumLineHeight
                         * @property {number|null} [minimumLineHeight] Paragraph minimumLineHeight
                         * @property {number|null} [lineSpacing] Paragraph lineSpacing
                         * @property {number|null} [paragraphSpacing] Paragraph paragraphSpacing
                         * @property {number|null} [paragraphSpacingBefore] Paragraph paragraphSpacingBefore
                         * @property {Array.<rv.data.Graphics.Text.Attributes.Paragraph.ITabStop>|null} [tabStops] Paragraph tabStops
                         * @property {number|null} [defaultTabInterval] Paragraph defaultTabInterval
                         * @property {rv.data.Graphics.Text.Attributes.Paragraph.ITextList|null} [textList] Paragraph textList
                         * @property {Array.<rv.data.Graphics.Text.Attributes.Paragraph.ITextList>|null} [textLists] Paragraph textLists
                         */

                        /**
                         * Constructs a new Paragraph.
                         * @memberof rv.data.Graphics.Text.Attributes
                         * @classdesc Represents a Paragraph.
                         * @implements IParagraph
                         * @constructor
                         * @param {rv.data.Graphics.Text.Attributes.IParagraph=} [properties] Properties to set
                         */
                        function Paragraph(properties) {
                            this.tabStops = [];
                            this.textLists = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Paragraph alignment.
                         * @member {rv.data.Graphics.Text.Attributes.Alignment} alignment
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.alignment = 0;

                        /**
                         * Paragraph firstLineHeadIndent.
                         * @member {number} firstLineHeadIndent
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.firstLineHeadIndent = 0;

                        /**
                         * Paragraph headIndent.
                         * @member {number} headIndent
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.headIndent = 0;

                        /**
                         * Paragraph tailIndent.
                         * @member {number} tailIndent
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.tailIndent = 0;

                        /**
                         * Paragraph lineHeightMultiple.
                         * @member {number} lineHeightMultiple
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.lineHeightMultiple = 0;

                        /**
                         * Paragraph maximumLineHeight.
                         * @member {number} maximumLineHeight
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.maximumLineHeight = 0;

                        /**
                         * Paragraph minimumLineHeight.
                         * @member {number} minimumLineHeight
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.minimumLineHeight = 0;

                        /**
                         * Paragraph lineSpacing.
                         * @member {number} lineSpacing
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.lineSpacing = 0;

                        /**
                         * Paragraph paragraphSpacing.
                         * @member {number} paragraphSpacing
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.paragraphSpacing = 0;

                        /**
                         * Paragraph paragraphSpacingBefore.
                         * @member {number} paragraphSpacingBefore
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.paragraphSpacingBefore = 0;

                        /**
                         * Paragraph tabStops.
                         * @member {Array.<rv.data.Graphics.Text.Attributes.Paragraph.ITabStop>} tabStops
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.tabStops = $util.emptyArray;

                        /**
                         * Paragraph defaultTabInterval.
                         * @member {number} defaultTabInterval
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.defaultTabInterval = 0;

                        /**
                         * Paragraph textList.
                         * @member {rv.data.Graphics.Text.Attributes.Paragraph.ITextList|null|undefined} textList
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.textList = null;

                        /**
                         * Paragraph textLists.
                         * @member {Array.<rv.data.Graphics.Text.Attributes.Paragraph.ITextList>} textLists
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         */
                        Paragraph.prototype.textLists = $util.emptyArray;

                        /**
                         * Creates a new Paragraph instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @static
                         * @param {rv.data.Graphics.Text.Attributes.IParagraph=} [properties] Properties to set
                         * @returns {rv.data.Graphics.Text.Attributes.Paragraph} Paragraph instance
                         */
                        Paragraph.create = function create(properties) {
                            return new Paragraph(properties);
                        };

                        /**
                         * Encodes the specified Paragraph message. Does not implicitly {@link rv.data.Graphics.Text.Attributes.Paragraph.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @static
                         * @param {rv.data.Graphics.Text.Attributes.IParagraph} message Paragraph message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Paragraph.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.alignment != null && Object.hasOwnProperty.call(message, "alignment"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.alignment);
                            if (message.firstLineHeadIndent != null && Object.hasOwnProperty.call(message, "firstLineHeadIndent"))
                                writer.uint32(/* id 2, wireType 1 =*/17).double(message.firstLineHeadIndent);
                            if (message.headIndent != null && Object.hasOwnProperty.call(message, "headIndent"))
                                writer.uint32(/* id 3, wireType 1 =*/25).double(message.headIndent);
                            if (message.tailIndent != null && Object.hasOwnProperty.call(message, "tailIndent"))
                                writer.uint32(/* id 4, wireType 1 =*/33).double(message.tailIndent);
                            if (message.lineHeightMultiple != null && Object.hasOwnProperty.call(message, "lineHeightMultiple"))
                                writer.uint32(/* id 5, wireType 1 =*/41).double(message.lineHeightMultiple);
                            if (message.maximumLineHeight != null && Object.hasOwnProperty.call(message, "maximumLineHeight"))
                                writer.uint32(/* id 6, wireType 1 =*/49).double(message.maximumLineHeight);
                            if (message.minimumLineHeight != null && Object.hasOwnProperty.call(message, "minimumLineHeight"))
                                writer.uint32(/* id 7, wireType 1 =*/57).double(message.minimumLineHeight);
                            if (message.lineSpacing != null && Object.hasOwnProperty.call(message, "lineSpacing"))
                                writer.uint32(/* id 8, wireType 1 =*/65).double(message.lineSpacing);
                            if (message.paragraphSpacing != null && Object.hasOwnProperty.call(message, "paragraphSpacing"))
                                writer.uint32(/* id 9, wireType 1 =*/73).double(message.paragraphSpacing);
                            if (message.paragraphSpacingBefore != null && Object.hasOwnProperty.call(message, "paragraphSpacingBefore"))
                                writer.uint32(/* id 10, wireType 1 =*/81).double(message.paragraphSpacingBefore);
                            if (message.tabStops != null && message.tabStops.length)
                                for (let i = 0; i < message.tabStops.length; ++i)
                                    $root.rv.data.Graphics.Text.Attributes.Paragraph.TabStop.encode(message.tabStops[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                            if (message.defaultTabInterval != null && Object.hasOwnProperty.call(message, "defaultTabInterval"))
                                writer.uint32(/* id 12, wireType 1 =*/97).double(message.defaultTabInterval);
                            if (message.textList != null && Object.hasOwnProperty.call(message, "textList"))
                                $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList.encode(message.textList, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                            if (message.textLists != null && message.textLists.length)
                                for (let i = 0; i < message.textLists.length; ++i)
                                    $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList.encode(message.textLists[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Paragraph message, length delimited. Does not implicitly {@link rv.data.Graphics.Text.Attributes.Paragraph.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @static
                         * @param {rv.data.Graphics.Text.Attributes.IParagraph} message Paragraph message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Paragraph.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Paragraph message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Graphics.Text.Attributes.Paragraph} Paragraph
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Paragraph.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Text.Attributes.Paragraph();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.alignment = reader.int32();
                                        break;
                                    }
                                case 2: {
                                        message.firstLineHeadIndent = reader.double();
                                        break;
                                    }
                                case 3: {
                                        message.headIndent = reader.double();
                                        break;
                                    }
                                case 4: {
                                        message.tailIndent = reader.double();
                                        break;
                                    }
                                case 5: {
                                        message.lineHeightMultiple = reader.double();
                                        break;
                                    }
                                case 6: {
                                        message.maximumLineHeight = reader.double();
                                        break;
                                    }
                                case 7: {
                                        message.minimumLineHeight = reader.double();
                                        break;
                                    }
                                case 8: {
                                        message.lineSpacing = reader.double();
                                        break;
                                    }
                                case 9: {
                                        message.paragraphSpacing = reader.double();
                                        break;
                                    }
                                case 10: {
                                        message.paragraphSpacingBefore = reader.double();
                                        break;
                                    }
                                case 11: {
                                        if (!(message.tabStops && message.tabStops.length))
                                            message.tabStops = [];
                                        message.tabStops.push($root.rv.data.Graphics.Text.Attributes.Paragraph.TabStop.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 12: {
                                        message.defaultTabInterval = reader.double();
                                        break;
                                    }
                                case 13: {
                                        message.textList = $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 14: {
                                        if (!(message.textLists && message.textLists.length))
                                            message.textLists = [];
                                        message.textLists.push($root.rv.data.Graphics.Text.Attributes.Paragraph.TextList.decode(reader, reader.uint32()));
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Paragraph message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Graphics.Text.Attributes.Paragraph} Paragraph
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Paragraph.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Paragraph message.
                         * @function verify
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Paragraph.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.alignment != null && message.hasOwnProperty("alignment"))
                                switch (message.alignment) {
                                default:
                                    return "alignment: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                    break;
                                }
                            if (message.firstLineHeadIndent != null && message.hasOwnProperty("firstLineHeadIndent"))
                                if (typeof message.firstLineHeadIndent !== "number")
                                    return "firstLineHeadIndent: number expected";
                            if (message.headIndent != null && message.hasOwnProperty("headIndent"))
                                if (typeof message.headIndent !== "number")
                                    return "headIndent: number expected";
                            if (message.tailIndent != null && message.hasOwnProperty("tailIndent"))
                                if (typeof message.tailIndent !== "number")
                                    return "tailIndent: number expected";
                            if (message.lineHeightMultiple != null && message.hasOwnProperty("lineHeightMultiple"))
                                if (typeof message.lineHeightMultiple !== "number")
                                    return "lineHeightMultiple: number expected";
                            if (message.maximumLineHeight != null && message.hasOwnProperty("maximumLineHeight"))
                                if (typeof message.maximumLineHeight !== "number")
                                    return "maximumLineHeight: number expected";
                            if (message.minimumLineHeight != null && message.hasOwnProperty("minimumLineHeight"))
                                if (typeof message.minimumLineHeight !== "number")
                                    return "minimumLineHeight: number expected";
                            if (message.lineSpacing != null && message.hasOwnProperty("lineSpacing"))
                                if (typeof message.lineSpacing !== "number")
                                    return "lineSpacing: number expected";
                            if (message.paragraphSpacing != null && message.hasOwnProperty("paragraphSpacing"))
                                if (typeof message.paragraphSpacing !== "number")
                                    return "paragraphSpacing: number expected";
                            if (message.paragraphSpacingBefore != null && message.hasOwnProperty("paragraphSpacingBefore"))
                                if (typeof message.paragraphSpacingBefore !== "number")
                                    return "paragraphSpacingBefore: number expected";
                            if (message.tabStops != null && message.hasOwnProperty("tabStops")) {
                                if (!Array.isArray(message.tabStops))
                                    return "tabStops: array expected";
                                for (let i = 0; i < message.tabStops.length; ++i) {
                                    let error = $root.rv.data.Graphics.Text.Attributes.Paragraph.TabStop.verify(message.tabStops[i]);
                                    if (error)
                                        return "tabStops." + error;
                                }
                            }
                            if (message.defaultTabInterval != null && message.hasOwnProperty("defaultTabInterval"))
                                if (typeof message.defaultTabInterval !== "number")
                                    return "defaultTabInterval: number expected";
                            if (message.textList != null && message.hasOwnProperty("textList")) {
                                let error = $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList.verify(message.textList);
                                if (error)
                                    return "textList." + error;
                            }
                            if (message.textLists != null && message.hasOwnProperty("textLists")) {
                                if (!Array.isArray(message.textLists))
                                    return "textLists: array expected";
                                for (let i = 0; i < message.textLists.length; ++i) {
                                    let error = $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList.verify(message.textLists[i]);
                                    if (error)
                                        return "textLists." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Paragraph message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Graphics.Text.Attributes.Paragraph} Paragraph
                         */
                        Paragraph.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Graphics.Text.Attributes.Paragraph)
                                return object;
                            let message = new $root.rv.data.Graphics.Text.Attributes.Paragraph();
                            switch (object.alignment) {
                            default:
                                if (typeof object.alignment === "number") {
                                    message.alignment = object.alignment;
                                    break;
                                }
                                break;
                            case "ALIGNMENT_LEFT":
                            case 0:
                                message.alignment = 0;
                                break;
                            case "ALIGNMENT_RIGHT":
                            case 1:
                                message.alignment = 1;
                                break;
                            case "ALIGNMENT_CENTER":
                            case 2:
                                message.alignment = 2;
                                break;
                            case "ALIGNMENT_JUSTIFIED":
                            case 3:
                                message.alignment = 3;
                                break;
                            case "ALIGNMENT_NATURAL":
                            case 4:
                                message.alignment = 4;
                                break;
                            }
                            if (object.firstLineHeadIndent != null)
                                message.firstLineHeadIndent = Number(object.firstLineHeadIndent);
                            if (object.headIndent != null)
                                message.headIndent = Number(object.headIndent);
                            if (object.tailIndent != null)
                                message.tailIndent = Number(object.tailIndent);
                            if (object.lineHeightMultiple != null)
                                message.lineHeightMultiple = Number(object.lineHeightMultiple);
                            if (object.maximumLineHeight != null)
                                message.maximumLineHeight = Number(object.maximumLineHeight);
                            if (object.minimumLineHeight != null)
                                message.minimumLineHeight = Number(object.minimumLineHeight);
                            if (object.lineSpacing != null)
                                message.lineSpacing = Number(object.lineSpacing);
                            if (object.paragraphSpacing != null)
                                message.paragraphSpacing = Number(object.paragraphSpacing);
                            if (object.paragraphSpacingBefore != null)
                                message.paragraphSpacingBefore = Number(object.paragraphSpacingBefore);
                            if (object.tabStops) {
                                if (!Array.isArray(object.tabStops))
                                    throw TypeError(".rv.data.Graphics.Text.Attributes.Paragraph.tabStops: array expected");
                                message.tabStops = [];
                                for (let i = 0; i < object.tabStops.length; ++i) {
                                    if (typeof object.tabStops[i] !== "object")
                                        throw TypeError(".rv.data.Graphics.Text.Attributes.Paragraph.tabStops: object expected");
                                    message.tabStops[i] = $root.rv.data.Graphics.Text.Attributes.Paragraph.TabStop.fromObject(object.tabStops[i]);
                                }
                            }
                            if (object.defaultTabInterval != null)
                                message.defaultTabInterval = Number(object.defaultTabInterval);
                            if (object.textList != null) {
                                if (typeof object.textList !== "object")
                                    throw TypeError(".rv.data.Graphics.Text.Attributes.Paragraph.textList: object expected");
                                message.textList = $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList.fromObject(object.textList);
                            }
                            if (object.textLists) {
                                if (!Array.isArray(object.textLists))
                                    throw TypeError(".rv.data.Graphics.Text.Attributes.Paragraph.textLists: array expected");
                                message.textLists = [];
                                for (let i = 0; i < object.textLists.length; ++i) {
                                    if (typeof object.textLists[i] !== "object")
                                        throw TypeError(".rv.data.Graphics.Text.Attributes.Paragraph.textLists: object expected");
                                    message.textLists[i] = $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList.fromObject(object.textLists[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Paragraph message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @static
                         * @param {rv.data.Graphics.Text.Attributes.Paragraph} message Paragraph
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Paragraph.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.tabStops = [];
                                object.textLists = [];
                            }
                            if (options.defaults) {
                                object.alignment = options.enums === String ? "ALIGNMENT_LEFT" : 0;
                                object.firstLineHeadIndent = 0;
                                object.headIndent = 0;
                                object.tailIndent = 0;
                                object.lineHeightMultiple = 0;
                                object.maximumLineHeight = 0;
                                object.minimumLineHeight = 0;
                                object.lineSpacing = 0;
                                object.paragraphSpacing = 0;
                                object.paragraphSpacingBefore = 0;
                                object.defaultTabInterval = 0;
                                object.textList = null;
                            }
                            if (message.alignment != null && message.hasOwnProperty("alignment"))
                                object.alignment = options.enums === String ? $root.rv.data.Graphics.Text.Attributes.Alignment[message.alignment] === undefined ? message.alignment : $root.rv.data.Graphics.Text.Attributes.Alignment[message.alignment] : message.alignment;
                            if (message.firstLineHeadIndent != null && message.hasOwnProperty("firstLineHeadIndent"))
                                object.firstLineHeadIndent = options.json && !isFinite(message.firstLineHeadIndent) ? String(message.firstLineHeadIndent) : message.firstLineHeadIndent;
                            if (message.headIndent != null && message.hasOwnProperty("headIndent"))
                                object.headIndent = options.json && !isFinite(message.headIndent) ? String(message.headIndent) : message.headIndent;
                            if (message.tailIndent != null && message.hasOwnProperty("tailIndent"))
                                object.tailIndent = options.json && !isFinite(message.tailIndent) ? String(message.tailIndent) : message.tailIndent;
                            if (message.lineHeightMultiple != null && message.hasOwnProperty("lineHeightMultiple"))
                                object.lineHeightMultiple = options.json && !isFinite(message.lineHeightMultiple) ? String(message.lineHeightMultiple) : message.lineHeightMultiple;
                            if (message.maximumLineHeight != null && message.hasOwnProperty("maximumLineHeight"))
                                object.maximumLineHeight = options.json && !isFinite(message.maximumLineHeight) ? String(message.maximumLineHeight) : message.maximumLineHeight;
                            if (message.minimumLineHeight != null && message.hasOwnProperty("minimumLineHeight"))
                                object.minimumLineHeight = options.json && !isFinite(message.minimumLineHeight) ? String(message.minimumLineHeight) : message.minimumLineHeight;
                            if (message.lineSpacing != null && message.hasOwnProperty("lineSpacing"))
                                object.lineSpacing = options.json && !isFinite(message.lineSpacing) ? String(message.lineSpacing) : message.lineSpacing;
                            if (message.paragraphSpacing != null && message.hasOwnProperty("paragraphSpacing"))
                                object.paragraphSpacing = options.json && !isFinite(message.paragraphSpacing) ? String(message.paragraphSpacing) : message.paragraphSpacing;
                            if (message.paragraphSpacingBefore != null && message.hasOwnProperty("paragraphSpacingBefore"))
                                object.paragraphSpacingBefore = options.json && !isFinite(message.paragraphSpacingBefore) ? String(message.paragraphSpacingBefore) : message.paragraphSpacingBefore;
                            if (message.tabStops && message.tabStops.length) {
                                object.tabStops = [];
                                for (let j = 0; j < message.tabStops.length; ++j)
                                    object.tabStops[j] = $root.rv.data.Graphics.Text.Attributes.Paragraph.TabStop.toObject(message.tabStops[j], options);
                            }
                            if (message.defaultTabInterval != null && message.hasOwnProperty("defaultTabInterval"))
                                object.defaultTabInterval = options.json && !isFinite(message.defaultTabInterval) ? String(message.defaultTabInterval) : message.defaultTabInterval;
                            if (message.textList != null && message.hasOwnProperty("textList"))
                                object.textList = $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList.toObject(message.textList, options);
                            if (message.textLists && message.textLists.length) {
                                object.textLists = [];
                                for (let j = 0; j < message.textLists.length; ++j)
                                    object.textLists[j] = $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList.toObject(message.textLists[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Paragraph to JSON.
                         * @function toJSON
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Paragraph.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Paragraph
                         * @function getTypeUrl
                         * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Paragraph.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Graphics.Text.Attributes.Paragraph";
                        };

                        Paragraph.TabStop = (function() {

                            /**
                             * Properties of a TabStop.
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                             * @interface ITabStop
                             * @property {number|null} [location] TabStop location
                             * @property {rv.data.Graphics.Text.Attributes.Alignment|null} [alignment] TabStop alignment
                             */

                            /**
                             * Constructs a new TabStop.
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                             * @classdesc Represents a TabStop.
                             * @implements ITabStop
                             * @constructor
                             * @param {rv.data.Graphics.Text.Attributes.Paragraph.ITabStop=} [properties] Properties to set
                             */
                            function TabStop(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * TabStop location.
                             * @member {number} location
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TabStop
                             * @instance
                             */
                            TabStop.prototype.location = 0;

                            /**
                             * TabStop alignment.
                             * @member {rv.data.Graphics.Text.Attributes.Alignment} alignment
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TabStop
                             * @instance
                             */
                            TabStop.prototype.alignment = 0;

                            /**
                             * Creates a new TabStop instance using the specified properties.
                             * @function create
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TabStop
                             * @static
                             * @param {rv.data.Graphics.Text.Attributes.Paragraph.ITabStop=} [properties] Properties to set
                             * @returns {rv.data.Graphics.Text.Attributes.Paragraph.TabStop} TabStop instance
                             */
                            TabStop.create = function create(properties) {
                                return new TabStop(properties);
                            };

                            /**
                             * Encodes the specified TabStop message. Does not implicitly {@link rv.data.Graphics.Text.Attributes.Paragraph.TabStop.verify|verify} messages.
                             * @function encode
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TabStop
                             * @static
                             * @param {rv.data.Graphics.Text.Attributes.Paragraph.ITabStop} message TabStop message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TabStop.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.location);
                                if (message.alignment != null && Object.hasOwnProperty.call(message, "alignment"))
                                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.alignment);
                                return writer;
                            };

                            /**
                             * Encodes the specified TabStop message, length delimited. Does not implicitly {@link rv.data.Graphics.Text.Attributes.Paragraph.TabStop.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TabStop
                             * @static
                             * @param {rv.data.Graphics.Text.Attributes.Paragraph.ITabStop} message TabStop message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TabStop.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a TabStop message from the specified reader or buffer.
                             * @function decode
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TabStop
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {rv.data.Graphics.Text.Attributes.Paragraph.TabStop} TabStop
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TabStop.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Text.Attributes.Paragraph.TabStop();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.location = reader.double();
                                            break;
                                        }
                                    case 2: {
                                            message.alignment = reader.int32();
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a TabStop message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TabStop
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {rv.data.Graphics.Text.Attributes.Paragraph.TabStop} TabStop
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TabStop.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a TabStop message.
                             * @function verify
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TabStop
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            TabStop.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.location != null && message.hasOwnProperty("location"))
                                    if (typeof message.location !== "number")
                                        return "location: number expected";
                                if (message.alignment != null && message.hasOwnProperty("alignment"))
                                    switch (message.alignment) {
                                    default:
                                        return "alignment: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                    case 4:
                                        break;
                                    }
                                return null;
                            };

                            /**
                             * Creates a TabStop message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TabStop
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {rv.data.Graphics.Text.Attributes.Paragraph.TabStop} TabStop
                             */
                            TabStop.fromObject = function fromObject(object) {
                                if (object instanceof $root.rv.data.Graphics.Text.Attributes.Paragraph.TabStop)
                                    return object;
                                let message = new $root.rv.data.Graphics.Text.Attributes.Paragraph.TabStop();
                                if (object.location != null)
                                    message.location = Number(object.location);
                                switch (object.alignment) {
                                default:
                                    if (typeof object.alignment === "number") {
                                        message.alignment = object.alignment;
                                        break;
                                    }
                                    break;
                                case "ALIGNMENT_LEFT":
                                case 0:
                                    message.alignment = 0;
                                    break;
                                case "ALIGNMENT_RIGHT":
                                case 1:
                                    message.alignment = 1;
                                    break;
                                case "ALIGNMENT_CENTER":
                                case 2:
                                    message.alignment = 2;
                                    break;
                                case "ALIGNMENT_JUSTIFIED":
                                case 3:
                                    message.alignment = 3;
                                    break;
                                case "ALIGNMENT_NATURAL":
                                case 4:
                                    message.alignment = 4;
                                    break;
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a TabStop message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TabStop
                             * @static
                             * @param {rv.data.Graphics.Text.Attributes.Paragraph.TabStop} message TabStop
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            TabStop.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.location = 0;
                                    object.alignment = options.enums === String ? "ALIGNMENT_LEFT" : 0;
                                }
                                if (message.location != null && message.hasOwnProperty("location"))
                                    object.location = options.json && !isFinite(message.location) ? String(message.location) : message.location;
                                if (message.alignment != null && message.hasOwnProperty("alignment"))
                                    object.alignment = options.enums === String ? $root.rv.data.Graphics.Text.Attributes.Alignment[message.alignment] === undefined ? message.alignment : $root.rv.data.Graphics.Text.Attributes.Alignment[message.alignment] : message.alignment;
                                return object;
                            };

                            /**
                             * Converts this TabStop to JSON.
                             * @function toJSON
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TabStop
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            TabStop.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for TabStop
                             * @function getTypeUrl
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TabStop
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            TabStop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/rv.data.Graphics.Text.Attributes.Paragraph.TabStop";
                            };

                            return TabStop;
                        })();

                        Paragraph.TextList = (function() {

                            /**
                             * Properties of a TextList.
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                             * @interface ITextList
                             * @property {boolean|null} [isEnabled] TextList isEnabled
                             * @property {rv.data.Graphics.Text.Attributes.Paragraph.TextList.NumberType|null} [numberType] TextList numberType
                             * @property {string|null} [prefix] TextList prefix
                             * @property {string|null} [postfix] TextList postfix
                             * @property {number|null} [startingNumber] TextList startingNumber
                             */

                            /**
                             * Constructs a new TextList.
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph
                             * @classdesc Represents a TextList.
                             * @implements ITextList
                             * @constructor
                             * @param {rv.data.Graphics.Text.Attributes.Paragraph.ITextList=} [properties] Properties to set
                             */
                            function TextList(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * TextList isEnabled.
                             * @member {boolean} isEnabled
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @instance
                             */
                            TextList.prototype.isEnabled = false;

                            /**
                             * TextList numberType.
                             * @member {rv.data.Graphics.Text.Attributes.Paragraph.TextList.NumberType} numberType
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @instance
                             */
                            TextList.prototype.numberType = 0;

                            /**
                             * TextList prefix.
                             * @member {string} prefix
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @instance
                             */
                            TextList.prototype.prefix = "";

                            /**
                             * TextList postfix.
                             * @member {string} postfix
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @instance
                             */
                            TextList.prototype.postfix = "";

                            /**
                             * TextList startingNumber.
                             * @member {number} startingNumber
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @instance
                             */
                            TextList.prototype.startingNumber = 0;

                            /**
                             * Creates a new TextList instance using the specified properties.
                             * @function create
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @static
                             * @param {rv.data.Graphics.Text.Attributes.Paragraph.ITextList=} [properties] Properties to set
                             * @returns {rv.data.Graphics.Text.Attributes.Paragraph.TextList} TextList instance
                             */
                            TextList.create = function create(properties) {
                                return new TextList(properties);
                            };

                            /**
                             * Encodes the specified TextList message. Does not implicitly {@link rv.data.Graphics.Text.Attributes.Paragraph.TextList.verify|verify} messages.
                             * @function encode
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @static
                             * @param {rv.data.Graphics.Text.Attributes.Paragraph.ITextList} message TextList message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TextList.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.isEnabled != null && Object.hasOwnProperty.call(message, "isEnabled"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isEnabled);
                                if (message.numberType != null && Object.hasOwnProperty.call(message, "numberType"))
                                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.numberType);
                                if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.prefix);
                                if (message.postfix != null && Object.hasOwnProperty.call(message, "postfix"))
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.postfix);
                                if (message.startingNumber != null && Object.hasOwnProperty.call(message, "startingNumber"))
                                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.startingNumber);
                                return writer;
                            };

                            /**
                             * Encodes the specified TextList message, length delimited. Does not implicitly {@link rv.data.Graphics.Text.Attributes.Paragraph.TextList.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @static
                             * @param {rv.data.Graphics.Text.Attributes.Paragraph.ITextList} message TextList message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TextList.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a TextList message from the specified reader or buffer.
                             * @function decode
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {rv.data.Graphics.Text.Attributes.Paragraph.TextList} TextList
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TextList.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.isEnabled = reader.bool();
                                            break;
                                        }
                                    case 2: {
                                            message.numberType = reader.int32();
                                            break;
                                        }
                                    case 3: {
                                            message.prefix = reader.string();
                                            break;
                                        }
                                    case 4: {
                                            message.postfix = reader.string();
                                            break;
                                        }
                                    case 5: {
                                            message.startingNumber = reader.int32();
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a TextList message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {rv.data.Graphics.Text.Attributes.Paragraph.TextList} TextList
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TextList.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a TextList message.
                             * @function verify
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            TextList.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.isEnabled != null && message.hasOwnProperty("isEnabled"))
                                    if (typeof message.isEnabled !== "boolean")
                                        return "isEnabled: boolean expected";
                                if (message.numberType != null && message.hasOwnProperty("numberType"))
                                    switch (message.numberType) {
                                    default:
                                        return "numberType: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                    case 4:
                                    case 5:
                                    case 6:
                                    case 7:
                                    case 8:
                                    case 9:
                                    case 10:
                                    case 11:
                                        break;
                                    }
                                if (message.prefix != null && message.hasOwnProperty("prefix"))
                                    if (!$util.isString(message.prefix))
                                        return "prefix: string expected";
                                if (message.postfix != null && message.hasOwnProperty("postfix"))
                                    if (!$util.isString(message.postfix))
                                        return "postfix: string expected";
                                if (message.startingNumber != null && message.hasOwnProperty("startingNumber"))
                                    if (!$util.isInteger(message.startingNumber))
                                        return "startingNumber: integer expected";
                                return null;
                            };

                            /**
                             * Creates a TextList message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {rv.data.Graphics.Text.Attributes.Paragraph.TextList} TextList
                             */
                            TextList.fromObject = function fromObject(object) {
                                if (object instanceof $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList)
                                    return object;
                                let message = new $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList();
                                if (object.isEnabled != null)
                                    message.isEnabled = Boolean(object.isEnabled);
                                switch (object.numberType) {
                                default:
                                    if (typeof object.numberType === "number") {
                                        message.numberType = object.numberType;
                                        break;
                                    }
                                    break;
                                case "NUMBER_TYPE_BOX":
                                case 0:
                                    message.numberType = 0;
                                    break;
                                case "NUMBER_TYPE_CHECK":
                                case 1:
                                    message.numberType = 1;
                                    break;
                                case "NUMBER_TYPE_CIRCLE":
                                case 2:
                                    message.numberType = 2;
                                    break;
                                case "NUMBER_TYPE_DIAMOND":
                                case 3:
                                    message.numberType = 3;
                                    break;
                                case "NUMBER_TYPE_DISC":
                                case 4:
                                    message.numberType = 4;
                                    break;
                                case "NUMBER_TYPE_HYPHEN":
                                case 5:
                                    message.numberType = 5;
                                    break;
                                case "NUMBER_TYPE_SQUARE":
                                case 6:
                                    message.numberType = 6;
                                    break;
                                case "NUMBER_TYPE_DECIMAL":
                                case 7:
                                    message.numberType = 7;
                                    break;
                                case "NUMBER_TYPE_LOWERCASE_ALPHA":
                                case 8:
                                    message.numberType = 8;
                                    break;
                                case "NUMBER_TYPE_UPPERCASE_ALPHA":
                                case 9:
                                    message.numberType = 9;
                                    break;
                                case "NUMBER_TYPE_LOWERCASE_ROMAN":
                                case 10:
                                    message.numberType = 10;
                                    break;
                                case "NUMBER_TYPE_UPPERCASE_ROMAN":
                                case 11:
                                    message.numberType = 11;
                                    break;
                                }
                                if (object.prefix != null)
                                    message.prefix = String(object.prefix);
                                if (object.postfix != null)
                                    message.postfix = String(object.postfix);
                                if (object.startingNumber != null)
                                    message.startingNumber = object.startingNumber | 0;
                                return message;
                            };

                            /**
                             * Creates a plain object from a TextList message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @static
                             * @param {rv.data.Graphics.Text.Attributes.Paragraph.TextList} message TextList
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            TextList.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.isEnabled = false;
                                    object.numberType = options.enums === String ? "NUMBER_TYPE_BOX" : 0;
                                    object.prefix = "";
                                    object.postfix = "";
                                    object.startingNumber = 0;
                                }
                                if (message.isEnabled != null && message.hasOwnProperty("isEnabled"))
                                    object.isEnabled = message.isEnabled;
                                if (message.numberType != null && message.hasOwnProperty("numberType"))
                                    object.numberType = options.enums === String ? $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList.NumberType[message.numberType] === undefined ? message.numberType : $root.rv.data.Graphics.Text.Attributes.Paragraph.TextList.NumberType[message.numberType] : message.numberType;
                                if (message.prefix != null && message.hasOwnProperty("prefix"))
                                    object.prefix = message.prefix;
                                if (message.postfix != null && message.hasOwnProperty("postfix"))
                                    object.postfix = message.postfix;
                                if (message.startingNumber != null && message.hasOwnProperty("startingNumber"))
                                    object.startingNumber = message.startingNumber;
                                return object;
                            };

                            /**
                             * Converts this TextList to JSON.
                             * @function toJSON
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            TextList.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for TextList
                             * @function getTypeUrl
                             * @memberof rv.data.Graphics.Text.Attributes.Paragraph.TextList
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            TextList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/rv.data.Graphics.Text.Attributes.Paragraph.TextList";
                            };

                            /**
                             * NumberType enum.
                             * @name rv.data.Graphics.Text.Attributes.Paragraph.TextList.NumberType
                             * @enum {number}
                             * @property {number} NUMBER_TYPE_BOX=0 NUMBER_TYPE_BOX value
                             * @property {number} NUMBER_TYPE_CHECK=1 NUMBER_TYPE_CHECK value
                             * @property {number} NUMBER_TYPE_CIRCLE=2 NUMBER_TYPE_CIRCLE value
                             * @property {number} NUMBER_TYPE_DIAMOND=3 NUMBER_TYPE_DIAMOND value
                             * @property {number} NUMBER_TYPE_DISC=4 NUMBER_TYPE_DISC value
                             * @property {number} NUMBER_TYPE_HYPHEN=5 NUMBER_TYPE_HYPHEN value
                             * @property {number} NUMBER_TYPE_SQUARE=6 NUMBER_TYPE_SQUARE value
                             * @property {number} NUMBER_TYPE_DECIMAL=7 NUMBER_TYPE_DECIMAL value
                             * @property {number} NUMBER_TYPE_LOWERCASE_ALPHA=8 NUMBER_TYPE_LOWERCASE_ALPHA value
                             * @property {number} NUMBER_TYPE_UPPERCASE_ALPHA=9 NUMBER_TYPE_UPPERCASE_ALPHA value
                             * @property {number} NUMBER_TYPE_LOWERCASE_ROMAN=10 NUMBER_TYPE_LOWERCASE_ROMAN value
                             * @property {number} NUMBER_TYPE_UPPERCASE_ROMAN=11 NUMBER_TYPE_UPPERCASE_ROMAN value
                             */
                            TextList.NumberType = (function() {
                                const valuesById = {}, values = Object.create(valuesById);
                                values[valuesById[0] = "NUMBER_TYPE_BOX"] = 0;
                                values[valuesById[1] = "NUMBER_TYPE_CHECK"] = 1;
                                values[valuesById[2] = "NUMBER_TYPE_CIRCLE"] = 2;
                                values[valuesById[3] = "NUMBER_TYPE_DIAMOND"] = 3;
                                values[valuesById[4] = "NUMBER_TYPE_DISC"] = 4;
                                values[valuesById[5] = "NUMBER_TYPE_HYPHEN"] = 5;
                                values[valuesById[6] = "NUMBER_TYPE_SQUARE"] = 6;
                                values[valuesById[7] = "NUMBER_TYPE_DECIMAL"] = 7;
                                values[valuesById[8] = "NUMBER_TYPE_LOWERCASE_ALPHA"] = 8;
                                values[valuesById[9] = "NUMBER_TYPE_UPPERCASE_ALPHA"] = 9;
                                values[valuesById[10] = "NUMBER_TYPE_LOWERCASE_ROMAN"] = 10;
                                values[valuesById[11] = "NUMBER_TYPE_UPPERCASE_ROMAN"] = 11;
                                return values;
                            })();

                            return TextList;
                        })();

                        return Paragraph;
                    })();

                    Attributes.CustomAttribute = (function() {

                        /**
                         * Properties of a CustomAttribute.
                         * @memberof rv.data.Graphics.Text.Attributes
                         * @interface ICustomAttribute
                         * @property {rv.data.IIntRange|null} [range] CustomAttribute range
                         * @property {rv.data.Graphics.Text.Attributes.Capitalization|null} [capitalization] CustomAttribute capitalization
                         * @property {number|null} [originalFontSize] CustomAttribute originalFontSize
                         * @property {number|null} [fontScaleFactor] CustomAttribute fontScaleFactor
                         * @property {rv.data.Graphics.Text.IGradientFill|null} [textGradientFill] CustomAttribute textGradientFill
                         * @property {boolean|null} [shouldPreserveForegroundColor] CustomAttribute shouldPreserveForegroundColor
                         * @property {string|null} [chord] CustomAttribute chord
                         * @property {rv.data.Graphics.Text.ICutOutFill|null} [cutOutFill] CustomAttribute cutOutFill
                         * @property {rv.data.Graphics.Text.IMediaFill|null} [mediaFill] CustomAttribute mediaFill
                         * @property {rv.data.Graphics.IBackgroundEffect|null} [backgroundEffect] CustomAttribute backgroundEffect
                         */

                        /**
                         * Constructs a new CustomAttribute.
                         * @memberof rv.data.Graphics.Text.Attributes
                         * @classdesc Represents a CustomAttribute.
                         * @implements ICustomAttribute
                         * @constructor
                         * @param {rv.data.Graphics.Text.Attributes.ICustomAttribute=} [properties] Properties to set
                         */
                        function CustomAttribute(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * CustomAttribute range.
                         * @member {rv.data.IIntRange|null|undefined} range
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @instance
                         */
                        CustomAttribute.prototype.range = null;

                        /**
                         * CustomAttribute capitalization.
                         * @member {rv.data.Graphics.Text.Attributes.Capitalization|null|undefined} capitalization
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @instance
                         */
                        CustomAttribute.prototype.capitalization = null;

                        /**
                         * CustomAttribute originalFontSize.
                         * @member {number|null|undefined} originalFontSize
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @instance
                         */
                        CustomAttribute.prototype.originalFontSize = null;

                        /**
                         * CustomAttribute fontScaleFactor.
                         * @member {number|null|undefined} fontScaleFactor
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @instance
                         */
                        CustomAttribute.prototype.fontScaleFactor = null;

                        /**
                         * CustomAttribute textGradientFill.
                         * @member {rv.data.Graphics.Text.IGradientFill|null|undefined} textGradientFill
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @instance
                         */
                        CustomAttribute.prototype.textGradientFill = null;

                        /**
                         * CustomAttribute shouldPreserveForegroundColor.
                         * @member {boolean|null|undefined} shouldPreserveForegroundColor
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @instance
                         */
                        CustomAttribute.prototype.shouldPreserveForegroundColor = null;

                        /**
                         * CustomAttribute chord.
                         * @member {string|null|undefined} chord
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @instance
                         */
                        CustomAttribute.prototype.chord = null;

                        /**
                         * CustomAttribute cutOutFill.
                         * @member {rv.data.Graphics.Text.ICutOutFill|null|undefined} cutOutFill
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @instance
                         */
                        CustomAttribute.prototype.cutOutFill = null;

                        /**
                         * CustomAttribute mediaFill.
                         * @member {rv.data.Graphics.Text.IMediaFill|null|undefined} mediaFill
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @instance
                         */
                        CustomAttribute.prototype.mediaFill = null;

                        /**
                         * CustomAttribute backgroundEffect.
                         * @member {rv.data.Graphics.IBackgroundEffect|null|undefined} backgroundEffect
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @instance
                         */
                        CustomAttribute.prototype.backgroundEffect = null;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * CustomAttribute Attribute.
                         * @member {"capitalization"|"originalFontSize"|"fontScaleFactor"|"textGradientFill"|"shouldPreserveForegroundColor"|"chord"|"cutOutFill"|"mediaFill"|"backgroundEffect"|undefined} Attribute
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @instance
                         */
                        Object.defineProperty(CustomAttribute.prototype, "Attribute", {
                            get: $util.oneOfGetter($oneOfFields = ["capitalization", "originalFontSize", "fontScaleFactor", "textGradientFill", "shouldPreserveForegroundColor", "chord", "cutOutFill", "mediaFill", "backgroundEffect"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Creates a new CustomAttribute instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @static
                         * @param {rv.data.Graphics.Text.Attributes.ICustomAttribute=} [properties] Properties to set
                         * @returns {rv.data.Graphics.Text.Attributes.CustomAttribute} CustomAttribute instance
                         */
                        CustomAttribute.create = function create(properties) {
                            return new CustomAttribute(properties);
                        };

                        /**
                         * Encodes the specified CustomAttribute message. Does not implicitly {@link rv.data.Graphics.Text.Attributes.CustomAttribute.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @static
                         * @param {rv.data.Graphics.Text.Attributes.ICustomAttribute} message CustomAttribute message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CustomAttribute.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.range != null && Object.hasOwnProperty.call(message, "range"))
                                $root.rv.data.IntRange.encode(message.range, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.capitalization != null && Object.hasOwnProperty.call(message, "capitalization"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.capitalization);
                            if (message.originalFontSize != null && Object.hasOwnProperty.call(message, "originalFontSize"))
                                writer.uint32(/* id 3, wireType 1 =*/25).double(message.originalFontSize);
                            if (message.fontScaleFactor != null && Object.hasOwnProperty.call(message, "fontScaleFactor"))
                                writer.uint32(/* id 4, wireType 1 =*/33).double(message.fontScaleFactor);
                            if (message.textGradientFill != null && Object.hasOwnProperty.call(message, "textGradientFill"))
                                $root.rv.data.Graphics.Text.GradientFill.encode(message.textGradientFill, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            if (message.shouldPreserveForegroundColor != null && Object.hasOwnProperty.call(message, "shouldPreserveForegroundColor"))
                                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.shouldPreserveForegroundColor);
                            if (message.chord != null && Object.hasOwnProperty.call(message, "chord"))
                                writer.uint32(/* id 7, wireType 2 =*/58).string(message.chord);
                            if (message.cutOutFill != null && Object.hasOwnProperty.call(message, "cutOutFill"))
                                $root.rv.data.Graphics.Text.CutOutFill.encode(message.cutOutFill, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                            if (message.mediaFill != null && Object.hasOwnProperty.call(message, "mediaFill"))
                                $root.rv.data.Graphics.Text.MediaFill.encode(message.mediaFill, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                            if (message.backgroundEffect != null && Object.hasOwnProperty.call(message, "backgroundEffect"))
                                $root.rv.data.Graphics.BackgroundEffect.encode(message.backgroundEffect, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified CustomAttribute message, length delimited. Does not implicitly {@link rv.data.Graphics.Text.Attributes.CustomAttribute.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @static
                         * @param {rv.data.Graphics.Text.Attributes.ICustomAttribute} message CustomAttribute message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CustomAttribute.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a CustomAttribute message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Graphics.Text.Attributes.CustomAttribute} CustomAttribute
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CustomAttribute.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Graphics.Text.Attributes.CustomAttribute();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.range = $root.rv.data.IntRange.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.capitalization = reader.int32();
                                        break;
                                    }
                                case 3: {
                                        message.originalFontSize = reader.double();
                                        break;
                                    }
                                case 4: {
                                        message.fontScaleFactor = reader.double();
                                        break;
                                    }
                                case 5: {
                                        message.textGradientFill = $root.rv.data.Graphics.Text.GradientFill.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 6: {
                                        message.shouldPreserveForegroundColor = reader.bool();
                                        break;
                                    }
                                case 7: {
                                        message.chord = reader.string();
                                        break;
                                    }
                                case 8: {
                                        message.cutOutFill = $root.rv.data.Graphics.Text.CutOutFill.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 9: {
                                        message.mediaFill = $root.rv.data.Graphics.Text.MediaFill.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 10: {
                                        message.backgroundEffect = $root.rv.data.Graphics.BackgroundEffect.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a CustomAttribute message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Graphics.Text.Attributes.CustomAttribute} CustomAttribute
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CustomAttribute.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a CustomAttribute message.
                         * @function verify
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        CustomAttribute.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.range != null && message.hasOwnProperty("range")) {
                                let error = $root.rv.data.IntRange.verify(message.range);
                                if (error)
                                    return "range." + error;
                            }
                            if (message.capitalization != null && message.hasOwnProperty("capitalization")) {
                                properties.Attribute = 1;
                                switch (message.capitalization) {
                                default:
                                    return "capitalization: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                    break;
                                }
                            }
                            if (message.originalFontSize != null && message.hasOwnProperty("originalFontSize")) {
                                if (properties.Attribute === 1)
                                    return "Attribute: multiple values";
                                properties.Attribute = 1;
                                if (typeof message.originalFontSize !== "number")
                                    return "originalFontSize: number expected";
                            }
                            if (message.fontScaleFactor != null && message.hasOwnProperty("fontScaleFactor")) {
                                if (properties.Attribute === 1)
                                    return "Attribute: multiple values";
                                properties.Attribute = 1;
                                if (typeof message.fontScaleFactor !== "number")
                                    return "fontScaleFactor: number expected";
                            }
                            if (message.textGradientFill != null && message.hasOwnProperty("textGradientFill")) {
                                if (properties.Attribute === 1)
                                    return "Attribute: multiple values";
                                properties.Attribute = 1;
                                {
                                    let error = $root.rv.data.Graphics.Text.GradientFill.verify(message.textGradientFill);
                                    if (error)
                                        return "textGradientFill." + error;
                                }
                            }
                            if (message.shouldPreserveForegroundColor != null && message.hasOwnProperty("shouldPreserveForegroundColor")) {
                                if (properties.Attribute === 1)
                                    return "Attribute: multiple values";
                                properties.Attribute = 1;
                                if (typeof message.shouldPreserveForegroundColor !== "boolean")
                                    return "shouldPreserveForegroundColor: boolean expected";
                            }
                            if (message.chord != null && message.hasOwnProperty("chord")) {
                                if (properties.Attribute === 1)
                                    return "Attribute: multiple values";
                                properties.Attribute = 1;
                                if (!$util.isString(message.chord))
                                    return "chord: string expected";
                            }
                            if (message.cutOutFill != null && message.hasOwnProperty("cutOutFill")) {
                                if (properties.Attribute === 1)
                                    return "Attribute: multiple values";
                                properties.Attribute = 1;
                                {
                                    let error = $root.rv.data.Graphics.Text.CutOutFill.verify(message.cutOutFill);
                                    if (error)
                                        return "cutOutFill." + error;
                                }
                            }
                            if (message.mediaFill != null && message.hasOwnProperty("mediaFill")) {
                                if (properties.Attribute === 1)
                                    return "Attribute: multiple values";
                                properties.Attribute = 1;
                                {
                                    let error = $root.rv.data.Graphics.Text.MediaFill.verify(message.mediaFill);
                                    if (error)
                                        return "mediaFill." + error;
                                }
                            }
                            if (message.backgroundEffect != null && message.hasOwnProperty("backgroundEffect")) {
                                if (properties.Attribute === 1)
                                    return "Attribute: multiple values";
                                properties.Attribute = 1;
                                {
                                    let error = $root.rv.data.Graphics.BackgroundEffect.verify(message.backgroundEffect);
                                    if (error)
                                        return "backgroundEffect." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a CustomAttribute message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Graphics.Text.Attributes.CustomAttribute} CustomAttribute
                         */
                        CustomAttribute.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Graphics.Text.Attributes.CustomAttribute)
                                return object;
                            let message = new $root.rv.data.Graphics.Text.Attributes.CustomAttribute();
                            if (object.range != null) {
                                if (typeof object.range !== "object")
                                    throw TypeError(".rv.data.Graphics.Text.Attributes.CustomAttribute.range: object expected");
                                message.range = $root.rv.data.IntRange.fromObject(object.range);
                            }
                            switch (object.capitalization) {
                            default:
                                if (typeof object.capitalization === "number") {
                                    message.capitalization = object.capitalization;
                                    break;
                                }
                                break;
                            case "CAPITALIZATION_NONE":
                            case 0:
                                message.capitalization = 0;
                                break;
                            case "CAPITALIZATION_ALL_CAPS":
                            case 1:
                                message.capitalization = 1;
                                break;
                            case "CAPITALIZATION_SMALL_CAPS":
                            case 2:
                                message.capitalization = 2;
                                break;
                            case "CAPITALIZATION_TITLE_CASE":
                            case 3:
                                message.capitalization = 3;
                                break;
                            case "CAPITALIZATION_START_CASE":
                            case 4:
                                message.capitalization = 4;
                                break;
                            }
                            if (object.originalFontSize != null)
                                message.originalFontSize = Number(object.originalFontSize);
                            if (object.fontScaleFactor != null)
                                message.fontScaleFactor = Number(object.fontScaleFactor);
                            if (object.textGradientFill != null) {
                                if (typeof object.textGradientFill !== "object")
                                    throw TypeError(".rv.data.Graphics.Text.Attributes.CustomAttribute.textGradientFill: object expected");
                                message.textGradientFill = $root.rv.data.Graphics.Text.GradientFill.fromObject(object.textGradientFill);
                            }
                            if (object.shouldPreserveForegroundColor != null)
                                message.shouldPreserveForegroundColor = Boolean(object.shouldPreserveForegroundColor);
                            if (object.chord != null)
                                message.chord = String(object.chord);
                            if (object.cutOutFill != null) {
                                if (typeof object.cutOutFill !== "object")
                                    throw TypeError(".rv.data.Graphics.Text.Attributes.CustomAttribute.cutOutFill: object expected");
                                message.cutOutFill = $root.rv.data.Graphics.Text.CutOutFill.fromObject(object.cutOutFill);
                            }
                            if (object.mediaFill != null) {
                                if (typeof object.mediaFill !== "object")
                                    throw TypeError(".rv.data.Graphics.Text.Attributes.CustomAttribute.mediaFill: object expected");
                                message.mediaFill = $root.rv.data.Graphics.Text.MediaFill.fromObject(object.mediaFill);
                            }
                            if (object.backgroundEffect != null) {
                                if (typeof object.backgroundEffect !== "object")
                                    throw TypeError(".rv.data.Graphics.Text.Attributes.CustomAttribute.backgroundEffect: object expected");
                                message.backgroundEffect = $root.rv.data.Graphics.BackgroundEffect.fromObject(object.backgroundEffect);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a CustomAttribute message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @static
                         * @param {rv.data.Graphics.Text.Attributes.CustomAttribute} message CustomAttribute
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        CustomAttribute.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.range = null;
                            if (message.range != null && message.hasOwnProperty("range"))
                                object.range = $root.rv.data.IntRange.toObject(message.range, options);
                            if (message.capitalization != null && message.hasOwnProperty("capitalization")) {
                                object.capitalization = options.enums === String ? $root.rv.data.Graphics.Text.Attributes.Capitalization[message.capitalization] === undefined ? message.capitalization : $root.rv.data.Graphics.Text.Attributes.Capitalization[message.capitalization] : message.capitalization;
                                if (options.oneofs)
                                    object.Attribute = "capitalization";
                            }
                            if (message.originalFontSize != null && message.hasOwnProperty("originalFontSize")) {
                                object.originalFontSize = options.json && !isFinite(message.originalFontSize) ? String(message.originalFontSize) : message.originalFontSize;
                                if (options.oneofs)
                                    object.Attribute = "originalFontSize";
                            }
                            if (message.fontScaleFactor != null && message.hasOwnProperty("fontScaleFactor")) {
                                object.fontScaleFactor = options.json && !isFinite(message.fontScaleFactor) ? String(message.fontScaleFactor) : message.fontScaleFactor;
                                if (options.oneofs)
                                    object.Attribute = "fontScaleFactor";
                            }
                            if (message.textGradientFill != null && message.hasOwnProperty("textGradientFill")) {
                                object.textGradientFill = $root.rv.data.Graphics.Text.GradientFill.toObject(message.textGradientFill, options);
                                if (options.oneofs)
                                    object.Attribute = "textGradientFill";
                            }
                            if (message.shouldPreserveForegroundColor != null && message.hasOwnProperty("shouldPreserveForegroundColor")) {
                                object.shouldPreserveForegroundColor = message.shouldPreserveForegroundColor;
                                if (options.oneofs)
                                    object.Attribute = "shouldPreserveForegroundColor";
                            }
                            if (message.chord != null && message.hasOwnProperty("chord")) {
                                object.chord = message.chord;
                                if (options.oneofs)
                                    object.Attribute = "chord";
                            }
                            if (message.cutOutFill != null && message.hasOwnProperty("cutOutFill")) {
                                object.cutOutFill = $root.rv.data.Graphics.Text.CutOutFill.toObject(message.cutOutFill, options);
                                if (options.oneofs)
                                    object.Attribute = "cutOutFill";
                            }
                            if (message.mediaFill != null && message.hasOwnProperty("mediaFill")) {
                                object.mediaFill = $root.rv.data.Graphics.Text.MediaFill.toObject(message.mediaFill, options);
                                if (options.oneofs)
                                    object.Attribute = "mediaFill";
                            }
                            if (message.backgroundEffect != null && message.hasOwnProperty("backgroundEffect")) {
                                object.backgroundEffect = $root.rv.data.Graphics.BackgroundEffect.toObject(message.backgroundEffect, options);
                                if (options.oneofs)
                                    object.Attribute = "backgroundEffect";
                            }
                            return object;
                        };

                        /**
                         * Converts this CustomAttribute to JSON.
                         * @function toJSON
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        CustomAttribute.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for CustomAttribute
                         * @function getTypeUrl
                         * @memberof rv.data.Graphics.Text.Attributes.CustomAttribute
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        CustomAttribute.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Graphics.Text.Attributes.CustomAttribute";
                        };

                        return CustomAttribute;
                    })();

                    /**
                     * Capitalization enum.
                     * @name rv.data.Graphics.Text.Attributes.Capitalization
                     * @enum {number}
                     * @property {number} CAPITALIZATION_NONE=0 CAPITALIZATION_NONE value
                     * @property {number} CAPITALIZATION_ALL_CAPS=1 CAPITALIZATION_ALL_CAPS value
                     * @property {number} CAPITALIZATION_SMALL_CAPS=2 CAPITALIZATION_SMALL_CAPS value
                     * @property {number} CAPITALIZATION_TITLE_CASE=3 CAPITALIZATION_TITLE_CASE value
                     * @property {number} CAPITALIZATION_START_CASE=4 CAPITALIZATION_START_CASE value
                     */
                    Attributes.Capitalization = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "CAPITALIZATION_NONE"] = 0;
                        values[valuesById[1] = "CAPITALIZATION_ALL_CAPS"] = 1;
                        values[valuesById[2] = "CAPITALIZATION_SMALL_CAPS"] = 2;
                        values[valuesById[3] = "CAPITALIZATION_TITLE_CASE"] = 3;
                        values[valuesById[4] = "CAPITALIZATION_START_CASE"] = 4;
                        return values;
                    })();

                    /**
                     * Alignment enum.
                     * @name rv.data.Graphics.Text.Attributes.Alignment
                     * @enum {number}
                     * @property {number} ALIGNMENT_LEFT=0 ALIGNMENT_LEFT value
                     * @property {number} ALIGNMENT_RIGHT=1 ALIGNMENT_RIGHT value
                     * @property {number} ALIGNMENT_CENTER=2 ALIGNMENT_CENTER value
                     * @property {number} ALIGNMENT_JUSTIFIED=3 ALIGNMENT_JUSTIFIED value
                     * @property {number} ALIGNMENT_NATURAL=4 ALIGNMENT_NATURAL value
                     */
                    Attributes.Alignment = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "ALIGNMENT_LEFT"] = 0;
                        values[valuesById[1] = "ALIGNMENT_RIGHT"] = 1;
                        values[valuesById[2] = "ALIGNMENT_CENTER"] = 2;
                        values[valuesById[3] = "ALIGNMENT_JUSTIFIED"] = 3;
                        values[valuesById[4] = "ALIGNMENT_NATURAL"] = 4;
                        return values;
                    })();

                    return Attributes;
                })();

                /**
                 * VerticalAlignment enum.
                 * @name rv.data.Graphics.Text.VerticalAlignment
                 * @enum {number}
                 * @property {number} VERTICAL_ALIGNMENT_TOP=0 VERTICAL_ALIGNMENT_TOP value
                 * @property {number} VERTICAL_ALIGNMENT_MIDDLE=1 VERTICAL_ALIGNMENT_MIDDLE value
                 * @property {number} VERTICAL_ALIGNMENT_BOTTOM=2 VERTICAL_ALIGNMENT_BOTTOM value
                 */
                Text.VerticalAlignment = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "VERTICAL_ALIGNMENT_TOP"] = 0;
                    values[valuesById[1] = "VERTICAL_ALIGNMENT_MIDDLE"] = 1;
                    values[valuesById[2] = "VERTICAL_ALIGNMENT_BOTTOM"] = 2;
                    return values;
                })();

                /**
                 * ScaleBehavior enum.
                 * @name rv.data.Graphics.Text.ScaleBehavior
                 * @enum {number}
                 * @property {number} SCALE_BEHAVIOR_NONE=0 SCALE_BEHAVIOR_NONE value
                 * @property {number} SCALE_BEHAVIOR_ADJUST_CONTAINER_HEIGHT=1 SCALE_BEHAVIOR_ADJUST_CONTAINER_HEIGHT value
                 * @property {number} SCALE_BEHAVIOR_SCALE_FONT_DOWN=2 SCALE_BEHAVIOR_SCALE_FONT_DOWN value
                 * @property {number} SCALE_BEHAVIOR_SCALE_FONT_UP=3 SCALE_BEHAVIOR_SCALE_FONT_UP value
                 * @property {number} SCALE_BEHAVIOR_SCALE_FONT_UP_DOWN=4 SCALE_BEHAVIOR_SCALE_FONT_UP_DOWN value
                 */
                Text.ScaleBehavior = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "SCALE_BEHAVIOR_NONE"] = 0;
                    values[valuesById[1] = "SCALE_BEHAVIOR_ADJUST_CONTAINER_HEIGHT"] = 1;
                    values[valuesById[2] = "SCALE_BEHAVIOR_SCALE_FONT_DOWN"] = 2;
                    values[valuesById[3] = "SCALE_BEHAVIOR_SCALE_FONT_UP"] = 3;
                    values[valuesById[4] = "SCALE_BEHAVIOR_SCALE_FONT_UP_DOWN"] = 4;
                    return values;
                })();

                /**
                 * Transform enum.
                 * @name rv.data.Graphics.Text.Transform
                 * @enum {number}
                 * @property {number} TRANSFORM_NONE=0 TRANSFORM_NONE value
                 * @property {number} TRANSFORM_SINGLE_LINE=1 TRANSFORM_SINGLE_LINE value
                 * @property {number} TRANSFORM_ONE_WORD_PER_LINE=2 TRANSFORM_ONE_WORD_PER_LINE value
                 * @property {number} TRANSFORM_ONE_CHARACTER_PER_LINE=3 TRANSFORM_ONE_CHARACTER_PER_LINE value
                 * @property {number} TRANSFORM_REPLACE_LINE_RETURNS=4 TRANSFORM_REPLACE_LINE_RETURNS value
                 */
                Text.Transform = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "TRANSFORM_NONE"] = 0;
                    values[valuesById[1] = "TRANSFORM_SINGLE_LINE"] = 1;
                    values[valuesById[2] = "TRANSFORM_ONE_WORD_PER_LINE"] = 2;
                    values[valuesById[3] = "TRANSFORM_ONE_CHARACTER_PER_LINE"] = 3;
                    values[valuesById[4] = "TRANSFORM_REPLACE_LINE_RETURNS"] = 4;
                    return values;
                })();

                return Text;
            })();

            return Graphics;
        })();

        data.Media = (function() {

            /**
             * Properties of a Media.
             * @memberof rv.data
             * @interface IMedia
             * @property {rv.data.IUUID|null} [uuid] Media uuid
             * @property {rv.data.IURL|null} [url] Media url
             * @property {rv.data.Media.IMetadata|null} [metadata] Media metadata
             * @property {rv.data.Media.IAudioTypeProperties|null} [audio] Media audio
             * @property {rv.data.Media.IImageTypeProperties|null} [image] Media image
             * @property {rv.data.Media.IVideoTypeProperties|null} [video] Media video
             * @property {rv.data.Media.ILiveVideoTypeProperties|null} [liveVideo] Media liveVideo
             * @property {rv.data.Media.IWebContentTypeProperties|null} [webContent] Media webContent
             */

            /**
             * Constructs a new Media.
             * @memberof rv.data
             * @classdesc Represents a Media.
             * @implements IMedia
             * @constructor
             * @param {rv.data.IMedia=} [properties] Properties to set
             */
            function Media(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Media uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.Media
             * @instance
             */
            Media.prototype.uuid = null;

            /**
             * Media url.
             * @member {rv.data.IURL|null|undefined} url
             * @memberof rv.data.Media
             * @instance
             */
            Media.prototype.url = null;

            /**
             * Media metadata.
             * @member {rv.data.Media.IMetadata|null|undefined} metadata
             * @memberof rv.data.Media
             * @instance
             */
            Media.prototype.metadata = null;

            /**
             * Media audio.
             * @member {rv.data.Media.IAudioTypeProperties|null|undefined} audio
             * @memberof rv.data.Media
             * @instance
             */
            Media.prototype.audio = null;

            /**
             * Media image.
             * @member {rv.data.Media.IImageTypeProperties|null|undefined} image
             * @memberof rv.data.Media
             * @instance
             */
            Media.prototype.image = null;

            /**
             * Media video.
             * @member {rv.data.Media.IVideoTypeProperties|null|undefined} video
             * @memberof rv.data.Media
             * @instance
             */
            Media.prototype.video = null;

            /**
             * Media liveVideo.
             * @member {rv.data.Media.ILiveVideoTypeProperties|null|undefined} liveVideo
             * @memberof rv.data.Media
             * @instance
             */
            Media.prototype.liveVideo = null;

            /**
             * Media webContent.
             * @member {rv.data.Media.IWebContentTypeProperties|null|undefined} webContent
             * @memberof rv.data.Media
             * @instance
             */
            Media.prototype.webContent = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Media TypeProperties.
             * @member {"audio"|"image"|"video"|"liveVideo"|"webContent"|undefined} TypeProperties
             * @memberof rv.data.Media
             * @instance
             */
            Object.defineProperty(Media.prototype, "TypeProperties", {
                get: $util.oneOfGetter($oneOfFields = ["audio", "image", "video", "liveVideo", "webContent"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Media instance using the specified properties.
             * @function create
             * @memberof rv.data.Media
             * @static
             * @param {rv.data.IMedia=} [properties] Properties to set
             * @returns {rv.data.Media} Media instance
             */
            Media.create = function create(properties) {
                return new Media(properties);
            };

            /**
             * Encodes the specified Media message. Does not implicitly {@link rv.data.Media.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Media
             * @static
             * @param {rv.data.IMedia} message Media message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Media.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    $root.rv.data.URL.encode(message.url, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    $root.rv.data.Media.Metadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                    $root.rv.data.Media.AudioTypeProperties.encode(message.audio, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                    $root.rv.data.Media.ImageTypeProperties.encode(message.image, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.video != null && Object.hasOwnProperty.call(message, "video"))
                    $root.rv.data.Media.VideoTypeProperties.encode(message.video, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.liveVideo != null && Object.hasOwnProperty.call(message, "liveVideo"))
                    $root.rv.data.Media.LiveVideoTypeProperties.encode(message.liveVideo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.webContent != null && Object.hasOwnProperty.call(message, "webContent"))
                    $root.rv.data.Media.WebContentTypeProperties.encode(message.webContent, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Media message, length delimited. Does not implicitly {@link rv.data.Media.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Media
             * @static
             * @param {rv.data.IMedia} message Media message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Media.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Media message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Media
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Media} Media
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Media.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.url = $root.rv.data.URL.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.metadata = $root.rv.data.Media.Metadata.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.audio = $root.rv.data.Media.AudioTypeProperties.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.image = $root.rv.data.Media.ImageTypeProperties.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.video = $root.rv.data.Media.VideoTypeProperties.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.liveVideo = $root.rv.data.Media.LiveVideoTypeProperties.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.webContent = $root.rv.data.Media.WebContentTypeProperties.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Media message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Media
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Media} Media
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Media.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Media message.
             * @function verify
             * @memberof rv.data.Media
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Media.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    let error = $root.rv.data.URL.verify(message.url);
                    if (error)
                        return "url." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.rv.data.Media.Metadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                if (message.audio != null && message.hasOwnProperty("audio")) {
                    properties.TypeProperties = 1;
                    {
                        let error = $root.rv.data.Media.AudioTypeProperties.verify(message.audio);
                        if (error)
                            return "audio." + error;
                    }
                }
                if (message.image != null && message.hasOwnProperty("image")) {
                    if (properties.TypeProperties === 1)
                        return "TypeProperties: multiple values";
                    properties.TypeProperties = 1;
                    {
                        let error = $root.rv.data.Media.ImageTypeProperties.verify(message.image);
                        if (error)
                            return "image." + error;
                    }
                }
                if (message.video != null && message.hasOwnProperty("video")) {
                    if (properties.TypeProperties === 1)
                        return "TypeProperties: multiple values";
                    properties.TypeProperties = 1;
                    {
                        let error = $root.rv.data.Media.VideoTypeProperties.verify(message.video);
                        if (error)
                            return "video." + error;
                    }
                }
                if (message.liveVideo != null && message.hasOwnProperty("liveVideo")) {
                    if (properties.TypeProperties === 1)
                        return "TypeProperties: multiple values";
                    properties.TypeProperties = 1;
                    {
                        let error = $root.rv.data.Media.LiveVideoTypeProperties.verify(message.liveVideo);
                        if (error)
                            return "liveVideo." + error;
                    }
                }
                if (message.webContent != null && message.hasOwnProperty("webContent")) {
                    if (properties.TypeProperties === 1)
                        return "TypeProperties: multiple values";
                    properties.TypeProperties = 1;
                    {
                        let error = $root.rv.data.Media.WebContentTypeProperties.verify(message.webContent);
                        if (error)
                            return "webContent." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Media message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Media
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Media} Media
             */
            Media.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Media)
                    return object;
                let message = new $root.rv.data.Media();
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.Media.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                if (object.url != null) {
                    if (typeof object.url !== "object")
                        throw TypeError(".rv.data.Media.url: object expected");
                    message.url = $root.rv.data.URL.fromObject(object.url);
                }
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".rv.data.Media.metadata: object expected");
                    message.metadata = $root.rv.data.Media.Metadata.fromObject(object.metadata);
                }
                if (object.audio != null) {
                    if (typeof object.audio !== "object")
                        throw TypeError(".rv.data.Media.audio: object expected");
                    message.audio = $root.rv.data.Media.AudioTypeProperties.fromObject(object.audio);
                }
                if (object.image != null) {
                    if (typeof object.image !== "object")
                        throw TypeError(".rv.data.Media.image: object expected");
                    message.image = $root.rv.data.Media.ImageTypeProperties.fromObject(object.image);
                }
                if (object.video != null) {
                    if (typeof object.video !== "object")
                        throw TypeError(".rv.data.Media.video: object expected");
                    message.video = $root.rv.data.Media.VideoTypeProperties.fromObject(object.video);
                }
                if (object.liveVideo != null) {
                    if (typeof object.liveVideo !== "object")
                        throw TypeError(".rv.data.Media.liveVideo: object expected");
                    message.liveVideo = $root.rv.data.Media.LiveVideoTypeProperties.fromObject(object.liveVideo);
                }
                if (object.webContent != null) {
                    if (typeof object.webContent !== "object")
                        throw TypeError(".rv.data.Media.webContent: object expected");
                    message.webContent = $root.rv.data.Media.WebContentTypeProperties.fromObject(object.webContent);
                }
                return message;
            };

            /**
             * Creates a plain object from a Media message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Media
             * @static
             * @param {rv.data.Media} message Media
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Media.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uuid = null;
                    object.url = null;
                    object.metadata = null;
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = $root.rv.data.URL.toObject(message.url, options);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.rv.data.Media.Metadata.toObject(message.metadata, options);
                if (message.audio != null && message.hasOwnProperty("audio")) {
                    object.audio = $root.rv.data.Media.AudioTypeProperties.toObject(message.audio, options);
                    if (options.oneofs)
                        object.TypeProperties = "audio";
                }
                if (message.image != null && message.hasOwnProperty("image")) {
                    object.image = $root.rv.data.Media.ImageTypeProperties.toObject(message.image, options);
                    if (options.oneofs)
                        object.TypeProperties = "image";
                }
                if (message.video != null && message.hasOwnProperty("video")) {
                    object.video = $root.rv.data.Media.VideoTypeProperties.toObject(message.video, options);
                    if (options.oneofs)
                        object.TypeProperties = "video";
                }
                if (message.liveVideo != null && message.hasOwnProperty("liveVideo")) {
                    object.liveVideo = $root.rv.data.Media.LiveVideoTypeProperties.toObject(message.liveVideo, options);
                    if (options.oneofs)
                        object.TypeProperties = "liveVideo";
                }
                if (message.webContent != null && message.hasOwnProperty("webContent")) {
                    object.webContent = $root.rv.data.Media.WebContentTypeProperties.toObject(message.webContent, options);
                    if (options.oneofs)
                        object.TypeProperties = "webContent";
                }
                return object;
            };

            /**
             * Converts this Media to JSON.
             * @function toJSON
             * @memberof rv.data.Media
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Media.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Media
             * @function getTypeUrl
             * @memberof rv.data.Media
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Media.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Media";
            };

            Media.Metadata = (function() {

                /**
                 * Properties of a Metadata.
                 * @memberof rv.data.Media
                 * @interface IMetadata
                 * @property {string|null} [manufactureName] Metadata manufactureName
                 * @property {rv.data.IURL|null} [manufactureUrl] Metadata manufactureUrl
                 * @property {string|null} [information] Metadata information
                 * @property {string|null} [artist] Metadata artist
                 * @property {string|null} [format] Metadata format
                 */

                /**
                 * Constructs a new Metadata.
                 * @memberof rv.data.Media
                 * @classdesc Represents a Metadata.
                 * @implements IMetadata
                 * @constructor
                 * @param {rv.data.Media.IMetadata=} [properties] Properties to set
                 */
                function Metadata(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Metadata manufactureName.
                 * @member {string} manufactureName
                 * @memberof rv.data.Media.Metadata
                 * @instance
                 */
                Metadata.prototype.manufactureName = "";

                /**
                 * Metadata manufactureUrl.
                 * @member {rv.data.IURL|null|undefined} manufactureUrl
                 * @memberof rv.data.Media.Metadata
                 * @instance
                 */
                Metadata.prototype.manufactureUrl = null;

                /**
                 * Metadata information.
                 * @member {string} information
                 * @memberof rv.data.Media.Metadata
                 * @instance
                 */
                Metadata.prototype.information = "";

                /**
                 * Metadata artist.
                 * @member {string} artist
                 * @memberof rv.data.Media.Metadata
                 * @instance
                 */
                Metadata.prototype.artist = "";

                /**
                 * Metadata format.
                 * @member {string} format
                 * @memberof rv.data.Media.Metadata
                 * @instance
                 */
                Metadata.prototype.format = "";

                /**
                 * Creates a new Metadata instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.Metadata
                 * @static
                 * @param {rv.data.Media.IMetadata=} [properties] Properties to set
                 * @returns {rv.data.Media.Metadata} Metadata instance
                 */
                Metadata.create = function create(properties) {
                    return new Metadata(properties);
                };

                /**
                 * Encodes the specified Metadata message. Does not implicitly {@link rv.data.Media.Metadata.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.Metadata
                 * @static
                 * @param {rv.data.Media.IMetadata} message Metadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Metadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.manufactureName != null && Object.hasOwnProperty.call(message, "manufactureName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.manufactureName);
                    if (message.manufactureUrl != null && Object.hasOwnProperty.call(message, "manufactureUrl"))
                        $root.rv.data.URL.encode(message.manufactureUrl, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.information != null && Object.hasOwnProperty.call(message, "information"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.information);
                    if (message.artist != null && Object.hasOwnProperty.call(message, "artist"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.artist);
                    if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.format);
                    return writer;
                };

                /**
                 * Encodes the specified Metadata message, length delimited. Does not implicitly {@link rv.data.Media.Metadata.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.Metadata
                 * @static
                 * @param {rv.data.Media.IMetadata} message Metadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Metadata.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Metadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.Metadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.Metadata} Metadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Metadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.Metadata();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.manufactureName = reader.string();
                                break;
                            }
                        case 2: {
                                message.manufactureUrl = $root.rv.data.URL.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.information = reader.string();
                                break;
                            }
                        case 4: {
                                message.artist = reader.string();
                                break;
                            }
                        case 5: {
                                message.format = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Metadata message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.Metadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.Metadata} Metadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Metadata.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Metadata message.
                 * @function verify
                 * @memberof rv.data.Media.Metadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Metadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.manufactureName != null && message.hasOwnProperty("manufactureName"))
                        if (!$util.isString(message.manufactureName))
                            return "manufactureName: string expected";
                    if (message.manufactureUrl != null && message.hasOwnProperty("manufactureUrl")) {
                        let error = $root.rv.data.URL.verify(message.manufactureUrl);
                        if (error)
                            return "manufactureUrl." + error;
                    }
                    if (message.information != null && message.hasOwnProperty("information"))
                        if (!$util.isString(message.information))
                            return "information: string expected";
                    if (message.artist != null && message.hasOwnProperty("artist"))
                        if (!$util.isString(message.artist))
                            return "artist: string expected";
                    if (message.format != null && message.hasOwnProperty("format"))
                        if (!$util.isString(message.format))
                            return "format: string expected";
                    return null;
                };

                /**
                 * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.Metadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.Metadata} Metadata
                 */
                Metadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.Metadata)
                        return object;
                    let message = new $root.rv.data.Media.Metadata();
                    if (object.manufactureName != null)
                        message.manufactureName = String(object.manufactureName);
                    if (object.manufactureUrl != null) {
                        if (typeof object.manufactureUrl !== "object")
                            throw TypeError(".rv.data.Media.Metadata.manufactureUrl: object expected");
                        message.manufactureUrl = $root.rv.data.URL.fromObject(object.manufactureUrl);
                    }
                    if (object.information != null)
                        message.information = String(object.information);
                    if (object.artist != null)
                        message.artist = String(object.artist);
                    if (object.format != null)
                        message.format = String(object.format);
                    return message;
                };

                /**
                 * Creates a plain object from a Metadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.Metadata
                 * @static
                 * @param {rv.data.Media.Metadata} message Metadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Metadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.manufactureName = "";
                        object.manufactureUrl = null;
                        object.information = "";
                        object.artist = "";
                        object.format = "";
                    }
                    if (message.manufactureName != null && message.hasOwnProperty("manufactureName"))
                        object.manufactureName = message.manufactureName;
                    if (message.manufactureUrl != null && message.hasOwnProperty("manufactureUrl"))
                        object.manufactureUrl = $root.rv.data.URL.toObject(message.manufactureUrl, options);
                    if (message.information != null && message.hasOwnProperty("information"))
                        object.information = message.information;
                    if (message.artist != null && message.hasOwnProperty("artist"))
                        object.artist = message.artist;
                    if (message.format != null && message.hasOwnProperty("format"))
                        object.format = message.format;
                    return object;
                };

                /**
                 * Converts this Metadata to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.Metadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Metadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Metadata
                 * @function getTypeUrl
                 * @memberof rv.data.Media.Metadata
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Metadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.Metadata";
                };

                return Metadata;
            })();

            Media.VideoDevice = (function() {

                /**
                 * Properties of a VideoDevice.
                 * @memberof rv.data.Media
                 * @interface IVideoDevice
                 * @property {rv.data.Media.VideoDevice.Type|null} [type] VideoDevice type
                 * @property {string|null} [name] VideoDevice name
                 * @property {string|null} [uniqueId] VideoDevice uniqueId
                 * @property {string|null} [modelId] VideoDevice modelId
                 * @property {number|null} [formatIndex] VideoDevice formatIndex
                 * @property {rv.data.DigitalAudio.Device.IRouting|null} [audioRouting] VideoDevice audioRouting
                 */

                /**
                 * Constructs a new VideoDevice.
                 * @memberof rv.data.Media
                 * @classdesc Represents a VideoDevice.
                 * @implements IVideoDevice
                 * @constructor
                 * @param {rv.data.Media.IVideoDevice=} [properties] Properties to set
                 */
                function VideoDevice(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * VideoDevice type.
                 * @member {rv.data.Media.VideoDevice.Type} type
                 * @memberof rv.data.Media.VideoDevice
                 * @instance
                 */
                VideoDevice.prototype.type = 0;

                /**
                 * VideoDevice name.
                 * @member {string} name
                 * @memberof rv.data.Media.VideoDevice
                 * @instance
                 */
                VideoDevice.prototype.name = "";

                /**
                 * VideoDevice uniqueId.
                 * @member {string} uniqueId
                 * @memberof rv.data.Media.VideoDevice
                 * @instance
                 */
                VideoDevice.prototype.uniqueId = "";

                /**
                 * VideoDevice modelId.
                 * @member {string} modelId
                 * @memberof rv.data.Media.VideoDevice
                 * @instance
                 */
                VideoDevice.prototype.modelId = "";

                /**
                 * VideoDevice formatIndex.
                 * @member {number} formatIndex
                 * @memberof rv.data.Media.VideoDevice
                 * @instance
                 */
                VideoDevice.prototype.formatIndex = 0;

                /**
                 * VideoDevice audioRouting.
                 * @member {rv.data.DigitalAudio.Device.IRouting|null|undefined} audioRouting
                 * @memberof rv.data.Media.VideoDevice
                 * @instance
                 */
                VideoDevice.prototype.audioRouting = null;

                /**
                 * Creates a new VideoDevice instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.VideoDevice
                 * @static
                 * @param {rv.data.Media.IVideoDevice=} [properties] Properties to set
                 * @returns {rv.data.Media.VideoDevice} VideoDevice instance
                 */
                VideoDevice.create = function create(properties) {
                    return new VideoDevice(properties);
                };

                /**
                 * Encodes the specified VideoDevice message. Does not implicitly {@link rv.data.Media.VideoDevice.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.VideoDevice
                 * @static
                 * @param {rv.data.Media.IVideoDevice} message VideoDevice message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VideoDevice.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.uniqueId != null && Object.hasOwnProperty.call(message, "uniqueId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.uniqueId);
                    if (message.modelId != null && Object.hasOwnProperty.call(message, "modelId"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.modelId);
                    if (message.formatIndex != null && Object.hasOwnProperty.call(message, "formatIndex"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.formatIndex);
                    if (message.audioRouting != null && Object.hasOwnProperty.call(message, "audioRouting"))
                        $root.rv.data.DigitalAudio.Device.Routing.encode(message.audioRouting, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified VideoDevice message, length delimited. Does not implicitly {@link rv.data.Media.VideoDevice.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.VideoDevice
                 * @static
                 * @param {rv.data.Media.IVideoDevice} message VideoDevice message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VideoDevice.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a VideoDevice message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.VideoDevice
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.VideoDevice} VideoDevice
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VideoDevice.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.VideoDevice();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.type = reader.int32();
                                break;
                            }
                        case 2: {
                                message.name = reader.string();
                                break;
                            }
                        case 3: {
                                message.uniqueId = reader.string();
                                break;
                            }
                        case 4: {
                                message.modelId = reader.string();
                                break;
                            }
                        case 5: {
                                message.formatIndex = reader.uint32();
                                break;
                            }
                        case 6: {
                                message.audioRouting = $root.rv.data.DigitalAudio.Device.Routing.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a VideoDevice message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.VideoDevice
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.VideoDevice} VideoDevice
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VideoDevice.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a VideoDevice message.
                 * @function verify
                 * @memberof rv.data.Media.VideoDevice
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                VideoDevice.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.uniqueId != null && message.hasOwnProperty("uniqueId"))
                        if (!$util.isString(message.uniqueId))
                            return "uniqueId: string expected";
                    if (message.modelId != null && message.hasOwnProperty("modelId"))
                        if (!$util.isString(message.modelId))
                            return "modelId: string expected";
                    if (message.formatIndex != null && message.hasOwnProperty("formatIndex"))
                        if (!$util.isInteger(message.formatIndex))
                            return "formatIndex: integer expected";
                    if (message.audioRouting != null && message.hasOwnProperty("audioRouting")) {
                        let error = $root.rv.data.DigitalAudio.Device.Routing.verify(message.audioRouting);
                        if (error)
                            return "audioRouting." + error;
                    }
                    return null;
                };

                /**
                 * Creates a VideoDevice message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.VideoDevice
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.VideoDevice} VideoDevice
                 */
                VideoDevice.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.VideoDevice)
                        return object;
                    let message = new $root.rv.data.Media.VideoDevice();
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "TYPE_GENERIC":
                    case 0:
                        message.type = 0;
                        break;
                    case "TYPE_DIRECTSHOW":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_BLACKMAGIC":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_AJA":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_AV":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_SYPHON":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_NDI":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_BLUEFISH":
                    case 7:
                        message.type = 7;
                        break;
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.uniqueId != null)
                        message.uniqueId = String(object.uniqueId);
                    if (object.modelId != null)
                        message.modelId = String(object.modelId);
                    if (object.formatIndex != null)
                        message.formatIndex = object.formatIndex >>> 0;
                    if (object.audioRouting != null) {
                        if (typeof object.audioRouting !== "object")
                            throw TypeError(".rv.data.Media.VideoDevice.audioRouting: object expected");
                        message.audioRouting = $root.rv.data.DigitalAudio.Device.Routing.fromObject(object.audioRouting);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a VideoDevice message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.VideoDevice
                 * @static
                 * @param {rv.data.Media.VideoDevice} message VideoDevice
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                VideoDevice.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "TYPE_GENERIC" : 0;
                        object.name = "";
                        object.uniqueId = "";
                        object.modelId = "";
                        object.formatIndex = 0;
                        object.audioRouting = null;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.rv.data.Media.VideoDevice.Type[message.type] === undefined ? message.type : $root.rv.data.Media.VideoDevice.Type[message.type] : message.type;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.uniqueId != null && message.hasOwnProperty("uniqueId"))
                        object.uniqueId = message.uniqueId;
                    if (message.modelId != null && message.hasOwnProperty("modelId"))
                        object.modelId = message.modelId;
                    if (message.formatIndex != null && message.hasOwnProperty("formatIndex"))
                        object.formatIndex = message.formatIndex;
                    if (message.audioRouting != null && message.hasOwnProperty("audioRouting"))
                        object.audioRouting = $root.rv.data.DigitalAudio.Device.Routing.toObject(message.audioRouting, options);
                    return object;
                };

                /**
                 * Converts this VideoDevice to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.VideoDevice
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                VideoDevice.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for VideoDevice
                 * @function getTypeUrl
                 * @memberof rv.data.Media.VideoDevice
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                VideoDevice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.VideoDevice";
                };

                /**
                 * Type enum.
                 * @name rv.data.Media.VideoDevice.Type
                 * @enum {number}
                 * @property {number} TYPE_GENERIC=0 TYPE_GENERIC value
                 * @property {number} TYPE_DIRECTSHOW=1 TYPE_DIRECTSHOW value
                 * @property {number} TYPE_BLACKMAGIC=2 TYPE_BLACKMAGIC value
                 * @property {number} TYPE_AJA=3 TYPE_AJA value
                 * @property {number} TYPE_AV=4 TYPE_AV value
                 * @property {number} TYPE_SYPHON=5 TYPE_SYPHON value
                 * @property {number} TYPE_NDI=6 TYPE_NDI value
                 * @property {number} TYPE_BLUEFISH=7 TYPE_BLUEFISH value
                 */
                VideoDevice.Type = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "TYPE_GENERIC"] = 0;
                    values[valuesById[1] = "TYPE_DIRECTSHOW"] = 1;
                    values[valuesById[2] = "TYPE_BLACKMAGIC"] = 2;
                    values[valuesById[3] = "TYPE_AJA"] = 3;
                    values[valuesById[4] = "TYPE_AV"] = 4;
                    values[valuesById[5] = "TYPE_SYPHON"] = 5;
                    values[valuesById[6] = "TYPE_NDI"] = 6;
                    values[valuesById[7] = "TYPE_BLUEFISH"] = 7;
                    return values;
                })();

                return VideoDevice;
            })();

            Media.AudioDevice = (function() {

                /**
                 * Properties of an AudioDevice.
                 * @memberof rv.data.Media
                 * @interface IAudioDevice
                 * @property {string|null} [name] AudioDevice name
                 * @property {string|null} [uniqueId] AudioDevice uniqueId
                 * @property {string|null} [modelId] AudioDevice modelId
                 * @property {number|null} [channelCount] AudioDevice channelCount
                 */

                /**
                 * Constructs a new AudioDevice.
                 * @memberof rv.data.Media
                 * @classdesc Represents an AudioDevice.
                 * @implements IAudioDevice
                 * @constructor
                 * @param {rv.data.Media.IAudioDevice=} [properties] Properties to set
                 */
                function AudioDevice(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AudioDevice name.
                 * @member {string} name
                 * @memberof rv.data.Media.AudioDevice
                 * @instance
                 */
                AudioDevice.prototype.name = "";

                /**
                 * AudioDevice uniqueId.
                 * @member {string} uniqueId
                 * @memberof rv.data.Media.AudioDevice
                 * @instance
                 */
                AudioDevice.prototype.uniqueId = "";

                /**
                 * AudioDevice modelId.
                 * @member {string} modelId
                 * @memberof rv.data.Media.AudioDevice
                 * @instance
                 */
                AudioDevice.prototype.modelId = "";

                /**
                 * AudioDevice channelCount.
                 * @member {number} channelCount
                 * @memberof rv.data.Media.AudioDevice
                 * @instance
                 */
                AudioDevice.prototype.channelCount = 0;

                /**
                 * Creates a new AudioDevice instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.AudioDevice
                 * @static
                 * @param {rv.data.Media.IAudioDevice=} [properties] Properties to set
                 * @returns {rv.data.Media.AudioDevice} AudioDevice instance
                 */
                AudioDevice.create = function create(properties) {
                    return new AudioDevice(properties);
                };

                /**
                 * Encodes the specified AudioDevice message. Does not implicitly {@link rv.data.Media.AudioDevice.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.AudioDevice
                 * @static
                 * @param {rv.data.Media.IAudioDevice} message AudioDevice message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AudioDevice.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.uniqueId != null && Object.hasOwnProperty.call(message, "uniqueId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.uniqueId);
                    if (message.modelId != null && Object.hasOwnProperty.call(message, "modelId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.modelId);
                    if (message.channelCount != null && Object.hasOwnProperty.call(message, "channelCount"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.channelCount);
                    return writer;
                };

                /**
                 * Encodes the specified AudioDevice message, length delimited. Does not implicitly {@link rv.data.Media.AudioDevice.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.AudioDevice
                 * @static
                 * @param {rv.data.Media.IAudioDevice} message AudioDevice message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AudioDevice.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AudioDevice message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.AudioDevice
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.AudioDevice} AudioDevice
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AudioDevice.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.AudioDevice();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.uniqueId = reader.string();
                                break;
                            }
                        case 3: {
                                message.modelId = reader.string();
                                break;
                            }
                        case 4: {
                                message.channelCount = reader.uint32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AudioDevice message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.AudioDevice
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.AudioDevice} AudioDevice
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AudioDevice.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AudioDevice message.
                 * @function verify
                 * @memberof rv.data.Media.AudioDevice
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AudioDevice.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.uniqueId != null && message.hasOwnProperty("uniqueId"))
                        if (!$util.isString(message.uniqueId))
                            return "uniqueId: string expected";
                    if (message.modelId != null && message.hasOwnProperty("modelId"))
                        if (!$util.isString(message.modelId))
                            return "modelId: string expected";
                    if (message.channelCount != null && message.hasOwnProperty("channelCount"))
                        if (!$util.isInteger(message.channelCount))
                            return "channelCount: integer expected";
                    return null;
                };

                /**
                 * Creates an AudioDevice message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.AudioDevice
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.AudioDevice} AudioDevice
                 */
                AudioDevice.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.AudioDevice)
                        return object;
                    let message = new $root.rv.data.Media.AudioDevice();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.uniqueId != null)
                        message.uniqueId = String(object.uniqueId);
                    if (object.modelId != null)
                        message.modelId = String(object.modelId);
                    if (object.channelCount != null)
                        message.channelCount = object.channelCount >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from an AudioDevice message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.AudioDevice
                 * @static
                 * @param {rv.data.Media.AudioDevice} message AudioDevice
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AudioDevice.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.uniqueId = "";
                        object.modelId = "";
                        object.channelCount = 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.uniqueId != null && message.hasOwnProperty("uniqueId"))
                        object.uniqueId = message.uniqueId;
                    if (message.modelId != null && message.hasOwnProperty("modelId"))
                        object.modelId = message.modelId;
                    if (message.channelCount != null && message.hasOwnProperty("channelCount"))
                        object.channelCount = message.channelCount;
                    return object;
                };

                /**
                 * Converts this AudioDevice to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.AudioDevice
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AudioDevice.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for AudioDevice
                 * @function getTypeUrl
                 * @memberof rv.data.Media.AudioDevice
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                AudioDevice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.AudioDevice";
                };

                return AudioDevice;
            })();

            Media.Audio = (function() {

                /**
                 * Properties of an Audio.
                 * @memberof rv.data.Media
                 * @interface IAudio
                 */

                /**
                 * Constructs a new Audio.
                 * @memberof rv.data.Media
                 * @classdesc Represents an Audio.
                 * @implements IAudio
                 * @constructor
                 * @param {rv.data.Media.IAudio=} [properties] Properties to set
                 */
                function Audio(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Audio instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.Audio
                 * @static
                 * @param {rv.data.Media.IAudio=} [properties] Properties to set
                 * @returns {rv.data.Media.Audio} Audio instance
                 */
                Audio.create = function create(properties) {
                    return new Audio(properties);
                };

                /**
                 * Encodes the specified Audio message. Does not implicitly {@link rv.data.Media.Audio.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.Audio
                 * @static
                 * @param {rv.data.Media.IAudio} message Audio message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Audio.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Audio message, length delimited. Does not implicitly {@link rv.data.Media.Audio.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.Audio
                 * @static
                 * @param {rv.data.Media.IAudio} message Audio message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Audio.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Audio message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.Audio
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.Audio} Audio
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Audio.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.Audio();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Audio message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.Audio
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.Audio} Audio
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Audio.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Audio message.
                 * @function verify
                 * @memberof rv.data.Media.Audio
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Audio.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an Audio message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.Audio
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.Audio} Audio
                 */
                Audio.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.Audio)
                        return object;
                    return new $root.rv.data.Media.Audio();
                };

                /**
                 * Creates a plain object from an Audio message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.Audio
                 * @static
                 * @param {rv.data.Media.Audio} message Audio
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Audio.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Audio to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.Audio
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Audio.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Audio
                 * @function getTypeUrl
                 * @memberof rv.data.Media.Audio
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Audio.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.Audio";
                };

                Audio.Channel = (function() {

                    /**
                     * Properties of a Channel.
                     * @memberof rv.data.Media.Audio
                     * @interface IChannel
                     * @property {number|null} [index] Channel index
                     * @property {boolean|null} [muted] Channel muted
                     * @property {number|null} [volume] Channel volume
                     * @property {boolean|null} [compressLimit] Channel compressLimit
                     * @property {Array.<rv.data.Media.Audio.Channel.IOutput>|null} [outputs] Channel outputs
                     */

                    /**
                     * Constructs a new Channel.
                     * @memberof rv.data.Media.Audio
                     * @classdesc Represents a Channel.
                     * @implements IChannel
                     * @constructor
                     * @param {rv.data.Media.Audio.IChannel=} [properties] Properties to set
                     */
                    function Channel(properties) {
                        this.outputs = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Channel index.
                     * @member {number} index
                     * @memberof rv.data.Media.Audio.Channel
                     * @instance
                     */
                    Channel.prototype.index = 0;

                    /**
                     * Channel muted.
                     * @member {boolean} muted
                     * @memberof rv.data.Media.Audio.Channel
                     * @instance
                     */
                    Channel.prototype.muted = false;

                    /**
                     * Channel volume.
                     * @member {number} volume
                     * @memberof rv.data.Media.Audio.Channel
                     * @instance
                     */
                    Channel.prototype.volume = 0;

                    /**
                     * Channel compressLimit.
                     * @member {boolean} compressLimit
                     * @memberof rv.data.Media.Audio.Channel
                     * @instance
                     */
                    Channel.prototype.compressLimit = false;

                    /**
                     * Channel outputs.
                     * @member {Array.<rv.data.Media.Audio.Channel.IOutput>} outputs
                     * @memberof rv.data.Media.Audio.Channel
                     * @instance
                     */
                    Channel.prototype.outputs = $util.emptyArray;

                    /**
                     * Creates a new Channel instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Media.Audio.Channel
                     * @static
                     * @param {rv.data.Media.Audio.IChannel=} [properties] Properties to set
                     * @returns {rv.data.Media.Audio.Channel} Channel instance
                     */
                    Channel.create = function create(properties) {
                        return new Channel(properties);
                    };

                    /**
                     * Encodes the specified Channel message. Does not implicitly {@link rv.data.Media.Audio.Channel.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Media.Audio.Channel
                     * @static
                     * @param {rv.data.Media.Audio.IChannel} message Channel message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Channel.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                        if (message.muted != null && Object.hasOwnProperty.call(message, "muted"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.muted);
                        if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                            writer.uint32(/* id 3, wireType 1 =*/25).double(message.volume);
                        if (message.compressLimit != null && Object.hasOwnProperty.call(message, "compressLimit"))
                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.compressLimit);
                        if (message.outputs != null && message.outputs.length)
                            for (let i = 0; i < message.outputs.length; ++i)
                                $root.rv.data.Media.Audio.Channel.Output.encode(message.outputs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Channel message, length delimited. Does not implicitly {@link rv.data.Media.Audio.Channel.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Media.Audio.Channel
                     * @static
                     * @param {rv.data.Media.Audio.IChannel} message Channel message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Channel.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Channel message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Media.Audio.Channel
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Media.Audio.Channel} Channel
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Channel.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.Audio.Channel();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.index = reader.uint32();
                                    break;
                                }
                            case 2: {
                                    message.muted = reader.bool();
                                    break;
                                }
                            case 3: {
                                    message.volume = reader.double();
                                    break;
                                }
                            case 4: {
                                    message.compressLimit = reader.bool();
                                    break;
                                }
                            case 5: {
                                    if (!(message.outputs && message.outputs.length))
                                        message.outputs = [];
                                    message.outputs.push($root.rv.data.Media.Audio.Channel.Output.decode(reader, reader.uint32()));
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Channel message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Media.Audio.Channel
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Media.Audio.Channel} Channel
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Channel.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Channel message.
                     * @function verify
                     * @memberof rv.data.Media.Audio.Channel
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Channel.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.index != null && message.hasOwnProperty("index"))
                            if (!$util.isInteger(message.index))
                                return "index: integer expected";
                        if (message.muted != null && message.hasOwnProperty("muted"))
                            if (typeof message.muted !== "boolean")
                                return "muted: boolean expected";
                        if (message.volume != null && message.hasOwnProperty("volume"))
                            if (typeof message.volume !== "number")
                                return "volume: number expected";
                        if (message.compressLimit != null && message.hasOwnProperty("compressLimit"))
                            if (typeof message.compressLimit !== "boolean")
                                return "compressLimit: boolean expected";
                        if (message.outputs != null && message.hasOwnProperty("outputs")) {
                            if (!Array.isArray(message.outputs))
                                return "outputs: array expected";
                            for (let i = 0; i < message.outputs.length; ++i) {
                                let error = $root.rv.data.Media.Audio.Channel.Output.verify(message.outputs[i]);
                                if (error)
                                    return "outputs." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Channel message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Media.Audio.Channel
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Media.Audio.Channel} Channel
                     */
                    Channel.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Media.Audio.Channel)
                            return object;
                        let message = new $root.rv.data.Media.Audio.Channel();
                        if (object.index != null)
                            message.index = object.index >>> 0;
                        if (object.muted != null)
                            message.muted = Boolean(object.muted);
                        if (object.volume != null)
                            message.volume = Number(object.volume);
                        if (object.compressLimit != null)
                            message.compressLimit = Boolean(object.compressLimit);
                        if (object.outputs) {
                            if (!Array.isArray(object.outputs))
                                throw TypeError(".rv.data.Media.Audio.Channel.outputs: array expected");
                            message.outputs = [];
                            for (let i = 0; i < object.outputs.length; ++i) {
                                if (typeof object.outputs[i] !== "object")
                                    throw TypeError(".rv.data.Media.Audio.Channel.outputs: object expected");
                                message.outputs[i] = $root.rv.data.Media.Audio.Channel.Output.fromObject(object.outputs[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Channel message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Media.Audio.Channel
                     * @static
                     * @param {rv.data.Media.Audio.Channel} message Channel
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Channel.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.outputs = [];
                        if (options.defaults) {
                            object.index = 0;
                            object.muted = false;
                            object.volume = 0;
                            object.compressLimit = false;
                        }
                        if (message.index != null && message.hasOwnProperty("index"))
                            object.index = message.index;
                        if (message.muted != null && message.hasOwnProperty("muted"))
                            object.muted = message.muted;
                        if (message.volume != null && message.hasOwnProperty("volume"))
                            object.volume = options.json && !isFinite(message.volume) ? String(message.volume) : message.volume;
                        if (message.compressLimit != null && message.hasOwnProperty("compressLimit"))
                            object.compressLimit = message.compressLimit;
                        if (message.outputs && message.outputs.length) {
                            object.outputs = [];
                            for (let j = 0; j < message.outputs.length; ++j)
                                object.outputs[j] = $root.rv.data.Media.Audio.Channel.Output.toObject(message.outputs[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Channel to JSON.
                     * @function toJSON
                     * @memberof rv.data.Media.Audio.Channel
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Channel.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Channel
                     * @function getTypeUrl
                     * @memberof rv.data.Media.Audio.Channel
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Channel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Media.Audio.Channel";
                    };

                    Channel.Output = (function() {

                        /**
                         * Properties of an Output.
                         * @memberof rv.data.Media.Audio.Channel
                         * @interface IOutput
                         * @property {number|null} [channelIndex] Output channelIndex
                         */

                        /**
                         * Constructs a new Output.
                         * @memberof rv.data.Media.Audio.Channel
                         * @classdesc Represents an Output.
                         * @implements IOutput
                         * @constructor
                         * @param {rv.data.Media.Audio.Channel.IOutput=} [properties] Properties to set
                         */
                        function Output(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Output channelIndex.
                         * @member {number} channelIndex
                         * @memberof rv.data.Media.Audio.Channel.Output
                         * @instance
                         */
                        Output.prototype.channelIndex = 0;

                        /**
                         * Creates a new Output instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Media.Audio.Channel.Output
                         * @static
                         * @param {rv.data.Media.Audio.Channel.IOutput=} [properties] Properties to set
                         * @returns {rv.data.Media.Audio.Channel.Output} Output instance
                         */
                        Output.create = function create(properties) {
                            return new Output(properties);
                        };

                        /**
                         * Encodes the specified Output message. Does not implicitly {@link rv.data.Media.Audio.Channel.Output.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Media.Audio.Channel.Output
                         * @static
                         * @param {rv.data.Media.Audio.Channel.IOutput} message Output message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Output.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.channelIndex != null && Object.hasOwnProperty.call(message, "channelIndex"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.channelIndex);
                            return writer;
                        };

                        /**
                         * Encodes the specified Output message, length delimited. Does not implicitly {@link rv.data.Media.Audio.Channel.Output.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Media.Audio.Channel.Output
                         * @static
                         * @param {rv.data.Media.Audio.Channel.IOutput} message Output message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Output.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Output message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Media.Audio.Channel.Output
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Media.Audio.Channel.Output} Output
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Output.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.Audio.Channel.Output();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 2: {
                                        message.channelIndex = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Output message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Media.Audio.Channel.Output
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Media.Audio.Channel.Output} Output
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Output.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Output message.
                         * @function verify
                         * @memberof rv.data.Media.Audio.Channel.Output
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Output.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.channelIndex != null && message.hasOwnProperty("channelIndex"))
                                if (!$util.isInteger(message.channelIndex))
                                    return "channelIndex: integer expected";
                            return null;
                        };

                        /**
                         * Creates an Output message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Media.Audio.Channel.Output
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Media.Audio.Channel.Output} Output
                         */
                        Output.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Media.Audio.Channel.Output)
                                return object;
                            let message = new $root.rv.data.Media.Audio.Channel.Output();
                            if (object.channelIndex != null)
                                message.channelIndex = object.channelIndex | 0;
                            return message;
                        };

                        /**
                         * Creates a plain object from an Output message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Media.Audio.Channel.Output
                         * @static
                         * @param {rv.data.Media.Audio.Channel.Output} message Output
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Output.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.channelIndex = 0;
                            if (message.channelIndex != null && message.hasOwnProperty("channelIndex"))
                                object.channelIndex = message.channelIndex;
                            return object;
                        };

                        /**
                         * Converts this Output to JSON.
                         * @function toJSON
                         * @memberof rv.data.Media.Audio.Channel.Output
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Output.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Output
                         * @function getTypeUrl
                         * @memberof rv.data.Media.Audio.Channel.Output
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Output.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Media.Audio.Channel.Output";
                        };

                        return Output;
                    })();

                    return Channel;
                })();

                return Audio;
            })();

            Media.AudioProperties = (function() {

                /**
                 * Properties of an AudioProperties.
                 * @memberof rv.data.Media
                 * @interface IAudioProperties
                 * @property {number|null} [volume] AudioProperties volume
                 * @property {Array.<rv.data.Media.Audio.IChannel>|null} [audioChannels] AudioProperties audioChannels
                 * @property {boolean|null} [isCustomMapping] AudioProperties isCustomMapping
                 */

                /**
                 * Constructs a new AudioProperties.
                 * @memberof rv.data.Media
                 * @classdesc Represents an AudioProperties.
                 * @implements IAudioProperties
                 * @constructor
                 * @param {rv.data.Media.IAudioProperties=} [properties] Properties to set
                 */
                function AudioProperties(properties) {
                    this.audioChannels = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AudioProperties volume.
                 * @member {number} volume
                 * @memberof rv.data.Media.AudioProperties
                 * @instance
                 */
                AudioProperties.prototype.volume = 0;

                /**
                 * AudioProperties audioChannels.
                 * @member {Array.<rv.data.Media.Audio.IChannel>} audioChannels
                 * @memberof rv.data.Media.AudioProperties
                 * @instance
                 */
                AudioProperties.prototype.audioChannels = $util.emptyArray;

                /**
                 * AudioProperties isCustomMapping.
                 * @member {boolean} isCustomMapping
                 * @memberof rv.data.Media.AudioProperties
                 * @instance
                 */
                AudioProperties.prototype.isCustomMapping = false;

                /**
                 * Creates a new AudioProperties instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.AudioProperties
                 * @static
                 * @param {rv.data.Media.IAudioProperties=} [properties] Properties to set
                 * @returns {rv.data.Media.AudioProperties} AudioProperties instance
                 */
                AudioProperties.create = function create(properties) {
                    return new AudioProperties(properties);
                };

                /**
                 * Encodes the specified AudioProperties message. Does not implicitly {@link rv.data.Media.AudioProperties.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.AudioProperties
                 * @static
                 * @param {rv.data.Media.IAudioProperties} message AudioProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AudioProperties.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.volume);
                    if (message.audioChannels != null && message.audioChannels.length)
                        for (let i = 0; i < message.audioChannels.length; ++i)
                            $root.rv.data.Media.Audio.Channel.encode(message.audioChannels[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.isCustomMapping != null && Object.hasOwnProperty.call(message, "isCustomMapping"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isCustomMapping);
                    return writer;
                };

                /**
                 * Encodes the specified AudioProperties message, length delimited. Does not implicitly {@link rv.data.Media.AudioProperties.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.AudioProperties
                 * @static
                 * @param {rv.data.Media.IAudioProperties} message AudioProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AudioProperties.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AudioProperties message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.AudioProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.AudioProperties} AudioProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AudioProperties.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.AudioProperties();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.volume = reader.double();
                                break;
                            }
                        case 2: {
                                if (!(message.audioChannels && message.audioChannels.length))
                                    message.audioChannels = [];
                                message.audioChannels.push($root.rv.data.Media.Audio.Channel.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                message.isCustomMapping = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AudioProperties message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.AudioProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.AudioProperties} AudioProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AudioProperties.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AudioProperties message.
                 * @function verify
                 * @memberof rv.data.Media.AudioProperties
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AudioProperties.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.volume != null && message.hasOwnProperty("volume"))
                        if (typeof message.volume !== "number")
                            return "volume: number expected";
                    if (message.audioChannels != null && message.hasOwnProperty("audioChannels")) {
                        if (!Array.isArray(message.audioChannels))
                            return "audioChannels: array expected";
                        for (let i = 0; i < message.audioChannels.length; ++i) {
                            let error = $root.rv.data.Media.Audio.Channel.verify(message.audioChannels[i]);
                            if (error)
                                return "audioChannels." + error;
                        }
                    }
                    if (message.isCustomMapping != null && message.hasOwnProperty("isCustomMapping"))
                        if (typeof message.isCustomMapping !== "boolean")
                            return "isCustomMapping: boolean expected";
                    return null;
                };

                /**
                 * Creates an AudioProperties message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.AudioProperties
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.AudioProperties} AudioProperties
                 */
                AudioProperties.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.AudioProperties)
                        return object;
                    let message = new $root.rv.data.Media.AudioProperties();
                    if (object.volume != null)
                        message.volume = Number(object.volume);
                    if (object.audioChannels) {
                        if (!Array.isArray(object.audioChannels))
                            throw TypeError(".rv.data.Media.AudioProperties.audioChannels: array expected");
                        message.audioChannels = [];
                        for (let i = 0; i < object.audioChannels.length; ++i) {
                            if (typeof object.audioChannels[i] !== "object")
                                throw TypeError(".rv.data.Media.AudioProperties.audioChannels: object expected");
                            message.audioChannels[i] = $root.rv.data.Media.Audio.Channel.fromObject(object.audioChannels[i]);
                        }
                    }
                    if (object.isCustomMapping != null)
                        message.isCustomMapping = Boolean(object.isCustomMapping);
                    return message;
                };

                /**
                 * Creates a plain object from an AudioProperties message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.AudioProperties
                 * @static
                 * @param {rv.data.Media.AudioProperties} message AudioProperties
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AudioProperties.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.audioChannels = [];
                    if (options.defaults) {
                        object.volume = 0;
                        object.isCustomMapping = false;
                    }
                    if (message.volume != null && message.hasOwnProperty("volume"))
                        object.volume = options.json && !isFinite(message.volume) ? String(message.volume) : message.volume;
                    if (message.audioChannels && message.audioChannels.length) {
                        object.audioChannels = [];
                        for (let j = 0; j < message.audioChannels.length; ++j)
                            object.audioChannels[j] = $root.rv.data.Media.Audio.Channel.toObject(message.audioChannels[j], options);
                    }
                    if (message.isCustomMapping != null && message.hasOwnProperty("isCustomMapping"))
                        object.isCustomMapping = message.isCustomMapping;
                    return object;
                };

                /**
                 * Converts this AudioProperties to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.AudioProperties
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AudioProperties.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for AudioProperties
                 * @function getTypeUrl
                 * @memberof rv.data.Media.AudioProperties
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                AudioProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.AudioProperties";
                };

                return AudioProperties;
            })();

            Media.TransportProperties = (function() {

                /**
                 * Properties of a TransportProperties.
                 * @memberof rv.data.Media
                 * @interface ITransportProperties
                 * @property {number|null} [playRate] TransportProperties playRate
                 * @property {number|null} [inPoint] TransportProperties inPoint
                 * @property {number|null} [outPoint] TransportProperties outPoint
                 * @property {number|null} [fadeInDuration] TransportProperties fadeInDuration
                 * @property {number|null} [fadeOutDuration] TransportProperties fadeOutDuration
                 * @property {boolean|null} [shouldFadeIn] TransportProperties shouldFadeIn
                 * @property {boolean|null} [shouldFadeOut] TransportProperties shouldFadeOut
                 * @property {number|null} [endPoint] TransportProperties endPoint
                 * @property {rv.data.Media.TransportProperties.PlaybackBehavior|null} [playbackBehavior] TransportProperties playbackBehavior
                 * @property {number|null} [loopTime] TransportProperties loopTime
                 * @property {number|null} [timesToLoop] TransportProperties timesToLoop
                 * @property {rv.data.Media.TransportProperties.RetriggerSetting|null} [retrigger] TransportProperties retrigger
                 */

                /**
                 * Constructs a new TransportProperties.
                 * @memberof rv.data.Media
                 * @classdesc Represents a TransportProperties.
                 * @implements ITransportProperties
                 * @constructor
                 * @param {rv.data.Media.ITransportProperties=} [properties] Properties to set
                 */
                function TransportProperties(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TransportProperties playRate.
                 * @member {number} playRate
                 * @memberof rv.data.Media.TransportProperties
                 * @instance
                 */
                TransportProperties.prototype.playRate = 0;

                /**
                 * TransportProperties inPoint.
                 * @member {number} inPoint
                 * @memberof rv.data.Media.TransportProperties
                 * @instance
                 */
                TransportProperties.prototype.inPoint = 0;

                /**
                 * TransportProperties outPoint.
                 * @member {number} outPoint
                 * @memberof rv.data.Media.TransportProperties
                 * @instance
                 */
                TransportProperties.prototype.outPoint = 0;

                /**
                 * TransportProperties fadeInDuration.
                 * @member {number} fadeInDuration
                 * @memberof rv.data.Media.TransportProperties
                 * @instance
                 */
                TransportProperties.prototype.fadeInDuration = 0;

                /**
                 * TransportProperties fadeOutDuration.
                 * @member {number} fadeOutDuration
                 * @memberof rv.data.Media.TransportProperties
                 * @instance
                 */
                TransportProperties.prototype.fadeOutDuration = 0;

                /**
                 * TransportProperties shouldFadeIn.
                 * @member {boolean} shouldFadeIn
                 * @memberof rv.data.Media.TransportProperties
                 * @instance
                 */
                TransportProperties.prototype.shouldFadeIn = false;

                /**
                 * TransportProperties shouldFadeOut.
                 * @member {boolean} shouldFadeOut
                 * @memberof rv.data.Media.TransportProperties
                 * @instance
                 */
                TransportProperties.prototype.shouldFadeOut = false;

                /**
                 * TransportProperties endPoint.
                 * @member {number} endPoint
                 * @memberof rv.data.Media.TransportProperties
                 * @instance
                 */
                TransportProperties.prototype.endPoint = 0;

                /**
                 * TransportProperties playbackBehavior.
                 * @member {rv.data.Media.TransportProperties.PlaybackBehavior} playbackBehavior
                 * @memberof rv.data.Media.TransportProperties
                 * @instance
                 */
                TransportProperties.prototype.playbackBehavior = 0;

                /**
                 * TransportProperties loopTime.
                 * @member {number} loopTime
                 * @memberof rv.data.Media.TransportProperties
                 * @instance
                 */
                TransportProperties.prototype.loopTime = 0;

                /**
                 * TransportProperties timesToLoop.
                 * @member {number} timesToLoop
                 * @memberof rv.data.Media.TransportProperties
                 * @instance
                 */
                TransportProperties.prototype.timesToLoop = 0;

                /**
                 * TransportProperties retrigger.
                 * @member {rv.data.Media.TransportProperties.RetriggerSetting} retrigger
                 * @memberof rv.data.Media.TransportProperties
                 * @instance
                 */
                TransportProperties.prototype.retrigger = 0;

                /**
                 * Creates a new TransportProperties instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.TransportProperties
                 * @static
                 * @param {rv.data.Media.ITransportProperties=} [properties] Properties to set
                 * @returns {rv.data.Media.TransportProperties} TransportProperties instance
                 */
                TransportProperties.create = function create(properties) {
                    return new TransportProperties(properties);
                };

                /**
                 * Encodes the specified TransportProperties message. Does not implicitly {@link rv.data.Media.TransportProperties.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.TransportProperties
                 * @static
                 * @param {rv.data.Media.ITransportProperties} message TransportProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransportProperties.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.playRate != null && Object.hasOwnProperty.call(message, "playRate"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.playRate);
                    if (message.inPoint != null && Object.hasOwnProperty.call(message, "inPoint"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.inPoint);
                    if (message.outPoint != null && Object.hasOwnProperty.call(message, "outPoint"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.outPoint);
                    if (message.fadeInDuration != null && Object.hasOwnProperty.call(message, "fadeInDuration"))
                        writer.uint32(/* id 7, wireType 1 =*/57).double(message.fadeInDuration);
                    if (message.fadeOutDuration != null && Object.hasOwnProperty.call(message, "fadeOutDuration"))
                        writer.uint32(/* id 8, wireType 1 =*/65).double(message.fadeOutDuration);
                    if (message.shouldFadeIn != null && Object.hasOwnProperty.call(message, "shouldFadeIn"))
                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.shouldFadeIn);
                    if (message.shouldFadeOut != null && Object.hasOwnProperty.call(message, "shouldFadeOut"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.shouldFadeOut);
                    if (message.endPoint != null && Object.hasOwnProperty.call(message, "endPoint"))
                        writer.uint32(/* id 11, wireType 1 =*/89).double(message.endPoint);
                    if (message.playbackBehavior != null && Object.hasOwnProperty.call(message, "playbackBehavior"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.playbackBehavior);
                    if (message.loopTime != null && Object.hasOwnProperty.call(message, "loopTime"))
                        writer.uint32(/* id 13, wireType 1 =*/105).double(message.loopTime);
                    if (message.timesToLoop != null && Object.hasOwnProperty.call(message, "timesToLoop"))
                        writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.timesToLoop);
                    if (message.retrigger != null && Object.hasOwnProperty.call(message, "retrigger"))
                        writer.uint32(/* id 15, wireType 0 =*/120).int32(message.retrigger);
                    return writer;
                };

                /**
                 * Encodes the specified TransportProperties message, length delimited. Does not implicitly {@link rv.data.Media.TransportProperties.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.TransportProperties
                 * @static
                 * @param {rv.data.Media.ITransportProperties} message TransportProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransportProperties.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TransportProperties message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.TransportProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.TransportProperties} TransportProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransportProperties.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.TransportProperties();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.playRate = reader.double();
                                break;
                            }
                        case 2: {
                                message.inPoint = reader.double();
                                break;
                            }
                        case 3: {
                                message.outPoint = reader.double();
                                break;
                            }
                        case 7: {
                                message.fadeInDuration = reader.double();
                                break;
                            }
                        case 8: {
                                message.fadeOutDuration = reader.double();
                                break;
                            }
                        case 9: {
                                message.shouldFadeIn = reader.bool();
                                break;
                            }
                        case 10: {
                                message.shouldFadeOut = reader.bool();
                                break;
                            }
                        case 11: {
                                message.endPoint = reader.double();
                                break;
                            }
                        case 12: {
                                message.playbackBehavior = reader.int32();
                                break;
                            }
                        case 13: {
                                message.loopTime = reader.double();
                                break;
                            }
                        case 14: {
                                message.timesToLoop = reader.uint32();
                                break;
                            }
                        case 15: {
                                message.retrigger = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TransportProperties message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.TransportProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.TransportProperties} TransportProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransportProperties.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TransportProperties message.
                 * @function verify
                 * @memberof rv.data.Media.TransportProperties
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransportProperties.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.playRate != null && message.hasOwnProperty("playRate"))
                        if (typeof message.playRate !== "number")
                            return "playRate: number expected";
                    if (message.inPoint != null && message.hasOwnProperty("inPoint"))
                        if (typeof message.inPoint !== "number")
                            return "inPoint: number expected";
                    if (message.outPoint != null && message.hasOwnProperty("outPoint"))
                        if (typeof message.outPoint !== "number")
                            return "outPoint: number expected";
                    if (message.fadeInDuration != null && message.hasOwnProperty("fadeInDuration"))
                        if (typeof message.fadeInDuration !== "number")
                            return "fadeInDuration: number expected";
                    if (message.fadeOutDuration != null && message.hasOwnProperty("fadeOutDuration"))
                        if (typeof message.fadeOutDuration !== "number")
                            return "fadeOutDuration: number expected";
                    if (message.shouldFadeIn != null && message.hasOwnProperty("shouldFadeIn"))
                        if (typeof message.shouldFadeIn !== "boolean")
                            return "shouldFadeIn: boolean expected";
                    if (message.shouldFadeOut != null && message.hasOwnProperty("shouldFadeOut"))
                        if (typeof message.shouldFadeOut !== "boolean")
                            return "shouldFadeOut: boolean expected";
                    if (message.endPoint != null && message.hasOwnProperty("endPoint"))
                        if (typeof message.endPoint !== "number")
                            return "endPoint: number expected";
                    if (message.playbackBehavior != null && message.hasOwnProperty("playbackBehavior"))
                        switch (message.playbackBehavior) {
                        default:
                            return "playbackBehavior: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.loopTime != null && message.hasOwnProperty("loopTime"))
                        if (typeof message.loopTime !== "number")
                            return "loopTime: number expected";
                    if (message.timesToLoop != null && message.hasOwnProperty("timesToLoop"))
                        if (!$util.isInteger(message.timesToLoop))
                            return "timesToLoop: integer expected";
                    if (message.retrigger != null && message.hasOwnProperty("retrigger"))
                        switch (message.retrigger) {
                        default:
                            return "retrigger: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a TransportProperties message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.TransportProperties
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.TransportProperties} TransportProperties
                 */
                TransportProperties.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.TransportProperties)
                        return object;
                    let message = new $root.rv.data.Media.TransportProperties();
                    if (object.playRate != null)
                        message.playRate = Number(object.playRate);
                    if (object.inPoint != null)
                        message.inPoint = Number(object.inPoint);
                    if (object.outPoint != null)
                        message.outPoint = Number(object.outPoint);
                    if (object.fadeInDuration != null)
                        message.fadeInDuration = Number(object.fadeInDuration);
                    if (object.fadeOutDuration != null)
                        message.fadeOutDuration = Number(object.fadeOutDuration);
                    if (object.shouldFadeIn != null)
                        message.shouldFadeIn = Boolean(object.shouldFadeIn);
                    if (object.shouldFadeOut != null)
                        message.shouldFadeOut = Boolean(object.shouldFadeOut);
                    if (object.endPoint != null)
                        message.endPoint = Number(object.endPoint);
                    switch (object.playbackBehavior) {
                    default:
                        if (typeof object.playbackBehavior === "number") {
                            message.playbackBehavior = object.playbackBehavior;
                            break;
                        }
                        break;
                    case "PLAYBACK_BEHAVIOR_STOP":
                    case 0:
                        message.playbackBehavior = 0;
                        break;
                    case "PLAYBACK_BEHAVIOR_LOOP":
                    case 1:
                        message.playbackBehavior = 1;
                        break;
                    case "PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT":
                    case 2:
                        message.playbackBehavior = 2;
                        break;
                    case "PLAYBACK_BEHAVIOR_LOOP_FOR_TIME":
                    case 3:
                        message.playbackBehavior = 3;
                        break;
                    }
                    if (object.loopTime != null)
                        message.loopTime = Number(object.loopTime);
                    if (object.timesToLoop != null)
                        message.timesToLoop = object.timesToLoop >>> 0;
                    switch (object.retrigger) {
                    default:
                        if (typeof object.retrigger === "number") {
                            message.retrigger = object.retrigger;
                            break;
                        }
                        break;
                    case "RETRIGGER_SETTING_UNSET":
                    case 0:
                        message.retrigger = 0;
                        break;
                    case "RETRIGGER_SETTING_ALWAYS":
                    case 1:
                        message.retrigger = 1;
                        break;
                    case "RETRIGGER_SETTING_NEVER":
                    case 2:
                        message.retrigger = 2;
                        break;
                    case "RETRIGGER_SETTING_AUTOMATIC":
                    case 3:
                        message.retrigger = 3;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TransportProperties message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.TransportProperties
                 * @static
                 * @param {rv.data.Media.TransportProperties} message TransportProperties
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransportProperties.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.playRate = 0;
                        object.inPoint = 0;
                        object.outPoint = 0;
                        object.fadeInDuration = 0;
                        object.fadeOutDuration = 0;
                        object.shouldFadeIn = false;
                        object.shouldFadeOut = false;
                        object.endPoint = 0;
                        object.playbackBehavior = options.enums === String ? "PLAYBACK_BEHAVIOR_STOP" : 0;
                        object.loopTime = 0;
                        object.timesToLoop = 0;
                        object.retrigger = options.enums === String ? "RETRIGGER_SETTING_UNSET" : 0;
                    }
                    if (message.playRate != null && message.hasOwnProperty("playRate"))
                        object.playRate = options.json && !isFinite(message.playRate) ? String(message.playRate) : message.playRate;
                    if (message.inPoint != null && message.hasOwnProperty("inPoint"))
                        object.inPoint = options.json && !isFinite(message.inPoint) ? String(message.inPoint) : message.inPoint;
                    if (message.outPoint != null && message.hasOwnProperty("outPoint"))
                        object.outPoint = options.json && !isFinite(message.outPoint) ? String(message.outPoint) : message.outPoint;
                    if (message.fadeInDuration != null && message.hasOwnProperty("fadeInDuration"))
                        object.fadeInDuration = options.json && !isFinite(message.fadeInDuration) ? String(message.fadeInDuration) : message.fadeInDuration;
                    if (message.fadeOutDuration != null && message.hasOwnProperty("fadeOutDuration"))
                        object.fadeOutDuration = options.json && !isFinite(message.fadeOutDuration) ? String(message.fadeOutDuration) : message.fadeOutDuration;
                    if (message.shouldFadeIn != null && message.hasOwnProperty("shouldFadeIn"))
                        object.shouldFadeIn = message.shouldFadeIn;
                    if (message.shouldFadeOut != null && message.hasOwnProperty("shouldFadeOut"))
                        object.shouldFadeOut = message.shouldFadeOut;
                    if (message.endPoint != null && message.hasOwnProperty("endPoint"))
                        object.endPoint = options.json && !isFinite(message.endPoint) ? String(message.endPoint) : message.endPoint;
                    if (message.playbackBehavior != null && message.hasOwnProperty("playbackBehavior"))
                        object.playbackBehavior = options.enums === String ? $root.rv.data.Media.TransportProperties.PlaybackBehavior[message.playbackBehavior] === undefined ? message.playbackBehavior : $root.rv.data.Media.TransportProperties.PlaybackBehavior[message.playbackBehavior] : message.playbackBehavior;
                    if (message.loopTime != null && message.hasOwnProperty("loopTime"))
                        object.loopTime = options.json && !isFinite(message.loopTime) ? String(message.loopTime) : message.loopTime;
                    if (message.timesToLoop != null && message.hasOwnProperty("timesToLoop"))
                        object.timesToLoop = message.timesToLoop;
                    if (message.retrigger != null && message.hasOwnProperty("retrigger"))
                        object.retrigger = options.enums === String ? $root.rv.data.Media.TransportProperties.RetriggerSetting[message.retrigger] === undefined ? message.retrigger : $root.rv.data.Media.TransportProperties.RetriggerSetting[message.retrigger] : message.retrigger;
                    return object;
                };

                /**
                 * Converts this TransportProperties to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.TransportProperties
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransportProperties.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TransportProperties
                 * @function getTypeUrl
                 * @memberof rv.data.Media.TransportProperties
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TransportProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.TransportProperties";
                };

                /**
                 * PlaybackBehavior enum.
                 * @name rv.data.Media.TransportProperties.PlaybackBehavior
                 * @enum {number}
                 * @property {number} PLAYBACK_BEHAVIOR_STOP=0 PLAYBACK_BEHAVIOR_STOP value
                 * @property {number} PLAYBACK_BEHAVIOR_LOOP=1 PLAYBACK_BEHAVIOR_LOOP value
                 * @property {number} PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT=2 PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT value
                 * @property {number} PLAYBACK_BEHAVIOR_LOOP_FOR_TIME=3 PLAYBACK_BEHAVIOR_LOOP_FOR_TIME value
                 */
                TransportProperties.PlaybackBehavior = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "PLAYBACK_BEHAVIOR_STOP"] = 0;
                    values[valuesById[1] = "PLAYBACK_BEHAVIOR_LOOP"] = 1;
                    values[valuesById[2] = "PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT"] = 2;
                    values[valuesById[3] = "PLAYBACK_BEHAVIOR_LOOP_FOR_TIME"] = 3;
                    return values;
                })();

                /**
                 * RetriggerSetting enum.
                 * @name rv.data.Media.TransportProperties.RetriggerSetting
                 * @enum {number}
                 * @property {number} RETRIGGER_SETTING_UNSET=0 RETRIGGER_SETTING_UNSET value
                 * @property {number} RETRIGGER_SETTING_ALWAYS=1 RETRIGGER_SETTING_ALWAYS value
                 * @property {number} RETRIGGER_SETTING_NEVER=2 RETRIGGER_SETTING_NEVER value
                 * @property {number} RETRIGGER_SETTING_AUTOMATIC=3 RETRIGGER_SETTING_AUTOMATIC value
                 */
                TransportProperties.RetriggerSetting = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "RETRIGGER_SETTING_UNSET"] = 0;
                    values[valuesById[1] = "RETRIGGER_SETTING_ALWAYS"] = 1;
                    values[valuesById[2] = "RETRIGGER_SETTING_NEVER"] = 2;
                    values[valuesById[3] = "RETRIGGER_SETTING_AUTOMATIC"] = 3;
                    return values;
                })();

                return TransportProperties;
            })();

            Media.DrawingProperties = (function() {

                /**
                 * Properties of a DrawingProperties.
                 * @memberof rv.data.Media
                 * @interface IDrawingProperties
                 * @property {rv.data.Media.ScaleBehavior|null} [scaleBehavior] DrawingProperties scaleBehavior
                 * @property {boolean|null} [isBlurred] DrawingProperties isBlurred
                 * @property {rv.data.Media.ScaleAlignment|null} [scaleAlignment] DrawingProperties scaleAlignment
                 * @property {boolean|null} [flippedHorizontally] DrawingProperties flippedHorizontally
                 * @property {boolean|null} [flippedVertically] DrawingProperties flippedVertically
                 * @property {rv.data.Graphics.ISize|null} [naturalSize] DrawingProperties naturalSize
                 * @property {number|null} [customImageRotation] DrawingProperties customImageRotation
                 * @property {rv.data.Graphics.IRect|null} [customImageBounds] DrawingProperties customImageBounds
                 * @property {boolean|null} [customImageAspectLocked] DrawingProperties customImageAspectLocked
                 * @property {boolean|null} [alphaInverted] DrawingProperties alphaInverted
                 * @property {rv.data.Media.DrawingProperties.NativeRotationType|null} [nativeRotation] DrawingProperties nativeRotation
                 * @property {rv.data.IUUID|null} [selectedEffectPresetUuid] DrawingProperties selectedEffectPresetUuid
                 * @property {Array.<rv.data.IEffect>|null} [effects] DrawingProperties effects
                 * @property {boolean|null} [cropEnable] DrawingProperties cropEnable
                 * @property {rv.data.Graphics.IEdgeInsets|null} [cropInsets] DrawingProperties cropInsets
                 * @property {rv.data.AlphaType|null} [alphaType] DrawingProperties alphaType
                 */

                /**
                 * Constructs a new DrawingProperties.
                 * @memberof rv.data.Media
                 * @classdesc Represents a DrawingProperties.
                 * @implements IDrawingProperties
                 * @constructor
                 * @param {rv.data.Media.IDrawingProperties=} [properties] Properties to set
                 */
                function DrawingProperties(properties) {
                    this.effects = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DrawingProperties scaleBehavior.
                 * @member {rv.data.Media.ScaleBehavior} scaleBehavior
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.scaleBehavior = 0;

                /**
                 * DrawingProperties isBlurred.
                 * @member {boolean} isBlurred
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.isBlurred = false;

                /**
                 * DrawingProperties scaleAlignment.
                 * @member {rv.data.Media.ScaleAlignment} scaleAlignment
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.scaleAlignment = 0;

                /**
                 * DrawingProperties flippedHorizontally.
                 * @member {boolean} flippedHorizontally
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.flippedHorizontally = false;

                /**
                 * DrawingProperties flippedVertically.
                 * @member {boolean} flippedVertically
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.flippedVertically = false;

                /**
                 * DrawingProperties naturalSize.
                 * @member {rv.data.Graphics.ISize|null|undefined} naturalSize
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.naturalSize = null;

                /**
                 * DrawingProperties customImageRotation.
                 * @member {number} customImageRotation
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.customImageRotation = 0;

                /**
                 * DrawingProperties customImageBounds.
                 * @member {rv.data.Graphics.IRect|null|undefined} customImageBounds
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.customImageBounds = null;

                /**
                 * DrawingProperties customImageAspectLocked.
                 * @member {boolean} customImageAspectLocked
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.customImageAspectLocked = false;

                /**
                 * DrawingProperties alphaInverted.
                 * @member {boolean} alphaInverted
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.alphaInverted = false;

                /**
                 * DrawingProperties nativeRotation.
                 * @member {rv.data.Media.DrawingProperties.NativeRotationType} nativeRotation
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.nativeRotation = 0;

                /**
                 * DrawingProperties selectedEffectPresetUuid.
                 * @member {rv.data.IUUID|null|undefined} selectedEffectPresetUuid
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.selectedEffectPresetUuid = null;

                /**
                 * DrawingProperties effects.
                 * @member {Array.<rv.data.IEffect>} effects
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.effects = $util.emptyArray;

                /**
                 * DrawingProperties cropEnable.
                 * @member {boolean} cropEnable
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.cropEnable = false;

                /**
                 * DrawingProperties cropInsets.
                 * @member {rv.data.Graphics.IEdgeInsets|null|undefined} cropInsets
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.cropInsets = null;

                /**
                 * DrawingProperties alphaType.
                 * @member {rv.data.AlphaType} alphaType
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 */
                DrawingProperties.prototype.alphaType = 0;

                /**
                 * Creates a new DrawingProperties instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.DrawingProperties
                 * @static
                 * @param {rv.data.Media.IDrawingProperties=} [properties] Properties to set
                 * @returns {rv.data.Media.DrawingProperties} DrawingProperties instance
                 */
                DrawingProperties.create = function create(properties) {
                    return new DrawingProperties(properties);
                };

                /**
                 * Encodes the specified DrawingProperties message. Does not implicitly {@link rv.data.Media.DrawingProperties.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.DrawingProperties
                 * @static
                 * @param {rv.data.Media.IDrawingProperties} message DrawingProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DrawingProperties.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.scaleBehavior != null && Object.hasOwnProperty.call(message, "scaleBehavior"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scaleBehavior);
                    if (message.scaleAlignment != null && Object.hasOwnProperty.call(message, "scaleAlignment"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.scaleAlignment);
                    if (message.flippedHorizontally != null && Object.hasOwnProperty.call(message, "flippedHorizontally"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.flippedHorizontally);
                    if (message.flippedVertically != null && Object.hasOwnProperty.call(message, "flippedVertically"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.flippedVertically);
                    if (message.naturalSize != null && Object.hasOwnProperty.call(message, "naturalSize"))
                        $root.rv.data.Graphics.Size.encode(message.naturalSize, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.customImageRotation != null && Object.hasOwnProperty.call(message, "customImageRotation"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.customImageRotation);
                    if (message.customImageBounds != null && Object.hasOwnProperty.call(message, "customImageBounds"))
                        $root.rv.data.Graphics.Rect.encode(message.customImageBounds, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.customImageAspectLocked != null && Object.hasOwnProperty.call(message, "customImageAspectLocked"))
                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.customImageAspectLocked);
                    if (message.alphaInverted != null && Object.hasOwnProperty.call(message, "alphaInverted"))
                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.alphaInverted);
                    if (message.nativeRotation != null && Object.hasOwnProperty.call(message, "nativeRotation"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.nativeRotation);
                    if (message.selectedEffectPresetUuid != null && Object.hasOwnProperty.call(message, "selectedEffectPresetUuid"))
                        $root.rv.data.UUID.encode(message.selectedEffectPresetUuid, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.effects != null && message.effects.length)
                        for (let i = 0; i < message.effects.length; ++i)
                            $root.rv.data.Effect.encode(message.effects[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.cropEnable != null && Object.hasOwnProperty.call(message, "cropEnable"))
                        writer.uint32(/* id 13, wireType 0 =*/104).bool(message.cropEnable);
                    if (message.cropInsets != null && Object.hasOwnProperty.call(message, "cropInsets"))
                        $root.rv.data.Graphics.EdgeInsets.encode(message.cropInsets, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.alphaType != null && Object.hasOwnProperty.call(message, "alphaType"))
                        writer.uint32(/* id 15, wireType 0 =*/120).int32(message.alphaType);
                    if (message.isBlurred != null && Object.hasOwnProperty.call(message, "isBlurred"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.isBlurred);
                    return writer;
                };

                /**
                 * Encodes the specified DrawingProperties message, length delimited. Does not implicitly {@link rv.data.Media.DrawingProperties.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.DrawingProperties
                 * @static
                 * @param {rv.data.Media.IDrawingProperties} message DrawingProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DrawingProperties.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DrawingProperties message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.DrawingProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.DrawingProperties} DrawingProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DrawingProperties.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.DrawingProperties();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.scaleBehavior = reader.int32();
                                break;
                            }
                        case 16: {
                                message.isBlurred = reader.bool();
                                break;
                            }
                        case 2: {
                                message.scaleAlignment = reader.int32();
                                break;
                            }
                        case 3: {
                                message.flippedHorizontally = reader.bool();
                                break;
                            }
                        case 4: {
                                message.flippedVertically = reader.bool();
                                break;
                            }
                        case 5: {
                                message.naturalSize = $root.rv.data.Graphics.Size.decode(reader, reader.uint32());
                                break;
                            }
                        case 6: {
                                message.customImageRotation = reader.double();
                                break;
                            }
                        case 7: {
                                message.customImageBounds = $root.rv.data.Graphics.Rect.decode(reader, reader.uint32());
                                break;
                            }
                        case 8: {
                                message.customImageAspectLocked = reader.bool();
                                break;
                            }
                        case 9: {
                                message.alphaInverted = reader.bool();
                                break;
                            }
                        case 10: {
                                message.nativeRotation = reader.int32();
                                break;
                            }
                        case 11: {
                                message.selectedEffectPresetUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 12: {
                                if (!(message.effects && message.effects.length))
                                    message.effects = [];
                                message.effects.push($root.rv.data.Effect.decode(reader, reader.uint32()));
                                break;
                            }
                        case 13: {
                                message.cropEnable = reader.bool();
                                break;
                            }
                        case 14: {
                                message.cropInsets = $root.rv.data.Graphics.EdgeInsets.decode(reader, reader.uint32());
                                break;
                            }
                        case 15: {
                                message.alphaType = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DrawingProperties message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.DrawingProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.DrawingProperties} DrawingProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DrawingProperties.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DrawingProperties message.
                 * @function verify
                 * @memberof rv.data.Media.DrawingProperties
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DrawingProperties.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.scaleBehavior != null && message.hasOwnProperty("scaleBehavior"))
                        switch (message.scaleBehavior) {
                        default:
                            return "scaleBehavior: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.isBlurred != null && message.hasOwnProperty("isBlurred"))
                        if (typeof message.isBlurred !== "boolean")
                            return "isBlurred: boolean expected";
                    if (message.scaleAlignment != null && message.hasOwnProperty("scaleAlignment"))
                        switch (message.scaleAlignment) {
                        default:
                            return "scaleAlignment: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                            break;
                        }
                    if (message.flippedHorizontally != null && message.hasOwnProperty("flippedHorizontally"))
                        if (typeof message.flippedHorizontally !== "boolean")
                            return "flippedHorizontally: boolean expected";
                    if (message.flippedVertically != null && message.hasOwnProperty("flippedVertically"))
                        if (typeof message.flippedVertically !== "boolean")
                            return "flippedVertically: boolean expected";
                    if (message.naturalSize != null && message.hasOwnProperty("naturalSize")) {
                        let error = $root.rv.data.Graphics.Size.verify(message.naturalSize);
                        if (error)
                            return "naturalSize." + error;
                    }
                    if (message.customImageRotation != null && message.hasOwnProperty("customImageRotation"))
                        if (typeof message.customImageRotation !== "number")
                            return "customImageRotation: number expected";
                    if (message.customImageBounds != null && message.hasOwnProperty("customImageBounds")) {
                        let error = $root.rv.data.Graphics.Rect.verify(message.customImageBounds);
                        if (error)
                            return "customImageBounds." + error;
                    }
                    if (message.customImageAspectLocked != null && message.hasOwnProperty("customImageAspectLocked"))
                        if (typeof message.customImageAspectLocked !== "boolean")
                            return "customImageAspectLocked: boolean expected";
                    if (message.alphaInverted != null && message.hasOwnProperty("alphaInverted"))
                        if (typeof message.alphaInverted !== "boolean")
                            return "alphaInverted: boolean expected";
                    if (message.nativeRotation != null && message.hasOwnProperty("nativeRotation"))
                        switch (message.nativeRotation) {
                        default:
                            return "nativeRotation: enum value expected";
                        case 0:
                        case 90:
                        case 180:
                        case 270:
                            break;
                        }
                    if (message.selectedEffectPresetUuid != null && message.hasOwnProperty("selectedEffectPresetUuid")) {
                        let error = $root.rv.data.UUID.verify(message.selectedEffectPresetUuid);
                        if (error)
                            return "selectedEffectPresetUuid." + error;
                    }
                    if (message.effects != null && message.hasOwnProperty("effects")) {
                        if (!Array.isArray(message.effects))
                            return "effects: array expected";
                        for (let i = 0; i < message.effects.length; ++i) {
                            let error = $root.rv.data.Effect.verify(message.effects[i]);
                            if (error)
                                return "effects." + error;
                        }
                    }
                    if (message.cropEnable != null && message.hasOwnProperty("cropEnable"))
                        if (typeof message.cropEnable !== "boolean")
                            return "cropEnable: boolean expected";
                    if (message.cropInsets != null && message.hasOwnProperty("cropInsets")) {
                        let error = $root.rv.data.Graphics.EdgeInsets.verify(message.cropInsets);
                        if (error)
                            return "cropInsets." + error;
                    }
                    if (message.alphaType != null && message.hasOwnProperty("alphaType"))
                        switch (message.alphaType) {
                        default:
                            return "alphaType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a DrawingProperties message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.DrawingProperties
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.DrawingProperties} DrawingProperties
                 */
                DrawingProperties.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.DrawingProperties)
                        return object;
                    let message = new $root.rv.data.Media.DrawingProperties();
                    switch (object.scaleBehavior) {
                    default:
                        if (typeof object.scaleBehavior === "number") {
                            message.scaleBehavior = object.scaleBehavior;
                            break;
                        }
                        break;
                    case "SCALE_BEHAVIOR_FIT":
                    case 0:
                        message.scaleBehavior = 0;
                        break;
                    case "SCALE_BEHAVIOR_FILL":
                    case 1:
                        message.scaleBehavior = 1;
                        break;
                    case "SCALE_BEHAVIOR_STRETCH":
                    case 2:
                        message.scaleBehavior = 2;
                        break;
                    case "SCALE_BEHAVIOR_CUSTOM":
                    case 3:
                        message.scaleBehavior = 3;
                        break;
                    }
                    if (object.isBlurred != null)
                        message.isBlurred = Boolean(object.isBlurred);
                    switch (object.scaleAlignment) {
                    default:
                        if (typeof object.scaleAlignment === "number") {
                            message.scaleAlignment = object.scaleAlignment;
                            break;
                        }
                        break;
                    case "SCALE_ALIGNMENT_MIDDLE_CENTER":
                    case 0:
                        message.scaleAlignment = 0;
                        break;
                    case "SCALE_ALIGNMENT_TOP_LEFT":
                    case 1:
                        message.scaleAlignment = 1;
                        break;
                    case "SCALE_ALIGNMENT_TOP_CENTER":
                    case 2:
                        message.scaleAlignment = 2;
                        break;
                    case "SCALE_ALIGNMENT_TOP_RIGHT":
                    case 3:
                        message.scaleAlignment = 3;
                        break;
                    case "SCALE_ALIGNMENT_MIDDLE_RIGHT":
                    case 4:
                        message.scaleAlignment = 4;
                        break;
                    case "SCALE_ALIGNMENT_BOTTOM_RIGHT":
                    case 5:
                        message.scaleAlignment = 5;
                        break;
                    case "SCALE_ALIGNMENT_BOTTOM_CENTER":
                    case 6:
                        message.scaleAlignment = 6;
                        break;
                    case "SCALE_ALIGNMENT_BOTTOM_LEFT":
                    case 7:
                        message.scaleAlignment = 7;
                        break;
                    case "SCALE_ALIGNMENT_MIDDLE_LEFT":
                    case 8:
                        message.scaleAlignment = 8;
                        break;
                    }
                    if (object.flippedHorizontally != null)
                        message.flippedHorizontally = Boolean(object.flippedHorizontally);
                    if (object.flippedVertically != null)
                        message.flippedVertically = Boolean(object.flippedVertically);
                    if (object.naturalSize != null) {
                        if (typeof object.naturalSize !== "object")
                            throw TypeError(".rv.data.Media.DrawingProperties.naturalSize: object expected");
                        message.naturalSize = $root.rv.data.Graphics.Size.fromObject(object.naturalSize);
                    }
                    if (object.customImageRotation != null)
                        message.customImageRotation = Number(object.customImageRotation);
                    if (object.customImageBounds != null) {
                        if (typeof object.customImageBounds !== "object")
                            throw TypeError(".rv.data.Media.DrawingProperties.customImageBounds: object expected");
                        message.customImageBounds = $root.rv.data.Graphics.Rect.fromObject(object.customImageBounds);
                    }
                    if (object.customImageAspectLocked != null)
                        message.customImageAspectLocked = Boolean(object.customImageAspectLocked);
                    if (object.alphaInverted != null)
                        message.alphaInverted = Boolean(object.alphaInverted);
                    switch (object.nativeRotation) {
                    default:
                        if (typeof object.nativeRotation === "number") {
                            message.nativeRotation = object.nativeRotation;
                            break;
                        }
                        break;
                    case "NATIVE_ROTATION_TYPE_ROTATE_STANDARD":
                    case 0:
                        message.nativeRotation = 0;
                        break;
                    case "NATIVE_ROTATION_TYPE_ROTATE_90":
                    case 90:
                        message.nativeRotation = 90;
                        break;
                    case "NATIVE_ROTATION_TYPE_ROTATE_180":
                    case 180:
                        message.nativeRotation = 180;
                        break;
                    case "NATIVE_ROTATION_TYPE_ROTATE_270":
                    case 270:
                        message.nativeRotation = 270;
                        break;
                    }
                    if (object.selectedEffectPresetUuid != null) {
                        if (typeof object.selectedEffectPresetUuid !== "object")
                            throw TypeError(".rv.data.Media.DrawingProperties.selectedEffectPresetUuid: object expected");
                        message.selectedEffectPresetUuid = $root.rv.data.UUID.fromObject(object.selectedEffectPresetUuid);
                    }
                    if (object.effects) {
                        if (!Array.isArray(object.effects))
                            throw TypeError(".rv.data.Media.DrawingProperties.effects: array expected");
                        message.effects = [];
                        for (let i = 0; i < object.effects.length; ++i) {
                            if (typeof object.effects[i] !== "object")
                                throw TypeError(".rv.data.Media.DrawingProperties.effects: object expected");
                            message.effects[i] = $root.rv.data.Effect.fromObject(object.effects[i]);
                        }
                    }
                    if (object.cropEnable != null)
                        message.cropEnable = Boolean(object.cropEnable);
                    if (object.cropInsets != null) {
                        if (typeof object.cropInsets !== "object")
                            throw TypeError(".rv.data.Media.DrawingProperties.cropInsets: object expected");
                        message.cropInsets = $root.rv.data.Graphics.EdgeInsets.fromObject(object.cropInsets);
                    }
                    switch (object.alphaType) {
                    default:
                        if (typeof object.alphaType === "number") {
                            message.alphaType = object.alphaType;
                            break;
                        }
                        break;
                    case "ALPHA_TYPE_UNKNOWN":
                    case 0:
                        message.alphaType = 0;
                        break;
                    case "ALPHA_TYPE_STRAIGHT":
                    case 1:
                        message.alphaType = 1;
                        break;
                    case "ALPHA_TYPE_PREMULTIPLIED":
                    case 2:
                        message.alphaType = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DrawingProperties message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.DrawingProperties
                 * @static
                 * @param {rv.data.Media.DrawingProperties} message DrawingProperties
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DrawingProperties.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.effects = [];
                    if (options.defaults) {
                        object.scaleBehavior = options.enums === String ? "SCALE_BEHAVIOR_FIT" : 0;
                        object.scaleAlignment = options.enums === String ? "SCALE_ALIGNMENT_MIDDLE_CENTER" : 0;
                        object.flippedHorizontally = false;
                        object.flippedVertically = false;
                        object.naturalSize = null;
                        object.customImageRotation = 0;
                        object.customImageBounds = null;
                        object.customImageAspectLocked = false;
                        object.alphaInverted = false;
                        object.nativeRotation = options.enums === String ? "NATIVE_ROTATION_TYPE_ROTATE_STANDARD" : 0;
                        object.selectedEffectPresetUuid = null;
                        object.cropEnable = false;
                        object.cropInsets = null;
                        object.alphaType = options.enums === String ? "ALPHA_TYPE_UNKNOWN" : 0;
                        object.isBlurred = false;
                    }
                    if (message.scaleBehavior != null && message.hasOwnProperty("scaleBehavior"))
                        object.scaleBehavior = options.enums === String ? $root.rv.data.Media.ScaleBehavior[message.scaleBehavior] === undefined ? message.scaleBehavior : $root.rv.data.Media.ScaleBehavior[message.scaleBehavior] : message.scaleBehavior;
                    if (message.scaleAlignment != null && message.hasOwnProperty("scaleAlignment"))
                        object.scaleAlignment = options.enums === String ? $root.rv.data.Media.ScaleAlignment[message.scaleAlignment] === undefined ? message.scaleAlignment : $root.rv.data.Media.ScaleAlignment[message.scaleAlignment] : message.scaleAlignment;
                    if (message.flippedHorizontally != null && message.hasOwnProperty("flippedHorizontally"))
                        object.flippedHorizontally = message.flippedHorizontally;
                    if (message.flippedVertically != null && message.hasOwnProperty("flippedVertically"))
                        object.flippedVertically = message.flippedVertically;
                    if (message.naturalSize != null && message.hasOwnProperty("naturalSize"))
                        object.naturalSize = $root.rv.data.Graphics.Size.toObject(message.naturalSize, options);
                    if (message.customImageRotation != null && message.hasOwnProperty("customImageRotation"))
                        object.customImageRotation = options.json && !isFinite(message.customImageRotation) ? String(message.customImageRotation) : message.customImageRotation;
                    if (message.customImageBounds != null && message.hasOwnProperty("customImageBounds"))
                        object.customImageBounds = $root.rv.data.Graphics.Rect.toObject(message.customImageBounds, options);
                    if (message.customImageAspectLocked != null && message.hasOwnProperty("customImageAspectLocked"))
                        object.customImageAspectLocked = message.customImageAspectLocked;
                    if (message.alphaInverted != null && message.hasOwnProperty("alphaInverted"))
                        object.alphaInverted = message.alphaInverted;
                    if (message.nativeRotation != null && message.hasOwnProperty("nativeRotation"))
                        object.nativeRotation = options.enums === String ? $root.rv.data.Media.DrawingProperties.NativeRotationType[message.nativeRotation] === undefined ? message.nativeRotation : $root.rv.data.Media.DrawingProperties.NativeRotationType[message.nativeRotation] : message.nativeRotation;
                    if (message.selectedEffectPresetUuid != null && message.hasOwnProperty("selectedEffectPresetUuid"))
                        object.selectedEffectPresetUuid = $root.rv.data.UUID.toObject(message.selectedEffectPresetUuid, options);
                    if (message.effects && message.effects.length) {
                        object.effects = [];
                        for (let j = 0; j < message.effects.length; ++j)
                            object.effects[j] = $root.rv.data.Effect.toObject(message.effects[j], options);
                    }
                    if (message.cropEnable != null && message.hasOwnProperty("cropEnable"))
                        object.cropEnable = message.cropEnable;
                    if (message.cropInsets != null && message.hasOwnProperty("cropInsets"))
                        object.cropInsets = $root.rv.data.Graphics.EdgeInsets.toObject(message.cropInsets, options);
                    if (message.alphaType != null && message.hasOwnProperty("alphaType"))
                        object.alphaType = options.enums === String ? $root.rv.data.AlphaType[message.alphaType] === undefined ? message.alphaType : $root.rv.data.AlphaType[message.alphaType] : message.alphaType;
                    if (message.isBlurred != null && message.hasOwnProperty("isBlurred"))
                        object.isBlurred = message.isBlurred;
                    return object;
                };

                /**
                 * Converts this DrawingProperties to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.DrawingProperties
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DrawingProperties.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for DrawingProperties
                 * @function getTypeUrl
                 * @memberof rv.data.Media.DrawingProperties
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                DrawingProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.DrawingProperties";
                };

                /**
                 * NativeRotationType enum.
                 * @name rv.data.Media.DrawingProperties.NativeRotationType
                 * @enum {number}
                 * @property {number} NATIVE_ROTATION_TYPE_ROTATE_STANDARD=0 NATIVE_ROTATION_TYPE_ROTATE_STANDARD value
                 * @property {number} NATIVE_ROTATION_TYPE_ROTATE_90=90 NATIVE_ROTATION_TYPE_ROTATE_90 value
                 * @property {number} NATIVE_ROTATION_TYPE_ROTATE_180=180 NATIVE_ROTATION_TYPE_ROTATE_180 value
                 * @property {number} NATIVE_ROTATION_TYPE_ROTATE_270=270 NATIVE_ROTATION_TYPE_ROTATE_270 value
                 */
                DrawingProperties.NativeRotationType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NATIVE_ROTATION_TYPE_ROTATE_STANDARD"] = 0;
                    values[valuesById[90] = "NATIVE_ROTATION_TYPE_ROTATE_90"] = 90;
                    values[valuesById[180] = "NATIVE_ROTATION_TYPE_ROTATE_180"] = 180;
                    values[valuesById[270] = "NATIVE_ROTATION_TYPE_ROTATE_270"] = 270;
                    return values;
                })();

                return DrawingProperties;
            })();

            Media.VideoProperties = (function() {

                /**
                 * Properties of a VideoProperties.
                 * @memberof rv.data.Media
                 * @interface IVideoProperties
                 * @property {number|null} [frameRate] VideoProperties frameRate
                 * @property {rv.data.Media.VideoProperties.FieldType|null} [fieldType] VideoProperties fieldType
                 * @property {number|null} [thumbnailPosition] VideoProperties thumbnailPosition
                 * @property {rv.data.Media.VideoProperties.EndBehavior|null} [endBehavior] VideoProperties endBehavior
                 * @property {boolean|null} [softLoop] VideoProperties softLoop
                 * @property {number|null} [softLoopDuration] VideoProperties softLoopDuration
                 */

                /**
                 * Constructs a new VideoProperties.
                 * @memberof rv.data.Media
                 * @classdesc Represents a VideoProperties.
                 * @implements IVideoProperties
                 * @constructor
                 * @param {rv.data.Media.IVideoProperties=} [properties] Properties to set
                 */
                function VideoProperties(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * VideoProperties frameRate.
                 * @member {number} frameRate
                 * @memberof rv.data.Media.VideoProperties
                 * @instance
                 */
                VideoProperties.prototype.frameRate = 0;

                /**
                 * VideoProperties fieldType.
                 * @member {rv.data.Media.VideoProperties.FieldType} fieldType
                 * @memberof rv.data.Media.VideoProperties
                 * @instance
                 */
                VideoProperties.prototype.fieldType = 0;

                /**
                 * VideoProperties thumbnailPosition.
                 * @member {number} thumbnailPosition
                 * @memberof rv.data.Media.VideoProperties
                 * @instance
                 */
                VideoProperties.prototype.thumbnailPosition = 0;

                /**
                 * VideoProperties endBehavior.
                 * @member {rv.data.Media.VideoProperties.EndBehavior} endBehavior
                 * @memberof rv.data.Media.VideoProperties
                 * @instance
                 */
                VideoProperties.prototype.endBehavior = 0;

                /**
                 * VideoProperties softLoop.
                 * @member {boolean} softLoop
                 * @memberof rv.data.Media.VideoProperties
                 * @instance
                 */
                VideoProperties.prototype.softLoop = false;

                /**
                 * VideoProperties softLoopDuration.
                 * @member {number} softLoopDuration
                 * @memberof rv.data.Media.VideoProperties
                 * @instance
                 */
                VideoProperties.prototype.softLoopDuration = 0;

                /**
                 * Creates a new VideoProperties instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.VideoProperties
                 * @static
                 * @param {rv.data.Media.IVideoProperties=} [properties] Properties to set
                 * @returns {rv.data.Media.VideoProperties} VideoProperties instance
                 */
                VideoProperties.create = function create(properties) {
                    return new VideoProperties(properties);
                };

                /**
                 * Encodes the specified VideoProperties message. Does not implicitly {@link rv.data.Media.VideoProperties.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.VideoProperties
                 * @static
                 * @param {rv.data.Media.IVideoProperties} message VideoProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VideoProperties.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.frameRate != null && Object.hasOwnProperty.call(message, "frameRate"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.frameRate);
                    if (message.fieldType != null && Object.hasOwnProperty.call(message, "fieldType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fieldType);
                    if (message.thumbnailPosition != null && Object.hasOwnProperty.call(message, "thumbnailPosition"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.thumbnailPosition);
                    if (message.endBehavior != null && Object.hasOwnProperty.call(message, "endBehavior"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.endBehavior);
                    if (message.softLoop != null && Object.hasOwnProperty.call(message, "softLoop"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.softLoop);
                    if (message.softLoopDuration != null && Object.hasOwnProperty.call(message, "softLoopDuration"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.softLoopDuration);
                    return writer;
                };

                /**
                 * Encodes the specified VideoProperties message, length delimited. Does not implicitly {@link rv.data.Media.VideoProperties.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.VideoProperties
                 * @static
                 * @param {rv.data.Media.IVideoProperties} message VideoProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VideoProperties.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a VideoProperties message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.VideoProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.VideoProperties} VideoProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VideoProperties.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.VideoProperties();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.frameRate = reader.double();
                                break;
                            }
                        case 2: {
                                message.fieldType = reader.int32();
                                break;
                            }
                        case 3: {
                                message.thumbnailPosition = reader.double();
                                break;
                            }
                        case 4: {
                                message.endBehavior = reader.int32();
                                break;
                            }
                        case 5: {
                                message.softLoop = reader.bool();
                                break;
                            }
                        case 6: {
                                message.softLoopDuration = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a VideoProperties message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.VideoProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.VideoProperties} VideoProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VideoProperties.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a VideoProperties message.
                 * @function verify
                 * @memberof rv.data.Media.VideoProperties
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                VideoProperties.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.frameRate != null && message.hasOwnProperty("frameRate"))
                        if (typeof message.frameRate !== "number")
                            return "frameRate: number expected";
                    if (message.fieldType != null && message.hasOwnProperty("fieldType"))
                        switch (message.fieldType) {
                        default:
                            return "fieldType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.thumbnailPosition != null && message.hasOwnProperty("thumbnailPosition"))
                        if (typeof message.thumbnailPosition !== "number")
                            return "thumbnailPosition: number expected";
                    if (message.endBehavior != null && message.hasOwnProperty("endBehavior"))
                        switch (message.endBehavior) {
                        default:
                            return "endBehavior: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.softLoop != null && message.hasOwnProperty("softLoop"))
                        if (typeof message.softLoop !== "boolean")
                            return "softLoop: boolean expected";
                    if (message.softLoopDuration != null && message.hasOwnProperty("softLoopDuration"))
                        if (typeof message.softLoopDuration !== "number")
                            return "softLoopDuration: number expected";
                    return null;
                };

                /**
                 * Creates a VideoProperties message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.VideoProperties
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.VideoProperties} VideoProperties
                 */
                VideoProperties.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.VideoProperties)
                        return object;
                    let message = new $root.rv.data.Media.VideoProperties();
                    if (object.frameRate != null)
                        message.frameRate = Number(object.frameRate);
                    switch (object.fieldType) {
                    default:
                        if (typeof object.fieldType === "number") {
                            message.fieldType = object.fieldType;
                            break;
                        }
                        break;
                    case "FIELD_TYPE_UNKNOWN":
                    case 0:
                        message.fieldType = 0;
                        break;
                    case "FIELD_TYPE_PROGRESSIVE":
                    case 1:
                        message.fieldType = 1;
                        break;
                    case "FIELD_TYPE_INTERLACED_UPPER_FIRST":
                    case 2:
                        message.fieldType = 2;
                        break;
                    case "FIELD_TYPE_INTERLACED_LOWER_FIRST":
                    case 3:
                        message.fieldType = 3;
                        break;
                    }
                    if (object.thumbnailPosition != null)
                        message.thumbnailPosition = Number(object.thumbnailPosition);
                    switch (object.endBehavior) {
                    default:
                        if (typeof object.endBehavior === "number") {
                            message.endBehavior = object.endBehavior;
                            break;
                        }
                        break;
                    case "END_BEHAVIOR_STOP":
                    case 0:
                        message.endBehavior = 0;
                        break;
                    case "END_BEHAVIOR_STOP_ON_BLACK":
                    case 1:
                        message.endBehavior = 1;
                        break;
                    case "END_BEHAVIOR_STOP_ON_CLEAR":
                    case 2:
                        message.endBehavior = 2;
                        break;
                    case "END_BEHAVIOR_FADE_TO_BLACK":
                    case 3:
                        message.endBehavior = 3;
                        break;
                    case "END_BEHAVIOR_FADE_TO_CLEAR":
                    case 4:
                        message.endBehavior = 4;
                        break;
                    }
                    if (object.softLoop != null)
                        message.softLoop = Boolean(object.softLoop);
                    if (object.softLoopDuration != null)
                        message.softLoopDuration = Number(object.softLoopDuration);
                    return message;
                };

                /**
                 * Creates a plain object from a VideoProperties message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.VideoProperties
                 * @static
                 * @param {rv.data.Media.VideoProperties} message VideoProperties
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                VideoProperties.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.frameRate = 0;
                        object.fieldType = options.enums === String ? "FIELD_TYPE_UNKNOWN" : 0;
                        object.thumbnailPosition = 0;
                        object.endBehavior = options.enums === String ? "END_BEHAVIOR_STOP" : 0;
                        object.softLoop = false;
                        object.softLoopDuration = 0;
                    }
                    if (message.frameRate != null && message.hasOwnProperty("frameRate"))
                        object.frameRate = options.json && !isFinite(message.frameRate) ? String(message.frameRate) : message.frameRate;
                    if (message.fieldType != null && message.hasOwnProperty("fieldType"))
                        object.fieldType = options.enums === String ? $root.rv.data.Media.VideoProperties.FieldType[message.fieldType] === undefined ? message.fieldType : $root.rv.data.Media.VideoProperties.FieldType[message.fieldType] : message.fieldType;
                    if (message.thumbnailPosition != null && message.hasOwnProperty("thumbnailPosition"))
                        object.thumbnailPosition = options.json && !isFinite(message.thumbnailPosition) ? String(message.thumbnailPosition) : message.thumbnailPosition;
                    if (message.endBehavior != null && message.hasOwnProperty("endBehavior"))
                        object.endBehavior = options.enums === String ? $root.rv.data.Media.VideoProperties.EndBehavior[message.endBehavior] === undefined ? message.endBehavior : $root.rv.data.Media.VideoProperties.EndBehavior[message.endBehavior] : message.endBehavior;
                    if (message.softLoop != null && message.hasOwnProperty("softLoop"))
                        object.softLoop = message.softLoop;
                    if (message.softLoopDuration != null && message.hasOwnProperty("softLoopDuration"))
                        object.softLoopDuration = options.json && !isFinite(message.softLoopDuration) ? String(message.softLoopDuration) : message.softLoopDuration;
                    return object;
                };

                /**
                 * Converts this VideoProperties to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.VideoProperties
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                VideoProperties.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for VideoProperties
                 * @function getTypeUrl
                 * @memberof rv.data.Media.VideoProperties
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                VideoProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.VideoProperties";
                };

                /**
                 * EndBehavior enum.
                 * @name rv.data.Media.VideoProperties.EndBehavior
                 * @enum {number}
                 * @property {number} END_BEHAVIOR_STOP=0 END_BEHAVIOR_STOP value
                 * @property {number} END_BEHAVIOR_STOP_ON_BLACK=1 END_BEHAVIOR_STOP_ON_BLACK value
                 * @property {number} END_BEHAVIOR_STOP_ON_CLEAR=2 END_BEHAVIOR_STOP_ON_CLEAR value
                 * @property {number} END_BEHAVIOR_FADE_TO_BLACK=3 END_BEHAVIOR_FADE_TO_BLACK value
                 * @property {number} END_BEHAVIOR_FADE_TO_CLEAR=4 END_BEHAVIOR_FADE_TO_CLEAR value
                 */
                VideoProperties.EndBehavior = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "END_BEHAVIOR_STOP"] = 0;
                    values[valuesById[1] = "END_BEHAVIOR_STOP_ON_BLACK"] = 1;
                    values[valuesById[2] = "END_BEHAVIOR_STOP_ON_CLEAR"] = 2;
                    values[valuesById[3] = "END_BEHAVIOR_FADE_TO_BLACK"] = 3;
                    values[valuesById[4] = "END_BEHAVIOR_FADE_TO_CLEAR"] = 4;
                    return values;
                })();

                /**
                 * FieldType enum.
                 * @name rv.data.Media.VideoProperties.FieldType
                 * @enum {number}
                 * @property {number} FIELD_TYPE_UNKNOWN=0 FIELD_TYPE_UNKNOWN value
                 * @property {number} FIELD_TYPE_PROGRESSIVE=1 FIELD_TYPE_PROGRESSIVE value
                 * @property {number} FIELD_TYPE_INTERLACED_UPPER_FIRST=2 FIELD_TYPE_INTERLACED_UPPER_FIRST value
                 * @property {number} FIELD_TYPE_INTERLACED_LOWER_FIRST=3 FIELD_TYPE_INTERLACED_LOWER_FIRST value
                 */
                VideoProperties.FieldType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "FIELD_TYPE_UNKNOWN"] = 0;
                    values[valuesById[1] = "FIELD_TYPE_PROGRESSIVE"] = 1;
                    values[valuesById[2] = "FIELD_TYPE_INTERLACED_UPPER_FIRST"] = 2;
                    values[valuesById[3] = "FIELD_TYPE_INTERLACED_LOWER_FIRST"] = 3;
                    return values;
                })();

                return VideoProperties;
            })();

            Media.LiveVideoProperties = (function() {

                /**
                 * Properties of a LiveVideoProperties.
                 * @memberof rv.data.Media
                 * @interface ILiveVideoProperties
                 * @property {rv.data.Media.IVideoDevice|null} [videoDevice] LiveVideoProperties videoDevice
                 * @property {rv.data.Media.IAudioDevice|null} [audioDevice] LiveVideoProperties audioDevice
                 * @property {number|null} [liveVideoIndex] LiveVideoProperties liveVideoIndex
                 */

                /**
                 * Constructs a new LiveVideoProperties.
                 * @memberof rv.data.Media
                 * @classdesc Represents a LiveVideoProperties.
                 * @implements ILiveVideoProperties
                 * @constructor
                 * @param {rv.data.Media.ILiveVideoProperties=} [properties] Properties to set
                 */
                function LiveVideoProperties(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LiveVideoProperties videoDevice.
                 * @member {rv.data.Media.IVideoDevice|null|undefined} videoDevice
                 * @memberof rv.data.Media.LiveVideoProperties
                 * @instance
                 */
                LiveVideoProperties.prototype.videoDevice = null;

                /**
                 * LiveVideoProperties audioDevice.
                 * @member {rv.data.Media.IAudioDevice|null|undefined} audioDevice
                 * @memberof rv.data.Media.LiveVideoProperties
                 * @instance
                 */
                LiveVideoProperties.prototype.audioDevice = null;

                /**
                 * LiveVideoProperties liveVideoIndex.
                 * @member {number} liveVideoIndex
                 * @memberof rv.data.Media.LiveVideoProperties
                 * @instance
                 */
                LiveVideoProperties.prototype.liveVideoIndex = 0;

                /**
                 * Creates a new LiveVideoProperties instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.LiveVideoProperties
                 * @static
                 * @param {rv.data.Media.ILiveVideoProperties=} [properties] Properties to set
                 * @returns {rv.data.Media.LiveVideoProperties} LiveVideoProperties instance
                 */
                LiveVideoProperties.create = function create(properties) {
                    return new LiveVideoProperties(properties);
                };

                /**
                 * Encodes the specified LiveVideoProperties message. Does not implicitly {@link rv.data.Media.LiveVideoProperties.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.LiveVideoProperties
                 * @static
                 * @param {rv.data.Media.ILiveVideoProperties} message LiveVideoProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LiveVideoProperties.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.videoDevice != null && Object.hasOwnProperty.call(message, "videoDevice"))
                        $root.rv.data.Media.VideoDevice.encode(message.videoDevice, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.audioDevice != null && Object.hasOwnProperty.call(message, "audioDevice"))
                        $root.rv.data.Media.AudioDevice.encode(message.audioDevice, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.liveVideoIndex != null && Object.hasOwnProperty.call(message, "liveVideoIndex"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.liveVideoIndex);
                    return writer;
                };

                /**
                 * Encodes the specified LiveVideoProperties message, length delimited. Does not implicitly {@link rv.data.Media.LiveVideoProperties.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.LiveVideoProperties
                 * @static
                 * @param {rv.data.Media.ILiveVideoProperties} message LiveVideoProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LiveVideoProperties.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LiveVideoProperties message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.LiveVideoProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.LiveVideoProperties} LiveVideoProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LiveVideoProperties.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.LiveVideoProperties();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.videoDevice = $root.rv.data.Media.VideoDevice.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.audioDevice = $root.rv.data.Media.AudioDevice.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.liveVideoIndex = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LiveVideoProperties message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.LiveVideoProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.LiveVideoProperties} LiveVideoProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LiveVideoProperties.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LiveVideoProperties message.
                 * @function verify
                 * @memberof rv.data.Media.LiveVideoProperties
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LiveVideoProperties.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.videoDevice != null && message.hasOwnProperty("videoDevice")) {
                        let error = $root.rv.data.Media.VideoDevice.verify(message.videoDevice);
                        if (error)
                            return "videoDevice." + error;
                    }
                    if (message.audioDevice != null && message.hasOwnProperty("audioDevice")) {
                        let error = $root.rv.data.Media.AudioDevice.verify(message.audioDevice);
                        if (error)
                            return "audioDevice." + error;
                    }
                    if (message.liveVideoIndex != null && message.hasOwnProperty("liveVideoIndex"))
                        if (!$util.isInteger(message.liveVideoIndex))
                            return "liveVideoIndex: integer expected";
                    return null;
                };

                /**
                 * Creates a LiveVideoProperties message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.LiveVideoProperties
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.LiveVideoProperties} LiveVideoProperties
                 */
                LiveVideoProperties.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.LiveVideoProperties)
                        return object;
                    let message = new $root.rv.data.Media.LiveVideoProperties();
                    if (object.videoDevice != null) {
                        if (typeof object.videoDevice !== "object")
                            throw TypeError(".rv.data.Media.LiveVideoProperties.videoDevice: object expected");
                        message.videoDevice = $root.rv.data.Media.VideoDevice.fromObject(object.videoDevice);
                    }
                    if (object.audioDevice != null) {
                        if (typeof object.audioDevice !== "object")
                            throw TypeError(".rv.data.Media.LiveVideoProperties.audioDevice: object expected");
                        message.audioDevice = $root.rv.data.Media.AudioDevice.fromObject(object.audioDevice);
                    }
                    if (object.liveVideoIndex != null)
                        message.liveVideoIndex = object.liveVideoIndex | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a LiveVideoProperties message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.LiveVideoProperties
                 * @static
                 * @param {rv.data.Media.LiveVideoProperties} message LiveVideoProperties
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LiveVideoProperties.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.videoDevice = null;
                        object.audioDevice = null;
                        object.liveVideoIndex = 0;
                    }
                    if (message.videoDevice != null && message.hasOwnProperty("videoDevice"))
                        object.videoDevice = $root.rv.data.Media.VideoDevice.toObject(message.videoDevice, options);
                    if (message.audioDevice != null && message.hasOwnProperty("audioDevice"))
                        object.audioDevice = $root.rv.data.Media.AudioDevice.toObject(message.audioDevice, options);
                    if (message.liveVideoIndex != null && message.hasOwnProperty("liveVideoIndex"))
                        object.liveVideoIndex = message.liveVideoIndex;
                    return object;
                };

                /**
                 * Converts this LiveVideoProperties to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.LiveVideoProperties
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LiveVideoProperties.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for LiveVideoProperties
                 * @function getTypeUrl
                 * @memberof rv.data.Media.LiveVideoProperties
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                LiveVideoProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.LiveVideoProperties";
                };

                return LiveVideoProperties;
            })();

            Media.AudioTypeProperties = (function() {

                /**
                 * Properties of an AudioTypeProperties.
                 * @memberof rv.data.Media
                 * @interface IAudioTypeProperties
                 * @property {rv.data.Media.IAudioProperties|null} [audio] AudioTypeProperties audio
                 * @property {rv.data.Media.ITransportProperties|null} [transport] AudioTypeProperties transport
                 * @property {rv.data.IFileProperties|null} [file] AudioTypeProperties file
                 */

                /**
                 * Constructs a new AudioTypeProperties.
                 * @memberof rv.data.Media
                 * @classdesc Represents an AudioTypeProperties.
                 * @implements IAudioTypeProperties
                 * @constructor
                 * @param {rv.data.Media.IAudioTypeProperties=} [properties] Properties to set
                 */
                function AudioTypeProperties(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AudioTypeProperties audio.
                 * @member {rv.data.Media.IAudioProperties|null|undefined} audio
                 * @memberof rv.data.Media.AudioTypeProperties
                 * @instance
                 */
                AudioTypeProperties.prototype.audio = null;

                /**
                 * AudioTypeProperties transport.
                 * @member {rv.data.Media.ITransportProperties|null|undefined} transport
                 * @memberof rv.data.Media.AudioTypeProperties
                 * @instance
                 */
                AudioTypeProperties.prototype.transport = null;

                /**
                 * AudioTypeProperties file.
                 * @member {rv.data.IFileProperties|null|undefined} file
                 * @memberof rv.data.Media.AudioTypeProperties
                 * @instance
                 */
                AudioTypeProperties.prototype.file = null;

                /**
                 * Creates a new AudioTypeProperties instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.AudioTypeProperties
                 * @static
                 * @param {rv.data.Media.IAudioTypeProperties=} [properties] Properties to set
                 * @returns {rv.data.Media.AudioTypeProperties} AudioTypeProperties instance
                 */
                AudioTypeProperties.create = function create(properties) {
                    return new AudioTypeProperties(properties);
                };

                /**
                 * Encodes the specified AudioTypeProperties message. Does not implicitly {@link rv.data.Media.AudioTypeProperties.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.AudioTypeProperties
                 * @static
                 * @param {rv.data.Media.IAudioTypeProperties} message AudioTypeProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AudioTypeProperties.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                        $root.rv.data.Media.AudioProperties.encode(message.audio, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.transport != null && Object.hasOwnProperty.call(message, "transport"))
                        $root.rv.data.Media.TransportProperties.encode(message.transport, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                        $root.rv.data.FileProperties.encode(message.file, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified AudioTypeProperties message, length delimited. Does not implicitly {@link rv.data.Media.AudioTypeProperties.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.AudioTypeProperties
                 * @static
                 * @param {rv.data.Media.IAudioTypeProperties} message AudioTypeProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AudioTypeProperties.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AudioTypeProperties message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.AudioTypeProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.AudioTypeProperties} AudioTypeProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AudioTypeProperties.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.AudioTypeProperties();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.audio = $root.rv.data.Media.AudioProperties.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.transport = $root.rv.data.Media.TransportProperties.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.file = $root.rv.data.FileProperties.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AudioTypeProperties message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.AudioTypeProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.AudioTypeProperties} AudioTypeProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AudioTypeProperties.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AudioTypeProperties message.
                 * @function verify
                 * @memberof rv.data.Media.AudioTypeProperties
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AudioTypeProperties.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.audio != null && message.hasOwnProperty("audio")) {
                        let error = $root.rv.data.Media.AudioProperties.verify(message.audio);
                        if (error)
                            return "audio." + error;
                    }
                    if (message.transport != null && message.hasOwnProperty("transport")) {
                        let error = $root.rv.data.Media.TransportProperties.verify(message.transport);
                        if (error)
                            return "transport." + error;
                    }
                    if (message.file != null && message.hasOwnProperty("file")) {
                        let error = $root.rv.data.FileProperties.verify(message.file);
                        if (error)
                            return "file." + error;
                    }
                    return null;
                };

                /**
                 * Creates an AudioTypeProperties message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.AudioTypeProperties
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.AudioTypeProperties} AudioTypeProperties
                 */
                AudioTypeProperties.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.AudioTypeProperties)
                        return object;
                    let message = new $root.rv.data.Media.AudioTypeProperties();
                    if (object.audio != null) {
                        if (typeof object.audio !== "object")
                            throw TypeError(".rv.data.Media.AudioTypeProperties.audio: object expected");
                        message.audio = $root.rv.data.Media.AudioProperties.fromObject(object.audio);
                    }
                    if (object.transport != null) {
                        if (typeof object.transport !== "object")
                            throw TypeError(".rv.data.Media.AudioTypeProperties.transport: object expected");
                        message.transport = $root.rv.data.Media.TransportProperties.fromObject(object.transport);
                    }
                    if (object.file != null) {
                        if (typeof object.file !== "object")
                            throw TypeError(".rv.data.Media.AudioTypeProperties.file: object expected");
                        message.file = $root.rv.data.FileProperties.fromObject(object.file);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an AudioTypeProperties message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.AudioTypeProperties
                 * @static
                 * @param {rv.data.Media.AudioTypeProperties} message AudioTypeProperties
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AudioTypeProperties.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.audio = null;
                        object.transport = null;
                        object.file = null;
                    }
                    if (message.audio != null && message.hasOwnProperty("audio"))
                        object.audio = $root.rv.data.Media.AudioProperties.toObject(message.audio, options);
                    if (message.transport != null && message.hasOwnProperty("transport"))
                        object.transport = $root.rv.data.Media.TransportProperties.toObject(message.transport, options);
                    if (message.file != null && message.hasOwnProperty("file"))
                        object.file = $root.rv.data.FileProperties.toObject(message.file, options);
                    return object;
                };

                /**
                 * Converts this AudioTypeProperties to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.AudioTypeProperties
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AudioTypeProperties.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for AudioTypeProperties
                 * @function getTypeUrl
                 * @memberof rv.data.Media.AudioTypeProperties
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                AudioTypeProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.AudioTypeProperties";
                };

                return AudioTypeProperties;
            })();

            Media.ImageTypeProperties = (function() {

                /**
                 * Properties of an ImageTypeProperties.
                 * @memberof rv.data.Media
                 * @interface IImageTypeProperties
                 * @property {rv.data.Media.IDrawingProperties|null} [drawing] ImageTypeProperties drawing
                 * @property {rv.data.IFileProperties|null} [file] ImageTypeProperties file
                 */

                /**
                 * Constructs a new ImageTypeProperties.
                 * @memberof rv.data.Media
                 * @classdesc Represents an ImageTypeProperties.
                 * @implements IImageTypeProperties
                 * @constructor
                 * @param {rv.data.Media.IImageTypeProperties=} [properties] Properties to set
                 */
                function ImageTypeProperties(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ImageTypeProperties drawing.
                 * @member {rv.data.Media.IDrawingProperties|null|undefined} drawing
                 * @memberof rv.data.Media.ImageTypeProperties
                 * @instance
                 */
                ImageTypeProperties.prototype.drawing = null;

                /**
                 * ImageTypeProperties file.
                 * @member {rv.data.IFileProperties|null|undefined} file
                 * @memberof rv.data.Media.ImageTypeProperties
                 * @instance
                 */
                ImageTypeProperties.prototype.file = null;

                /**
                 * Creates a new ImageTypeProperties instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.ImageTypeProperties
                 * @static
                 * @param {rv.data.Media.IImageTypeProperties=} [properties] Properties to set
                 * @returns {rv.data.Media.ImageTypeProperties} ImageTypeProperties instance
                 */
                ImageTypeProperties.create = function create(properties) {
                    return new ImageTypeProperties(properties);
                };

                /**
                 * Encodes the specified ImageTypeProperties message. Does not implicitly {@link rv.data.Media.ImageTypeProperties.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.ImageTypeProperties
                 * @static
                 * @param {rv.data.Media.IImageTypeProperties} message ImageTypeProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageTypeProperties.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.drawing != null && Object.hasOwnProperty.call(message, "drawing"))
                        $root.rv.data.Media.DrawingProperties.encode(message.drawing, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                        $root.rv.data.FileProperties.encode(message.file, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ImageTypeProperties message, length delimited. Does not implicitly {@link rv.data.Media.ImageTypeProperties.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.ImageTypeProperties
                 * @static
                 * @param {rv.data.Media.IImageTypeProperties} message ImageTypeProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageTypeProperties.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ImageTypeProperties message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.ImageTypeProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.ImageTypeProperties} ImageTypeProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageTypeProperties.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.ImageTypeProperties();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.drawing = $root.rv.data.Media.DrawingProperties.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.file = $root.rv.data.FileProperties.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ImageTypeProperties message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.ImageTypeProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.ImageTypeProperties} ImageTypeProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageTypeProperties.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ImageTypeProperties message.
                 * @function verify
                 * @memberof rv.data.Media.ImageTypeProperties
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ImageTypeProperties.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.drawing != null && message.hasOwnProperty("drawing")) {
                        let error = $root.rv.data.Media.DrawingProperties.verify(message.drawing);
                        if (error)
                            return "drawing." + error;
                    }
                    if (message.file != null && message.hasOwnProperty("file")) {
                        let error = $root.rv.data.FileProperties.verify(message.file);
                        if (error)
                            return "file." + error;
                    }
                    return null;
                };

                /**
                 * Creates an ImageTypeProperties message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.ImageTypeProperties
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.ImageTypeProperties} ImageTypeProperties
                 */
                ImageTypeProperties.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.ImageTypeProperties)
                        return object;
                    let message = new $root.rv.data.Media.ImageTypeProperties();
                    if (object.drawing != null) {
                        if (typeof object.drawing !== "object")
                            throw TypeError(".rv.data.Media.ImageTypeProperties.drawing: object expected");
                        message.drawing = $root.rv.data.Media.DrawingProperties.fromObject(object.drawing);
                    }
                    if (object.file != null) {
                        if (typeof object.file !== "object")
                            throw TypeError(".rv.data.Media.ImageTypeProperties.file: object expected");
                        message.file = $root.rv.data.FileProperties.fromObject(object.file);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ImageTypeProperties message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.ImageTypeProperties
                 * @static
                 * @param {rv.data.Media.ImageTypeProperties} message ImageTypeProperties
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ImageTypeProperties.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.drawing = null;
                        object.file = null;
                    }
                    if (message.drawing != null && message.hasOwnProperty("drawing"))
                        object.drawing = $root.rv.data.Media.DrawingProperties.toObject(message.drawing, options);
                    if (message.file != null && message.hasOwnProperty("file"))
                        object.file = $root.rv.data.FileProperties.toObject(message.file, options);
                    return object;
                };

                /**
                 * Converts this ImageTypeProperties to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.ImageTypeProperties
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ImageTypeProperties.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ImageTypeProperties
                 * @function getTypeUrl
                 * @memberof rv.data.Media.ImageTypeProperties
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ImageTypeProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.ImageTypeProperties";
                };

                return ImageTypeProperties;
            })();

            Media.VideoTypeProperties = (function() {

                /**
                 * Properties of a VideoTypeProperties.
                 * @memberof rv.data.Media
                 * @interface IVideoTypeProperties
                 * @property {rv.data.Media.IDrawingProperties|null} [drawing] VideoTypeProperties drawing
                 * @property {rv.data.Media.IAudioProperties|null} [audio] VideoTypeProperties audio
                 * @property {rv.data.Media.ITransportProperties|null} [transport] VideoTypeProperties transport
                 * @property {rv.data.Media.IVideoProperties|null} [video] VideoTypeProperties video
                 * @property {rv.data.IFileProperties|null} [file] VideoTypeProperties file
                 */

                /**
                 * Constructs a new VideoTypeProperties.
                 * @memberof rv.data.Media
                 * @classdesc Represents a VideoTypeProperties.
                 * @implements IVideoTypeProperties
                 * @constructor
                 * @param {rv.data.Media.IVideoTypeProperties=} [properties] Properties to set
                 */
                function VideoTypeProperties(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * VideoTypeProperties drawing.
                 * @member {rv.data.Media.IDrawingProperties|null|undefined} drawing
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @instance
                 */
                VideoTypeProperties.prototype.drawing = null;

                /**
                 * VideoTypeProperties audio.
                 * @member {rv.data.Media.IAudioProperties|null|undefined} audio
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @instance
                 */
                VideoTypeProperties.prototype.audio = null;

                /**
                 * VideoTypeProperties transport.
                 * @member {rv.data.Media.ITransportProperties|null|undefined} transport
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @instance
                 */
                VideoTypeProperties.prototype.transport = null;

                /**
                 * VideoTypeProperties video.
                 * @member {rv.data.Media.IVideoProperties|null|undefined} video
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @instance
                 */
                VideoTypeProperties.prototype.video = null;

                /**
                 * VideoTypeProperties file.
                 * @member {rv.data.IFileProperties|null|undefined} file
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @instance
                 */
                VideoTypeProperties.prototype.file = null;

                /**
                 * Creates a new VideoTypeProperties instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @static
                 * @param {rv.data.Media.IVideoTypeProperties=} [properties] Properties to set
                 * @returns {rv.data.Media.VideoTypeProperties} VideoTypeProperties instance
                 */
                VideoTypeProperties.create = function create(properties) {
                    return new VideoTypeProperties(properties);
                };

                /**
                 * Encodes the specified VideoTypeProperties message. Does not implicitly {@link rv.data.Media.VideoTypeProperties.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @static
                 * @param {rv.data.Media.IVideoTypeProperties} message VideoTypeProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VideoTypeProperties.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.drawing != null && Object.hasOwnProperty.call(message, "drawing"))
                        $root.rv.data.Media.DrawingProperties.encode(message.drawing, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                        $root.rv.data.Media.AudioProperties.encode(message.audio, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.transport != null && Object.hasOwnProperty.call(message, "transport"))
                        $root.rv.data.Media.TransportProperties.encode(message.transport, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.video != null && Object.hasOwnProperty.call(message, "video"))
                        $root.rv.data.Media.VideoProperties.encode(message.video, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                        $root.rv.data.FileProperties.encode(message.file, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified VideoTypeProperties message, length delimited. Does not implicitly {@link rv.data.Media.VideoTypeProperties.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @static
                 * @param {rv.data.Media.IVideoTypeProperties} message VideoTypeProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VideoTypeProperties.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a VideoTypeProperties message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.VideoTypeProperties} VideoTypeProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VideoTypeProperties.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.VideoTypeProperties();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.drawing = $root.rv.data.Media.DrawingProperties.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.audio = $root.rv.data.Media.AudioProperties.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.transport = $root.rv.data.Media.TransportProperties.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.video = $root.rv.data.Media.VideoProperties.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.file = $root.rv.data.FileProperties.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a VideoTypeProperties message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.VideoTypeProperties} VideoTypeProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VideoTypeProperties.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a VideoTypeProperties message.
                 * @function verify
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                VideoTypeProperties.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.drawing != null && message.hasOwnProperty("drawing")) {
                        let error = $root.rv.data.Media.DrawingProperties.verify(message.drawing);
                        if (error)
                            return "drawing." + error;
                    }
                    if (message.audio != null && message.hasOwnProperty("audio")) {
                        let error = $root.rv.data.Media.AudioProperties.verify(message.audio);
                        if (error)
                            return "audio." + error;
                    }
                    if (message.transport != null && message.hasOwnProperty("transport")) {
                        let error = $root.rv.data.Media.TransportProperties.verify(message.transport);
                        if (error)
                            return "transport." + error;
                    }
                    if (message.video != null && message.hasOwnProperty("video")) {
                        let error = $root.rv.data.Media.VideoProperties.verify(message.video);
                        if (error)
                            return "video." + error;
                    }
                    if (message.file != null && message.hasOwnProperty("file")) {
                        let error = $root.rv.data.FileProperties.verify(message.file);
                        if (error)
                            return "file." + error;
                    }
                    return null;
                };

                /**
                 * Creates a VideoTypeProperties message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.VideoTypeProperties} VideoTypeProperties
                 */
                VideoTypeProperties.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.VideoTypeProperties)
                        return object;
                    let message = new $root.rv.data.Media.VideoTypeProperties();
                    if (object.drawing != null) {
                        if (typeof object.drawing !== "object")
                            throw TypeError(".rv.data.Media.VideoTypeProperties.drawing: object expected");
                        message.drawing = $root.rv.data.Media.DrawingProperties.fromObject(object.drawing);
                    }
                    if (object.audio != null) {
                        if (typeof object.audio !== "object")
                            throw TypeError(".rv.data.Media.VideoTypeProperties.audio: object expected");
                        message.audio = $root.rv.data.Media.AudioProperties.fromObject(object.audio);
                    }
                    if (object.transport != null) {
                        if (typeof object.transport !== "object")
                            throw TypeError(".rv.data.Media.VideoTypeProperties.transport: object expected");
                        message.transport = $root.rv.data.Media.TransportProperties.fromObject(object.transport);
                    }
                    if (object.video != null) {
                        if (typeof object.video !== "object")
                            throw TypeError(".rv.data.Media.VideoTypeProperties.video: object expected");
                        message.video = $root.rv.data.Media.VideoProperties.fromObject(object.video);
                    }
                    if (object.file != null) {
                        if (typeof object.file !== "object")
                            throw TypeError(".rv.data.Media.VideoTypeProperties.file: object expected");
                        message.file = $root.rv.data.FileProperties.fromObject(object.file);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a VideoTypeProperties message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @static
                 * @param {rv.data.Media.VideoTypeProperties} message VideoTypeProperties
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                VideoTypeProperties.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.drawing = null;
                        object.audio = null;
                        object.transport = null;
                        object.video = null;
                        object.file = null;
                    }
                    if (message.drawing != null && message.hasOwnProperty("drawing"))
                        object.drawing = $root.rv.data.Media.DrawingProperties.toObject(message.drawing, options);
                    if (message.audio != null && message.hasOwnProperty("audio"))
                        object.audio = $root.rv.data.Media.AudioProperties.toObject(message.audio, options);
                    if (message.transport != null && message.hasOwnProperty("transport"))
                        object.transport = $root.rv.data.Media.TransportProperties.toObject(message.transport, options);
                    if (message.video != null && message.hasOwnProperty("video"))
                        object.video = $root.rv.data.Media.VideoProperties.toObject(message.video, options);
                    if (message.file != null && message.hasOwnProperty("file"))
                        object.file = $root.rv.data.FileProperties.toObject(message.file, options);
                    return object;
                };

                /**
                 * Converts this VideoTypeProperties to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                VideoTypeProperties.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for VideoTypeProperties
                 * @function getTypeUrl
                 * @memberof rv.data.Media.VideoTypeProperties
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                VideoTypeProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.VideoTypeProperties";
                };

                return VideoTypeProperties;
            })();

            Media.LiveVideoTypeProperties = (function() {

                /**
                 * Properties of a LiveVideoTypeProperties.
                 * @memberof rv.data.Media
                 * @interface ILiveVideoTypeProperties
                 * @property {rv.data.Media.IDrawingProperties|null} [drawing] LiveVideoTypeProperties drawing
                 * @property {rv.data.Media.IAudioProperties|null} [audio] LiveVideoTypeProperties audio
                 * @property {rv.data.Media.ILiveVideoProperties|null} [liveVideo] LiveVideoTypeProperties liveVideo
                 */

                /**
                 * Constructs a new LiveVideoTypeProperties.
                 * @memberof rv.data.Media
                 * @classdesc Represents a LiveVideoTypeProperties.
                 * @implements ILiveVideoTypeProperties
                 * @constructor
                 * @param {rv.data.Media.ILiveVideoTypeProperties=} [properties] Properties to set
                 */
                function LiveVideoTypeProperties(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LiveVideoTypeProperties drawing.
                 * @member {rv.data.Media.IDrawingProperties|null|undefined} drawing
                 * @memberof rv.data.Media.LiveVideoTypeProperties
                 * @instance
                 */
                LiveVideoTypeProperties.prototype.drawing = null;

                /**
                 * LiveVideoTypeProperties audio.
                 * @member {rv.data.Media.IAudioProperties|null|undefined} audio
                 * @memberof rv.data.Media.LiveVideoTypeProperties
                 * @instance
                 */
                LiveVideoTypeProperties.prototype.audio = null;

                /**
                 * LiveVideoTypeProperties liveVideo.
                 * @member {rv.data.Media.ILiveVideoProperties|null|undefined} liveVideo
                 * @memberof rv.data.Media.LiveVideoTypeProperties
                 * @instance
                 */
                LiveVideoTypeProperties.prototype.liveVideo = null;

                /**
                 * Creates a new LiveVideoTypeProperties instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.LiveVideoTypeProperties
                 * @static
                 * @param {rv.data.Media.ILiveVideoTypeProperties=} [properties] Properties to set
                 * @returns {rv.data.Media.LiveVideoTypeProperties} LiveVideoTypeProperties instance
                 */
                LiveVideoTypeProperties.create = function create(properties) {
                    return new LiveVideoTypeProperties(properties);
                };

                /**
                 * Encodes the specified LiveVideoTypeProperties message. Does not implicitly {@link rv.data.Media.LiveVideoTypeProperties.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.LiveVideoTypeProperties
                 * @static
                 * @param {rv.data.Media.ILiveVideoTypeProperties} message LiveVideoTypeProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LiveVideoTypeProperties.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.drawing != null && Object.hasOwnProperty.call(message, "drawing"))
                        $root.rv.data.Media.DrawingProperties.encode(message.drawing, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                        $root.rv.data.Media.AudioProperties.encode(message.audio, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.liveVideo != null && Object.hasOwnProperty.call(message, "liveVideo"))
                        $root.rv.data.Media.LiveVideoProperties.encode(message.liveVideo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified LiveVideoTypeProperties message, length delimited. Does not implicitly {@link rv.data.Media.LiveVideoTypeProperties.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.LiveVideoTypeProperties
                 * @static
                 * @param {rv.data.Media.ILiveVideoTypeProperties} message LiveVideoTypeProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LiveVideoTypeProperties.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LiveVideoTypeProperties message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.LiveVideoTypeProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.LiveVideoTypeProperties} LiveVideoTypeProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LiveVideoTypeProperties.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.LiveVideoTypeProperties();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.drawing = $root.rv.data.Media.DrawingProperties.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.audio = $root.rv.data.Media.AudioProperties.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.liveVideo = $root.rv.data.Media.LiveVideoProperties.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LiveVideoTypeProperties message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.LiveVideoTypeProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.LiveVideoTypeProperties} LiveVideoTypeProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LiveVideoTypeProperties.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LiveVideoTypeProperties message.
                 * @function verify
                 * @memberof rv.data.Media.LiveVideoTypeProperties
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LiveVideoTypeProperties.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.drawing != null && message.hasOwnProperty("drawing")) {
                        let error = $root.rv.data.Media.DrawingProperties.verify(message.drawing);
                        if (error)
                            return "drawing." + error;
                    }
                    if (message.audio != null && message.hasOwnProperty("audio")) {
                        let error = $root.rv.data.Media.AudioProperties.verify(message.audio);
                        if (error)
                            return "audio." + error;
                    }
                    if (message.liveVideo != null && message.hasOwnProperty("liveVideo")) {
                        let error = $root.rv.data.Media.LiveVideoProperties.verify(message.liveVideo);
                        if (error)
                            return "liveVideo." + error;
                    }
                    return null;
                };

                /**
                 * Creates a LiveVideoTypeProperties message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.LiveVideoTypeProperties
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.LiveVideoTypeProperties} LiveVideoTypeProperties
                 */
                LiveVideoTypeProperties.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.LiveVideoTypeProperties)
                        return object;
                    let message = new $root.rv.data.Media.LiveVideoTypeProperties();
                    if (object.drawing != null) {
                        if (typeof object.drawing !== "object")
                            throw TypeError(".rv.data.Media.LiveVideoTypeProperties.drawing: object expected");
                        message.drawing = $root.rv.data.Media.DrawingProperties.fromObject(object.drawing);
                    }
                    if (object.audio != null) {
                        if (typeof object.audio !== "object")
                            throw TypeError(".rv.data.Media.LiveVideoTypeProperties.audio: object expected");
                        message.audio = $root.rv.data.Media.AudioProperties.fromObject(object.audio);
                    }
                    if (object.liveVideo != null) {
                        if (typeof object.liveVideo !== "object")
                            throw TypeError(".rv.data.Media.LiveVideoTypeProperties.liveVideo: object expected");
                        message.liveVideo = $root.rv.data.Media.LiveVideoProperties.fromObject(object.liveVideo);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a LiveVideoTypeProperties message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.LiveVideoTypeProperties
                 * @static
                 * @param {rv.data.Media.LiveVideoTypeProperties} message LiveVideoTypeProperties
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LiveVideoTypeProperties.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.drawing = null;
                        object.audio = null;
                        object.liveVideo = null;
                    }
                    if (message.drawing != null && message.hasOwnProperty("drawing"))
                        object.drawing = $root.rv.data.Media.DrawingProperties.toObject(message.drawing, options);
                    if (message.audio != null && message.hasOwnProperty("audio"))
                        object.audio = $root.rv.data.Media.AudioProperties.toObject(message.audio, options);
                    if (message.liveVideo != null && message.hasOwnProperty("liveVideo"))
                        object.liveVideo = $root.rv.data.Media.LiveVideoProperties.toObject(message.liveVideo, options);
                    return object;
                };

                /**
                 * Converts this LiveVideoTypeProperties to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.LiveVideoTypeProperties
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LiveVideoTypeProperties.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for LiveVideoTypeProperties
                 * @function getTypeUrl
                 * @memberof rv.data.Media.LiveVideoTypeProperties
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                LiveVideoTypeProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.LiveVideoTypeProperties";
                };

                return LiveVideoTypeProperties;
            })();

            Media.WebContentTypeProperties = (function() {

                /**
                 * Properties of a WebContentTypeProperties.
                 * @memberof rv.data.Media
                 * @interface IWebContentTypeProperties
                 * @property {rv.data.Media.IDrawingProperties|null} [drawing] WebContentTypeProperties drawing
                 * @property {rv.data.IURL|null} [url] WebContentTypeProperties url
                 */

                /**
                 * Constructs a new WebContentTypeProperties.
                 * @memberof rv.data.Media
                 * @classdesc Represents a WebContentTypeProperties.
                 * @implements IWebContentTypeProperties
                 * @constructor
                 * @param {rv.data.Media.IWebContentTypeProperties=} [properties] Properties to set
                 */
                function WebContentTypeProperties(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * WebContentTypeProperties drawing.
                 * @member {rv.data.Media.IDrawingProperties|null|undefined} drawing
                 * @memberof rv.data.Media.WebContentTypeProperties
                 * @instance
                 */
                WebContentTypeProperties.prototype.drawing = null;

                /**
                 * WebContentTypeProperties url.
                 * @member {rv.data.IURL|null|undefined} url
                 * @memberof rv.data.Media.WebContentTypeProperties
                 * @instance
                 */
                WebContentTypeProperties.prototype.url = null;

                /**
                 * Creates a new WebContentTypeProperties instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Media.WebContentTypeProperties
                 * @static
                 * @param {rv.data.Media.IWebContentTypeProperties=} [properties] Properties to set
                 * @returns {rv.data.Media.WebContentTypeProperties} WebContentTypeProperties instance
                 */
                WebContentTypeProperties.create = function create(properties) {
                    return new WebContentTypeProperties(properties);
                };

                /**
                 * Encodes the specified WebContentTypeProperties message. Does not implicitly {@link rv.data.Media.WebContentTypeProperties.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Media.WebContentTypeProperties
                 * @static
                 * @param {rv.data.Media.IWebContentTypeProperties} message WebContentTypeProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WebContentTypeProperties.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.drawing != null && Object.hasOwnProperty.call(message, "drawing"))
                        $root.rv.data.Media.DrawingProperties.encode(message.drawing, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                        $root.rv.data.URL.encode(message.url, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified WebContentTypeProperties message, length delimited. Does not implicitly {@link rv.data.Media.WebContentTypeProperties.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Media.WebContentTypeProperties
                 * @static
                 * @param {rv.data.Media.IWebContentTypeProperties} message WebContentTypeProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WebContentTypeProperties.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a WebContentTypeProperties message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Media.WebContentTypeProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Media.WebContentTypeProperties} WebContentTypeProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WebContentTypeProperties.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Media.WebContentTypeProperties();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.drawing = $root.rv.data.Media.DrawingProperties.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.url = $root.rv.data.URL.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a WebContentTypeProperties message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Media.WebContentTypeProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Media.WebContentTypeProperties} WebContentTypeProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WebContentTypeProperties.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a WebContentTypeProperties message.
                 * @function verify
                 * @memberof rv.data.Media.WebContentTypeProperties
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WebContentTypeProperties.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.drawing != null && message.hasOwnProperty("drawing")) {
                        let error = $root.rv.data.Media.DrawingProperties.verify(message.drawing);
                        if (error)
                            return "drawing." + error;
                    }
                    if (message.url != null && message.hasOwnProperty("url")) {
                        let error = $root.rv.data.URL.verify(message.url);
                        if (error)
                            return "url." + error;
                    }
                    return null;
                };

                /**
                 * Creates a WebContentTypeProperties message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Media.WebContentTypeProperties
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Media.WebContentTypeProperties} WebContentTypeProperties
                 */
                WebContentTypeProperties.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Media.WebContentTypeProperties)
                        return object;
                    let message = new $root.rv.data.Media.WebContentTypeProperties();
                    if (object.drawing != null) {
                        if (typeof object.drawing !== "object")
                            throw TypeError(".rv.data.Media.WebContentTypeProperties.drawing: object expected");
                        message.drawing = $root.rv.data.Media.DrawingProperties.fromObject(object.drawing);
                    }
                    if (object.url != null) {
                        if (typeof object.url !== "object")
                            throw TypeError(".rv.data.Media.WebContentTypeProperties.url: object expected");
                        message.url = $root.rv.data.URL.fromObject(object.url);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a WebContentTypeProperties message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Media.WebContentTypeProperties
                 * @static
                 * @param {rv.data.Media.WebContentTypeProperties} message WebContentTypeProperties
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                WebContentTypeProperties.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.drawing = null;
                        object.url = null;
                    }
                    if (message.drawing != null && message.hasOwnProperty("drawing"))
                        object.drawing = $root.rv.data.Media.DrawingProperties.toObject(message.drawing, options);
                    if (message.url != null && message.hasOwnProperty("url"))
                        object.url = $root.rv.data.URL.toObject(message.url, options);
                    return object;
                };

                /**
                 * Converts this WebContentTypeProperties to JSON.
                 * @function toJSON
                 * @memberof rv.data.Media.WebContentTypeProperties
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                WebContentTypeProperties.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for WebContentTypeProperties
                 * @function getTypeUrl
                 * @memberof rv.data.Media.WebContentTypeProperties
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                WebContentTypeProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Media.WebContentTypeProperties";
                };

                return WebContentTypeProperties;
            })();

            /**
             * ScaleBehavior enum.
             * @name rv.data.Media.ScaleBehavior
             * @enum {number}
             * @property {number} SCALE_BEHAVIOR_FIT=0 SCALE_BEHAVIOR_FIT value
             * @property {number} SCALE_BEHAVIOR_FILL=1 SCALE_BEHAVIOR_FILL value
             * @property {number} SCALE_BEHAVIOR_STRETCH=2 SCALE_BEHAVIOR_STRETCH value
             * @property {number} SCALE_BEHAVIOR_CUSTOM=3 SCALE_BEHAVIOR_CUSTOM value
             */
            Media.ScaleBehavior = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SCALE_BEHAVIOR_FIT"] = 0;
                values[valuesById[1] = "SCALE_BEHAVIOR_FILL"] = 1;
                values[valuesById[2] = "SCALE_BEHAVIOR_STRETCH"] = 2;
                values[valuesById[3] = "SCALE_BEHAVIOR_CUSTOM"] = 3;
                return values;
            })();

            /**
             * ScaleAlignment enum.
             * @name rv.data.Media.ScaleAlignment
             * @enum {number}
             * @property {number} SCALE_ALIGNMENT_MIDDLE_CENTER=0 SCALE_ALIGNMENT_MIDDLE_CENTER value
             * @property {number} SCALE_ALIGNMENT_TOP_LEFT=1 SCALE_ALIGNMENT_TOP_LEFT value
             * @property {number} SCALE_ALIGNMENT_TOP_CENTER=2 SCALE_ALIGNMENT_TOP_CENTER value
             * @property {number} SCALE_ALIGNMENT_TOP_RIGHT=3 SCALE_ALIGNMENT_TOP_RIGHT value
             * @property {number} SCALE_ALIGNMENT_MIDDLE_RIGHT=4 SCALE_ALIGNMENT_MIDDLE_RIGHT value
             * @property {number} SCALE_ALIGNMENT_BOTTOM_RIGHT=5 SCALE_ALIGNMENT_BOTTOM_RIGHT value
             * @property {number} SCALE_ALIGNMENT_BOTTOM_CENTER=6 SCALE_ALIGNMENT_BOTTOM_CENTER value
             * @property {number} SCALE_ALIGNMENT_BOTTOM_LEFT=7 SCALE_ALIGNMENT_BOTTOM_LEFT value
             * @property {number} SCALE_ALIGNMENT_MIDDLE_LEFT=8 SCALE_ALIGNMENT_MIDDLE_LEFT value
             */
            Media.ScaleAlignment = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SCALE_ALIGNMENT_MIDDLE_CENTER"] = 0;
                values[valuesById[1] = "SCALE_ALIGNMENT_TOP_LEFT"] = 1;
                values[valuesById[2] = "SCALE_ALIGNMENT_TOP_CENTER"] = 2;
                values[valuesById[3] = "SCALE_ALIGNMENT_TOP_RIGHT"] = 3;
                values[valuesById[4] = "SCALE_ALIGNMENT_MIDDLE_RIGHT"] = 4;
                values[valuesById[5] = "SCALE_ALIGNMENT_BOTTOM_RIGHT"] = 5;
                values[valuesById[6] = "SCALE_ALIGNMENT_BOTTOM_CENTER"] = 6;
                values[valuesById[7] = "SCALE_ALIGNMENT_BOTTOM_LEFT"] = 7;
                values[valuesById[8] = "SCALE_ALIGNMENT_MIDDLE_LEFT"] = 8;
                return values;
            })();

            return Media;
        })();

        /**
         * AlphaType enum.
         * @name rv.data.AlphaType
         * @enum {number}
         * @property {number} ALPHA_TYPE_UNKNOWN=0 ALPHA_TYPE_UNKNOWN value
         * @property {number} ALPHA_TYPE_STRAIGHT=1 ALPHA_TYPE_STRAIGHT value
         * @property {number} ALPHA_TYPE_PREMULTIPLIED=2 ALPHA_TYPE_PREMULTIPLIED value
         */
        data.AlphaType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ALPHA_TYPE_UNKNOWN"] = 0;
            values[valuesById[1] = "ALPHA_TYPE_STRAIGHT"] = 1;
            values[valuesById[2] = "ALPHA_TYPE_PREMULTIPLIED"] = 2;
            return values;
        })();

        data.DigitalAudio = (function() {

            /**
             * Properties of a DigitalAudio.
             * @memberof rv.data
             * @interface IDigitalAudio
             */

            /**
             * Constructs a new DigitalAudio.
             * @memberof rv.data
             * @classdesc Represents a DigitalAudio.
             * @implements IDigitalAudio
             * @constructor
             * @param {rv.data.IDigitalAudio=} [properties] Properties to set
             */
            function DigitalAudio(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DigitalAudio instance using the specified properties.
             * @function create
             * @memberof rv.data.DigitalAudio
             * @static
             * @param {rv.data.IDigitalAudio=} [properties] Properties to set
             * @returns {rv.data.DigitalAudio} DigitalAudio instance
             */
            DigitalAudio.create = function create(properties) {
                return new DigitalAudio(properties);
            };

            /**
             * Encodes the specified DigitalAudio message. Does not implicitly {@link rv.data.DigitalAudio.verify|verify} messages.
             * @function encode
             * @memberof rv.data.DigitalAudio
             * @static
             * @param {rv.data.IDigitalAudio} message DigitalAudio message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DigitalAudio.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DigitalAudio message, length delimited. Does not implicitly {@link rv.data.DigitalAudio.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.DigitalAudio
             * @static
             * @param {rv.data.IDigitalAudio} message DigitalAudio message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DigitalAudio.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DigitalAudio message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.DigitalAudio
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.DigitalAudio} DigitalAudio
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DigitalAudio.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.DigitalAudio();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DigitalAudio message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.DigitalAudio
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.DigitalAudio} DigitalAudio
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DigitalAudio.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DigitalAudio message.
             * @function verify
             * @memberof rv.data.DigitalAudio
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DigitalAudio.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DigitalAudio message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.DigitalAudio
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.DigitalAudio} DigitalAudio
             */
            DigitalAudio.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.DigitalAudio)
                    return object;
                return new $root.rv.data.DigitalAudio();
            };

            /**
             * Creates a plain object from a DigitalAudio message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.DigitalAudio
             * @static
             * @param {rv.data.DigitalAudio} message DigitalAudio
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DigitalAudio.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DigitalAudio to JSON.
             * @function toJSON
             * @memberof rv.data.DigitalAudio
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DigitalAudio.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DigitalAudio
             * @function getTypeUrl
             * @memberof rv.data.DigitalAudio
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DigitalAudio.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.DigitalAudio";
            };

            DigitalAudio.Setup = (function() {

                /**
                 * Properties of a Setup.
                 * @memberof rv.data.DigitalAudio
                 * @interface ISetup
                 * @property {Array.<rv.data.DigitalAudio.IBus>|null} [buses] Setup buses
                 * @property {rv.data.DigitalAudio.IDevice|null} [monitorDevice] Setup monitorDevice
                 * @property {rv.data.DigitalAudio.IDevice|null} [mainOutputDevice] Setup mainOutputDevice
                 * @property {boolean|null} [enableSdiNdiDevice] Setup enableSdiNdiDevice
                 * @property {rv.data.DigitalAudio.IDevice|null} [sdiNdiDevice] Setup sdiNdiDevice
                 * @property {boolean|null} [monitorOnMains] Setup monitorOnMains
                 * @property {boolean|null} [disableMainOutputDevice] Setup disableMainOutputDevice
                 */

                /**
                 * Constructs a new Setup.
                 * @memberof rv.data.DigitalAudio
                 * @classdesc Represents a Setup.
                 * @implements ISetup
                 * @constructor
                 * @param {rv.data.DigitalAudio.ISetup=} [properties] Properties to set
                 */
                function Setup(properties) {
                    this.buses = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Setup buses.
                 * @member {Array.<rv.data.DigitalAudio.IBus>} buses
                 * @memberof rv.data.DigitalAudio.Setup
                 * @instance
                 */
                Setup.prototype.buses = $util.emptyArray;

                /**
                 * Setup monitorDevice.
                 * @member {rv.data.DigitalAudio.IDevice|null|undefined} monitorDevice
                 * @memberof rv.data.DigitalAudio.Setup
                 * @instance
                 */
                Setup.prototype.monitorDevice = null;

                /**
                 * Setup mainOutputDevice.
                 * @member {rv.data.DigitalAudio.IDevice|null|undefined} mainOutputDevice
                 * @memberof rv.data.DigitalAudio.Setup
                 * @instance
                 */
                Setup.prototype.mainOutputDevice = null;

                /**
                 * Setup enableSdiNdiDevice.
                 * @member {boolean} enableSdiNdiDevice
                 * @memberof rv.data.DigitalAudio.Setup
                 * @instance
                 */
                Setup.prototype.enableSdiNdiDevice = false;

                /**
                 * Setup sdiNdiDevice.
                 * @member {rv.data.DigitalAudio.IDevice|null|undefined} sdiNdiDevice
                 * @memberof rv.data.DigitalAudio.Setup
                 * @instance
                 */
                Setup.prototype.sdiNdiDevice = null;

                /**
                 * Setup monitorOnMains.
                 * @member {boolean} monitorOnMains
                 * @memberof rv.data.DigitalAudio.Setup
                 * @instance
                 */
                Setup.prototype.monitorOnMains = false;

                /**
                 * Setup disableMainOutputDevice.
                 * @member {boolean} disableMainOutputDevice
                 * @memberof rv.data.DigitalAudio.Setup
                 * @instance
                 */
                Setup.prototype.disableMainOutputDevice = false;

                /**
                 * Creates a new Setup instance using the specified properties.
                 * @function create
                 * @memberof rv.data.DigitalAudio.Setup
                 * @static
                 * @param {rv.data.DigitalAudio.ISetup=} [properties] Properties to set
                 * @returns {rv.data.DigitalAudio.Setup} Setup instance
                 */
                Setup.create = function create(properties) {
                    return new Setup(properties);
                };

                /**
                 * Encodes the specified Setup message. Does not implicitly {@link rv.data.DigitalAudio.Setup.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.DigitalAudio.Setup
                 * @static
                 * @param {rv.data.DigitalAudio.ISetup} message Setup message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Setup.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.buses != null && message.buses.length)
                        for (let i = 0; i < message.buses.length; ++i)
                            $root.rv.data.DigitalAudio.Bus.encode(message.buses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.monitorDevice != null && Object.hasOwnProperty.call(message, "monitorDevice"))
                        $root.rv.data.DigitalAudio.Device.encode(message.monitorDevice, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.mainOutputDevice != null && Object.hasOwnProperty.call(message, "mainOutputDevice"))
                        $root.rv.data.DigitalAudio.Device.encode(message.mainOutputDevice, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enableSdiNdiDevice != null && Object.hasOwnProperty.call(message, "enableSdiNdiDevice"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.enableSdiNdiDevice);
                    if (message.sdiNdiDevice != null && Object.hasOwnProperty.call(message, "sdiNdiDevice"))
                        $root.rv.data.DigitalAudio.Device.encode(message.sdiNdiDevice, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.monitorOnMains != null && Object.hasOwnProperty.call(message, "monitorOnMains"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.monitorOnMains);
                    if (message.disableMainOutputDevice != null && Object.hasOwnProperty.call(message, "disableMainOutputDevice"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.disableMainOutputDevice);
                    return writer;
                };

                /**
                 * Encodes the specified Setup message, length delimited. Does not implicitly {@link rv.data.DigitalAudio.Setup.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.DigitalAudio.Setup
                 * @static
                 * @param {rv.data.DigitalAudio.ISetup} message Setup message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Setup.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Setup message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.DigitalAudio.Setup
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.DigitalAudio.Setup} Setup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Setup.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.DigitalAudio.Setup();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.buses && message.buses.length))
                                    message.buses = [];
                                message.buses.push($root.rv.data.DigitalAudio.Bus.decode(reader, reader.uint32()));
                                break;
                            }
                        case 2: {
                                message.monitorDevice = $root.rv.data.DigitalAudio.Device.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.mainOutputDevice = $root.rv.data.DigitalAudio.Device.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.enableSdiNdiDevice = reader.bool();
                                break;
                            }
                        case 5: {
                                message.sdiNdiDevice = $root.rv.data.DigitalAudio.Device.decode(reader, reader.uint32());
                                break;
                            }
                        case 6: {
                                message.monitorOnMains = reader.bool();
                                break;
                            }
                        case 7: {
                                message.disableMainOutputDevice = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Setup message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.DigitalAudio.Setup
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.DigitalAudio.Setup} Setup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Setup.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Setup message.
                 * @function verify
                 * @memberof rv.data.DigitalAudio.Setup
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Setup.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.buses != null && message.hasOwnProperty("buses")) {
                        if (!Array.isArray(message.buses))
                            return "buses: array expected";
                        for (let i = 0; i < message.buses.length; ++i) {
                            let error = $root.rv.data.DigitalAudio.Bus.verify(message.buses[i]);
                            if (error)
                                return "buses." + error;
                        }
                    }
                    if (message.monitorDevice != null && message.hasOwnProperty("monitorDevice")) {
                        let error = $root.rv.data.DigitalAudio.Device.verify(message.monitorDevice);
                        if (error)
                            return "monitorDevice." + error;
                    }
                    if (message.mainOutputDevice != null && message.hasOwnProperty("mainOutputDevice")) {
                        let error = $root.rv.data.DigitalAudio.Device.verify(message.mainOutputDevice);
                        if (error)
                            return "mainOutputDevice." + error;
                    }
                    if (message.enableSdiNdiDevice != null && message.hasOwnProperty("enableSdiNdiDevice"))
                        if (typeof message.enableSdiNdiDevice !== "boolean")
                            return "enableSdiNdiDevice: boolean expected";
                    if (message.sdiNdiDevice != null && message.hasOwnProperty("sdiNdiDevice")) {
                        let error = $root.rv.data.DigitalAudio.Device.verify(message.sdiNdiDevice);
                        if (error)
                            return "sdiNdiDevice." + error;
                    }
                    if (message.monitorOnMains != null && message.hasOwnProperty("monitorOnMains"))
                        if (typeof message.monitorOnMains !== "boolean")
                            return "monitorOnMains: boolean expected";
                    if (message.disableMainOutputDevice != null && message.hasOwnProperty("disableMainOutputDevice"))
                        if (typeof message.disableMainOutputDevice !== "boolean")
                            return "disableMainOutputDevice: boolean expected";
                    return null;
                };

                /**
                 * Creates a Setup message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.DigitalAudio.Setup
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.DigitalAudio.Setup} Setup
                 */
                Setup.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.DigitalAudio.Setup)
                        return object;
                    let message = new $root.rv.data.DigitalAudio.Setup();
                    if (object.buses) {
                        if (!Array.isArray(object.buses))
                            throw TypeError(".rv.data.DigitalAudio.Setup.buses: array expected");
                        message.buses = [];
                        for (let i = 0; i < object.buses.length; ++i) {
                            if (typeof object.buses[i] !== "object")
                                throw TypeError(".rv.data.DigitalAudio.Setup.buses: object expected");
                            message.buses[i] = $root.rv.data.DigitalAudio.Bus.fromObject(object.buses[i]);
                        }
                    }
                    if (object.monitorDevice != null) {
                        if (typeof object.monitorDevice !== "object")
                            throw TypeError(".rv.data.DigitalAudio.Setup.monitorDevice: object expected");
                        message.monitorDevice = $root.rv.data.DigitalAudio.Device.fromObject(object.monitorDevice);
                    }
                    if (object.mainOutputDevice != null) {
                        if (typeof object.mainOutputDevice !== "object")
                            throw TypeError(".rv.data.DigitalAudio.Setup.mainOutputDevice: object expected");
                        message.mainOutputDevice = $root.rv.data.DigitalAudio.Device.fromObject(object.mainOutputDevice);
                    }
                    if (object.enableSdiNdiDevice != null)
                        message.enableSdiNdiDevice = Boolean(object.enableSdiNdiDevice);
                    if (object.sdiNdiDevice != null) {
                        if (typeof object.sdiNdiDevice !== "object")
                            throw TypeError(".rv.data.DigitalAudio.Setup.sdiNdiDevice: object expected");
                        message.sdiNdiDevice = $root.rv.data.DigitalAudio.Device.fromObject(object.sdiNdiDevice);
                    }
                    if (object.monitorOnMains != null)
                        message.monitorOnMains = Boolean(object.monitorOnMains);
                    if (object.disableMainOutputDevice != null)
                        message.disableMainOutputDevice = Boolean(object.disableMainOutputDevice);
                    return message;
                };

                /**
                 * Creates a plain object from a Setup message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.DigitalAudio.Setup
                 * @static
                 * @param {rv.data.DigitalAudio.Setup} message Setup
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Setup.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.buses = [];
                    if (options.defaults) {
                        object.monitorDevice = null;
                        object.mainOutputDevice = null;
                        object.enableSdiNdiDevice = false;
                        object.sdiNdiDevice = null;
                        object.monitorOnMains = false;
                        object.disableMainOutputDevice = false;
                    }
                    if (message.buses && message.buses.length) {
                        object.buses = [];
                        for (let j = 0; j < message.buses.length; ++j)
                            object.buses[j] = $root.rv.data.DigitalAudio.Bus.toObject(message.buses[j], options);
                    }
                    if (message.monitorDevice != null && message.hasOwnProperty("monitorDevice"))
                        object.monitorDevice = $root.rv.data.DigitalAudio.Device.toObject(message.monitorDevice, options);
                    if (message.mainOutputDevice != null && message.hasOwnProperty("mainOutputDevice"))
                        object.mainOutputDevice = $root.rv.data.DigitalAudio.Device.toObject(message.mainOutputDevice, options);
                    if (message.enableSdiNdiDevice != null && message.hasOwnProperty("enableSdiNdiDevice"))
                        object.enableSdiNdiDevice = message.enableSdiNdiDevice;
                    if (message.sdiNdiDevice != null && message.hasOwnProperty("sdiNdiDevice"))
                        object.sdiNdiDevice = $root.rv.data.DigitalAudio.Device.toObject(message.sdiNdiDevice, options);
                    if (message.monitorOnMains != null && message.hasOwnProperty("monitorOnMains"))
                        object.monitorOnMains = message.monitorOnMains;
                    if (message.disableMainOutputDevice != null && message.hasOwnProperty("disableMainOutputDevice"))
                        object.disableMainOutputDevice = message.disableMainOutputDevice;
                    return object;
                };

                /**
                 * Converts this Setup to JSON.
                 * @function toJSON
                 * @memberof rv.data.DigitalAudio.Setup
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Setup.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Setup
                 * @function getTypeUrl
                 * @memberof rv.data.DigitalAudio.Setup
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Setup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.DigitalAudio.Setup";
                };

                return Setup;
            })();

            DigitalAudio.Bus = (function() {

                /**
                 * Properties of a Bus.
                 * @memberof rv.data.DigitalAudio
                 * @interface IBus
                 * @property {string|null} [name] Bus name
                 * @property {boolean|null} [muted] Bus muted
                 * @property {boolean|null} [solo] Bus solo
                 * @property {boolean|null} [testTone] Bus testTone
                 * @property {number|null} [masterLevel] Bus masterLevel
                 */

                /**
                 * Constructs a new Bus.
                 * @memberof rv.data.DigitalAudio
                 * @classdesc Represents a Bus.
                 * @implements IBus
                 * @constructor
                 * @param {rv.data.DigitalAudio.IBus=} [properties] Properties to set
                 */
                function Bus(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Bus name.
                 * @member {string} name
                 * @memberof rv.data.DigitalAudio.Bus
                 * @instance
                 */
                Bus.prototype.name = "";

                /**
                 * Bus muted.
                 * @member {boolean} muted
                 * @memberof rv.data.DigitalAudio.Bus
                 * @instance
                 */
                Bus.prototype.muted = false;

                /**
                 * Bus solo.
                 * @member {boolean} solo
                 * @memberof rv.data.DigitalAudio.Bus
                 * @instance
                 */
                Bus.prototype.solo = false;

                /**
                 * Bus testTone.
                 * @member {boolean} testTone
                 * @memberof rv.data.DigitalAudio.Bus
                 * @instance
                 */
                Bus.prototype.testTone = false;

                /**
                 * Bus masterLevel.
                 * @member {number} masterLevel
                 * @memberof rv.data.DigitalAudio.Bus
                 * @instance
                 */
                Bus.prototype.masterLevel = 0;

                /**
                 * Creates a new Bus instance using the specified properties.
                 * @function create
                 * @memberof rv.data.DigitalAudio.Bus
                 * @static
                 * @param {rv.data.DigitalAudio.IBus=} [properties] Properties to set
                 * @returns {rv.data.DigitalAudio.Bus} Bus instance
                 */
                Bus.create = function create(properties) {
                    return new Bus(properties);
                };

                /**
                 * Encodes the specified Bus message. Does not implicitly {@link rv.data.DigitalAudio.Bus.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.DigitalAudio.Bus
                 * @static
                 * @param {rv.data.DigitalAudio.IBus} message Bus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Bus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.muted != null && Object.hasOwnProperty.call(message, "muted"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.muted);
                    if (message.solo != null && Object.hasOwnProperty.call(message, "solo"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.solo);
                    if (message.testTone != null && Object.hasOwnProperty.call(message, "testTone"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.testTone);
                    if (message.masterLevel != null && Object.hasOwnProperty.call(message, "masterLevel"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.masterLevel);
                    return writer;
                };

                /**
                 * Encodes the specified Bus message, length delimited. Does not implicitly {@link rv.data.DigitalAudio.Bus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.DigitalAudio.Bus
                 * @static
                 * @param {rv.data.DigitalAudio.IBus} message Bus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Bus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Bus message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.DigitalAudio.Bus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.DigitalAudio.Bus} Bus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Bus.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.DigitalAudio.Bus();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.muted = reader.bool();
                                break;
                            }
                        case 3: {
                                message.solo = reader.bool();
                                break;
                            }
                        case 4: {
                                message.testTone = reader.bool();
                                break;
                            }
                        case 5: {
                                message.masterLevel = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Bus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.DigitalAudio.Bus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.DigitalAudio.Bus} Bus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Bus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Bus message.
                 * @function verify
                 * @memberof rv.data.DigitalAudio.Bus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Bus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.muted != null && message.hasOwnProperty("muted"))
                        if (typeof message.muted !== "boolean")
                            return "muted: boolean expected";
                    if (message.solo != null && message.hasOwnProperty("solo"))
                        if (typeof message.solo !== "boolean")
                            return "solo: boolean expected";
                    if (message.testTone != null && message.hasOwnProperty("testTone"))
                        if (typeof message.testTone !== "boolean")
                            return "testTone: boolean expected";
                    if (message.masterLevel != null && message.hasOwnProperty("masterLevel"))
                        if (typeof message.masterLevel !== "number")
                            return "masterLevel: number expected";
                    return null;
                };

                /**
                 * Creates a Bus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.DigitalAudio.Bus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.DigitalAudio.Bus} Bus
                 */
                Bus.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.DigitalAudio.Bus)
                        return object;
                    let message = new $root.rv.data.DigitalAudio.Bus();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.muted != null)
                        message.muted = Boolean(object.muted);
                    if (object.solo != null)
                        message.solo = Boolean(object.solo);
                    if (object.testTone != null)
                        message.testTone = Boolean(object.testTone);
                    if (object.masterLevel != null)
                        message.masterLevel = Number(object.masterLevel);
                    return message;
                };

                /**
                 * Creates a plain object from a Bus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.DigitalAudio.Bus
                 * @static
                 * @param {rv.data.DigitalAudio.Bus} message Bus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Bus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.muted = false;
                        object.solo = false;
                        object.testTone = false;
                        object.masterLevel = 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.muted != null && message.hasOwnProperty("muted"))
                        object.muted = message.muted;
                    if (message.solo != null && message.hasOwnProperty("solo"))
                        object.solo = message.solo;
                    if (message.testTone != null && message.hasOwnProperty("testTone"))
                        object.testTone = message.testTone;
                    if (message.masterLevel != null && message.hasOwnProperty("masterLevel"))
                        object.masterLevel = options.json && !isFinite(message.masterLevel) ? String(message.masterLevel) : message.masterLevel;
                    return object;
                };

                /**
                 * Converts this Bus to JSON.
                 * @function toJSON
                 * @memberof rv.data.DigitalAudio.Bus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Bus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Bus
                 * @function getTypeUrl
                 * @memberof rv.data.DigitalAudio.Bus
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Bus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.DigitalAudio.Bus";
                };

                return Bus;
            })();

            DigitalAudio.Device = (function() {

                /**
                 * Properties of a Device.
                 * @memberof rv.data.DigitalAudio
                 * @interface IDevice
                 * @property {string|null} [name] Device name
                 * @property {string|null} [renderID] Device renderID
                 * @property {Array.<rv.data.DigitalAudio.Device.IFormat>|null} [formats] Device formats
                 * @property {rv.data.DigitalAudio.Device.IRouting|null} [routing] Device routing
                 */

                /**
                 * Constructs a new Device.
                 * @memberof rv.data.DigitalAudio
                 * @classdesc Represents a Device.
                 * @implements IDevice
                 * @constructor
                 * @param {rv.data.DigitalAudio.IDevice=} [properties] Properties to set
                 */
                function Device(properties) {
                    this.formats = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Device name.
                 * @member {string} name
                 * @memberof rv.data.DigitalAudio.Device
                 * @instance
                 */
                Device.prototype.name = "";

                /**
                 * Device renderID.
                 * @member {string} renderID
                 * @memberof rv.data.DigitalAudio.Device
                 * @instance
                 */
                Device.prototype.renderID = "";

                /**
                 * Device formats.
                 * @member {Array.<rv.data.DigitalAudio.Device.IFormat>} formats
                 * @memberof rv.data.DigitalAudio.Device
                 * @instance
                 */
                Device.prototype.formats = $util.emptyArray;

                /**
                 * Device routing.
                 * @member {rv.data.DigitalAudio.Device.IRouting|null|undefined} routing
                 * @memberof rv.data.DigitalAudio.Device
                 * @instance
                 */
                Device.prototype.routing = null;

                /**
                 * Creates a new Device instance using the specified properties.
                 * @function create
                 * @memberof rv.data.DigitalAudio.Device
                 * @static
                 * @param {rv.data.DigitalAudio.IDevice=} [properties] Properties to set
                 * @returns {rv.data.DigitalAudio.Device} Device instance
                 */
                Device.create = function create(properties) {
                    return new Device(properties);
                };

                /**
                 * Encodes the specified Device message. Does not implicitly {@link rv.data.DigitalAudio.Device.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.DigitalAudio.Device
                 * @static
                 * @param {rv.data.DigitalAudio.IDevice} message Device message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Device.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.renderID != null && Object.hasOwnProperty.call(message, "renderID"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.renderID);
                    if (message.formats != null && message.formats.length)
                        for (let i = 0; i < message.formats.length; ++i)
                            $root.rv.data.DigitalAudio.Device.Format.encode(message.formats[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.routing != null && Object.hasOwnProperty.call(message, "routing"))
                        $root.rv.data.DigitalAudio.Device.Routing.encode(message.routing, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Device message, length delimited. Does not implicitly {@link rv.data.DigitalAudio.Device.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.DigitalAudio.Device
                 * @static
                 * @param {rv.data.DigitalAudio.IDevice} message Device message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Device.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Device message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.DigitalAudio.Device
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.DigitalAudio.Device} Device
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Device.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.DigitalAudio.Device();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.renderID = reader.string();
                                break;
                            }
                        case 3: {
                                if (!(message.formats && message.formats.length))
                                    message.formats = [];
                                message.formats.push($root.rv.data.DigitalAudio.Device.Format.decode(reader, reader.uint32()));
                                break;
                            }
                        case 4: {
                                message.routing = $root.rv.data.DigitalAudio.Device.Routing.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Device message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.DigitalAudio.Device
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.DigitalAudio.Device} Device
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Device.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Device message.
                 * @function verify
                 * @memberof rv.data.DigitalAudio.Device
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Device.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.renderID != null && message.hasOwnProperty("renderID"))
                        if (!$util.isString(message.renderID))
                            return "renderID: string expected";
                    if (message.formats != null && message.hasOwnProperty("formats")) {
                        if (!Array.isArray(message.formats))
                            return "formats: array expected";
                        for (let i = 0; i < message.formats.length; ++i) {
                            let error = $root.rv.data.DigitalAudio.Device.Format.verify(message.formats[i]);
                            if (error)
                                return "formats." + error;
                        }
                    }
                    if (message.routing != null && message.hasOwnProperty("routing")) {
                        let error = $root.rv.data.DigitalAudio.Device.Routing.verify(message.routing);
                        if (error)
                            return "routing." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Device message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.DigitalAudio.Device
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.DigitalAudio.Device} Device
                 */
                Device.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.DigitalAudio.Device)
                        return object;
                    let message = new $root.rv.data.DigitalAudio.Device();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.renderID != null)
                        message.renderID = String(object.renderID);
                    if (object.formats) {
                        if (!Array.isArray(object.formats))
                            throw TypeError(".rv.data.DigitalAudio.Device.formats: array expected");
                        message.formats = [];
                        for (let i = 0; i < object.formats.length; ++i) {
                            if (typeof object.formats[i] !== "object")
                                throw TypeError(".rv.data.DigitalAudio.Device.formats: object expected");
                            message.formats[i] = $root.rv.data.DigitalAudio.Device.Format.fromObject(object.formats[i]);
                        }
                    }
                    if (object.routing != null) {
                        if (typeof object.routing !== "object")
                            throw TypeError(".rv.data.DigitalAudio.Device.routing: object expected");
                        message.routing = $root.rv.data.DigitalAudio.Device.Routing.fromObject(object.routing);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Device message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.DigitalAudio.Device
                 * @static
                 * @param {rv.data.DigitalAudio.Device} message Device
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Device.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.formats = [];
                    if (options.defaults) {
                        object.name = "";
                        object.renderID = "";
                        object.routing = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.renderID != null && message.hasOwnProperty("renderID"))
                        object.renderID = message.renderID;
                    if (message.formats && message.formats.length) {
                        object.formats = [];
                        for (let j = 0; j < message.formats.length; ++j)
                            object.formats[j] = $root.rv.data.DigitalAudio.Device.Format.toObject(message.formats[j], options);
                    }
                    if (message.routing != null && message.hasOwnProperty("routing"))
                        object.routing = $root.rv.data.DigitalAudio.Device.Routing.toObject(message.routing, options);
                    return object;
                };

                /**
                 * Converts this Device to JSON.
                 * @function toJSON
                 * @memberof rv.data.DigitalAudio.Device
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Device.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Device
                 * @function getTypeUrl
                 * @memberof rv.data.DigitalAudio.Device
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Device.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.DigitalAudio.Device";
                };

                Device.Format = (function() {

                    /**
                     * Properties of a Format.
                     * @memberof rv.data.DigitalAudio.Device
                     * @interface IFormat
                     * @property {number|null} [sampleRate] Format sampleRate
                     * @property {number|null} [bitDepth] Format bitDepth
                     * @property {rv.data.DigitalAudio.Device.Format.Type|null} [type] Format type
                     */

                    /**
                     * Constructs a new Format.
                     * @memberof rv.data.DigitalAudio.Device
                     * @classdesc Represents a Format.
                     * @implements IFormat
                     * @constructor
                     * @param {rv.data.DigitalAudio.Device.IFormat=} [properties] Properties to set
                     */
                    function Format(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Format sampleRate.
                     * @member {number} sampleRate
                     * @memberof rv.data.DigitalAudio.Device.Format
                     * @instance
                     */
                    Format.prototype.sampleRate = 0;

                    /**
                     * Format bitDepth.
                     * @member {number} bitDepth
                     * @memberof rv.data.DigitalAudio.Device.Format
                     * @instance
                     */
                    Format.prototype.bitDepth = 0;

                    /**
                     * Format type.
                     * @member {rv.data.DigitalAudio.Device.Format.Type} type
                     * @memberof rv.data.DigitalAudio.Device.Format
                     * @instance
                     */
                    Format.prototype.type = 0;

                    /**
                     * Creates a new Format instance using the specified properties.
                     * @function create
                     * @memberof rv.data.DigitalAudio.Device.Format
                     * @static
                     * @param {rv.data.DigitalAudio.Device.IFormat=} [properties] Properties to set
                     * @returns {rv.data.DigitalAudio.Device.Format} Format instance
                     */
                    Format.create = function create(properties) {
                        return new Format(properties);
                    };

                    /**
                     * Encodes the specified Format message. Does not implicitly {@link rv.data.DigitalAudio.Device.Format.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.DigitalAudio.Device.Format
                     * @static
                     * @param {rv.data.DigitalAudio.Device.IFormat} message Format message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Format.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.sampleRate != null && Object.hasOwnProperty.call(message, "sampleRate"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sampleRate);
                        if (message.bitDepth != null && Object.hasOwnProperty.call(message, "bitDepth"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.bitDepth);
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                        return writer;
                    };

                    /**
                     * Encodes the specified Format message, length delimited. Does not implicitly {@link rv.data.DigitalAudio.Device.Format.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.DigitalAudio.Device.Format
                     * @static
                     * @param {rv.data.DigitalAudio.Device.IFormat} message Format message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Format.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Format message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.DigitalAudio.Device.Format
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.DigitalAudio.Device.Format} Format
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Format.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.DigitalAudio.Device.Format();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.sampleRate = reader.uint32();
                                    break;
                                }
                            case 2: {
                                    message.bitDepth = reader.uint32();
                                    break;
                                }
                            case 3: {
                                    message.type = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Format message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.DigitalAudio.Device.Format
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.DigitalAudio.Device.Format} Format
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Format.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Format message.
                     * @function verify
                     * @memberof rv.data.DigitalAudio.Device.Format
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Format.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                            if (!$util.isInteger(message.sampleRate))
                                return "sampleRate: integer expected";
                        if (message.bitDepth != null && message.hasOwnProperty("bitDepth"))
                            if (!$util.isInteger(message.bitDepth))
                                return "bitDepth: integer expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            switch (message.type) {
                            default:
                                return "type: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a Format message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.DigitalAudio.Device.Format
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.DigitalAudio.Device.Format} Format
                     */
                    Format.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.DigitalAudio.Device.Format)
                            return object;
                        let message = new $root.rv.data.DigitalAudio.Device.Format();
                        if (object.sampleRate != null)
                            message.sampleRate = object.sampleRate >>> 0;
                        if (object.bitDepth != null)
                            message.bitDepth = object.bitDepth >>> 0;
                        switch (object.type) {
                        default:
                            if (typeof object.type === "number") {
                                message.type = object.type;
                                break;
                            }
                            break;
                        case "TYPE_INT":
                        case 0:
                            message.type = 0;
                            break;
                        case "TYPE_FLOAT":
                        case 1:
                            message.type = 1;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Format message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.DigitalAudio.Device.Format
                     * @static
                     * @param {rv.data.DigitalAudio.Device.Format} message Format
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Format.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.sampleRate = 0;
                            object.bitDepth = 0;
                            object.type = options.enums === String ? "TYPE_INT" : 0;
                        }
                        if (message.sampleRate != null && message.hasOwnProperty("sampleRate"))
                            object.sampleRate = message.sampleRate;
                        if (message.bitDepth != null && message.hasOwnProperty("bitDepth"))
                            object.bitDepth = message.bitDepth;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = options.enums === String ? $root.rv.data.DigitalAudio.Device.Format.Type[message.type] === undefined ? message.type : $root.rv.data.DigitalAudio.Device.Format.Type[message.type] : message.type;
                        return object;
                    };

                    /**
                     * Converts this Format to JSON.
                     * @function toJSON
                     * @memberof rv.data.DigitalAudio.Device.Format
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Format.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Format
                     * @function getTypeUrl
                     * @memberof rv.data.DigitalAudio.Device.Format
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Format.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.DigitalAudio.Device.Format";
                    };

                    /**
                     * Type enum.
                     * @name rv.data.DigitalAudio.Device.Format.Type
                     * @enum {number}
                     * @property {number} TYPE_INT=0 TYPE_INT value
                     * @property {number} TYPE_FLOAT=1 TYPE_FLOAT value
                     */
                    Format.Type = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "TYPE_INT"] = 0;
                        values[valuesById[1] = "TYPE_FLOAT"] = 1;
                        return values;
                    })();

                    return Format;
                })();

                Device.Map = (function() {

                    /**
                     * Properties of a Map.
                     * @memberof rv.data.DigitalAudio.Device
                     * @interface IMap
                     * @property {number|null} [channelIndex] Map channelIndex
                     * @property {Array.<number>|null} [mappedIndices] Map mappedIndices
                     */

                    /**
                     * Constructs a new Map.
                     * @memberof rv.data.DigitalAudio.Device
                     * @classdesc Represents a Map.
                     * @implements IMap
                     * @constructor
                     * @param {rv.data.DigitalAudio.Device.IMap=} [properties] Properties to set
                     */
                    function Map(properties) {
                        this.mappedIndices = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Map channelIndex.
                     * @member {number} channelIndex
                     * @memberof rv.data.DigitalAudio.Device.Map
                     * @instance
                     */
                    Map.prototype.channelIndex = 0;

                    /**
                     * Map mappedIndices.
                     * @member {Array.<number>} mappedIndices
                     * @memberof rv.data.DigitalAudio.Device.Map
                     * @instance
                     */
                    Map.prototype.mappedIndices = $util.emptyArray;

                    /**
                     * Creates a new Map instance using the specified properties.
                     * @function create
                     * @memberof rv.data.DigitalAudio.Device.Map
                     * @static
                     * @param {rv.data.DigitalAudio.Device.IMap=} [properties] Properties to set
                     * @returns {rv.data.DigitalAudio.Device.Map} Map instance
                     */
                    Map.create = function create(properties) {
                        return new Map(properties);
                    };

                    /**
                     * Encodes the specified Map message. Does not implicitly {@link rv.data.DigitalAudio.Device.Map.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.DigitalAudio.Device.Map
                     * @static
                     * @param {rv.data.DigitalAudio.Device.IMap} message Map message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Map.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.channelIndex != null && Object.hasOwnProperty.call(message, "channelIndex"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.channelIndex);
                        if (message.mappedIndices != null && message.mappedIndices.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (let i = 0; i < message.mappedIndices.length; ++i)
                                writer.uint32(message.mappedIndices[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };

                    /**
                     * Encodes the specified Map message, length delimited. Does not implicitly {@link rv.data.DigitalAudio.Device.Map.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.DigitalAudio.Device.Map
                     * @static
                     * @param {rv.data.DigitalAudio.Device.IMap} message Map message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Map.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Map message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.DigitalAudio.Device.Map
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.DigitalAudio.Device.Map} Map
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Map.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.DigitalAudio.Device.Map();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.channelIndex = reader.uint32();
                                    break;
                                }
                            case 2: {
                                    if (!(message.mappedIndices && message.mappedIndices.length))
                                        message.mappedIndices = [];
                                    if ((tag & 7) === 2) {
                                        let end2 = reader.uint32() + reader.pos;
                                        while (reader.pos < end2)
                                            message.mappedIndices.push(reader.uint32());
                                    } else
                                        message.mappedIndices.push(reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Map message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.DigitalAudio.Device.Map
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.DigitalAudio.Device.Map} Map
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Map.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Map message.
                     * @function verify
                     * @memberof rv.data.DigitalAudio.Device.Map
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Map.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.channelIndex != null && message.hasOwnProperty("channelIndex"))
                            if (!$util.isInteger(message.channelIndex))
                                return "channelIndex: integer expected";
                        if (message.mappedIndices != null && message.hasOwnProperty("mappedIndices")) {
                            if (!Array.isArray(message.mappedIndices))
                                return "mappedIndices: array expected";
                            for (let i = 0; i < message.mappedIndices.length; ++i)
                                if (!$util.isInteger(message.mappedIndices[i]))
                                    return "mappedIndices: integer[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Map message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.DigitalAudio.Device.Map
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.DigitalAudio.Device.Map} Map
                     */
                    Map.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.DigitalAudio.Device.Map)
                            return object;
                        let message = new $root.rv.data.DigitalAudio.Device.Map();
                        if (object.channelIndex != null)
                            message.channelIndex = object.channelIndex >>> 0;
                        if (object.mappedIndices) {
                            if (!Array.isArray(object.mappedIndices))
                                throw TypeError(".rv.data.DigitalAudio.Device.Map.mappedIndices: array expected");
                            message.mappedIndices = [];
                            for (let i = 0; i < object.mappedIndices.length; ++i)
                                message.mappedIndices[i] = object.mappedIndices[i] >>> 0;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Map message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.DigitalAudio.Device.Map
                     * @static
                     * @param {rv.data.DigitalAudio.Device.Map} message Map
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Map.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.mappedIndices = [];
                        if (options.defaults)
                            object.channelIndex = 0;
                        if (message.channelIndex != null && message.hasOwnProperty("channelIndex"))
                            object.channelIndex = message.channelIndex;
                        if (message.mappedIndices && message.mappedIndices.length) {
                            object.mappedIndices = [];
                            for (let j = 0; j < message.mappedIndices.length; ++j)
                                object.mappedIndices[j] = message.mappedIndices[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this Map to JSON.
                     * @function toJSON
                     * @memberof rv.data.DigitalAudio.Device.Map
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Map.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Map
                     * @function getTypeUrl
                     * @memberof rv.data.DigitalAudio.Device.Map
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Map.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.DigitalAudio.Device.Map";
                    };

                    return Map;
                })();

                Device.Channel = (function() {

                    /**
                     * Properties of a Channel.
                     * @memberof rv.data.DigitalAudio.Device
                     * @interface IChannel
                     * @property {boolean|null} [muteEnable] Channel muteEnable
                     * @property {boolean|null} [soloEnable] Channel soloEnable
                     * @property {boolean|null} [toneEnable] Channel toneEnable
                     * @property {number|null} [audioDelay] Channel audioDelay
                     * @property {number|null} [level] Channel level
                     */

                    /**
                     * Constructs a new Channel.
                     * @memberof rv.data.DigitalAudio.Device
                     * @classdesc Represents a Channel.
                     * @implements IChannel
                     * @constructor
                     * @param {rv.data.DigitalAudio.Device.IChannel=} [properties] Properties to set
                     */
                    function Channel(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Channel muteEnable.
                     * @member {boolean} muteEnable
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @instance
                     */
                    Channel.prototype.muteEnable = false;

                    /**
                     * Channel soloEnable.
                     * @member {boolean} soloEnable
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @instance
                     */
                    Channel.prototype.soloEnable = false;

                    /**
                     * Channel toneEnable.
                     * @member {boolean} toneEnable
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @instance
                     */
                    Channel.prototype.toneEnable = false;

                    /**
                     * Channel audioDelay.
                     * @member {number} audioDelay
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @instance
                     */
                    Channel.prototype.audioDelay = 0;

                    /**
                     * Channel level.
                     * @member {number} level
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @instance
                     */
                    Channel.prototype.level = 0;

                    /**
                     * Creates a new Channel instance using the specified properties.
                     * @function create
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @static
                     * @param {rv.data.DigitalAudio.Device.IChannel=} [properties] Properties to set
                     * @returns {rv.data.DigitalAudio.Device.Channel} Channel instance
                     */
                    Channel.create = function create(properties) {
                        return new Channel(properties);
                    };

                    /**
                     * Encodes the specified Channel message. Does not implicitly {@link rv.data.DigitalAudio.Device.Channel.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @static
                     * @param {rv.data.DigitalAudio.Device.IChannel} message Channel message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Channel.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.muteEnable != null && Object.hasOwnProperty.call(message, "muteEnable"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.muteEnable);
                        if (message.soloEnable != null && Object.hasOwnProperty.call(message, "soloEnable"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.soloEnable);
                        if (message.toneEnable != null && Object.hasOwnProperty.call(message, "toneEnable"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.toneEnable);
                        if (message.audioDelay != null && Object.hasOwnProperty.call(message, "audioDelay"))
                            writer.uint32(/* id 4, wireType 1 =*/33).double(message.audioDelay);
                        if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                            writer.uint32(/* id 5, wireType 1 =*/41).double(message.level);
                        return writer;
                    };

                    /**
                     * Encodes the specified Channel message, length delimited. Does not implicitly {@link rv.data.DigitalAudio.Device.Channel.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @static
                     * @param {rv.data.DigitalAudio.Device.IChannel} message Channel message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Channel.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Channel message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.DigitalAudio.Device.Channel} Channel
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Channel.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.DigitalAudio.Device.Channel();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.muteEnable = reader.bool();
                                    break;
                                }
                            case 2: {
                                    message.soloEnable = reader.bool();
                                    break;
                                }
                            case 3: {
                                    message.toneEnable = reader.bool();
                                    break;
                                }
                            case 4: {
                                    message.audioDelay = reader.double();
                                    break;
                                }
                            case 5: {
                                    message.level = reader.double();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Channel message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.DigitalAudio.Device.Channel} Channel
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Channel.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Channel message.
                     * @function verify
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Channel.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.muteEnable != null && message.hasOwnProperty("muteEnable"))
                            if (typeof message.muteEnable !== "boolean")
                                return "muteEnable: boolean expected";
                        if (message.soloEnable != null && message.hasOwnProperty("soloEnable"))
                            if (typeof message.soloEnable !== "boolean")
                                return "soloEnable: boolean expected";
                        if (message.toneEnable != null && message.hasOwnProperty("toneEnable"))
                            if (typeof message.toneEnable !== "boolean")
                                return "toneEnable: boolean expected";
                        if (message.audioDelay != null && message.hasOwnProperty("audioDelay"))
                            if (typeof message.audioDelay !== "number")
                                return "audioDelay: number expected";
                        if (message.level != null && message.hasOwnProperty("level"))
                            if (typeof message.level !== "number")
                                return "level: number expected";
                        return null;
                    };

                    /**
                     * Creates a Channel message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.DigitalAudio.Device.Channel} Channel
                     */
                    Channel.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.DigitalAudio.Device.Channel)
                            return object;
                        let message = new $root.rv.data.DigitalAudio.Device.Channel();
                        if (object.muteEnable != null)
                            message.muteEnable = Boolean(object.muteEnable);
                        if (object.soloEnable != null)
                            message.soloEnable = Boolean(object.soloEnable);
                        if (object.toneEnable != null)
                            message.toneEnable = Boolean(object.toneEnable);
                        if (object.audioDelay != null)
                            message.audioDelay = Number(object.audioDelay);
                        if (object.level != null)
                            message.level = Number(object.level);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Channel message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @static
                     * @param {rv.data.DigitalAudio.Device.Channel} message Channel
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Channel.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.muteEnable = false;
                            object.soloEnable = false;
                            object.toneEnable = false;
                            object.audioDelay = 0;
                            object.level = 0;
                        }
                        if (message.muteEnable != null && message.hasOwnProperty("muteEnable"))
                            object.muteEnable = message.muteEnable;
                        if (message.soloEnable != null && message.hasOwnProperty("soloEnable"))
                            object.soloEnable = message.soloEnable;
                        if (message.toneEnable != null && message.hasOwnProperty("toneEnable"))
                            object.toneEnable = message.toneEnable;
                        if (message.audioDelay != null && message.hasOwnProperty("audioDelay"))
                            object.audioDelay = options.json && !isFinite(message.audioDelay) ? String(message.audioDelay) : message.audioDelay;
                        if (message.level != null && message.hasOwnProperty("level"))
                            object.level = options.json && !isFinite(message.level) ? String(message.level) : message.level;
                        return object;
                    };

                    /**
                     * Converts this Channel to JSON.
                     * @function toJSON
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Channel.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Channel
                     * @function getTypeUrl
                     * @memberof rv.data.DigitalAudio.Device.Channel
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Channel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.DigitalAudio.Device.Channel";
                    };

                    return Channel;
                })();

                Device.Routing = (function() {

                    /**
                     * Properties of a Routing.
                     * @memberof rv.data.DigitalAudio.Device
                     * @interface IRouting
                     * @property {Array.<rv.data.DigitalAudio.Device.IChannel>|null} [channels] Routing channels
                     * @property {Array.<rv.data.DigitalAudio.Device.IMap>|null} [map] Routing map
                     * @property {boolean|null} [isCustomMap] Routing isCustomMap
                     * @property {rv.data.DigitalAudio.Device.IChannel|null} [masterChannel] Routing masterChannel
                     */

                    /**
                     * Constructs a new Routing.
                     * @memberof rv.data.DigitalAudio.Device
                     * @classdesc Represents a Routing.
                     * @implements IRouting
                     * @constructor
                     * @param {rv.data.DigitalAudio.Device.IRouting=} [properties] Properties to set
                     */
                    function Routing(properties) {
                        this.channels = [];
                        this.map = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Routing channels.
                     * @member {Array.<rv.data.DigitalAudio.Device.IChannel>} channels
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @instance
                     */
                    Routing.prototype.channels = $util.emptyArray;

                    /**
                     * Routing map.
                     * @member {Array.<rv.data.DigitalAudio.Device.IMap>} map
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @instance
                     */
                    Routing.prototype.map = $util.emptyArray;

                    /**
                     * Routing isCustomMap.
                     * @member {boolean} isCustomMap
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @instance
                     */
                    Routing.prototype.isCustomMap = false;

                    /**
                     * Routing masterChannel.
                     * @member {rv.data.DigitalAudio.Device.IChannel|null|undefined} masterChannel
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @instance
                     */
                    Routing.prototype.masterChannel = null;

                    /**
                     * Creates a new Routing instance using the specified properties.
                     * @function create
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @static
                     * @param {rv.data.DigitalAudio.Device.IRouting=} [properties] Properties to set
                     * @returns {rv.data.DigitalAudio.Device.Routing} Routing instance
                     */
                    Routing.create = function create(properties) {
                        return new Routing(properties);
                    };

                    /**
                     * Encodes the specified Routing message. Does not implicitly {@link rv.data.DigitalAudio.Device.Routing.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @static
                     * @param {rv.data.DigitalAudio.Device.IRouting} message Routing message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Routing.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.channels != null && message.channels.length)
                            for (let i = 0; i < message.channels.length; ++i)
                                $root.rv.data.DigitalAudio.Device.Channel.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.map != null && message.map.length)
                            for (let i = 0; i < message.map.length; ++i)
                                $root.rv.data.DigitalAudio.Device.Map.encode(message.map[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.isCustomMap != null && Object.hasOwnProperty.call(message, "isCustomMap"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isCustomMap);
                        if (message.masterChannel != null && Object.hasOwnProperty.call(message, "masterChannel"))
                            $root.rv.data.DigitalAudio.Device.Channel.encode(message.masterChannel, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Routing message, length delimited. Does not implicitly {@link rv.data.DigitalAudio.Device.Routing.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @static
                     * @param {rv.data.DigitalAudio.Device.IRouting} message Routing message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Routing.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Routing message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.DigitalAudio.Device.Routing} Routing
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Routing.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.DigitalAudio.Device.Routing();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.channels && message.channels.length))
                                        message.channels = [];
                                    message.channels.push($root.rv.data.DigitalAudio.Device.Channel.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 2: {
                                    if (!(message.map && message.map.length))
                                        message.map = [];
                                    message.map.push($root.rv.data.DigitalAudio.Device.Map.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 3: {
                                    message.isCustomMap = reader.bool();
                                    break;
                                }
                            case 4: {
                                    message.masterChannel = $root.rv.data.DigitalAudio.Device.Channel.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Routing message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.DigitalAudio.Device.Routing} Routing
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Routing.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Routing message.
                     * @function verify
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Routing.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.channels != null && message.hasOwnProperty("channels")) {
                            if (!Array.isArray(message.channels))
                                return "channels: array expected";
                            for (let i = 0; i < message.channels.length; ++i) {
                                let error = $root.rv.data.DigitalAudio.Device.Channel.verify(message.channels[i]);
                                if (error)
                                    return "channels." + error;
                            }
                        }
                        if (message.map != null && message.hasOwnProperty("map")) {
                            if (!Array.isArray(message.map))
                                return "map: array expected";
                            for (let i = 0; i < message.map.length; ++i) {
                                let error = $root.rv.data.DigitalAudio.Device.Map.verify(message.map[i]);
                                if (error)
                                    return "map." + error;
                            }
                        }
                        if (message.isCustomMap != null && message.hasOwnProperty("isCustomMap"))
                            if (typeof message.isCustomMap !== "boolean")
                                return "isCustomMap: boolean expected";
                        if (message.masterChannel != null && message.hasOwnProperty("masterChannel")) {
                            let error = $root.rv.data.DigitalAudio.Device.Channel.verify(message.masterChannel);
                            if (error)
                                return "masterChannel." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Routing message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.DigitalAudio.Device.Routing} Routing
                     */
                    Routing.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.DigitalAudio.Device.Routing)
                            return object;
                        let message = new $root.rv.data.DigitalAudio.Device.Routing();
                        if (object.channels) {
                            if (!Array.isArray(object.channels))
                                throw TypeError(".rv.data.DigitalAudio.Device.Routing.channels: array expected");
                            message.channels = [];
                            for (let i = 0; i < object.channels.length; ++i) {
                                if (typeof object.channels[i] !== "object")
                                    throw TypeError(".rv.data.DigitalAudio.Device.Routing.channels: object expected");
                                message.channels[i] = $root.rv.data.DigitalAudio.Device.Channel.fromObject(object.channels[i]);
                            }
                        }
                        if (object.map) {
                            if (!Array.isArray(object.map))
                                throw TypeError(".rv.data.DigitalAudio.Device.Routing.map: array expected");
                            message.map = [];
                            for (let i = 0; i < object.map.length; ++i) {
                                if (typeof object.map[i] !== "object")
                                    throw TypeError(".rv.data.DigitalAudio.Device.Routing.map: object expected");
                                message.map[i] = $root.rv.data.DigitalAudio.Device.Map.fromObject(object.map[i]);
                            }
                        }
                        if (object.isCustomMap != null)
                            message.isCustomMap = Boolean(object.isCustomMap);
                        if (object.masterChannel != null) {
                            if (typeof object.masterChannel !== "object")
                                throw TypeError(".rv.data.DigitalAudio.Device.Routing.masterChannel: object expected");
                            message.masterChannel = $root.rv.data.DigitalAudio.Device.Channel.fromObject(object.masterChannel);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Routing message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @static
                     * @param {rv.data.DigitalAudio.Device.Routing} message Routing
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Routing.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object.channels = [];
                            object.map = [];
                        }
                        if (options.defaults) {
                            object.isCustomMap = false;
                            object.masterChannel = null;
                        }
                        if (message.channels && message.channels.length) {
                            object.channels = [];
                            for (let j = 0; j < message.channels.length; ++j)
                                object.channels[j] = $root.rv.data.DigitalAudio.Device.Channel.toObject(message.channels[j], options);
                        }
                        if (message.map && message.map.length) {
                            object.map = [];
                            for (let j = 0; j < message.map.length; ++j)
                                object.map[j] = $root.rv.data.DigitalAudio.Device.Map.toObject(message.map[j], options);
                        }
                        if (message.isCustomMap != null && message.hasOwnProperty("isCustomMap"))
                            object.isCustomMap = message.isCustomMap;
                        if (message.masterChannel != null && message.hasOwnProperty("masterChannel"))
                            object.masterChannel = $root.rv.data.DigitalAudio.Device.Channel.toObject(message.masterChannel, options);
                        return object;
                    };

                    /**
                     * Converts this Routing to JSON.
                     * @function toJSON
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Routing.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Routing
                     * @function getTypeUrl
                     * @memberof rv.data.DigitalAudio.Device.Routing
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Routing.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.DigitalAudio.Device.Routing";
                    };

                    return Routing;
                })();

                return Device;
            })();

            return DigitalAudio;
        })();

        data.Effect = (function() {

            /**
             * Properties of an Effect.
             * @memberof rv.data
             * @interface IEffect
             * @property {rv.data.IUUID|null} [uuid] Effect uuid
             * @property {boolean|null} [enabled] Effect enabled
             * @property {string|null} [name] Effect name
             * @property {string|null} [renderId] Effect renderId
             * @property {string|null} [behaviorDescription] Effect behaviorDescription
             * @property {string|null} [category] Effect category
             * @property {Array.<rv.data.Effect.IEffectVariable>|null} [variables] Effect variables
             */

            /**
             * Constructs a new Effect.
             * @memberof rv.data
             * @classdesc Represents an Effect.
             * @implements IEffect
             * @constructor
             * @param {rv.data.IEffect=} [properties] Properties to set
             */
            function Effect(properties) {
                this.variables = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Effect uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.Effect
             * @instance
             */
            Effect.prototype.uuid = null;

            /**
             * Effect enabled.
             * @member {boolean} enabled
             * @memberof rv.data.Effect
             * @instance
             */
            Effect.prototype.enabled = false;

            /**
             * Effect name.
             * @member {string} name
             * @memberof rv.data.Effect
             * @instance
             */
            Effect.prototype.name = "";

            /**
             * Effect renderId.
             * @member {string} renderId
             * @memberof rv.data.Effect
             * @instance
             */
            Effect.prototype.renderId = "";

            /**
             * Effect behaviorDescription.
             * @member {string} behaviorDescription
             * @memberof rv.data.Effect
             * @instance
             */
            Effect.prototype.behaviorDescription = "";

            /**
             * Effect category.
             * @member {string} category
             * @memberof rv.data.Effect
             * @instance
             */
            Effect.prototype.category = "";

            /**
             * Effect variables.
             * @member {Array.<rv.data.Effect.IEffectVariable>} variables
             * @memberof rv.data.Effect
             * @instance
             */
            Effect.prototype.variables = $util.emptyArray;

            /**
             * Creates a new Effect instance using the specified properties.
             * @function create
             * @memberof rv.data.Effect
             * @static
             * @param {rv.data.IEffect=} [properties] Properties to set
             * @returns {rv.data.Effect} Effect instance
             */
            Effect.create = function create(properties) {
                return new Effect(properties);
            };

            /**
             * Encodes the specified Effect message. Does not implicitly {@link rv.data.Effect.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Effect
             * @static
             * @param {rv.data.IEffect} message Effect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Effect.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                if (message.renderId != null && Object.hasOwnProperty.call(message, "renderId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.renderId);
                if (message.behaviorDescription != null && Object.hasOwnProperty.call(message, "behaviorDescription"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.behaviorDescription);
                if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.category);
                if (message.variables != null && message.variables.length)
                    for (let i = 0; i < message.variables.length; ++i)
                        $root.rv.data.Effect.EffectVariable.encode(message.variables[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Effect message, length delimited. Does not implicitly {@link rv.data.Effect.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Effect
             * @static
             * @param {rv.data.IEffect} message Effect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Effect.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Effect message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Effect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Effect} Effect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Effect.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Effect();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.enabled = reader.bool();
                            break;
                        }
                    case 3: {
                            message.name = reader.string();
                            break;
                        }
                    case 4: {
                            message.renderId = reader.string();
                            break;
                        }
                    case 5: {
                            message.behaviorDescription = reader.string();
                            break;
                        }
                    case 6: {
                            message.category = reader.string();
                            break;
                        }
                    case 7: {
                            if (!(message.variables && message.variables.length))
                                message.variables = [];
                            message.variables.push($root.rv.data.Effect.EffectVariable.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Effect message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Effect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Effect} Effect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Effect.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Effect message.
             * @function verify
             * @memberof rv.data.Effect
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Effect.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    if (typeof message.enabled !== "boolean")
                        return "enabled: boolean expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.renderId != null && message.hasOwnProperty("renderId"))
                    if (!$util.isString(message.renderId))
                        return "renderId: string expected";
                if (message.behaviorDescription != null && message.hasOwnProperty("behaviorDescription"))
                    if (!$util.isString(message.behaviorDescription))
                        return "behaviorDescription: string expected";
                if (message.category != null && message.hasOwnProperty("category"))
                    if (!$util.isString(message.category))
                        return "category: string expected";
                if (message.variables != null && message.hasOwnProperty("variables")) {
                    if (!Array.isArray(message.variables))
                        return "variables: array expected";
                    for (let i = 0; i < message.variables.length; ++i) {
                        let error = $root.rv.data.Effect.EffectVariable.verify(message.variables[i]);
                        if (error)
                            return "variables." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Effect message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Effect
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Effect} Effect
             */
            Effect.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Effect)
                    return object;
                let message = new $root.rv.data.Effect();
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.Effect.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                if (object.enabled != null)
                    message.enabled = Boolean(object.enabled);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.renderId != null)
                    message.renderId = String(object.renderId);
                if (object.behaviorDescription != null)
                    message.behaviorDescription = String(object.behaviorDescription);
                if (object.category != null)
                    message.category = String(object.category);
                if (object.variables) {
                    if (!Array.isArray(object.variables))
                        throw TypeError(".rv.data.Effect.variables: array expected");
                    message.variables = [];
                    for (let i = 0; i < object.variables.length; ++i) {
                        if (typeof object.variables[i] !== "object")
                            throw TypeError(".rv.data.Effect.variables: object expected");
                        message.variables[i] = $root.rv.data.Effect.EffectVariable.fromObject(object.variables[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Effect message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Effect
             * @static
             * @param {rv.data.Effect} message Effect
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Effect.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.variables = [];
                if (options.defaults) {
                    object.uuid = null;
                    object.enabled = false;
                    object.name = "";
                    object.renderId = "";
                    object.behaviorDescription = "";
                    object.category = "";
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    object.enabled = message.enabled;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.renderId != null && message.hasOwnProperty("renderId"))
                    object.renderId = message.renderId;
                if (message.behaviorDescription != null && message.hasOwnProperty("behaviorDescription"))
                    object.behaviorDescription = message.behaviorDescription;
                if (message.category != null && message.hasOwnProperty("category"))
                    object.category = message.category;
                if (message.variables && message.variables.length) {
                    object.variables = [];
                    for (let j = 0; j < message.variables.length; ++j)
                        object.variables[j] = $root.rv.data.Effect.EffectVariable.toObject(message.variables[j], options);
                }
                return object;
            };

            /**
             * Converts this Effect to JSON.
             * @function toJSON
             * @memberof rv.data.Effect
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Effect.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Effect
             * @function getTypeUrl
             * @memberof rv.data.Effect
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Effect.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Effect";
            };

            Effect.EffectVariable = (function() {

                /**
                 * Properties of an EffectVariable.
                 * @memberof rv.data.Effect
                 * @interface IEffectVariable
                 * @property {string|null} [name] EffectVariable name
                 * @property {string|null} [description] EffectVariable description
                 * @property {rv.data.Effect.EffectVariable.IEffectInt|null} [int] EffectVariable int
                 * @property {rv.data.Effect.EffectVariable.IEffectFloat|null} [float] EffectVariable float
                 * @property {rv.data.Effect.EffectVariable.IEffectColor|null} [color] EffectVariable color
                 * @property {rv.data.Effect.EffectVariable.IEffectDirection|null} [direction] EffectVariable direction
                 * @property {rv.data.Effect.EffectVariable.IEffectDouble|null} [double] EffectVariable double
                 */

                /**
                 * Constructs a new EffectVariable.
                 * @memberof rv.data.Effect
                 * @classdesc Represents an EffectVariable.
                 * @implements IEffectVariable
                 * @constructor
                 * @param {rv.data.Effect.IEffectVariable=} [properties] Properties to set
                 */
                function EffectVariable(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EffectVariable name.
                 * @member {string} name
                 * @memberof rv.data.Effect.EffectVariable
                 * @instance
                 */
                EffectVariable.prototype.name = "";

                /**
                 * EffectVariable description.
                 * @member {string} description
                 * @memberof rv.data.Effect.EffectVariable
                 * @instance
                 */
                EffectVariable.prototype.description = "";

                /**
                 * EffectVariable int.
                 * @member {rv.data.Effect.EffectVariable.IEffectInt|null|undefined} int
                 * @memberof rv.data.Effect.EffectVariable
                 * @instance
                 */
                EffectVariable.prototype.int = null;

                /**
                 * EffectVariable float.
                 * @member {rv.data.Effect.EffectVariable.IEffectFloat|null|undefined} float
                 * @memberof rv.data.Effect.EffectVariable
                 * @instance
                 */
                EffectVariable.prototype.float = null;

                /**
                 * EffectVariable color.
                 * @member {rv.data.Effect.EffectVariable.IEffectColor|null|undefined} color
                 * @memberof rv.data.Effect.EffectVariable
                 * @instance
                 */
                EffectVariable.prototype.color = null;

                /**
                 * EffectVariable direction.
                 * @member {rv.data.Effect.EffectVariable.IEffectDirection|null|undefined} direction
                 * @memberof rv.data.Effect.EffectVariable
                 * @instance
                 */
                EffectVariable.prototype.direction = null;

                /**
                 * EffectVariable double.
                 * @member {rv.data.Effect.EffectVariable.IEffectDouble|null|undefined} double
                 * @memberof rv.data.Effect.EffectVariable
                 * @instance
                 */
                EffectVariable.prototype.double = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * EffectVariable Type.
                 * @member {"int"|"float"|"color"|"direction"|"double"|undefined} Type
                 * @memberof rv.data.Effect.EffectVariable
                 * @instance
                 */
                Object.defineProperty(EffectVariable.prototype, "Type", {
                    get: $util.oneOfGetter($oneOfFields = ["int", "float", "color", "direction", "double"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new EffectVariable instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Effect.EffectVariable
                 * @static
                 * @param {rv.data.Effect.IEffectVariable=} [properties] Properties to set
                 * @returns {rv.data.Effect.EffectVariable} EffectVariable instance
                 */
                EffectVariable.create = function create(properties) {
                    return new EffectVariable(properties);
                };

                /**
                 * Encodes the specified EffectVariable message. Does not implicitly {@link rv.data.Effect.EffectVariable.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Effect.EffectVariable
                 * @static
                 * @param {rv.data.Effect.IEffectVariable} message EffectVariable message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EffectVariable.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                    if (message.int != null && Object.hasOwnProperty.call(message, "int"))
                        $root.rv.data.Effect.EffectVariable.EffectInt.encode(message.int, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.float != null && Object.hasOwnProperty.call(message, "float"))
                        $root.rv.data.Effect.EffectVariable.EffectFloat.encode(message.float, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                        $root.rv.data.Effect.EffectVariable.EffectColor.encode(message.color, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                        $root.rv.data.Effect.EffectVariable.EffectDirection.encode(message.direction, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.double != null && Object.hasOwnProperty.call(message, "double"))
                        $root.rv.data.Effect.EffectVariable.EffectDouble.encode(message.double, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified EffectVariable message, length delimited. Does not implicitly {@link rv.data.Effect.EffectVariable.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Effect.EffectVariable
                 * @static
                 * @param {rv.data.Effect.IEffectVariable} message EffectVariable message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EffectVariable.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EffectVariable message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Effect.EffectVariable
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Effect.EffectVariable} EffectVariable
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EffectVariable.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Effect.EffectVariable();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.description = reader.string();
                                break;
                            }
                        case 3: {
                                message.int = $root.rv.data.Effect.EffectVariable.EffectInt.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.float = $root.rv.data.Effect.EffectVariable.EffectFloat.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.color = $root.rv.data.Effect.EffectVariable.EffectColor.decode(reader, reader.uint32());
                                break;
                            }
                        case 6: {
                                message.direction = $root.rv.data.Effect.EffectVariable.EffectDirection.decode(reader, reader.uint32());
                                break;
                            }
                        case 7: {
                                message.double = $root.rv.data.Effect.EffectVariable.EffectDouble.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EffectVariable message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Effect.EffectVariable
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Effect.EffectVariable} EffectVariable
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EffectVariable.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EffectVariable message.
                 * @function verify
                 * @memberof rv.data.Effect.EffectVariable
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EffectVariable.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.int != null && message.hasOwnProperty("int")) {
                        properties.Type = 1;
                        {
                            let error = $root.rv.data.Effect.EffectVariable.EffectInt.verify(message.int);
                            if (error)
                                return "int." + error;
                        }
                    }
                    if (message.float != null && message.hasOwnProperty("float")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            let error = $root.rv.data.Effect.EffectVariable.EffectFloat.verify(message.float);
                            if (error)
                                return "float." + error;
                        }
                    }
                    if (message.color != null && message.hasOwnProperty("color")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            let error = $root.rv.data.Effect.EffectVariable.EffectColor.verify(message.color);
                            if (error)
                                return "color." + error;
                        }
                    }
                    if (message.direction != null && message.hasOwnProperty("direction")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            let error = $root.rv.data.Effect.EffectVariable.EffectDirection.verify(message.direction);
                            if (error)
                                return "direction." + error;
                        }
                    }
                    if (message.double != null && message.hasOwnProperty("double")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            let error = $root.rv.data.Effect.EffectVariable.EffectDouble.verify(message.double);
                            if (error)
                                return "double." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an EffectVariable message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Effect.EffectVariable
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Effect.EffectVariable} EffectVariable
                 */
                EffectVariable.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Effect.EffectVariable)
                        return object;
                    let message = new $root.rv.data.Effect.EffectVariable();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.int != null) {
                        if (typeof object.int !== "object")
                            throw TypeError(".rv.data.Effect.EffectVariable.int: object expected");
                        message.int = $root.rv.data.Effect.EffectVariable.EffectInt.fromObject(object.int);
                    }
                    if (object.float != null) {
                        if (typeof object.float !== "object")
                            throw TypeError(".rv.data.Effect.EffectVariable.float: object expected");
                        message.float = $root.rv.data.Effect.EffectVariable.EffectFloat.fromObject(object.float);
                    }
                    if (object.color != null) {
                        if (typeof object.color !== "object")
                            throw TypeError(".rv.data.Effect.EffectVariable.color: object expected");
                        message.color = $root.rv.data.Effect.EffectVariable.EffectColor.fromObject(object.color);
                    }
                    if (object.direction != null) {
                        if (typeof object.direction !== "object")
                            throw TypeError(".rv.data.Effect.EffectVariable.direction: object expected");
                        message.direction = $root.rv.data.Effect.EffectVariable.EffectDirection.fromObject(object.direction);
                    }
                    if (object.double != null) {
                        if (typeof object.double !== "object")
                            throw TypeError(".rv.data.Effect.EffectVariable.double: object expected");
                        message.double = $root.rv.data.Effect.EffectVariable.EffectDouble.fromObject(object.double);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an EffectVariable message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Effect.EffectVariable
                 * @static
                 * @param {rv.data.Effect.EffectVariable} message EffectVariable
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EffectVariable.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.description = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.int != null && message.hasOwnProperty("int")) {
                        object.int = $root.rv.data.Effect.EffectVariable.EffectInt.toObject(message.int, options);
                        if (options.oneofs)
                            object.Type = "int";
                    }
                    if (message.float != null && message.hasOwnProperty("float")) {
                        object.float = $root.rv.data.Effect.EffectVariable.EffectFloat.toObject(message.float, options);
                        if (options.oneofs)
                            object.Type = "float";
                    }
                    if (message.color != null && message.hasOwnProperty("color")) {
                        object.color = $root.rv.data.Effect.EffectVariable.EffectColor.toObject(message.color, options);
                        if (options.oneofs)
                            object.Type = "color";
                    }
                    if (message.direction != null && message.hasOwnProperty("direction")) {
                        object.direction = $root.rv.data.Effect.EffectVariable.EffectDirection.toObject(message.direction, options);
                        if (options.oneofs)
                            object.Type = "direction";
                    }
                    if (message.double != null && message.hasOwnProperty("double")) {
                        object.double = $root.rv.data.Effect.EffectVariable.EffectDouble.toObject(message.double, options);
                        if (options.oneofs)
                            object.Type = "double";
                    }
                    return object;
                };

                /**
                 * Converts this EffectVariable to JSON.
                 * @function toJSON
                 * @memberof rv.data.Effect.EffectVariable
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EffectVariable.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for EffectVariable
                 * @function getTypeUrl
                 * @memberof rv.data.Effect.EffectVariable
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EffectVariable.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Effect.EffectVariable";
                };

                EffectVariable.EffectInt = (function() {

                    /**
                     * Properties of an EffectInt.
                     * @memberof rv.data.Effect.EffectVariable
                     * @interface IEffectInt
                     * @property {number|null} [value] EffectInt value
                     * @property {number|null} [defaultValue] EffectInt defaultValue
                     * @property {number|null} [min] EffectInt min
                     * @property {number|null} [max] EffectInt max
                     */

                    /**
                     * Constructs a new EffectInt.
                     * @memberof rv.data.Effect.EffectVariable
                     * @classdesc Represents an EffectInt.
                     * @implements IEffectInt
                     * @constructor
                     * @param {rv.data.Effect.EffectVariable.IEffectInt=} [properties] Properties to set
                     */
                    function EffectInt(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * EffectInt value.
                     * @member {number} value
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @instance
                     */
                    EffectInt.prototype.value = 0;

                    /**
                     * EffectInt defaultValue.
                     * @member {number} defaultValue
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @instance
                     */
                    EffectInt.prototype.defaultValue = 0;

                    /**
                     * EffectInt min.
                     * @member {number} min
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @instance
                     */
                    EffectInt.prototype.min = 0;

                    /**
                     * EffectInt max.
                     * @member {number} max
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @instance
                     */
                    EffectInt.prototype.max = 0;

                    /**
                     * Creates a new EffectInt instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectInt=} [properties] Properties to set
                     * @returns {rv.data.Effect.EffectVariable.EffectInt} EffectInt instance
                     */
                    EffectInt.create = function create(properties) {
                        return new EffectInt(properties);
                    };

                    /**
                     * Encodes the specified EffectInt message. Does not implicitly {@link rv.data.Effect.EffectVariable.EffectInt.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectInt} message EffectInt message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EffectInt.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
                        if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.defaultValue);
                        if (message.min != null && Object.hasOwnProperty.call(message, "min"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.min);
                        if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.max);
                        return writer;
                    };

                    /**
                     * Encodes the specified EffectInt message, length delimited. Does not implicitly {@link rv.data.Effect.EffectVariable.EffectInt.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectInt} message EffectInt message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EffectInt.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an EffectInt message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Effect.EffectVariable.EffectInt} EffectInt
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EffectInt.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Effect.EffectVariable.EffectInt();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.value = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.defaultValue = reader.int32();
                                    break;
                                }
                            case 3: {
                                    message.min = reader.int32();
                                    break;
                                }
                            case 4: {
                                    message.max = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an EffectInt message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Effect.EffectVariable.EffectInt} EffectInt
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EffectInt.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an EffectInt message.
                     * @function verify
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    EffectInt.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value))
                                return "value: integer expected";
                        if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                            if (!$util.isInteger(message.defaultValue))
                                return "defaultValue: integer expected";
                        if (message.min != null && message.hasOwnProperty("min"))
                            if (!$util.isInteger(message.min))
                                return "min: integer expected";
                        if (message.max != null && message.hasOwnProperty("max"))
                            if (!$util.isInteger(message.max))
                                return "max: integer expected";
                        return null;
                    };

                    /**
                     * Creates an EffectInt message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Effect.EffectVariable.EffectInt} EffectInt
                     */
                    EffectInt.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Effect.EffectVariable.EffectInt)
                            return object;
                        let message = new $root.rv.data.Effect.EffectVariable.EffectInt();
                        if (object.value != null)
                            message.value = object.value | 0;
                        if (object.defaultValue != null)
                            message.defaultValue = object.defaultValue | 0;
                        if (object.min != null)
                            message.min = object.min | 0;
                        if (object.max != null)
                            message.max = object.max | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from an EffectInt message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @static
                     * @param {rv.data.Effect.EffectVariable.EffectInt} message EffectInt
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    EffectInt.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.value = 0;
                            object.defaultValue = 0;
                            object.min = 0;
                            object.max = 0;
                        }
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = message.value;
                        if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                            object.defaultValue = message.defaultValue;
                        if (message.min != null && message.hasOwnProperty("min"))
                            object.min = message.min;
                        if (message.max != null && message.hasOwnProperty("max"))
                            object.max = message.max;
                        return object;
                    };

                    /**
                     * Converts this EffectInt to JSON.
                     * @function toJSON
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    EffectInt.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for EffectInt
                     * @function getTypeUrl
                     * @memberof rv.data.Effect.EffectVariable.EffectInt
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    EffectInt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Effect.EffectVariable.EffectInt";
                    };

                    return EffectInt;
                })();

                EffectVariable.EffectFloat = (function() {

                    /**
                     * Properties of an EffectFloat.
                     * @memberof rv.data.Effect.EffectVariable
                     * @interface IEffectFloat
                     * @property {number|null} [value] EffectFloat value
                     * @property {number|null} [defaultValue] EffectFloat defaultValue
                     * @property {number|null} [min] EffectFloat min
                     * @property {number|null} [max] EffectFloat max
                     */

                    /**
                     * Constructs a new EffectFloat.
                     * @memberof rv.data.Effect.EffectVariable
                     * @classdesc Represents an EffectFloat.
                     * @implements IEffectFloat
                     * @constructor
                     * @param {rv.data.Effect.EffectVariable.IEffectFloat=} [properties] Properties to set
                     */
                    function EffectFloat(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * EffectFloat value.
                     * @member {number} value
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @instance
                     */
                    EffectFloat.prototype.value = 0;

                    /**
                     * EffectFloat defaultValue.
                     * @member {number} defaultValue
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @instance
                     */
                    EffectFloat.prototype.defaultValue = 0;

                    /**
                     * EffectFloat min.
                     * @member {number} min
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @instance
                     */
                    EffectFloat.prototype.min = 0;

                    /**
                     * EffectFloat max.
                     * @member {number} max
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @instance
                     */
                    EffectFloat.prototype.max = 0;

                    /**
                     * Creates a new EffectFloat instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectFloat=} [properties] Properties to set
                     * @returns {rv.data.Effect.EffectVariable.EffectFloat} EffectFloat instance
                     */
                    EffectFloat.create = function create(properties) {
                        return new EffectFloat(properties);
                    };

                    /**
                     * Encodes the specified EffectFloat message. Does not implicitly {@link rv.data.Effect.EffectVariable.EffectFloat.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectFloat} message EffectFloat message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EffectFloat.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
                        if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
                            writer.uint32(/* id 2, wireType 5 =*/21).float(message.defaultValue);
                        if (message.min != null && Object.hasOwnProperty.call(message, "min"))
                            writer.uint32(/* id 3, wireType 5 =*/29).float(message.min);
                        if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                            writer.uint32(/* id 4, wireType 5 =*/37).float(message.max);
                        return writer;
                    };

                    /**
                     * Encodes the specified EffectFloat message, length delimited. Does not implicitly {@link rv.data.Effect.EffectVariable.EffectFloat.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectFloat} message EffectFloat message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EffectFloat.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an EffectFloat message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Effect.EffectVariable.EffectFloat} EffectFloat
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EffectFloat.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Effect.EffectVariable.EffectFloat();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.value = reader.float();
                                    break;
                                }
                            case 2: {
                                    message.defaultValue = reader.float();
                                    break;
                                }
                            case 3: {
                                    message.min = reader.float();
                                    break;
                                }
                            case 4: {
                                    message.max = reader.float();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an EffectFloat message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Effect.EffectVariable.EffectFloat} EffectFloat
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EffectFloat.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an EffectFloat message.
                     * @function verify
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    EffectFloat.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value !== "number")
                                return "value: number expected";
                        if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                            if (typeof message.defaultValue !== "number")
                                return "defaultValue: number expected";
                        if (message.min != null && message.hasOwnProperty("min"))
                            if (typeof message.min !== "number")
                                return "min: number expected";
                        if (message.max != null && message.hasOwnProperty("max"))
                            if (typeof message.max !== "number")
                                return "max: number expected";
                        return null;
                    };

                    /**
                     * Creates an EffectFloat message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Effect.EffectVariable.EffectFloat} EffectFloat
                     */
                    EffectFloat.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Effect.EffectVariable.EffectFloat)
                            return object;
                        let message = new $root.rv.data.Effect.EffectVariable.EffectFloat();
                        if (object.value != null)
                            message.value = Number(object.value);
                        if (object.defaultValue != null)
                            message.defaultValue = Number(object.defaultValue);
                        if (object.min != null)
                            message.min = Number(object.min);
                        if (object.max != null)
                            message.max = Number(object.max);
                        return message;
                    };

                    /**
                     * Creates a plain object from an EffectFloat message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @static
                     * @param {rv.data.Effect.EffectVariable.EffectFloat} message EffectFloat
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    EffectFloat.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.value = 0;
                            object.defaultValue = 0;
                            object.min = 0;
                            object.max = 0;
                        }
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                        if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                            object.defaultValue = options.json && !isFinite(message.defaultValue) ? String(message.defaultValue) : message.defaultValue;
                        if (message.min != null && message.hasOwnProperty("min"))
                            object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;
                        if (message.max != null && message.hasOwnProperty("max"))
                            object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;
                        return object;
                    };

                    /**
                     * Converts this EffectFloat to JSON.
                     * @function toJSON
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    EffectFloat.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for EffectFloat
                     * @function getTypeUrl
                     * @memberof rv.data.Effect.EffectVariable.EffectFloat
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    EffectFloat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Effect.EffectVariable.EffectFloat";
                    };

                    return EffectFloat;
                })();

                EffectVariable.EffectDouble = (function() {

                    /**
                     * Properties of an EffectDouble.
                     * @memberof rv.data.Effect.EffectVariable
                     * @interface IEffectDouble
                     * @property {number|null} [value] EffectDouble value
                     * @property {number|null} [defaultValue] EffectDouble defaultValue
                     * @property {number|null} [min] EffectDouble min
                     * @property {number|null} [max] EffectDouble max
                     */

                    /**
                     * Constructs a new EffectDouble.
                     * @memberof rv.data.Effect.EffectVariable
                     * @classdesc Represents an EffectDouble.
                     * @implements IEffectDouble
                     * @constructor
                     * @param {rv.data.Effect.EffectVariable.IEffectDouble=} [properties] Properties to set
                     */
                    function EffectDouble(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * EffectDouble value.
                     * @member {number} value
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @instance
                     */
                    EffectDouble.prototype.value = 0;

                    /**
                     * EffectDouble defaultValue.
                     * @member {number} defaultValue
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @instance
                     */
                    EffectDouble.prototype.defaultValue = 0;

                    /**
                     * EffectDouble min.
                     * @member {number} min
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @instance
                     */
                    EffectDouble.prototype.min = 0;

                    /**
                     * EffectDouble max.
                     * @member {number} max
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @instance
                     */
                    EffectDouble.prototype.max = 0;

                    /**
                     * Creates a new EffectDouble instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectDouble=} [properties] Properties to set
                     * @returns {rv.data.Effect.EffectVariable.EffectDouble} EffectDouble instance
                     */
                    EffectDouble.create = function create(properties) {
                        return new EffectDouble(properties);
                    };

                    /**
                     * Encodes the specified EffectDouble message. Does not implicitly {@link rv.data.Effect.EffectVariable.EffectDouble.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectDouble} message EffectDouble message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EffectDouble.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                        if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
                            writer.uint32(/* id 2, wireType 1 =*/17).double(message.defaultValue);
                        if (message.min != null && Object.hasOwnProperty.call(message, "min"))
                            writer.uint32(/* id 3, wireType 1 =*/25).double(message.min);
                        if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                            writer.uint32(/* id 4, wireType 1 =*/33).double(message.max);
                        return writer;
                    };

                    /**
                     * Encodes the specified EffectDouble message, length delimited. Does not implicitly {@link rv.data.Effect.EffectVariable.EffectDouble.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectDouble} message EffectDouble message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EffectDouble.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an EffectDouble message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Effect.EffectVariable.EffectDouble} EffectDouble
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EffectDouble.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Effect.EffectVariable.EffectDouble();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.value = reader.double();
                                    break;
                                }
                            case 2: {
                                    message.defaultValue = reader.double();
                                    break;
                                }
                            case 3: {
                                    message.min = reader.double();
                                    break;
                                }
                            case 4: {
                                    message.max = reader.double();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an EffectDouble message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Effect.EffectVariable.EffectDouble} EffectDouble
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EffectDouble.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an EffectDouble message.
                     * @function verify
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    EffectDouble.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value !== "number")
                                return "value: number expected";
                        if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                            if (typeof message.defaultValue !== "number")
                                return "defaultValue: number expected";
                        if (message.min != null && message.hasOwnProperty("min"))
                            if (typeof message.min !== "number")
                                return "min: number expected";
                        if (message.max != null && message.hasOwnProperty("max"))
                            if (typeof message.max !== "number")
                                return "max: number expected";
                        return null;
                    };

                    /**
                     * Creates an EffectDouble message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Effect.EffectVariable.EffectDouble} EffectDouble
                     */
                    EffectDouble.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Effect.EffectVariable.EffectDouble)
                            return object;
                        let message = new $root.rv.data.Effect.EffectVariable.EffectDouble();
                        if (object.value != null)
                            message.value = Number(object.value);
                        if (object.defaultValue != null)
                            message.defaultValue = Number(object.defaultValue);
                        if (object.min != null)
                            message.min = Number(object.min);
                        if (object.max != null)
                            message.max = Number(object.max);
                        return message;
                    };

                    /**
                     * Creates a plain object from an EffectDouble message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @static
                     * @param {rv.data.Effect.EffectVariable.EffectDouble} message EffectDouble
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    EffectDouble.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.value = 0;
                            object.defaultValue = 0;
                            object.min = 0;
                            object.max = 0;
                        }
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                        if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                            object.defaultValue = options.json && !isFinite(message.defaultValue) ? String(message.defaultValue) : message.defaultValue;
                        if (message.min != null && message.hasOwnProperty("min"))
                            object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;
                        if (message.max != null && message.hasOwnProperty("max"))
                            object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;
                        return object;
                    };

                    /**
                     * Converts this EffectDouble to JSON.
                     * @function toJSON
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    EffectDouble.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for EffectDouble
                     * @function getTypeUrl
                     * @memberof rv.data.Effect.EffectVariable.EffectDouble
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    EffectDouble.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Effect.EffectVariable.EffectDouble";
                    };

                    return EffectDouble;
                })();

                EffectVariable.EffectColor = (function() {

                    /**
                     * Properties of an EffectColor.
                     * @memberof rv.data.Effect.EffectVariable
                     * @interface IEffectColor
                     * @property {rv.data.IColor|null} [color] EffectColor color
                     * @property {rv.data.IColor|null} [defaultColor] EffectColor defaultColor
                     */

                    /**
                     * Constructs a new EffectColor.
                     * @memberof rv.data.Effect.EffectVariable
                     * @classdesc Represents an EffectColor.
                     * @implements IEffectColor
                     * @constructor
                     * @param {rv.data.Effect.EffectVariable.IEffectColor=} [properties] Properties to set
                     */
                    function EffectColor(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * EffectColor color.
                     * @member {rv.data.IColor|null|undefined} color
                     * @memberof rv.data.Effect.EffectVariable.EffectColor
                     * @instance
                     */
                    EffectColor.prototype.color = null;

                    /**
                     * EffectColor defaultColor.
                     * @member {rv.data.IColor|null|undefined} defaultColor
                     * @memberof rv.data.Effect.EffectVariable.EffectColor
                     * @instance
                     */
                    EffectColor.prototype.defaultColor = null;

                    /**
                     * Creates a new EffectColor instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Effect.EffectVariable.EffectColor
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectColor=} [properties] Properties to set
                     * @returns {rv.data.Effect.EffectVariable.EffectColor} EffectColor instance
                     */
                    EffectColor.create = function create(properties) {
                        return new EffectColor(properties);
                    };

                    /**
                     * Encodes the specified EffectColor message. Does not implicitly {@link rv.data.Effect.EffectVariable.EffectColor.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Effect.EffectVariable.EffectColor
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectColor} message EffectColor message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EffectColor.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                            $root.rv.data.Color.encode(message.color, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.defaultColor != null && Object.hasOwnProperty.call(message, "defaultColor"))
                            $root.rv.data.Color.encode(message.defaultColor, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified EffectColor message, length delimited. Does not implicitly {@link rv.data.Effect.EffectVariable.EffectColor.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Effect.EffectVariable.EffectColor
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectColor} message EffectColor message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EffectColor.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an EffectColor message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Effect.EffectVariable.EffectColor
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Effect.EffectVariable.EffectColor} EffectColor
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EffectColor.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Effect.EffectVariable.EffectColor();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.color = $root.rv.data.Color.decode(reader, reader.uint32());
                                    break;
                                }
                            case 2: {
                                    message.defaultColor = $root.rv.data.Color.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an EffectColor message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Effect.EffectVariable.EffectColor
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Effect.EffectVariable.EffectColor} EffectColor
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EffectColor.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an EffectColor message.
                     * @function verify
                     * @memberof rv.data.Effect.EffectVariable.EffectColor
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    EffectColor.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.color != null && message.hasOwnProperty("color")) {
                            let error = $root.rv.data.Color.verify(message.color);
                            if (error)
                                return "color." + error;
                        }
                        if (message.defaultColor != null && message.hasOwnProperty("defaultColor")) {
                            let error = $root.rv.data.Color.verify(message.defaultColor);
                            if (error)
                                return "defaultColor." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an EffectColor message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Effect.EffectVariable.EffectColor
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Effect.EffectVariable.EffectColor} EffectColor
                     */
                    EffectColor.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Effect.EffectVariable.EffectColor)
                            return object;
                        let message = new $root.rv.data.Effect.EffectVariable.EffectColor();
                        if (object.color != null) {
                            if (typeof object.color !== "object")
                                throw TypeError(".rv.data.Effect.EffectVariable.EffectColor.color: object expected");
                            message.color = $root.rv.data.Color.fromObject(object.color);
                        }
                        if (object.defaultColor != null) {
                            if (typeof object.defaultColor !== "object")
                                throw TypeError(".rv.data.Effect.EffectVariable.EffectColor.defaultColor: object expected");
                            message.defaultColor = $root.rv.data.Color.fromObject(object.defaultColor);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an EffectColor message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Effect.EffectVariable.EffectColor
                     * @static
                     * @param {rv.data.Effect.EffectVariable.EffectColor} message EffectColor
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    EffectColor.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.color = null;
                            object.defaultColor = null;
                        }
                        if (message.color != null && message.hasOwnProperty("color"))
                            object.color = $root.rv.data.Color.toObject(message.color, options);
                        if (message.defaultColor != null && message.hasOwnProperty("defaultColor"))
                            object.defaultColor = $root.rv.data.Color.toObject(message.defaultColor, options);
                        return object;
                    };

                    /**
                     * Converts this EffectColor to JSON.
                     * @function toJSON
                     * @memberof rv.data.Effect.EffectVariable.EffectColor
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    EffectColor.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for EffectColor
                     * @function getTypeUrl
                     * @memberof rv.data.Effect.EffectVariable.EffectColor
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    EffectColor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Effect.EffectVariable.EffectColor";
                    };

                    return EffectColor;
                })();

                EffectVariable.EffectDirection = (function() {

                    /**
                     * Properties of an EffectDirection.
                     * @memberof rv.data.Effect.EffectVariable
                     * @interface IEffectDirection
                     * @property {rv.data.Effect.EffectVariable.EffectDirection.EffectDirection|null} [direction] EffectDirection direction
                     * @property {rv.data.Effect.EffectVariable.EffectDirection.EffectDirection|null} [defaultDirection] EffectDirection defaultDirection
                     * @property {number|null} [availableDirections] EffectDirection availableDirections
                     */

                    /**
                     * Constructs a new EffectDirection.
                     * @memberof rv.data.Effect.EffectVariable
                     * @classdesc Represents an EffectDirection.
                     * @implements IEffectDirection
                     * @constructor
                     * @param {rv.data.Effect.EffectVariable.IEffectDirection=} [properties] Properties to set
                     */
                    function EffectDirection(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * EffectDirection direction.
                     * @member {rv.data.Effect.EffectVariable.EffectDirection.EffectDirection} direction
                     * @memberof rv.data.Effect.EffectVariable.EffectDirection
                     * @instance
                     */
                    EffectDirection.prototype.direction = 0;

                    /**
                     * EffectDirection defaultDirection.
                     * @member {rv.data.Effect.EffectVariable.EffectDirection.EffectDirection} defaultDirection
                     * @memberof rv.data.Effect.EffectVariable.EffectDirection
                     * @instance
                     */
                    EffectDirection.prototype.defaultDirection = 0;

                    /**
                     * EffectDirection availableDirections.
                     * @member {number} availableDirections
                     * @memberof rv.data.Effect.EffectVariable.EffectDirection
                     * @instance
                     */
                    EffectDirection.prototype.availableDirections = 0;

                    /**
                     * Creates a new EffectDirection instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Effect.EffectVariable.EffectDirection
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectDirection=} [properties] Properties to set
                     * @returns {rv.data.Effect.EffectVariable.EffectDirection} EffectDirection instance
                     */
                    EffectDirection.create = function create(properties) {
                        return new EffectDirection(properties);
                    };

                    /**
                     * Encodes the specified EffectDirection message. Does not implicitly {@link rv.data.Effect.EffectVariable.EffectDirection.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Effect.EffectVariable.EffectDirection
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectDirection} message EffectDirection message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EffectDirection.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.direction);
                        if (message.defaultDirection != null && Object.hasOwnProperty.call(message, "defaultDirection"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.defaultDirection);
                        if (message.availableDirections != null && Object.hasOwnProperty.call(message, "availableDirections"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.availableDirections);
                        return writer;
                    };

                    /**
                     * Encodes the specified EffectDirection message, length delimited. Does not implicitly {@link rv.data.Effect.EffectVariable.EffectDirection.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Effect.EffectVariable.EffectDirection
                     * @static
                     * @param {rv.data.Effect.EffectVariable.IEffectDirection} message EffectDirection message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EffectDirection.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an EffectDirection message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Effect.EffectVariable.EffectDirection
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Effect.EffectVariable.EffectDirection} EffectDirection
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EffectDirection.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Effect.EffectVariable.EffectDirection();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.direction = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.defaultDirection = reader.int32();
                                    break;
                                }
                            case 3: {
                                    message.availableDirections = reader.uint32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an EffectDirection message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Effect.EffectVariable.EffectDirection
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Effect.EffectVariable.EffectDirection} EffectDirection
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EffectDirection.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an EffectDirection message.
                     * @function verify
                     * @memberof rv.data.Effect.EffectVariable.EffectDirection
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    EffectDirection.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.direction != null && message.hasOwnProperty("direction"))
                            switch (message.direction) {
                            default:
                                return "direction: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 4:
                            case 8:
                            case 16:
                            case 32:
                            case 64:
                            case 128:
                            case 256:
                                break;
                            }
                        if (message.defaultDirection != null && message.hasOwnProperty("defaultDirection"))
                            switch (message.defaultDirection) {
                            default:
                                return "defaultDirection: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 4:
                            case 8:
                            case 16:
                            case 32:
                            case 64:
                            case 128:
                            case 256:
                                break;
                            }
                        if (message.availableDirections != null && message.hasOwnProperty("availableDirections"))
                            if (!$util.isInteger(message.availableDirections))
                                return "availableDirections: integer expected";
                        return null;
                    };

                    /**
                     * Creates an EffectDirection message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Effect.EffectVariable.EffectDirection
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Effect.EffectVariable.EffectDirection} EffectDirection
                     */
                    EffectDirection.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Effect.EffectVariable.EffectDirection)
                            return object;
                        let message = new $root.rv.data.Effect.EffectVariable.EffectDirection();
                        switch (object.direction) {
                        default:
                            if (typeof object.direction === "number") {
                                message.direction = object.direction;
                                break;
                            }
                            break;
                        case "EFFECT_DIRECTION_NONE":
                        case 0:
                            message.direction = 0;
                            break;
                        case "EFFECT_DIRECTION_TOP_LEFT":
                        case 1:
                            message.direction = 1;
                            break;
                        case "EFFECT_DIRECTION_TOP":
                        case 2:
                            message.direction = 2;
                            break;
                        case "EFFECT_DIRECTION_TOP_RIGHT":
                        case 4:
                            message.direction = 4;
                            break;
                        case "EFFECT_DIRECTION_LEFT":
                        case 8:
                            message.direction = 8;
                            break;
                        case "EFFECT_DIRECTION_CENTER":
                        case 16:
                            message.direction = 16;
                            break;
                        case "EFFECT_DIRECTION_RIGHT":
                        case 32:
                            message.direction = 32;
                            break;
                        case "EFFECT_DIRECTION_BOTTOM_LEFT":
                        case 64:
                            message.direction = 64;
                            break;
                        case "EFFECT_DIRECTION_BOTTOM":
                        case 128:
                            message.direction = 128;
                            break;
                        case "EFFECT_DIRECTION_BOTTOM_RIGHT":
                        case 256:
                            message.direction = 256;
                            break;
                        }
                        switch (object.defaultDirection) {
                        default:
                            if (typeof object.defaultDirection === "number") {
                                message.defaultDirection = object.defaultDirection;
                                break;
                            }
                            break;
                        case "EFFECT_DIRECTION_NONE":
                        case 0:
                            message.defaultDirection = 0;
                            break;
                        case "EFFECT_DIRECTION_TOP_LEFT":
                        case 1:
                            message.defaultDirection = 1;
                            break;
                        case "EFFECT_DIRECTION_TOP":
                        case 2:
                            message.defaultDirection = 2;
                            break;
                        case "EFFECT_DIRECTION_TOP_RIGHT":
                        case 4:
                            message.defaultDirection = 4;
                            break;
                        case "EFFECT_DIRECTION_LEFT":
                        case 8:
                            message.defaultDirection = 8;
                            break;
                        case "EFFECT_DIRECTION_CENTER":
                        case 16:
                            message.defaultDirection = 16;
                            break;
                        case "EFFECT_DIRECTION_RIGHT":
                        case 32:
                            message.defaultDirection = 32;
                            break;
                        case "EFFECT_DIRECTION_BOTTOM_LEFT":
                        case 64:
                            message.defaultDirection = 64;
                            break;
                        case "EFFECT_DIRECTION_BOTTOM":
                        case 128:
                            message.defaultDirection = 128;
                            break;
                        case "EFFECT_DIRECTION_BOTTOM_RIGHT":
                        case 256:
                            message.defaultDirection = 256;
                            break;
                        }
                        if (object.availableDirections != null)
                            message.availableDirections = object.availableDirections >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from an EffectDirection message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Effect.EffectVariable.EffectDirection
                     * @static
                     * @param {rv.data.Effect.EffectVariable.EffectDirection} message EffectDirection
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    EffectDirection.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.direction = options.enums === String ? "EFFECT_DIRECTION_NONE" : 0;
                            object.defaultDirection = options.enums === String ? "EFFECT_DIRECTION_NONE" : 0;
                            object.availableDirections = 0;
                        }
                        if (message.direction != null && message.hasOwnProperty("direction"))
                            object.direction = options.enums === String ? $root.rv.data.Effect.EffectVariable.EffectDirection.EffectDirection[message.direction] === undefined ? message.direction : $root.rv.data.Effect.EffectVariable.EffectDirection.EffectDirection[message.direction] : message.direction;
                        if (message.defaultDirection != null && message.hasOwnProperty("defaultDirection"))
                            object.defaultDirection = options.enums === String ? $root.rv.data.Effect.EffectVariable.EffectDirection.EffectDirection[message.defaultDirection] === undefined ? message.defaultDirection : $root.rv.data.Effect.EffectVariable.EffectDirection.EffectDirection[message.defaultDirection] : message.defaultDirection;
                        if (message.availableDirections != null && message.hasOwnProperty("availableDirections"))
                            object.availableDirections = message.availableDirections;
                        return object;
                    };

                    /**
                     * Converts this EffectDirection to JSON.
                     * @function toJSON
                     * @memberof rv.data.Effect.EffectVariable.EffectDirection
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    EffectDirection.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for EffectDirection
                     * @function getTypeUrl
                     * @memberof rv.data.Effect.EffectVariable.EffectDirection
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    EffectDirection.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Effect.EffectVariable.EffectDirection";
                    };

                    /**
                     * EffectDirection enum.
                     * @name rv.data.Effect.EffectVariable.EffectDirection.EffectDirection
                     * @enum {number}
                     * @property {number} EFFECT_DIRECTION_NONE=0 EFFECT_DIRECTION_NONE value
                     * @property {number} EFFECT_DIRECTION_TOP_LEFT=1 EFFECT_DIRECTION_TOP_LEFT value
                     * @property {number} EFFECT_DIRECTION_TOP=2 EFFECT_DIRECTION_TOP value
                     * @property {number} EFFECT_DIRECTION_TOP_RIGHT=4 EFFECT_DIRECTION_TOP_RIGHT value
                     * @property {number} EFFECT_DIRECTION_LEFT=8 EFFECT_DIRECTION_LEFT value
                     * @property {number} EFFECT_DIRECTION_CENTER=16 EFFECT_DIRECTION_CENTER value
                     * @property {number} EFFECT_DIRECTION_RIGHT=32 EFFECT_DIRECTION_RIGHT value
                     * @property {number} EFFECT_DIRECTION_BOTTOM_LEFT=64 EFFECT_DIRECTION_BOTTOM_LEFT value
                     * @property {number} EFFECT_DIRECTION_BOTTOM=128 EFFECT_DIRECTION_BOTTOM value
                     * @property {number} EFFECT_DIRECTION_BOTTOM_RIGHT=256 EFFECT_DIRECTION_BOTTOM_RIGHT value
                     */
                    EffectDirection.EffectDirection = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "EFFECT_DIRECTION_NONE"] = 0;
                        values[valuesById[1] = "EFFECT_DIRECTION_TOP_LEFT"] = 1;
                        values[valuesById[2] = "EFFECT_DIRECTION_TOP"] = 2;
                        values[valuesById[4] = "EFFECT_DIRECTION_TOP_RIGHT"] = 4;
                        values[valuesById[8] = "EFFECT_DIRECTION_LEFT"] = 8;
                        values[valuesById[16] = "EFFECT_DIRECTION_CENTER"] = 16;
                        values[valuesById[32] = "EFFECT_DIRECTION_RIGHT"] = 32;
                        values[valuesById[64] = "EFFECT_DIRECTION_BOTTOM_LEFT"] = 64;
                        values[valuesById[128] = "EFFECT_DIRECTION_BOTTOM"] = 128;
                        values[valuesById[256] = "EFFECT_DIRECTION_BOTTOM_RIGHT"] = 256;
                        return values;
                    })();

                    return EffectDirection;
                })();

                return EffectVariable;
            })();

            Effect.Preset = (function() {

                /**
                 * Properties of a Preset.
                 * @memberof rv.data.Effect
                 * @interface IPreset
                 * @property {rv.data.IUUID|null} [uuid] Preset uuid
                 * @property {string|null} [name] Preset name
                 * @property {Array.<rv.data.IEffect>|null} [effects] Preset effects
                 */

                /**
                 * Constructs a new Preset.
                 * @memberof rv.data.Effect
                 * @classdesc Represents a Preset.
                 * @implements IPreset
                 * @constructor
                 * @param {rv.data.Effect.IPreset=} [properties] Properties to set
                 */
                function Preset(properties) {
                    this.effects = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Preset uuid.
                 * @member {rv.data.IUUID|null|undefined} uuid
                 * @memberof rv.data.Effect.Preset
                 * @instance
                 */
                Preset.prototype.uuid = null;

                /**
                 * Preset name.
                 * @member {string} name
                 * @memberof rv.data.Effect.Preset
                 * @instance
                 */
                Preset.prototype.name = "";

                /**
                 * Preset effects.
                 * @member {Array.<rv.data.IEffect>} effects
                 * @memberof rv.data.Effect.Preset
                 * @instance
                 */
                Preset.prototype.effects = $util.emptyArray;

                /**
                 * Creates a new Preset instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Effect.Preset
                 * @static
                 * @param {rv.data.Effect.IPreset=} [properties] Properties to set
                 * @returns {rv.data.Effect.Preset} Preset instance
                 */
                Preset.create = function create(properties) {
                    return new Preset(properties);
                };

                /**
                 * Encodes the specified Preset message. Does not implicitly {@link rv.data.Effect.Preset.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Effect.Preset
                 * @static
                 * @param {rv.data.Effect.IPreset} message Preset message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Preset.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                        $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.effects != null && message.effects.length)
                        for (let i = 0; i < message.effects.length; ++i)
                            $root.rv.data.Effect.encode(message.effects[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Preset message, length delimited. Does not implicitly {@link rv.data.Effect.Preset.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Effect.Preset
                 * @static
                 * @param {rv.data.Effect.IPreset} message Preset message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Preset.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Preset message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Effect.Preset
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Effect.Preset} Preset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Preset.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Effect.Preset();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.name = reader.string();
                                break;
                            }
                        case 3: {
                                if (!(message.effects && message.effects.length))
                                    message.effects = [];
                                message.effects.push($root.rv.data.Effect.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Preset message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Effect.Preset
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Effect.Preset} Preset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Preset.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Preset message.
                 * @function verify
                 * @memberof rv.data.Effect.Preset
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Preset.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uuid != null && message.hasOwnProperty("uuid")) {
                        let error = $root.rv.data.UUID.verify(message.uuid);
                        if (error)
                            return "uuid." + error;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.effects != null && message.hasOwnProperty("effects")) {
                        if (!Array.isArray(message.effects))
                            return "effects: array expected";
                        for (let i = 0; i < message.effects.length; ++i) {
                            let error = $root.rv.data.Effect.verify(message.effects[i]);
                            if (error)
                                return "effects." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Preset message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Effect.Preset
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Effect.Preset} Preset
                 */
                Preset.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Effect.Preset)
                        return object;
                    let message = new $root.rv.data.Effect.Preset();
                    if (object.uuid != null) {
                        if (typeof object.uuid !== "object")
                            throw TypeError(".rv.data.Effect.Preset.uuid: object expected");
                        message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.effects) {
                        if (!Array.isArray(object.effects))
                            throw TypeError(".rv.data.Effect.Preset.effects: array expected");
                        message.effects = [];
                        for (let i = 0; i < object.effects.length; ++i) {
                            if (typeof object.effects[i] !== "object")
                                throw TypeError(".rv.data.Effect.Preset.effects: object expected");
                            message.effects[i] = $root.rv.data.Effect.fromObject(object.effects[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Preset message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Effect.Preset
                 * @static
                 * @param {rv.data.Effect.Preset} message Preset
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Preset.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.effects = [];
                    if (options.defaults) {
                        object.uuid = null;
                        object.name = "";
                    }
                    if (message.uuid != null && message.hasOwnProperty("uuid"))
                        object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.effects && message.effects.length) {
                        object.effects = [];
                        for (let j = 0; j < message.effects.length; ++j)
                            object.effects[j] = $root.rv.data.Effect.toObject(message.effects[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Preset to JSON.
                 * @function toJSON
                 * @memberof rv.data.Effect.Preset
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Preset.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Preset
                 * @function getTypeUrl
                 * @memberof rv.data.Effect.Preset
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Preset.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Effect.Preset";
                };

                return Preset;
            })();

            return Effect;
        })();

        data.Transition = (function() {

            /**
             * Properties of a Transition.
             * @memberof rv.data
             * @interface ITransition
             * @property {number|null} [duration] Transition duration
             * @property {rv.data.IUUID|null} [favoriteUuid] Transition favoriteUuid
             * @property {rv.data.IEffect|null} [effect] Transition effect
             */

            /**
             * Constructs a new Transition.
             * @memberof rv.data
             * @classdesc Represents a Transition.
             * @implements ITransition
             * @constructor
             * @param {rv.data.ITransition=} [properties] Properties to set
             */
            function Transition(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Transition duration.
             * @member {number} duration
             * @memberof rv.data.Transition
             * @instance
             */
            Transition.prototype.duration = 0;

            /**
             * Transition favoriteUuid.
             * @member {rv.data.IUUID|null|undefined} favoriteUuid
             * @memberof rv.data.Transition
             * @instance
             */
            Transition.prototype.favoriteUuid = null;

            /**
             * Transition effect.
             * @member {rv.data.IEffect|null|undefined} effect
             * @memberof rv.data.Transition
             * @instance
             */
            Transition.prototype.effect = null;

            /**
             * Creates a new Transition instance using the specified properties.
             * @function create
             * @memberof rv.data.Transition
             * @static
             * @param {rv.data.ITransition=} [properties] Properties to set
             * @returns {rv.data.Transition} Transition instance
             */
            Transition.create = function create(properties) {
                return new Transition(properties);
            };

            /**
             * Encodes the specified Transition message. Does not implicitly {@link rv.data.Transition.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Transition
             * @static
             * @param {rv.data.ITransition} message Transition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transition.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.duration);
                if (message.favoriteUuid != null && Object.hasOwnProperty.call(message, "favoriteUuid"))
                    $root.rv.data.UUID.encode(message.favoriteUuid, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.effect != null && Object.hasOwnProperty.call(message, "effect"))
                    $root.rv.data.Effect.encode(message.effect, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Transition message, length delimited. Does not implicitly {@link rv.data.Transition.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Transition
             * @static
             * @param {rv.data.ITransition} message Transition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transition.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Transition message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Transition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Transition} Transition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transition.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Transition();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.duration = reader.double();
                            break;
                        }
                    case 2: {
                            message.favoriteUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.effect = $root.rv.data.Effect.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Transition message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Transition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Transition} Transition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transition.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Transition message.
             * @function verify
             * @memberof rv.data.Transition
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Transition.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (typeof message.duration !== "number")
                        return "duration: number expected";
                if (message.favoriteUuid != null && message.hasOwnProperty("favoriteUuid")) {
                    let error = $root.rv.data.UUID.verify(message.favoriteUuid);
                    if (error)
                        return "favoriteUuid." + error;
                }
                if (message.effect != null && message.hasOwnProperty("effect")) {
                    let error = $root.rv.data.Effect.verify(message.effect);
                    if (error)
                        return "effect." + error;
                }
                return null;
            };

            /**
             * Creates a Transition message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Transition
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Transition} Transition
             */
            Transition.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Transition)
                    return object;
                let message = new $root.rv.data.Transition();
                if (object.duration != null)
                    message.duration = Number(object.duration);
                if (object.favoriteUuid != null) {
                    if (typeof object.favoriteUuid !== "object")
                        throw TypeError(".rv.data.Transition.favoriteUuid: object expected");
                    message.favoriteUuid = $root.rv.data.UUID.fromObject(object.favoriteUuid);
                }
                if (object.effect != null) {
                    if (typeof object.effect !== "object")
                        throw TypeError(".rv.data.Transition.effect: object expected");
                    message.effect = $root.rv.data.Effect.fromObject(object.effect);
                }
                return message;
            };

            /**
             * Creates a plain object from a Transition message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Transition
             * @static
             * @param {rv.data.Transition} message Transition
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Transition.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.duration = 0;
                    object.favoriteUuid = null;
                    object.effect = null;
                }
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
                if (message.favoriteUuid != null && message.hasOwnProperty("favoriteUuid"))
                    object.favoriteUuid = $root.rv.data.UUID.toObject(message.favoriteUuid, options);
                if (message.effect != null && message.hasOwnProperty("effect"))
                    object.effect = $root.rv.data.Effect.toObject(message.effect, options);
                return object;
            };

            /**
             * Converts this Transition to JSON.
             * @function toJSON
             * @memberof rv.data.Transition
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Transition.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Transition
             * @function getTypeUrl
             * @memberof rv.data.Transition
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Transition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Transition";
            };

            Transition.Preset = (function() {

                /**
                 * Properties of a Preset.
                 * @memberof rv.data.Transition
                 * @interface IPreset
                 * @property {rv.data.IUUID|null} [uuid] Preset uuid
                 * @property {string|null} [name] Preset name
                 * @property {rv.data.ITransition|null} [transition] Preset transition
                 */

                /**
                 * Constructs a new Preset.
                 * @memberof rv.data.Transition
                 * @classdesc Represents a Preset.
                 * @implements IPreset
                 * @constructor
                 * @param {rv.data.Transition.IPreset=} [properties] Properties to set
                 */
                function Preset(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Preset uuid.
                 * @member {rv.data.IUUID|null|undefined} uuid
                 * @memberof rv.data.Transition.Preset
                 * @instance
                 */
                Preset.prototype.uuid = null;

                /**
                 * Preset name.
                 * @member {string} name
                 * @memberof rv.data.Transition.Preset
                 * @instance
                 */
                Preset.prototype.name = "";

                /**
                 * Preset transition.
                 * @member {rv.data.ITransition|null|undefined} transition
                 * @memberof rv.data.Transition.Preset
                 * @instance
                 */
                Preset.prototype.transition = null;

                /**
                 * Creates a new Preset instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Transition.Preset
                 * @static
                 * @param {rv.data.Transition.IPreset=} [properties] Properties to set
                 * @returns {rv.data.Transition.Preset} Preset instance
                 */
                Preset.create = function create(properties) {
                    return new Preset(properties);
                };

                /**
                 * Encodes the specified Preset message. Does not implicitly {@link rv.data.Transition.Preset.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Transition.Preset
                 * @static
                 * @param {rv.data.Transition.IPreset} message Preset message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Preset.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                        $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.transition != null && Object.hasOwnProperty.call(message, "transition"))
                        $root.rv.data.Transition.encode(message.transition, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Preset message, length delimited. Does not implicitly {@link rv.data.Transition.Preset.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Transition.Preset
                 * @static
                 * @param {rv.data.Transition.IPreset} message Preset message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Preset.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Preset message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Transition.Preset
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Transition.Preset} Preset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Preset.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Transition.Preset();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.name = reader.string();
                                break;
                            }
                        case 3: {
                                message.transition = $root.rv.data.Transition.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Preset message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Transition.Preset
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Transition.Preset} Preset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Preset.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Preset message.
                 * @function verify
                 * @memberof rv.data.Transition.Preset
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Preset.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uuid != null && message.hasOwnProperty("uuid")) {
                        let error = $root.rv.data.UUID.verify(message.uuid);
                        if (error)
                            return "uuid." + error;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.transition != null && message.hasOwnProperty("transition")) {
                        let error = $root.rv.data.Transition.verify(message.transition);
                        if (error)
                            return "transition." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Preset message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Transition.Preset
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Transition.Preset} Preset
                 */
                Preset.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Transition.Preset)
                        return object;
                    let message = new $root.rv.data.Transition.Preset();
                    if (object.uuid != null) {
                        if (typeof object.uuid !== "object")
                            throw TypeError(".rv.data.Transition.Preset.uuid: object expected");
                        message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.transition != null) {
                        if (typeof object.transition !== "object")
                            throw TypeError(".rv.data.Transition.Preset.transition: object expected");
                        message.transition = $root.rv.data.Transition.fromObject(object.transition);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Preset message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Transition.Preset
                 * @static
                 * @param {rv.data.Transition.Preset} message Preset
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Preset.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.uuid = null;
                        object.name = "";
                        object.transition = null;
                    }
                    if (message.uuid != null && message.hasOwnProperty("uuid"))
                        object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.transition != null && message.hasOwnProperty("transition"))
                        object.transition = $root.rv.data.Transition.toObject(message.transition, options);
                    return object;
                };

                /**
                 * Converts this Preset to JSON.
                 * @function toJSON
                 * @memberof rv.data.Transition.Preset
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Preset.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Preset
                 * @function getTypeUrl
                 * @memberof rv.data.Transition.Preset
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Preset.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Transition.Preset";
                };

                return Preset;
            })();

            return Transition;
        })();

        data.UUID = (function() {

            /**
             * Properties of a UUID.
             * @memberof rv.data
             * @interface IUUID
             * @property {string|null} [string] UUID string
             */

            /**
             * Constructs a new UUID.
             * @memberof rv.data
             * @classdesc Represents a UUID.
             * @implements IUUID
             * @constructor
             * @param {rv.data.IUUID=} [properties] Properties to set
             */
            function UUID(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UUID string.
             * @member {string} string
             * @memberof rv.data.UUID
             * @instance
             */
            UUID.prototype.string = "";

            /**
             * Creates a new UUID instance using the specified properties.
             * @function create
             * @memberof rv.data.UUID
             * @static
             * @param {rv.data.IUUID=} [properties] Properties to set
             * @returns {rv.data.UUID} UUID instance
             */
            UUID.create = function create(properties) {
                return new UUID(properties);
            };

            /**
             * Encodes the specified UUID message. Does not implicitly {@link rv.data.UUID.verify|verify} messages.
             * @function encode
             * @memberof rv.data.UUID
             * @static
             * @param {rv.data.IUUID} message UUID message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UUID.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.string != null && Object.hasOwnProperty.call(message, "string"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.string);
                return writer;
            };

            /**
             * Encodes the specified UUID message, length delimited. Does not implicitly {@link rv.data.UUID.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.UUID
             * @static
             * @param {rv.data.IUUID} message UUID message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UUID.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UUID message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.UUID
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.UUID} UUID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UUID.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.UUID();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.string = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UUID message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.UUID
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.UUID} UUID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UUID.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UUID message.
             * @function verify
             * @memberof rv.data.UUID
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UUID.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.string != null && message.hasOwnProperty("string"))
                    if (!$util.isString(message.string))
                        return "string: string expected";
                return null;
            };

            /**
             * Creates a UUID message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.UUID
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.UUID} UUID
             */
            UUID.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.UUID)
                    return object;
                let message = new $root.rv.data.UUID();
                if (object.string != null)
                    message.string = String(object.string);
                return message;
            };

            /**
             * Creates a plain object from a UUID message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.UUID
             * @static
             * @param {rv.data.UUID} message UUID
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UUID.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.string = "";
                if (message.string != null && message.hasOwnProperty("string"))
                    object.string = message.string;
                return object;
            };

            /**
             * Converts this UUID to JSON.
             * @function toJSON
             * @memberof rv.data.UUID
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UUID.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UUID
             * @function getTypeUrl
             * @memberof rv.data.UUID
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UUID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.UUID";
            };

            return UUID;
        })();

        data.FileProperties = (function() {

            /**
             * Properties of a FileProperties.
             * @memberof rv.data
             * @interface IFileProperties
             * @property {rv.data.IURL|null} [localUrl] FileProperties localUrl
             * @property {rv.data.FileProperties.IRemoteProperties|null} [remoteProperties] FileProperties remoteProperties
             */

            /**
             * Constructs a new FileProperties.
             * @memberof rv.data
             * @classdesc Represents a FileProperties.
             * @implements IFileProperties
             * @constructor
             * @param {rv.data.IFileProperties=} [properties] Properties to set
             */
            function FileProperties(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileProperties localUrl.
             * @member {rv.data.IURL|null|undefined} localUrl
             * @memberof rv.data.FileProperties
             * @instance
             */
            FileProperties.prototype.localUrl = null;

            /**
             * FileProperties remoteProperties.
             * @member {rv.data.FileProperties.IRemoteProperties|null|undefined} remoteProperties
             * @memberof rv.data.FileProperties
             * @instance
             */
            FileProperties.prototype.remoteProperties = null;

            /**
             * Creates a new FileProperties instance using the specified properties.
             * @function create
             * @memberof rv.data.FileProperties
             * @static
             * @param {rv.data.IFileProperties=} [properties] Properties to set
             * @returns {rv.data.FileProperties} FileProperties instance
             */
            FileProperties.create = function create(properties) {
                return new FileProperties(properties);
            };

            /**
             * Encodes the specified FileProperties message. Does not implicitly {@link rv.data.FileProperties.verify|verify} messages.
             * @function encode
             * @memberof rv.data.FileProperties
             * @static
             * @param {rv.data.IFileProperties} message FileProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileProperties.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.localUrl != null && Object.hasOwnProperty.call(message, "localUrl"))
                    $root.rv.data.URL.encode(message.localUrl, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.remoteProperties != null && Object.hasOwnProperty.call(message, "remoteProperties"))
                    $root.rv.data.FileProperties.RemoteProperties.encode(message.remoteProperties, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileProperties message, length delimited. Does not implicitly {@link rv.data.FileProperties.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.FileProperties
             * @static
             * @param {rv.data.IFileProperties} message FileProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileProperties.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileProperties message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.FileProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.FileProperties} FileProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileProperties.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.FileProperties();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.localUrl = $root.rv.data.URL.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.remoteProperties = $root.rv.data.FileProperties.RemoteProperties.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileProperties message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.FileProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.FileProperties} FileProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileProperties.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileProperties message.
             * @function verify
             * @memberof rv.data.FileProperties
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileProperties.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.localUrl != null && message.hasOwnProperty("localUrl")) {
                    let error = $root.rv.data.URL.verify(message.localUrl);
                    if (error)
                        return "localUrl." + error;
                }
                if (message.remoteProperties != null && message.hasOwnProperty("remoteProperties")) {
                    let error = $root.rv.data.FileProperties.RemoteProperties.verify(message.remoteProperties);
                    if (error)
                        return "remoteProperties." + error;
                }
                return null;
            };

            /**
             * Creates a FileProperties message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.FileProperties
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.FileProperties} FileProperties
             */
            FileProperties.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.FileProperties)
                    return object;
                let message = new $root.rv.data.FileProperties();
                if (object.localUrl != null) {
                    if (typeof object.localUrl !== "object")
                        throw TypeError(".rv.data.FileProperties.localUrl: object expected");
                    message.localUrl = $root.rv.data.URL.fromObject(object.localUrl);
                }
                if (object.remoteProperties != null) {
                    if (typeof object.remoteProperties !== "object")
                        throw TypeError(".rv.data.FileProperties.remoteProperties: object expected");
                    message.remoteProperties = $root.rv.data.FileProperties.RemoteProperties.fromObject(object.remoteProperties);
                }
                return message;
            };

            /**
             * Creates a plain object from a FileProperties message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.FileProperties
             * @static
             * @param {rv.data.FileProperties} message FileProperties
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileProperties.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.localUrl = null;
                    object.remoteProperties = null;
                }
                if (message.localUrl != null && message.hasOwnProperty("localUrl"))
                    object.localUrl = $root.rv.data.URL.toObject(message.localUrl, options);
                if (message.remoteProperties != null && message.hasOwnProperty("remoteProperties"))
                    object.remoteProperties = $root.rv.data.FileProperties.RemoteProperties.toObject(message.remoteProperties, options);
                return object;
            };

            /**
             * Converts this FileProperties to JSON.
             * @function toJSON
             * @memberof rv.data.FileProperties
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileProperties.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FileProperties
             * @function getTypeUrl
             * @memberof rv.data.FileProperties
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.FileProperties";
            };

            FileProperties.RemoteProperties = (function() {

                /**
                 * Properties of a RemoteProperties.
                 * @memberof rv.data.FileProperties
                 * @interface IRemoteProperties
                 * @property {rv.data.FileProperties.RemoteProperties.IProContent|null} [procontent] RemoteProperties procontent
                 */

                /**
                 * Constructs a new RemoteProperties.
                 * @memberof rv.data.FileProperties
                 * @classdesc Represents a RemoteProperties.
                 * @implements IRemoteProperties
                 * @constructor
                 * @param {rv.data.FileProperties.IRemoteProperties=} [properties] Properties to set
                 */
                function RemoteProperties(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RemoteProperties procontent.
                 * @member {rv.data.FileProperties.RemoteProperties.IProContent|null|undefined} procontent
                 * @memberof rv.data.FileProperties.RemoteProperties
                 * @instance
                 */
                RemoteProperties.prototype.procontent = null;

                /**
                 * Creates a new RemoteProperties instance using the specified properties.
                 * @function create
                 * @memberof rv.data.FileProperties.RemoteProperties
                 * @static
                 * @param {rv.data.FileProperties.IRemoteProperties=} [properties] Properties to set
                 * @returns {rv.data.FileProperties.RemoteProperties} RemoteProperties instance
                 */
                RemoteProperties.create = function create(properties) {
                    return new RemoteProperties(properties);
                };

                /**
                 * Encodes the specified RemoteProperties message. Does not implicitly {@link rv.data.FileProperties.RemoteProperties.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.FileProperties.RemoteProperties
                 * @static
                 * @param {rv.data.FileProperties.IRemoteProperties} message RemoteProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RemoteProperties.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.procontent != null && Object.hasOwnProperty.call(message, "procontent"))
                        $root.rv.data.FileProperties.RemoteProperties.ProContent.encode(message.procontent, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RemoteProperties message, length delimited. Does not implicitly {@link rv.data.FileProperties.RemoteProperties.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.FileProperties.RemoteProperties
                 * @static
                 * @param {rv.data.FileProperties.IRemoteProperties} message RemoteProperties message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RemoteProperties.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RemoteProperties message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.FileProperties.RemoteProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.FileProperties.RemoteProperties} RemoteProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RemoteProperties.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.FileProperties.RemoteProperties();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.procontent = $root.rv.data.FileProperties.RemoteProperties.ProContent.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RemoteProperties message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.FileProperties.RemoteProperties
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.FileProperties.RemoteProperties} RemoteProperties
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RemoteProperties.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RemoteProperties message.
                 * @function verify
                 * @memberof rv.data.FileProperties.RemoteProperties
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RemoteProperties.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.procontent != null && message.hasOwnProperty("procontent")) {
                        let error = $root.rv.data.FileProperties.RemoteProperties.ProContent.verify(message.procontent);
                        if (error)
                            return "procontent." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RemoteProperties message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.FileProperties.RemoteProperties
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.FileProperties.RemoteProperties} RemoteProperties
                 */
                RemoteProperties.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.FileProperties.RemoteProperties)
                        return object;
                    let message = new $root.rv.data.FileProperties.RemoteProperties();
                    if (object.procontent != null) {
                        if (typeof object.procontent !== "object")
                            throw TypeError(".rv.data.FileProperties.RemoteProperties.procontent: object expected");
                        message.procontent = $root.rv.data.FileProperties.RemoteProperties.ProContent.fromObject(object.procontent);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RemoteProperties message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.FileProperties.RemoteProperties
                 * @static
                 * @param {rv.data.FileProperties.RemoteProperties} message RemoteProperties
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RemoteProperties.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.procontent = null;
                    if (message.procontent != null && message.hasOwnProperty("procontent"))
                        object.procontent = $root.rv.data.FileProperties.RemoteProperties.ProContent.toObject(message.procontent, options);
                    return object;
                };

                /**
                 * Converts this RemoteProperties to JSON.
                 * @function toJSON
                 * @memberof rv.data.FileProperties.RemoteProperties
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RemoteProperties.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for RemoteProperties
                 * @function getTypeUrl
                 * @memberof rv.data.FileProperties.RemoteProperties
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                RemoteProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.FileProperties.RemoteProperties";
                };

                RemoteProperties.ProContent = (function() {

                    /**
                     * Properties of a ProContent.
                     * @memberof rv.data.FileProperties.RemoteProperties
                     * @interface IProContent
                     * @property {string|null} [downloadIdentifier] ProContent downloadIdentifier
                     */

                    /**
                     * Constructs a new ProContent.
                     * @memberof rv.data.FileProperties.RemoteProperties
                     * @classdesc Represents a ProContent.
                     * @implements IProContent
                     * @constructor
                     * @param {rv.data.FileProperties.RemoteProperties.IProContent=} [properties] Properties to set
                     */
                    function ProContent(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ProContent downloadIdentifier.
                     * @member {string} downloadIdentifier
                     * @memberof rv.data.FileProperties.RemoteProperties.ProContent
                     * @instance
                     */
                    ProContent.prototype.downloadIdentifier = "";

                    /**
                     * Creates a new ProContent instance using the specified properties.
                     * @function create
                     * @memberof rv.data.FileProperties.RemoteProperties.ProContent
                     * @static
                     * @param {rv.data.FileProperties.RemoteProperties.IProContent=} [properties] Properties to set
                     * @returns {rv.data.FileProperties.RemoteProperties.ProContent} ProContent instance
                     */
                    ProContent.create = function create(properties) {
                        return new ProContent(properties);
                    };

                    /**
                     * Encodes the specified ProContent message. Does not implicitly {@link rv.data.FileProperties.RemoteProperties.ProContent.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.FileProperties.RemoteProperties.ProContent
                     * @static
                     * @param {rv.data.FileProperties.RemoteProperties.IProContent} message ProContent message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ProContent.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.downloadIdentifier != null && Object.hasOwnProperty.call(message, "downloadIdentifier"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.downloadIdentifier);
                        return writer;
                    };

                    /**
                     * Encodes the specified ProContent message, length delimited. Does not implicitly {@link rv.data.FileProperties.RemoteProperties.ProContent.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.FileProperties.RemoteProperties.ProContent
                     * @static
                     * @param {rv.data.FileProperties.RemoteProperties.IProContent} message ProContent message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ProContent.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ProContent message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.FileProperties.RemoteProperties.ProContent
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.FileProperties.RemoteProperties.ProContent} ProContent
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ProContent.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.FileProperties.RemoteProperties.ProContent();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.downloadIdentifier = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ProContent message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.FileProperties.RemoteProperties.ProContent
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.FileProperties.RemoteProperties.ProContent} ProContent
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ProContent.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ProContent message.
                     * @function verify
                     * @memberof rv.data.FileProperties.RemoteProperties.ProContent
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ProContent.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.downloadIdentifier != null && message.hasOwnProperty("downloadIdentifier"))
                            if (!$util.isString(message.downloadIdentifier))
                                return "downloadIdentifier: string expected";
                        return null;
                    };

                    /**
                     * Creates a ProContent message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.FileProperties.RemoteProperties.ProContent
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.FileProperties.RemoteProperties.ProContent} ProContent
                     */
                    ProContent.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.FileProperties.RemoteProperties.ProContent)
                            return object;
                        let message = new $root.rv.data.FileProperties.RemoteProperties.ProContent();
                        if (object.downloadIdentifier != null)
                            message.downloadIdentifier = String(object.downloadIdentifier);
                        return message;
                    };

                    /**
                     * Creates a plain object from a ProContent message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.FileProperties.RemoteProperties.ProContent
                     * @static
                     * @param {rv.data.FileProperties.RemoteProperties.ProContent} message ProContent
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ProContent.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.downloadIdentifier = "";
                        if (message.downloadIdentifier != null && message.hasOwnProperty("downloadIdentifier"))
                            object.downloadIdentifier = message.downloadIdentifier;
                        return object;
                    };

                    /**
                     * Converts this ProContent to JSON.
                     * @function toJSON
                     * @memberof rv.data.FileProperties.RemoteProperties.ProContent
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ProContent.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ProContent
                     * @function getTypeUrl
                     * @memberof rv.data.FileProperties.RemoteProperties.ProContent
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ProContent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.FileProperties.RemoteProperties.ProContent";
                    };

                    return ProContent;
                })();

                return RemoteProperties;
            })();

            return FileProperties;
        })();

        data.URL = (function() {

            /**
             * Properties of a URL.
             * @memberof rv.data
             * @interface IURL
             * @property {rv.data.URL.Platform|null} [platform] URL platform
             * @property {string|null} [absoluteString] URL absoluteString
             * @property {string|null} [relativePath] URL relativePath
             * @property {rv.data.URL.ILocalRelativePath|null} [local] URL local
             * @property {rv.data.URL.IExternalRelativePath|null} [external] URL external
             */

            /**
             * Constructs a new URL.
             * @memberof rv.data
             * @classdesc Represents a URL.
             * @implements IURL
             * @constructor
             * @param {rv.data.IURL=} [properties] Properties to set
             */
            function URL(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * URL platform.
             * @member {rv.data.URL.Platform} platform
             * @memberof rv.data.URL
             * @instance
             */
            URL.prototype.platform = 0;

            /**
             * URL absoluteString.
             * @member {string|null|undefined} absoluteString
             * @memberof rv.data.URL
             * @instance
             */
            URL.prototype.absoluteString = null;

            /**
             * URL relativePath.
             * @member {string|null|undefined} relativePath
             * @memberof rv.data.URL
             * @instance
             */
            URL.prototype.relativePath = null;

            /**
             * URL local.
             * @member {rv.data.URL.ILocalRelativePath|null|undefined} local
             * @memberof rv.data.URL
             * @instance
             */
            URL.prototype.local = null;

            /**
             * URL external.
             * @member {rv.data.URL.IExternalRelativePath|null|undefined} external
             * @memberof rv.data.URL
             * @instance
             */
            URL.prototype.external = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * URL Storage.
             * @member {"absoluteString"|"relativePath"|undefined} Storage
             * @memberof rv.data.URL
             * @instance
             */
            Object.defineProperty(URL.prototype, "Storage", {
                get: $util.oneOfGetter($oneOfFields = ["absoluteString", "relativePath"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * URL RelativeFilePath.
             * @member {"local"|"external"|undefined} RelativeFilePath
             * @memberof rv.data.URL
             * @instance
             */
            Object.defineProperty(URL.prototype, "RelativeFilePath", {
                get: $util.oneOfGetter($oneOfFields = ["local", "external"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new URL instance using the specified properties.
             * @function create
             * @memberof rv.data.URL
             * @static
             * @param {rv.data.IURL=} [properties] Properties to set
             * @returns {rv.data.URL} URL instance
             */
            URL.create = function create(properties) {
                return new URL(properties);
            };

            /**
             * Encodes the specified URL message. Does not implicitly {@link rv.data.URL.verify|verify} messages.
             * @function encode
             * @memberof rv.data.URL
             * @static
             * @param {rv.data.IURL} message URL message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            URL.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.absoluteString != null && Object.hasOwnProperty.call(message, "absoluteString"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.absoluteString);
                if (message.relativePath != null && Object.hasOwnProperty.call(message, "relativePath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.relativePath);
                if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.platform);
                if (message.local != null && Object.hasOwnProperty.call(message, "local"))
                    $root.rv.data.URL.LocalRelativePath.encode(message.local, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.external != null && Object.hasOwnProperty.call(message, "external"))
                    $root.rv.data.URL.ExternalRelativePath.encode(message.external, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified URL message, length delimited. Does not implicitly {@link rv.data.URL.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.URL
             * @static
             * @param {rv.data.IURL} message URL message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            URL.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a URL message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.URL
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.URL} URL
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            URL.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.URL();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 3: {
                            message.platform = reader.int32();
                            break;
                        }
                    case 1: {
                            message.absoluteString = reader.string();
                            break;
                        }
                    case 2: {
                            message.relativePath = reader.string();
                            break;
                        }
                    case 4: {
                            message.local = $root.rv.data.URL.LocalRelativePath.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.external = $root.rv.data.URL.ExternalRelativePath.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a URL message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.URL
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.URL} URL
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            URL.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a URL message.
             * @function verify
             * @memberof rv.data.URL
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            URL.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.platform != null && message.hasOwnProperty("platform"))
                    switch (message.platform) {
                    default:
                        return "platform: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.absoluteString != null && message.hasOwnProperty("absoluteString")) {
                    properties.Storage = 1;
                    if (!$util.isString(message.absoluteString))
                        return "absoluteString: string expected";
                }
                if (message.relativePath != null && message.hasOwnProperty("relativePath")) {
                    if (properties.Storage === 1)
                        return "Storage: multiple values";
                    properties.Storage = 1;
                    if (!$util.isString(message.relativePath))
                        return "relativePath: string expected";
                }
                if (message.local != null && message.hasOwnProperty("local")) {
                    properties.RelativeFilePath = 1;
                    {
                        let error = $root.rv.data.URL.LocalRelativePath.verify(message.local);
                        if (error)
                            return "local." + error;
                    }
                }
                if (message.external != null && message.hasOwnProperty("external")) {
                    if (properties.RelativeFilePath === 1)
                        return "RelativeFilePath: multiple values";
                    properties.RelativeFilePath = 1;
                    {
                        let error = $root.rv.data.URL.ExternalRelativePath.verify(message.external);
                        if (error)
                            return "external." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a URL message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.URL
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.URL} URL
             */
            URL.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.URL)
                    return object;
                let message = new $root.rv.data.URL();
                switch (object.platform) {
                default:
                    if (typeof object.platform === "number") {
                        message.platform = object.platform;
                        break;
                    }
                    break;
                case "PLATFORM_UNKNOWN":
                case 0:
                    message.platform = 0;
                    break;
                case "PLATFORM_MACOS":
                case 1:
                    message.platform = 1;
                    break;
                case "PLATFORM_WIN32":
                case 2:
                    message.platform = 2;
                    break;
                case "PLATFORM_WEB":
                case 3:
                    message.platform = 3;
                    break;
                }
                if (object.absoluteString != null)
                    message.absoluteString = String(object.absoluteString);
                if (object.relativePath != null)
                    message.relativePath = String(object.relativePath);
                if (object.local != null) {
                    if (typeof object.local !== "object")
                        throw TypeError(".rv.data.URL.local: object expected");
                    message.local = $root.rv.data.URL.LocalRelativePath.fromObject(object.local);
                }
                if (object.external != null) {
                    if (typeof object.external !== "object")
                        throw TypeError(".rv.data.URL.external: object expected");
                    message.external = $root.rv.data.URL.ExternalRelativePath.fromObject(object.external);
                }
                return message;
            };

            /**
             * Creates a plain object from a URL message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.URL
             * @static
             * @param {rv.data.URL} message URL
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            URL.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.platform = options.enums === String ? "PLATFORM_UNKNOWN" : 0;
                if (message.absoluteString != null && message.hasOwnProperty("absoluteString")) {
                    object.absoluteString = message.absoluteString;
                    if (options.oneofs)
                        object.Storage = "absoluteString";
                }
                if (message.relativePath != null && message.hasOwnProperty("relativePath")) {
                    object.relativePath = message.relativePath;
                    if (options.oneofs)
                        object.Storage = "relativePath";
                }
                if (message.platform != null && message.hasOwnProperty("platform"))
                    object.platform = options.enums === String ? $root.rv.data.URL.Platform[message.platform] === undefined ? message.platform : $root.rv.data.URL.Platform[message.platform] : message.platform;
                if (message.local != null && message.hasOwnProperty("local")) {
                    object.local = $root.rv.data.URL.LocalRelativePath.toObject(message.local, options);
                    if (options.oneofs)
                        object.RelativeFilePath = "local";
                }
                if (message.external != null && message.hasOwnProperty("external")) {
                    object.external = $root.rv.data.URL.ExternalRelativePath.toObject(message.external, options);
                    if (options.oneofs)
                        object.RelativeFilePath = "external";
                }
                return object;
            };

            /**
             * Converts this URL to JSON.
             * @function toJSON
             * @memberof rv.data.URL
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            URL.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for URL
             * @function getTypeUrl
             * @memberof rv.data.URL
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            URL.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.URL";
            };

            URL.LocalRelativePath = (function() {

                /**
                 * Properties of a LocalRelativePath.
                 * @memberof rv.data.URL
                 * @interface ILocalRelativePath
                 * @property {rv.data.URL.LocalRelativePath.Root|null} [root] LocalRelativePath root
                 * @property {string|null} [path] LocalRelativePath path
                 */

                /**
                 * Constructs a new LocalRelativePath.
                 * @memberof rv.data.URL
                 * @classdesc Represents a LocalRelativePath.
                 * @implements ILocalRelativePath
                 * @constructor
                 * @param {rv.data.URL.ILocalRelativePath=} [properties] Properties to set
                 */
                function LocalRelativePath(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LocalRelativePath root.
                 * @member {rv.data.URL.LocalRelativePath.Root} root
                 * @memberof rv.data.URL.LocalRelativePath
                 * @instance
                 */
                LocalRelativePath.prototype.root = 0;

                /**
                 * LocalRelativePath path.
                 * @member {string} path
                 * @memberof rv.data.URL.LocalRelativePath
                 * @instance
                 */
                LocalRelativePath.prototype.path = "";

                /**
                 * Creates a new LocalRelativePath instance using the specified properties.
                 * @function create
                 * @memberof rv.data.URL.LocalRelativePath
                 * @static
                 * @param {rv.data.URL.ILocalRelativePath=} [properties] Properties to set
                 * @returns {rv.data.URL.LocalRelativePath} LocalRelativePath instance
                 */
                LocalRelativePath.create = function create(properties) {
                    return new LocalRelativePath(properties);
                };

                /**
                 * Encodes the specified LocalRelativePath message. Does not implicitly {@link rv.data.URL.LocalRelativePath.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.URL.LocalRelativePath
                 * @static
                 * @param {rv.data.URL.ILocalRelativePath} message LocalRelativePath message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LocalRelativePath.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.root != null && Object.hasOwnProperty.call(message, "root"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.root);
                    if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                    return writer;
                };

                /**
                 * Encodes the specified LocalRelativePath message, length delimited. Does not implicitly {@link rv.data.URL.LocalRelativePath.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.URL.LocalRelativePath
                 * @static
                 * @param {rv.data.URL.ILocalRelativePath} message LocalRelativePath message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LocalRelativePath.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LocalRelativePath message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.URL.LocalRelativePath
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.URL.LocalRelativePath} LocalRelativePath
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LocalRelativePath.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.URL.LocalRelativePath();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.root = reader.int32();
                                break;
                            }
                        case 2: {
                                message.path = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LocalRelativePath message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.URL.LocalRelativePath
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.URL.LocalRelativePath} LocalRelativePath
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LocalRelativePath.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LocalRelativePath message.
                 * @function verify
                 * @memberof rv.data.URL.LocalRelativePath
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LocalRelativePath.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.root != null && message.hasOwnProperty("root"))
                        switch (message.root) {
                        default:
                            return "root: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 11:
                        case 8:
                        case 9:
                        case 10:
                        case 12:
                            break;
                        }
                    if (message.path != null && message.hasOwnProperty("path"))
                        if (!$util.isString(message.path))
                            return "path: string expected";
                    return null;
                };

                /**
                 * Creates a LocalRelativePath message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.URL.LocalRelativePath
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.URL.LocalRelativePath} LocalRelativePath
                 */
                LocalRelativePath.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.URL.LocalRelativePath)
                        return object;
                    let message = new $root.rv.data.URL.LocalRelativePath();
                    switch (object.root) {
                    default:
                        if (typeof object.root === "number") {
                            message.root = object.root;
                            break;
                        }
                        break;
                    case "ROOT_UNKNOWN":
                    case 0:
                        message.root = 0;
                        break;
                    case "ROOT_BOOT_VOLUME":
                    case 1:
                        message.root = 1;
                        break;
                    case "ROOT_USER_HOME":
                    case 2:
                        message.root = 2;
                        break;
                    case "ROOT_USER_DOCUMENTS":
                    case 3:
                        message.root = 3;
                        break;
                    case "ROOT_USER_DOWNLOADS":
                    case 4:
                        message.root = 4;
                        break;
                    case "ROOT_USER_MUSIC":
                    case 5:
                        message.root = 5;
                        break;
                    case "ROOT_USER_PICTURES":
                    case 6:
                        message.root = 6;
                        break;
                    case "ROOT_USER_VIDEOS":
                    case 7:
                        message.root = 7;
                        break;
                    case "ROOT_USER_DESKTOP":
                    case 11:
                        message.root = 11;
                        break;
                    case "ROOT_USER_APP_SUPPORT":
                    case 8:
                        message.root = 8;
                        break;
                    case "ROOT_SHARED":
                    case 9:
                        message.root = 9;
                        break;
                    case "ROOT_SHOW":
                    case 10:
                        message.root = 10;
                        break;
                    case "ROOT_CURRENT_RESOURCE":
                    case 12:
                        message.root = 12;
                        break;
                    }
                    if (object.path != null)
                        message.path = String(object.path);
                    return message;
                };

                /**
                 * Creates a plain object from a LocalRelativePath message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.URL.LocalRelativePath
                 * @static
                 * @param {rv.data.URL.LocalRelativePath} message LocalRelativePath
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LocalRelativePath.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.root = options.enums === String ? "ROOT_UNKNOWN" : 0;
                        object.path = "";
                    }
                    if (message.root != null && message.hasOwnProperty("root"))
                        object.root = options.enums === String ? $root.rv.data.URL.LocalRelativePath.Root[message.root] === undefined ? message.root : $root.rv.data.URL.LocalRelativePath.Root[message.root] : message.root;
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = message.path;
                    return object;
                };

                /**
                 * Converts this LocalRelativePath to JSON.
                 * @function toJSON
                 * @memberof rv.data.URL.LocalRelativePath
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LocalRelativePath.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for LocalRelativePath
                 * @function getTypeUrl
                 * @memberof rv.data.URL.LocalRelativePath
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                LocalRelativePath.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.URL.LocalRelativePath";
                };

                /**
                 * Root enum.
                 * @name rv.data.URL.LocalRelativePath.Root
                 * @enum {number}
                 * @property {number} ROOT_UNKNOWN=0 ROOT_UNKNOWN value
                 * @property {number} ROOT_BOOT_VOLUME=1 ROOT_BOOT_VOLUME value
                 * @property {number} ROOT_USER_HOME=2 ROOT_USER_HOME value
                 * @property {number} ROOT_USER_DOCUMENTS=3 ROOT_USER_DOCUMENTS value
                 * @property {number} ROOT_USER_DOWNLOADS=4 ROOT_USER_DOWNLOADS value
                 * @property {number} ROOT_USER_MUSIC=5 ROOT_USER_MUSIC value
                 * @property {number} ROOT_USER_PICTURES=6 ROOT_USER_PICTURES value
                 * @property {number} ROOT_USER_VIDEOS=7 ROOT_USER_VIDEOS value
                 * @property {number} ROOT_USER_DESKTOP=11 ROOT_USER_DESKTOP value
                 * @property {number} ROOT_USER_APP_SUPPORT=8 ROOT_USER_APP_SUPPORT value
                 * @property {number} ROOT_SHARED=9 ROOT_SHARED value
                 * @property {number} ROOT_SHOW=10 ROOT_SHOW value
                 * @property {number} ROOT_CURRENT_RESOURCE=12 ROOT_CURRENT_RESOURCE value
                 */
                LocalRelativePath.Root = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ROOT_UNKNOWN"] = 0;
                    values[valuesById[1] = "ROOT_BOOT_VOLUME"] = 1;
                    values[valuesById[2] = "ROOT_USER_HOME"] = 2;
                    values[valuesById[3] = "ROOT_USER_DOCUMENTS"] = 3;
                    values[valuesById[4] = "ROOT_USER_DOWNLOADS"] = 4;
                    values[valuesById[5] = "ROOT_USER_MUSIC"] = 5;
                    values[valuesById[6] = "ROOT_USER_PICTURES"] = 6;
                    values[valuesById[7] = "ROOT_USER_VIDEOS"] = 7;
                    values[valuesById[11] = "ROOT_USER_DESKTOP"] = 11;
                    values[valuesById[8] = "ROOT_USER_APP_SUPPORT"] = 8;
                    values[valuesById[9] = "ROOT_SHARED"] = 9;
                    values[valuesById[10] = "ROOT_SHOW"] = 10;
                    values[valuesById[12] = "ROOT_CURRENT_RESOURCE"] = 12;
                    return values;
                })();

                return LocalRelativePath;
            })();

            URL.ExternalRelativePath = (function() {

                /**
                 * Properties of an ExternalRelativePath.
                 * @memberof rv.data.URL
                 * @interface IExternalRelativePath
                 * @property {rv.data.URL.ExternalRelativePath.IMacOSExternalVolume|null} [macos] ExternalRelativePath macos
                 * @property {rv.data.URL.ExternalRelativePath.IWin32ExternalVolume|null} [win32] ExternalRelativePath win32
                 * @property {string|null} [path] ExternalRelativePath path
                 */

                /**
                 * Constructs a new ExternalRelativePath.
                 * @memberof rv.data.URL
                 * @classdesc Represents an ExternalRelativePath.
                 * @implements IExternalRelativePath
                 * @constructor
                 * @param {rv.data.URL.IExternalRelativePath=} [properties] Properties to set
                 */
                function ExternalRelativePath(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExternalRelativePath macos.
                 * @member {rv.data.URL.ExternalRelativePath.IMacOSExternalVolume|null|undefined} macos
                 * @memberof rv.data.URL.ExternalRelativePath
                 * @instance
                 */
                ExternalRelativePath.prototype.macos = null;

                /**
                 * ExternalRelativePath win32.
                 * @member {rv.data.URL.ExternalRelativePath.IWin32ExternalVolume|null|undefined} win32
                 * @memberof rv.data.URL.ExternalRelativePath
                 * @instance
                 */
                ExternalRelativePath.prototype.win32 = null;

                /**
                 * ExternalRelativePath path.
                 * @member {string} path
                 * @memberof rv.data.URL.ExternalRelativePath
                 * @instance
                 */
                ExternalRelativePath.prototype.path = "";

                /**
                 * Creates a new ExternalRelativePath instance using the specified properties.
                 * @function create
                 * @memberof rv.data.URL.ExternalRelativePath
                 * @static
                 * @param {rv.data.URL.IExternalRelativePath=} [properties] Properties to set
                 * @returns {rv.data.URL.ExternalRelativePath} ExternalRelativePath instance
                 */
                ExternalRelativePath.create = function create(properties) {
                    return new ExternalRelativePath(properties);
                };

                /**
                 * Encodes the specified ExternalRelativePath message. Does not implicitly {@link rv.data.URL.ExternalRelativePath.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.URL.ExternalRelativePath
                 * @static
                 * @param {rv.data.URL.IExternalRelativePath} message ExternalRelativePath message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExternalRelativePath.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.macos != null && Object.hasOwnProperty.call(message, "macos"))
                        $root.rv.data.URL.ExternalRelativePath.MacOSExternalVolume.encode(message.macos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.win32 != null && Object.hasOwnProperty.call(message, "win32"))
                        $root.rv.data.URL.ExternalRelativePath.Win32ExternalVolume.encode(message.win32, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.path);
                    return writer;
                };

                /**
                 * Encodes the specified ExternalRelativePath message, length delimited. Does not implicitly {@link rv.data.URL.ExternalRelativePath.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.URL.ExternalRelativePath
                 * @static
                 * @param {rv.data.URL.IExternalRelativePath} message ExternalRelativePath message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExternalRelativePath.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExternalRelativePath message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.URL.ExternalRelativePath
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.URL.ExternalRelativePath} ExternalRelativePath
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExternalRelativePath.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.URL.ExternalRelativePath();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.macos = $root.rv.data.URL.ExternalRelativePath.MacOSExternalVolume.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.win32 = $root.rv.data.URL.ExternalRelativePath.Win32ExternalVolume.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.path = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExternalRelativePath message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.URL.ExternalRelativePath
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.URL.ExternalRelativePath} ExternalRelativePath
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExternalRelativePath.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExternalRelativePath message.
                 * @function verify
                 * @memberof rv.data.URL.ExternalRelativePath
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExternalRelativePath.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.macos != null && message.hasOwnProperty("macos")) {
                        let error = $root.rv.data.URL.ExternalRelativePath.MacOSExternalVolume.verify(message.macos);
                        if (error)
                            return "macos." + error;
                    }
                    if (message.win32 != null && message.hasOwnProperty("win32")) {
                        let error = $root.rv.data.URL.ExternalRelativePath.Win32ExternalVolume.verify(message.win32);
                        if (error)
                            return "win32." + error;
                    }
                    if (message.path != null && message.hasOwnProperty("path"))
                        if (!$util.isString(message.path))
                            return "path: string expected";
                    return null;
                };

                /**
                 * Creates an ExternalRelativePath message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.URL.ExternalRelativePath
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.URL.ExternalRelativePath} ExternalRelativePath
                 */
                ExternalRelativePath.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.URL.ExternalRelativePath)
                        return object;
                    let message = new $root.rv.data.URL.ExternalRelativePath();
                    if (object.macos != null) {
                        if (typeof object.macos !== "object")
                            throw TypeError(".rv.data.URL.ExternalRelativePath.macos: object expected");
                        message.macos = $root.rv.data.URL.ExternalRelativePath.MacOSExternalVolume.fromObject(object.macos);
                    }
                    if (object.win32 != null) {
                        if (typeof object.win32 !== "object")
                            throw TypeError(".rv.data.URL.ExternalRelativePath.win32: object expected");
                        message.win32 = $root.rv.data.URL.ExternalRelativePath.Win32ExternalVolume.fromObject(object.win32);
                    }
                    if (object.path != null)
                        message.path = String(object.path);
                    return message;
                };

                /**
                 * Creates a plain object from an ExternalRelativePath message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.URL.ExternalRelativePath
                 * @static
                 * @param {rv.data.URL.ExternalRelativePath} message ExternalRelativePath
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExternalRelativePath.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.macos = null;
                        object.win32 = null;
                        object.path = "";
                    }
                    if (message.macos != null && message.hasOwnProperty("macos"))
                        object.macos = $root.rv.data.URL.ExternalRelativePath.MacOSExternalVolume.toObject(message.macos, options);
                    if (message.win32 != null && message.hasOwnProperty("win32"))
                        object.win32 = $root.rv.data.URL.ExternalRelativePath.Win32ExternalVolume.toObject(message.win32, options);
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = message.path;
                    return object;
                };

                /**
                 * Converts this ExternalRelativePath to JSON.
                 * @function toJSON
                 * @memberof rv.data.URL.ExternalRelativePath
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExternalRelativePath.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ExternalRelativePath
                 * @function getTypeUrl
                 * @memberof rv.data.URL.ExternalRelativePath
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ExternalRelativePath.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.URL.ExternalRelativePath";
                };

                ExternalRelativePath.MacOSExternalVolume = (function() {

                    /**
                     * Properties of a MacOSExternalVolume.
                     * @memberof rv.data.URL.ExternalRelativePath
                     * @interface IMacOSExternalVolume
                     * @property {string|null} [volumeName] MacOSExternalVolume volumeName
                     */

                    /**
                     * Constructs a new MacOSExternalVolume.
                     * @memberof rv.data.URL.ExternalRelativePath
                     * @classdesc Represents a MacOSExternalVolume.
                     * @implements IMacOSExternalVolume
                     * @constructor
                     * @param {rv.data.URL.ExternalRelativePath.IMacOSExternalVolume=} [properties] Properties to set
                     */
                    function MacOSExternalVolume(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MacOSExternalVolume volumeName.
                     * @member {string} volumeName
                     * @memberof rv.data.URL.ExternalRelativePath.MacOSExternalVolume
                     * @instance
                     */
                    MacOSExternalVolume.prototype.volumeName = "";

                    /**
                     * Creates a new MacOSExternalVolume instance using the specified properties.
                     * @function create
                     * @memberof rv.data.URL.ExternalRelativePath.MacOSExternalVolume
                     * @static
                     * @param {rv.data.URL.ExternalRelativePath.IMacOSExternalVolume=} [properties] Properties to set
                     * @returns {rv.data.URL.ExternalRelativePath.MacOSExternalVolume} MacOSExternalVolume instance
                     */
                    MacOSExternalVolume.create = function create(properties) {
                        return new MacOSExternalVolume(properties);
                    };

                    /**
                     * Encodes the specified MacOSExternalVolume message. Does not implicitly {@link rv.data.URL.ExternalRelativePath.MacOSExternalVolume.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.URL.ExternalRelativePath.MacOSExternalVolume
                     * @static
                     * @param {rv.data.URL.ExternalRelativePath.IMacOSExternalVolume} message MacOSExternalVolume message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MacOSExternalVolume.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.volumeName != null && Object.hasOwnProperty.call(message, "volumeName"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.volumeName);
                        return writer;
                    };

                    /**
                     * Encodes the specified MacOSExternalVolume message, length delimited. Does not implicitly {@link rv.data.URL.ExternalRelativePath.MacOSExternalVolume.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.URL.ExternalRelativePath.MacOSExternalVolume
                     * @static
                     * @param {rv.data.URL.ExternalRelativePath.IMacOSExternalVolume} message MacOSExternalVolume message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MacOSExternalVolume.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MacOSExternalVolume message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.URL.ExternalRelativePath.MacOSExternalVolume
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.URL.ExternalRelativePath.MacOSExternalVolume} MacOSExternalVolume
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MacOSExternalVolume.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.URL.ExternalRelativePath.MacOSExternalVolume();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.volumeName = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a MacOSExternalVolume message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.URL.ExternalRelativePath.MacOSExternalVolume
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.URL.ExternalRelativePath.MacOSExternalVolume} MacOSExternalVolume
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MacOSExternalVolume.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MacOSExternalVolume message.
                     * @function verify
                     * @memberof rv.data.URL.ExternalRelativePath.MacOSExternalVolume
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MacOSExternalVolume.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.volumeName != null && message.hasOwnProperty("volumeName"))
                            if (!$util.isString(message.volumeName))
                                return "volumeName: string expected";
                        return null;
                    };

                    /**
                     * Creates a MacOSExternalVolume message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.URL.ExternalRelativePath.MacOSExternalVolume
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.URL.ExternalRelativePath.MacOSExternalVolume} MacOSExternalVolume
                     */
                    MacOSExternalVolume.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.URL.ExternalRelativePath.MacOSExternalVolume)
                            return object;
                        let message = new $root.rv.data.URL.ExternalRelativePath.MacOSExternalVolume();
                        if (object.volumeName != null)
                            message.volumeName = String(object.volumeName);
                        return message;
                    };

                    /**
                     * Creates a plain object from a MacOSExternalVolume message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.URL.ExternalRelativePath.MacOSExternalVolume
                     * @static
                     * @param {rv.data.URL.ExternalRelativePath.MacOSExternalVolume} message MacOSExternalVolume
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MacOSExternalVolume.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.volumeName = "";
                        if (message.volumeName != null && message.hasOwnProperty("volumeName"))
                            object.volumeName = message.volumeName;
                        return object;
                    };

                    /**
                     * Converts this MacOSExternalVolume to JSON.
                     * @function toJSON
                     * @memberof rv.data.URL.ExternalRelativePath.MacOSExternalVolume
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MacOSExternalVolume.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for MacOSExternalVolume
                     * @function getTypeUrl
                     * @memberof rv.data.URL.ExternalRelativePath.MacOSExternalVolume
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    MacOSExternalVolume.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.URL.ExternalRelativePath.MacOSExternalVolume";
                    };

                    return MacOSExternalVolume;
                })();

                ExternalRelativePath.Win32ExternalVolume = (function() {

                    /**
                     * Properties of a Win32ExternalVolume.
                     * @memberof rv.data.URL.ExternalRelativePath
                     * @interface IWin32ExternalVolume
                     * @property {string|null} [driveLetter] Win32ExternalVolume driveLetter
                     * @property {string|null} [volumeName] Win32ExternalVolume volumeName
                     * @property {boolean|null} [networkShare] Win32ExternalVolume networkShare
                     */

                    /**
                     * Constructs a new Win32ExternalVolume.
                     * @memberof rv.data.URL.ExternalRelativePath
                     * @classdesc Represents a Win32ExternalVolume.
                     * @implements IWin32ExternalVolume
                     * @constructor
                     * @param {rv.data.URL.ExternalRelativePath.IWin32ExternalVolume=} [properties] Properties to set
                     */
                    function Win32ExternalVolume(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Win32ExternalVolume driveLetter.
                     * @member {string} driveLetter
                     * @memberof rv.data.URL.ExternalRelativePath.Win32ExternalVolume
                     * @instance
                     */
                    Win32ExternalVolume.prototype.driveLetter = "";

                    /**
                     * Win32ExternalVolume volumeName.
                     * @member {string} volumeName
                     * @memberof rv.data.URL.ExternalRelativePath.Win32ExternalVolume
                     * @instance
                     */
                    Win32ExternalVolume.prototype.volumeName = "";

                    /**
                     * Win32ExternalVolume networkShare.
                     * @member {boolean} networkShare
                     * @memberof rv.data.URL.ExternalRelativePath.Win32ExternalVolume
                     * @instance
                     */
                    Win32ExternalVolume.prototype.networkShare = false;

                    /**
                     * Creates a new Win32ExternalVolume instance using the specified properties.
                     * @function create
                     * @memberof rv.data.URL.ExternalRelativePath.Win32ExternalVolume
                     * @static
                     * @param {rv.data.URL.ExternalRelativePath.IWin32ExternalVolume=} [properties] Properties to set
                     * @returns {rv.data.URL.ExternalRelativePath.Win32ExternalVolume} Win32ExternalVolume instance
                     */
                    Win32ExternalVolume.create = function create(properties) {
                        return new Win32ExternalVolume(properties);
                    };

                    /**
                     * Encodes the specified Win32ExternalVolume message. Does not implicitly {@link rv.data.URL.ExternalRelativePath.Win32ExternalVolume.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.URL.ExternalRelativePath.Win32ExternalVolume
                     * @static
                     * @param {rv.data.URL.ExternalRelativePath.IWin32ExternalVolume} message Win32ExternalVolume message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Win32ExternalVolume.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.driveLetter != null && Object.hasOwnProperty.call(message, "driveLetter"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.driveLetter);
                        if (message.volumeName != null && Object.hasOwnProperty.call(message, "volumeName"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.volumeName);
                        if (message.networkShare != null && Object.hasOwnProperty.call(message, "networkShare"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.networkShare);
                        return writer;
                    };

                    /**
                     * Encodes the specified Win32ExternalVolume message, length delimited. Does not implicitly {@link rv.data.URL.ExternalRelativePath.Win32ExternalVolume.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.URL.ExternalRelativePath.Win32ExternalVolume
                     * @static
                     * @param {rv.data.URL.ExternalRelativePath.IWin32ExternalVolume} message Win32ExternalVolume message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Win32ExternalVolume.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Win32ExternalVolume message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.URL.ExternalRelativePath.Win32ExternalVolume
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.URL.ExternalRelativePath.Win32ExternalVolume} Win32ExternalVolume
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Win32ExternalVolume.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.URL.ExternalRelativePath.Win32ExternalVolume();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.driveLetter = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.volumeName = reader.string();
                                    break;
                                }
                            case 3: {
                                    message.networkShare = reader.bool();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Win32ExternalVolume message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.URL.ExternalRelativePath.Win32ExternalVolume
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.URL.ExternalRelativePath.Win32ExternalVolume} Win32ExternalVolume
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Win32ExternalVolume.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Win32ExternalVolume message.
                     * @function verify
                     * @memberof rv.data.URL.ExternalRelativePath.Win32ExternalVolume
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Win32ExternalVolume.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.driveLetter != null && message.hasOwnProperty("driveLetter"))
                            if (!$util.isString(message.driveLetter))
                                return "driveLetter: string expected";
                        if (message.volumeName != null && message.hasOwnProperty("volumeName"))
                            if (!$util.isString(message.volumeName))
                                return "volumeName: string expected";
                        if (message.networkShare != null && message.hasOwnProperty("networkShare"))
                            if (typeof message.networkShare !== "boolean")
                                return "networkShare: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a Win32ExternalVolume message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.URL.ExternalRelativePath.Win32ExternalVolume
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.URL.ExternalRelativePath.Win32ExternalVolume} Win32ExternalVolume
                     */
                    Win32ExternalVolume.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.URL.ExternalRelativePath.Win32ExternalVolume)
                            return object;
                        let message = new $root.rv.data.URL.ExternalRelativePath.Win32ExternalVolume();
                        if (object.driveLetter != null)
                            message.driveLetter = String(object.driveLetter);
                        if (object.volumeName != null)
                            message.volumeName = String(object.volumeName);
                        if (object.networkShare != null)
                            message.networkShare = Boolean(object.networkShare);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Win32ExternalVolume message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.URL.ExternalRelativePath.Win32ExternalVolume
                     * @static
                     * @param {rv.data.URL.ExternalRelativePath.Win32ExternalVolume} message Win32ExternalVolume
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Win32ExternalVolume.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.driveLetter = "";
                            object.volumeName = "";
                            object.networkShare = false;
                        }
                        if (message.driveLetter != null && message.hasOwnProperty("driveLetter"))
                            object.driveLetter = message.driveLetter;
                        if (message.volumeName != null && message.hasOwnProperty("volumeName"))
                            object.volumeName = message.volumeName;
                        if (message.networkShare != null && message.hasOwnProperty("networkShare"))
                            object.networkShare = message.networkShare;
                        return object;
                    };

                    /**
                     * Converts this Win32ExternalVolume to JSON.
                     * @function toJSON
                     * @memberof rv.data.URL.ExternalRelativePath.Win32ExternalVolume
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Win32ExternalVolume.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Win32ExternalVolume
                     * @function getTypeUrl
                     * @memberof rv.data.URL.ExternalRelativePath.Win32ExternalVolume
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Win32ExternalVolume.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.URL.ExternalRelativePath.Win32ExternalVolume";
                    };

                    return Win32ExternalVolume;
                })();

                return ExternalRelativePath;
            })();

            /**
             * Platform enum.
             * @name rv.data.URL.Platform
             * @enum {number}
             * @property {number} PLATFORM_UNKNOWN=0 PLATFORM_UNKNOWN value
             * @property {number} PLATFORM_MACOS=1 PLATFORM_MACOS value
             * @property {number} PLATFORM_WIN32=2 PLATFORM_WIN32 value
             * @property {number} PLATFORM_WEB=3 PLATFORM_WEB value
             */
            URL.Platform = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "PLATFORM_UNKNOWN"] = 0;
                values[valuesById[1] = "PLATFORM_MACOS"] = 1;
                values[valuesById[2] = "PLATFORM_WIN32"] = 2;
                values[valuesById[3] = "PLATFORM_WEB"] = 3;
                return values;
            })();

            return URL;
        })();

        data.URLs = (function() {

            /**
             * Properties of a URLs.
             * @memberof rv.data
             * @interface IURLs
             * @property {Array.<rv.data.IURL>|null} [urls] URLs urls
             */

            /**
             * Constructs a new URLs.
             * @memberof rv.data
             * @classdesc Represents a URLs.
             * @implements IURLs
             * @constructor
             * @param {rv.data.IURLs=} [properties] Properties to set
             */
            function URLs(properties) {
                this.urls = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * URLs urls.
             * @member {Array.<rv.data.IURL>} urls
             * @memberof rv.data.URLs
             * @instance
             */
            URLs.prototype.urls = $util.emptyArray;

            /**
             * Creates a new URLs instance using the specified properties.
             * @function create
             * @memberof rv.data.URLs
             * @static
             * @param {rv.data.IURLs=} [properties] Properties to set
             * @returns {rv.data.URLs} URLs instance
             */
            URLs.create = function create(properties) {
                return new URLs(properties);
            };

            /**
             * Encodes the specified URLs message. Does not implicitly {@link rv.data.URLs.verify|verify} messages.
             * @function encode
             * @memberof rv.data.URLs
             * @static
             * @param {rv.data.IURLs} message URLs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            URLs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.urls != null && message.urls.length)
                    for (let i = 0; i < message.urls.length; ++i)
                        $root.rv.data.URL.encode(message.urls[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified URLs message, length delimited. Does not implicitly {@link rv.data.URLs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.URLs
             * @static
             * @param {rv.data.IURLs} message URLs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            URLs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a URLs message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.URLs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.URLs} URLs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            URLs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.URLs();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.urls && message.urls.length))
                                message.urls = [];
                            message.urls.push($root.rv.data.URL.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a URLs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.URLs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.URLs} URLs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            URLs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a URLs message.
             * @function verify
             * @memberof rv.data.URLs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            URLs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.urls != null && message.hasOwnProperty("urls")) {
                    if (!Array.isArray(message.urls))
                        return "urls: array expected";
                    for (let i = 0; i < message.urls.length; ++i) {
                        let error = $root.rv.data.URL.verify(message.urls[i]);
                        if (error)
                            return "urls." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a URLs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.URLs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.URLs} URLs
             */
            URLs.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.URLs)
                    return object;
                let message = new $root.rv.data.URLs();
                if (object.urls) {
                    if (!Array.isArray(object.urls))
                        throw TypeError(".rv.data.URLs.urls: array expected");
                    message.urls = [];
                    for (let i = 0; i < object.urls.length; ++i) {
                        if (typeof object.urls[i] !== "object")
                            throw TypeError(".rv.data.URLs.urls: object expected");
                        message.urls[i] = $root.rv.data.URL.fromObject(object.urls[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a URLs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.URLs
             * @static
             * @param {rv.data.URLs} message URLs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            URLs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.urls = [];
                if (message.urls && message.urls.length) {
                    object.urls = [];
                    for (let j = 0; j < message.urls.length; ++j)
                        object.urls[j] = $root.rv.data.URL.toObject(message.urls[j], options);
                }
                return object;
            };

            /**
             * Converts this URLs to JSON.
             * @function toJSON
             * @memberof rv.data.URLs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            URLs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for URLs
             * @function getTypeUrl
             * @memberof rv.data.URLs
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            URLs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.URLs";
            };

            return URLs;
        })();

        data.Font = (function() {

            /**
             * Properties of a Font.
             * @memberof rv.data
             * @interface IFont
             * @property {string|null} [name] Font name
             * @property {number|null} [size] Font size
             * @property {boolean|null} [italic] Font italic
             * @property {boolean|null} [bold] Font bold
             * @property {string|null} [family] Font family
             * @property {string|null} [face] Font face
             */

            /**
             * Constructs a new Font.
             * @memberof rv.data
             * @classdesc Represents a Font.
             * @implements IFont
             * @constructor
             * @param {rv.data.IFont=} [properties] Properties to set
             */
            function Font(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Font name.
             * @member {string} name
             * @memberof rv.data.Font
             * @instance
             */
            Font.prototype.name = "";

            /**
             * Font size.
             * @member {number} size
             * @memberof rv.data.Font
             * @instance
             */
            Font.prototype.size = 0;

            /**
             * Font italic.
             * @member {boolean} italic
             * @memberof rv.data.Font
             * @instance
             */
            Font.prototype.italic = false;

            /**
             * Font bold.
             * @member {boolean} bold
             * @memberof rv.data.Font
             * @instance
             */
            Font.prototype.bold = false;

            /**
             * Font family.
             * @member {string} family
             * @memberof rv.data.Font
             * @instance
             */
            Font.prototype.family = "";

            /**
             * Font face.
             * @member {string} face
             * @memberof rv.data.Font
             * @instance
             */
            Font.prototype.face = "";

            /**
             * Creates a new Font instance using the specified properties.
             * @function create
             * @memberof rv.data.Font
             * @static
             * @param {rv.data.IFont=} [properties] Properties to set
             * @returns {rv.data.Font} Font instance
             */
            Font.create = function create(properties) {
                return new Font(properties);
            };

            /**
             * Encodes the specified Font message. Does not implicitly {@link rv.data.Font.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Font
             * @static
             * @param {rv.data.IFont} message Font message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Font.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.size);
                if (message.italic != null && Object.hasOwnProperty.call(message, "italic"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.italic);
                if (message.bold != null && Object.hasOwnProperty.call(message, "bold"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.bold);
                if (message.family != null && Object.hasOwnProperty.call(message, "family"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.family);
                if (message.face != null && Object.hasOwnProperty.call(message, "face"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.face);
                return writer;
            };

            /**
             * Encodes the specified Font message, length delimited. Does not implicitly {@link rv.data.Font.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Font
             * @static
             * @param {rv.data.IFont} message Font message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Font.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Font message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Font
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Font} Font
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Font.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Font();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.size = reader.double();
                            break;
                        }
                    case 4: {
                            message.italic = reader.bool();
                            break;
                        }
                    case 8: {
                            message.bold = reader.bool();
                            break;
                        }
                    case 9: {
                            message.family = reader.string();
                            break;
                        }
                    case 10: {
                            message.face = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Font message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Font
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Font} Font
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Font.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Font message.
             * @function verify
             * @memberof rv.data.Font
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Font.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.size != null && message.hasOwnProperty("size"))
                    if (typeof message.size !== "number")
                        return "size: number expected";
                if (message.italic != null && message.hasOwnProperty("italic"))
                    if (typeof message.italic !== "boolean")
                        return "italic: boolean expected";
                if (message.bold != null && message.hasOwnProperty("bold"))
                    if (typeof message.bold !== "boolean")
                        return "bold: boolean expected";
                if (message.family != null && message.hasOwnProperty("family"))
                    if (!$util.isString(message.family))
                        return "family: string expected";
                if (message.face != null && message.hasOwnProperty("face"))
                    if (!$util.isString(message.face))
                        return "face: string expected";
                return null;
            };

            /**
             * Creates a Font message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Font
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Font} Font
             */
            Font.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Font)
                    return object;
                let message = new $root.rv.data.Font();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.size != null)
                    message.size = Number(object.size);
                if (object.italic != null)
                    message.italic = Boolean(object.italic);
                if (object.bold != null)
                    message.bold = Boolean(object.bold);
                if (object.family != null)
                    message.family = String(object.family);
                if (object.face != null)
                    message.face = String(object.face);
                return message;
            };

            /**
             * Creates a plain object from a Font message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Font
             * @static
             * @param {rv.data.Font} message Font
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Font.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.size = 0;
                    object.italic = false;
                    object.bold = false;
                    object.family = "";
                    object.face = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.size != null && message.hasOwnProperty("size"))
                    object.size = options.json && !isFinite(message.size) ? String(message.size) : message.size;
                if (message.italic != null && message.hasOwnProperty("italic"))
                    object.italic = message.italic;
                if (message.bold != null && message.hasOwnProperty("bold"))
                    object.bold = message.bold;
                if (message.family != null && message.hasOwnProperty("family"))
                    object.family = message.family;
                if (message.face != null && message.hasOwnProperty("face"))
                    object.face = message.face;
                return object;
            };

            /**
             * Converts this Font to JSON.
             * @function toJSON
             * @memberof rv.data.Font
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Font.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Font
             * @function getTypeUrl
             * @memberof rv.data.Font
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Font.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Font";
            };

            return Font;
        })();

        data.IntRange = (function() {

            /**
             * Properties of an IntRange.
             * @memberof rv.data
             * @interface IIntRange
             * @property {number|null} [start] IntRange start
             * @property {number|null} [end] IntRange end
             */

            /**
             * Constructs a new IntRange.
             * @memberof rv.data
             * @classdesc Represents an IntRange.
             * @implements IIntRange
             * @constructor
             * @param {rv.data.IIntRange=} [properties] Properties to set
             */
            function IntRange(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IntRange start.
             * @member {number} start
             * @memberof rv.data.IntRange
             * @instance
             */
            IntRange.prototype.start = 0;

            /**
             * IntRange end.
             * @member {number} end
             * @memberof rv.data.IntRange
             * @instance
             */
            IntRange.prototype.end = 0;

            /**
             * Creates a new IntRange instance using the specified properties.
             * @function create
             * @memberof rv.data.IntRange
             * @static
             * @param {rv.data.IIntRange=} [properties] Properties to set
             * @returns {rv.data.IntRange} IntRange instance
             */
            IntRange.create = function create(properties) {
                return new IntRange(properties);
            };

            /**
             * Encodes the specified IntRange message. Does not implicitly {@link rv.data.IntRange.verify|verify} messages.
             * @function encode
             * @memberof rv.data.IntRange
             * @static
             * @param {rv.data.IIntRange} message IntRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IntRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                return writer;
            };

            /**
             * Encodes the specified IntRange message, length delimited. Does not implicitly {@link rv.data.IntRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.IntRange
             * @static
             * @param {rv.data.IIntRange} message IntRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IntRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IntRange message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.IntRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.IntRange} IntRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IntRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.IntRange();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.start = reader.int32();
                            break;
                        }
                    case 2: {
                            message.end = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IntRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.IntRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.IntRange} IntRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IntRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IntRange message.
             * @function verify
             * @memberof rv.data.IntRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IntRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.start != null && message.hasOwnProperty("start"))
                    if (!$util.isInteger(message.start))
                        return "start: integer expected";
                if (message.end != null && message.hasOwnProperty("end"))
                    if (!$util.isInteger(message.end))
                        return "end: integer expected";
                return null;
            };

            /**
             * Creates an IntRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.IntRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.IntRange} IntRange
             */
            IntRange.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.IntRange)
                    return object;
                let message = new $root.rv.data.IntRange();
                if (object.start != null)
                    message.start = object.start | 0;
                if (object.end != null)
                    message.end = object.end | 0;
                return message;
            };

            /**
             * Creates a plain object from an IntRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.IntRange
             * @static
             * @param {rv.data.IntRange} message IntRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IntRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.start = 0;
                    object.end = 0;
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    object.start = message.start;
                if (message.end != null && message.hasOwnProperty("end"))
                    object.end = message.end;
                return object;
            };

            /**
             * Converts this IntRange to JSON.
             * @function toJSON
             * @memberof rv.data.IntRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IntRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for IntRange
             * @function getTypeUrl
             * @memberof rv.data.IntRange
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            IntRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.IntRange";
            };

            return IntRange;
        })();

        data.CollectionElementType = (function() {

            /**
             * Properties of a CollectionElementType.
             * @memberof rv.data
             * @interface ICollectionElementType
             * @property {rv.data.IUUID|null} [parameterUuid] CollectionElementType parameterUuid
             * @property {string|null} [parameterName] CollectionElementType parameterName
             * @property {rv.data.ICollectionElementType|null} [parentCollection] CollectionElementType parentCollection
             */

            /**
             * Constructs a new CollectionElementType.
             * @memberof rv.data
             * @classdesc Represents a CollectionElementType.
             * @implements ICollectionElementType
             * @constructor
             * @param {rv.data.ICollectionElementType=} [properties] Properties to set
             */
            function CollectionElementType(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CollectionElementType parameterUuid.
             * @member {rv.data.IUUID|null|undefined} parameterUuid
             * @memberof rv.data.CollectionElementType
             * @instance
             */
            CollectionElementType.prototype.parameterUuid = null;

            /**
             * CollectionElementType parameterName.
             * @member {string} parameterName
             * @memberof rv.data.CollectionElementType
             * @instance
             */
            CollectionElementType.prototype.parameterName = "";

            /**
             * CollectionElementType parentCollection.
             * @member {rv.data.ICollectionElementType|null|undefined} parentCollection
             * @memberof rv.data.CollectionElementType
             * @instance
             */
            CollectionElementType.prototype.parentCollection = null;

            /**
             * Creates a new CollectionElementType instance using the specified properties.
             * @function create
             * @memberof rv.data.CollectionElementType
             * @static
             * @param {rv.data.ICollectionElementType=} [properties] Properties to set
             * @returns {rv.data.CollectionElementType} CollectionElementType instance
             */
            CollectionElementType.create = function create(properties) {
                return new CollectionElementType(properties);
            };

            /**
             * Encodes the specified CollectionElementType message. Does not implicitly {@link rv.data.CollectionElementType.verify|verify} messages.
             * @function encode
             * @memberof rv.data.CollectionElementType
             * @static
             * @param {rv.data.ICollectionElementType} message CollectionElementType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionElementType.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.parameterUuid != null && Object.hasOwnProperty.call(message, "parameterUuid"))
                    $root.rv.data.UUID.encode(message.parameterUuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.parameterName != null && Object.hasOwnProperty.call(message, "parameterName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.parameterName);
                if (message.parentCollection != null && Object.hasOwnProperty.call(message, "parentCollection"))
                    $root.rv.data.CollectionElementType.encode(message.parentCollection, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CollectionElementType message, length delimited. Does not implicitly {@link rv.data.CollectionElementType.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.CollectionElementType
             * @static
             * @param {rv.data.ICollectionElementType} message CollectionElementType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionElementType.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CollectionElementType message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.CollectionElementType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.CollectionElementType} CollectionElementType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionElementType.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.CollectionElementType();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.parameterUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.parameterName = reader.string();
                            break;
                        }
                    case 3: {
                            message.parentCollection = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CollectionElementType message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.CollectionElementType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.CollectionElementType} CollectionElementType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionElementType.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CollectionElementType message.
             * @function verify
             * @memberof rv.data.CollectionElementType
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionElementType.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.parameterUuid != null && message.hasOwnProperty("parameterUuid")) {
                    let error = $root.rv.data.UUID.verify(message.parameterUuid);
                    if (error)
                        return "parameterUuid." + error;
                }
                if (message.parameterName != null && message.hasOwnProperty("parameterName"))
                    if (!$util.isString(message.parameterName))
                        return "parameterName: string expected";
                if (message.parentCollection != null && message.hasOwnProperty("parentCollection")) {
                    let error = $root.rv.data.CollectionElementType.verify(message.parentCollection);
                    if (error)
                        return "parentCollection." + error;
                }
                return null;
            };

            /**
             * Creates a CollectionElementType message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.CollectionElementType
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.CollectionElementType} CollectionElementType
             */
            CollectionElementType.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.CollectionElementType)
                    return object;
                let message = new $root.rv.data.CollectionElementType();
                if (object.parameterUuid != null) {
                    if (typeof object.parameterUuid !== "object")
                        throw TypeError(".rv.data.CollectionElementType.parameterUuid: object expected");
                    message.parameterUuid = $root.rv.data.UUID.fromObject(object.parameterUuid);
                }
                if (object.parameterName != null)
                    message.parameterName = String(object.parameterName);
                if (object.parentCollection != null) {
                    if (typeof object.parentCollection !== "object")
                        throw TypeError(".rv.data.CollectionElementType.parentCollection: object expected");
                    message.parentCollection = $root.rv.data.CollectionElementType.fromObject(object.parentCollection);
                }
                return message;
            };

            /**
             * Creates a plain object from a CollectionElementType message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.CollectionElementType
             * @static
             * @param {rv.data.CollectionElementType} message CollectionElementType
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionElementType.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.parameterUuid = null;
                    object.parameterName = "";
                    object.parentCollection = null;
                }
                if (message.parameterUuid != null && message.hasOwnProperty("parameterUuid"))
                    object.parameterUuid = $root.rv.data.UUID.toObject(message.parameterUuid, options);
                if (message.parameterName != null && message.hasOwnProperty("parameterName"))
                    object.parameterName = message.parameterName;
                if (message.parentCollection != null && message.hasOwnProperty("parentCollection"))
                    object.parentCollection = $root.rv.data.CollectionElementType.toObject(message.parentCollection, options);
                return object;
            };

            /**
             * Converts this CollectionElementType to JSON.
             * @function toJSON
             * @memberof rv.data.CollectionElementType
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionElementType.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CollectionElementType
             * @function getTypeUrl
             * @memberof rv.data.CollectionElementType
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CollectionElementType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.CollectionElementType";
            };

            return CollectionElementType;
        })();

        data.VideoInput = (function() {

            /**
             * Properties of a VideoInput.
             * @memberof rv.data
             * @interface IVideoInput
             * @property {rv.data.IUUID|null} [uuid] VideoInput uuid
             * @property {string|null} [userDescription] VideoInput userDescription
             * @property {rv.data.Media.IVideoDevice|null} [videoInputDevice] VideoInput videoInputDevice
             * @property {rv.data.IColor|null} [displayColor] VideoInput displayColor
             * @property {rv.data.IURL|null} [thumbnailPath] VideoInput thumbnailPath
             * @property {rv.data.VideoInput.AudioDeviceType|null} [audioType] VideoInput audioType
             * @property {rv.data.AlphaType|null} [alphaType] VideoInput alphaType
             * @property {rv.data.DigitalAudio.IDevice|null} [audioDevice] VideoInput audioDevice
             * @property {rv.data.Media.IVideoDevice|null} [videoDevice] VideoInput videoDevice
             */

            /**
             * Constructs a new VideoInput.
             * @memberof rv.data
             * @classdesc Represents a VideoInput.
             * @implements IVideoInput
             * @constructor
             * @param {rv.data.IVideoInput=} [properties] Properties to set
             */
            function VideoInput(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VideoInput uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.VideoInput
             * @instance
             */
            VideoInput.prototype.uuid = null;

            /**
             * VideoInput userDescription.
             * @member {string} userDescription
             * @memberof rv.data.VideoInput
             * @instance
             */
            VideoInput.prototype.userDescription = "";

            /**
             * VideoInput videoInputDevice.
             * @member {rv.data.Media.IVideoDevice|null|undefined} videoInputDevice
             * @memberof rv.data.VideoInput
             * @instance
             */
            VideoInput.prototype.videoInputDevice = null;

            /**
             * VideoInput displayColor.
             * @member {rv.data.IColor|null|undefined} displayColor
             * @memberof rv.data.VideoInput
             * @instance
             */
            VideoInput.prototype.displayColor = null;

            /**
             * VideoInput thumbnailPath.
             * @member {rv.data.IURL|null|undefined} thumbnailPath
             * @memberof rv.data.VideoInput
             * @instance
             */
            VideoInput.prototype.thumbnailPath = null;

            /**
             * VideoInput audioType.
             * @member {rv.data.VideoInput.AudioDeviceType} audioType
             * @memberof rv.data.VideoInput
             * @instance
             */
            VideoInput.prototype.audioType = 0;

            /**
             * VideoInput alphaType.
             * @member {rv.data.AlphaType} alphaType
             * @memberof rv.data.VideoInput
             * @instance
             */
            VideoInput.prototype.alphaType = 0;

            /**
             * VideoInput audioDevice.
             * @member {rv.data.DigitalAudio.IDevice|null|undefined} audioDevice
             * @memberof rv.data.VideoInput
             * @instance
             */
            VideoInput.prototype.audioDevice = null;

            /**
             * VideoInput videoDevice.
             * @member {rv.data.Media.IVideoDevice|null|undefined} videoDevice
             * @memberof rv.data.VideoInput
             * @instance
             */
            VideoInput.prototype.videoDevice = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * VideoInput AltAudioSource.
             * @member {"audioDevice"|"videoDevice"|undefined} AltAudioSource
             * @memberof rv.data.VideoInput
             * @instance
             */
            Object.defineProperty(VideoInput.prototype, "AltAudioSource", {
                get: $util.oneOfGetter($oneOfFields = ["audioDevice", "videoDevice"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new VideoInput instance using the specified properties.
             * @function create
             * @memberof rv.data.VideoInput
             * @static
             * @param {rv.data.IVideoInput=} [properties] Properties to set
             * @returns {rv.data.VideoInput} VideoInput instance
             */
            VideoInput.create = function create(properties) {
                return new VideoInput(properties);
            };

            /**
             * Encodes the specified VideoInput message. Does not implicitly {@link rv.data.VideoInput.verify|verify} messages.
             * @function encode
             * @memberof rv.data.VideoInput
             * @static
             * @param {rv.data.IVideoInput} message VideoInput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VideoInput.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.userDescription != null && Object.hasOwnProperty.call(message, "userDescription"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.userDescription);
                if (message.videoInputDevice != null && Object.hasOwnProperty.call(message, "videoInputDevice"))
                    $root.rv.data.Media.VideoDevice.encode(message.videoInputDevice, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.displayColor != null && Object.hasOwnProperty.call(message, "displayColor"))
                    $root.rv.data.Color.encode(message.displayColor, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.thumbnailPath != null && Object.hasOwnProperty.call(message, "thumbnailPath"))
                    $root.rv.data.URL.encode(message.thumbnailPath, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.audioDevice != null && Object.hasOwnProperty.call(message, "audioDevice"))
                    $root.rv.data.DigitalAudio.Device.encode(message.audioDevice, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.videoDevice != null && Object.hasOwnProperty.call(message, "videoDevice"))
                    $root.rv.data.Media.VideoDevice.encode(message.videoDevice, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.audioType != null && Object.hasOwnProperty.call(message, "audioType"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.audioType);
                if (message.alphaType != null && Object.hasOwnProperty.call(message, "alphaType"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.alphaType);
                return writer;
            };

            /**
             * Encodes the specified VideoInput message, length delimited. Does not implicitly {@link rv.data.VideoInput.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.VideoInput
             * @static
             * @param {rv.data.IVideoInput} message VideoInput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VideoInput.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VideoInput message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.VideoInput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.VideoInput} VideoInput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VideoInput.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.VideoInput();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.userDescription = reader.string();
                            break;
                        }
                    case 3: {
                            message.videoInputDevice = $root.rv.data.Media.VideoDevice.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.displayColor = $root.rv.data.Color.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.thumbnailPath = $root.rv.data.URL.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.audioType = reader.int32();
                            break;
                        }
                    case 9: {
                            message.alphaType = reader.int32();
                            break;
                        }
                    case 6: {
                            message.audioDevice = $root.rv.data.DigitalAudio.Device.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.videoDevice = $root.rv.data.Media.VideoDevice.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VideoInput message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.VideoInput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.VideoInput} VideoInput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VideoInput.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VideoInput message.
             * @function verify
             * @memberof rv.data.VideoInput
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VideoInput.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                if (message.userDescription != null && message.hasOwnProperty("userDescription"))
                    if (!$util.isString(message.userDescription))
                        return "userDescription: string expected";
                if (message.videoInputDevice != null && message.hasOwnProperty("videoInputDevice")) {
                    let error = $root.rv.data.Media.VideoDevice.verify(message.videoInputDevice);
                    if (error)
                        return "videoInputDevice." + error;
                }
                if (message.displayColor != null && message.hasOwnProperty("displayColor")) {
                    let error = $root.rv.data.Color.verify(message.displayColor);
                    if (error)
                        return "displayColor." + error;
                }
                if (message.thumbnailPath != null && message.hasOwnProperty("thumbnailPath")) {
                    let error = $root.rv.data.URL.verify(message.thumbnailPath);
                    if (error)
                        return "thumbnailPath." + error;
                }
                if (message.audioType != null && message.hasOwnProperty("audioType"))
                    switch (message.audioType) {
                    default:
                        return "audioType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.alphaType != null && message.hasOwnProperty("alphaType"))
                    switch (message.alphaType) {
                    default:
                        return "alphaType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.audioDevice != null && message.hasOwnProperty("audioDevice")) {
                    properties.AltAudioSource = 1;
                    {
                        let error = $root.rv.data.DigitalAudio.Device.verify(message.audioDevice);
                        if (error)
                            return "audioDevice." + error;
                    }
                }
                if (message.videoDevice != null && message.hasOwnProperty("videoDevice")) {
                    if (properties.AltAudioSource === 1)
                        return "AltAudioSource: multiple values";
                    properties.AltAudioSource = 1;
                    {
                        let error = $root.rv.data.Media.VideoDevice.verify(message.videoDevice);
                        if (error)
                            return "videoDevice." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a VideoInput message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.VideoInput
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.VideoInput} VideoInput
             */
            VideoInput.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.VideoInput)
                    return object;
                let message = new $root.rv.data.VideoInput();
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.VideoInput.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                if (object.userDescription != null)
                    message.userDescription = String(object.userDescription);
                if (object.videoInputDevice != null) {
                    if (typeof object.videoInputDevice !== "object")
                        throw TypeError(".rv.data.VideoInput.videoInputDevice: object expected");
                    message.videoInputDevice = $root.rv.data.Media.VideoDevice.fromObject(object.videoInputDevice);
                }
                if (object.displayColor != null) {
                    if (typeof object.displayColor !== "object")
                        throw TypeError(".rv.data.VideoInput.displayColor: object expected");
                    message.displayColor = $root.rv.data.Color.fromObject(object.displayColor);
                }
                if (object.thumbnailPath != null) {
                    if (typeof object.thumbnailPath !== "object")
                        throw TypeError(".rv.data.VideoInput.thumbnailPath: object expected");
                    message.thumbnailPath = $root.rv.data.URL.fromObject(object.thumbnailPath);
                }
                switch (object.audioType) {
                default:
                    if (typeof object.audioType === "number") {
                        message.audioType = object.audioType;
                        break;
                    }
                    break;
                case "AUDIO_DEVICE_TYPE_DEFAULT":
                case 0:
                    message.audioType = 0;
                    break;
                case "AUDIO_DEVICE_TYPE_NONE":
                case 1:
                    message.audioType = 1;
                    break;
                case "AUDIO_DEVICE_TYPE_ALTERNATE":
                case 2:
                    message.audioType = 2;
                    break;
                }
                switch (object.alphaType) {
                default:
                    if (typeof object.alphaType === "number") {
                        message.alphaType = object.alphaType;
                        break;
                    }
                    break;
                case "ALPHA_TYPE_UNKNOWN":
                case 0:
                    message.alphaType = 0;
                    break;
                case "ALPHA_TYPE_STRAIGHT":
                case 1:
                    message.alphaType = 1;
                    break;
                case "ALPHA_TYPE_PREMULTIPLIED":
                case 2:
                    message.alphaType = 2;
                    break;
                }
                if (object.audioDevice != null) {
                    if (typeof object.audioDevice !== "object")
                        throw TypeError(".rv.data.VideoInput.audioDevice: object expected");
                    message.audioDevice = $root.rv.data.DigitalAudio.Device.fromObject(object.audioDevice);
                }
                if (object.videoDevice != null) {
                    if (typeof object.videoDevice !== "object")
                        throw TypeError(".rv.data.VideoInput.videoDevice: object expected");
                    message.videoDevice = $root.rv.data.Media.VideoDevice.fromObject(object.videoDevice);
                }
                return message;
            };

            /**
             * Creates a plain object from a VideoInput message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.VideoInput
             * @static
             * @param {rv.data.VideoInput} message VideoInput
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VideoInput.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uuid = null;
                    object.userDescription = "";
                    object.videoInputDevice = null;
                    object.displayColor = null;
                    object.thumbnailPath = null;
                    object.audioType = options.enums === String ? "AUDIO_DEVICE_TYPE_DEFAULT" : 0;
                    object.alphaType = options.enums === String ? "ALPHA_TYPE_UNKNOWN" : 0;
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                if (message.userDescription != null && message.hasOwnProperty("userDescription"))
                    object.userDescription = message.userDescription;
                if (message.videoInputDevice != null && message.hasOwnProperty("videoInputDevice"))
                    object.videoInputDevice = $root.rv.data.Media.VideoDevice.toObject(message.videoInputDevice, options);
                if (message.displayColor != null && message.hasOwnProperty("displayColor"))
                    object.displayColor = $root.rv.data.Color.toObject(message.displayColor, options);
                if (message.thumbnailPath != null && message.hasOwnProperty("thumbnailPath"))
                    object.thumbnailPath = $root.rv.data.URL.toObject(message.thumbnailPath, options);
                if (message.audioDevice != null && message.hasOwnProperty("audioDevice")) {
                    object.audioDevice = $root.rv.data.DigitalAudio.Device.toObject(message.audioDevice, options);
                    if (options.oneofs)
                        object.AltAudioSource = "audioDevice";
                }
                if (message.videoDevice != null && message.hasOwnProperty("videoDevice")) {
                    object.videoDevice = $root.rv.data.Media.VideoDevice.toObject(message.videoDevice, options);
                    if (options.oneofs)
                        object.AltAudioSource = "videoDevice";
                }
                if (message.audioType != null && message.hasOwnProperty("audioType"))
                    object.audioType = options.enums === String ? $root.rv.data.VideoInput.AudioDeviceType[message.audioType] === undefined ? message.audioType : $root.rv.data.VideoInput.AudioDeviceType[message.audioType] : message.audioType;
                if (message.alphaType != null && message.hasOwnProperty("alphaType"))
                    object.alphaType = options.enums === String ? $root.rv.data.AlphaType[message.alphaType] === undefined ? message.alphaType : $root.rv.data.AlphaType[message.alphaType] : message.alphaType;
                return object;
            };

            /**
             * Converts this VideoInput to JSON.
             * @function toJSON
             * @memberof rv.data.VideoInput
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VideoInput.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VideoInput
             * @function getTypeUrl
             * @memberof rv.data.VideoInput
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VideoInput.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.VideoInput";
            };

            VideoInput.SettingsDocument = (function() {

                /**
                 * Properties of a SettingsDocument.
                 * @memberof rv.data.VideoInput
                 * @interface ISettingsDocument
                 * @property {Array.<rv.data.IVideoInput>|null} [inputs] SettingsDocument inputs
                 */

                /**
                 * Constructs a new SettingsDocument.
                 * @memberof rv.data.VideoInput
                 * @classdesc Represents a SettingsDocument.
                 * @implements ISettingsDocument
                 * @constructor
                 * @param {rv.data.VideoInput.ISettingsDocument=} [properties] Properties to set
                 */
                function SettingsDocument(properties) {
                    this.inputs = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SettingsDocument inputs.
                 * @member {Array.<rv.data.IVideoInput>} inputs
                 * @memberof rv.data.VideoInput.SettingsDocument
                 * @instance
                 */
                SettingsDocument.prototype.inputs = $util.emptyArray;

                /**
                 * Creates a new SettingsDocument instance using the specified properties.
                 * @function create
                 * @memberof rv.data.VideoInput.SettingsDocument
                 * @static
                 * @param {rv.data.VideoInput.ISettingsDocument=} [properties] Properties to set
                 * @returns {rv.data.VideoInput.SettingsDocument} SettingsDocument instance
                 */
                SettingsDocument.create = function create(properties) {
                    return new SettingsDocument(properties);
                };

                /**
                 * Encodes the specified SettingsDocument message. Does not implicitly {@link rv.data.VideoInput.SettingsDocument.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.VideoInput.SettingsDocument
                 * @static
                 * @param {rv.data.VideoInput.ISettingsDocument} message SettingsDocument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SettingsDocument.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputs != null && message.inputs.length)
                        for (let i = 0; i < message.inputs.length; ++i)
                            $root.rv.data.VideoInput.encode(message.inputs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SettingsDocument message, length delimited. Does not implicitly {@link rv.data.VideoInput.SettingsDocument.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.VideoInput.SettingsDocument
                 * @static
                 * @param {rv.data.VideoInput.ISettingsDocument} message SettingsDocument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SettingsDocument.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SettingsDocument message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.VideoInput.SettingsDocument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.VideoInput.SettingsDocument} SettingsDocument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SettingsDocument.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.VideoInput.SettingsDocument();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.inputs && message.inputs.length))
                                    message.inputs = [];
                                message.inputs.push($root.rv.data.VideoInput.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SettingsDocument message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.VideoInput.SettingsDocument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.VideoInput.SettingsDocument} SettingsDocument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SettingsDocument.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SettingsDocument message.
                 * @function verify
                 * @memberof rv.data.VideoInput.SettingsDocument
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SettingsDocument.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputs != null && message.hasOwnProperty("inputs")) {
                        if (!Array.isArray(message.inputs))
                            return "inputs: array expected";
                        for (let i = 0; i < message.inputs.length; ++i) {
                            let error = $root.rv.data.VideoInput.verify(message.inputs[i]);
                            if (error)
                                return "inputs." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SettingsDocument message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.VideoInput.SettingsDocument
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.VideoInput.SettingsDocument} SettingsDocument
                 */
                SettingsDocument.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.VideoInput.SettingsDocument)
                        return object;
                    let message = new $root.rv.data.VideoInput.SettingsDocument();
                    if (object.inputs) {
                        if (!Array.isArray(object.inputs))
                            throw TypeError(".rv.data.VideoInput.SettingsDocument.inputs: array expected");
                        message.inputs = [];
                        for (let i = 0; i < object.inputs.length; ++i) {
                            if (typeof object.inputs[i] !== "object")
                                throw TypeError(".rv.data.VideoInput.SettingsDocument.inputs: object expected");
                            message.inputs[i] = $root.rv.data.VideoInput.fromObject(object.inputs[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SettingsDocument message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.VideoInput.SettingsDocument
                 * @static
                 * @param {rv.data.VideoInput.SettingsDocument} message SettingsDocument
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SettingsDocument.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.inputs = [];
                    if (message.inputs && message.inputs.length) {
                        object.inputs = [];
                        for (let j = 0; j < message.inputs.length; ++j)
                            object.inputs[j] = $root.rv.data.VideoInput.toObject(message.inputs[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SettingsDocument to JSON.
                 * @function toJSON
                 * @memberof rv.data.VideoInput.SettingsDocument
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SettingsDocument.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SettingsDocument
                 * @function getTypeUrl
                 * @memberof rv.data.VideoInput.SettingsDocument
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SettingsDocument.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.VideoInput.SettingsDocument";
                };

                return SettingsDocument;
            })();

            /**
             * AudioDeviceType enum.
             * @name rv.data.VideoInput.AudioDeviceType
             * @enum {number}
             * @property {number} AUDIO_DEVICE_TYPE_DEFAULT=0 AUDIO_DEVICE_TYPE_DEFAULT value
             * @property {number} AUDIO_DEVICE_TYPE_NONE=1 AUDIO_DEVICE_TYPE_NONE value
             * @property {number} AUDIO_DEVICE_TYPE_ALTERNATE=2 AUDIO_DEVICE_TYPE_ALTERNATE value
             */
            VideoInput.AudioDeviceType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "AUDIO_DEVICE_TYPE_DEFAULT"] = 0;
                values[valuesById[1] = "AUDIO_DEVICE_TYPE_NONE"] = 1;
                values[valuesById[2] = "AUDIO_DEVICE_TYPE_ALTERNATE"] = 2;
                return values;
            })();

            return VideoInput;
        })();

        data.AudioInput = (function() {

            /**
             * Properties of an AudioInput.
             * @memberof rv.data
             * @interface IAudioInput
             * @property {rv.data.IUUID|null} [uuid] AudioInput uuid
             * @property {string|null} [userDescription] AudioInput userDescription
             * @property {rv.data.AudioInput.IBehaviorMode|null} [behaviorMode] AudioInput behaviorMode
             * @property {rv.data.DigitalAudio.IDevice|null} [audioDevice] AudioInput audioDevice
             * @property {rv.data.Media.IVideoDevice|null} [videoDevice] AudioInput videoDevice
             */

            /**
             * Constructs a new AudioInput.
             * @memberof rv.data
             * @classdesc Represents an AudioInput.
             * @implements IAudioInput
             * @constructor
             * @param {rv.data.IAudioInput=} [properties] Properties to set
             */
            function AudioInput(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AudioInput uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.AudioInput
             * @instance
             */
            AudioInput.prototype.uuid = null;

            /**
             * AudioInput userDescription.
             * @member {string} userDescription
             * @memberof rv.data.AudioInput
             * @instance
             */
            AudioInput.prototype.userDescription = "";

            /**
             * AudioInput behaviorMode.
             * @member {rv.data.AudioInput.IBehaviorMode|null|undefined} behaviorMode
             * @memberof rv.data.AudioInput
             * @instance
             */
            AudioInput.prototype.behaviorMode = null;

            /**
             * AudioInput audioDevice.
             * @member {rv.data.DigitalAudio.IDevice|null|undefined} audioDevice
             * @memberof rv.data.AudioInput
             * @instance
             */
            AudioInput.prototype.audioDevice = null;

            /**
             * AudioInput videoDevice.
             * @member {rv.data.Media.IVideoDevice|null|undefined} videoDevice
             * @memberof rv.data.AudioInput
             * @instance
             */
            AudioInput.prototype.videoDevice = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * AudioInput Source.
             * @member {"audioDevice"|"videoDevice"|undefined} Source
             * @memberof rv.data.AudioInput
             * @instance
             */
            Object.defineProperty(AudioInput.prototype, "Source", {
                get: $util.oneOfGetter($oneOfFields = ["audioDevice", "videoDevice"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new AudioInput instance using the specified properties.
             * @function create
             * @memberof rv.data.AudioInput
             * @static
             * @param {rv.data.IAudioInput=} [properties] Properties to set
             * @returns {rv.data.AudioInput} AudioInput instance
             */
            AudioInput.create = function create(properties) {
                return new AudioInput(properties);
            };

            /**
             * Encodes the specified AudioInput message. Does not implicitly {@link rv.data.AudioInput.verify|verify} messages.
             * @function encode
             * @memberof rv.data.AudioInput
             * @static
             * @param {rv.data.IAudioInput} message AudioInput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AudioInput.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.userDescription != null && Object.hasOwnProperty.call(message, "userDescription"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.userDescription);
                if (message.audioDevice != null && Object.hasOwnProperty.call(message, "audioDevice"))
                    $root.rv.data.DigitalAudio.Device.encode(message.audioDevice, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.videoDevice != null && Object.hasOwnProperty.call(message, "videoDevice"))
                    $root.rv.data.Media.VideoDevice.encode(message.videoDevice, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.behaviorMode != null && Object.hasOwnProperty.call(message, "behaviorMode"))
                    $root.rv.data.AudioInput.BehaviorMode.encode(message.behaviorMode, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AudioInput message, length delimited. Does not implicitly {@link rv.data.AudioInput.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.AudioInput
             * @static
             * @param {rv.data.IAudioInput} message AudioInput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AudioInput.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AudioInput message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.AudioInput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.AudioInput} AudioInput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AudioInput.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.AudioInput();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.userDescription = reader.string();
                            break;
                        }
                    case 5: {
                            message.behaviorMode = $root.rv.data.AudioInput.BehaviorMode.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.audioDevice = $root.rv.data.DigitalAudio.Device.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.videoDevice = $root.rv.data.Media.VideoDevice.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AudioInput message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.AudioInput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.AudioInput} AudioInput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AudioInput.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AudioInput message.
             * @function verify
             * @memberof rv.data.AudioInput
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AudioInput.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                if (message.userDescription != null && message.hasOwnProperty("userDescription"))
                    if (!$util.isString(message.userDescription))
                        return "userDescription: string expected";
                if (message.behaviorMode != null && message.hasOwnProperty("behaviorMode")) {
                    let error = $root.rv.data.AudioInput.BehaviorMode.verify(message.behaviorMode);
                    if (error)
                        return "behaviorMode." + error;
                }
                if (message.audioDevice != null && message.hasOwnProperty("audioDevice")) {
                    properties.Source = 1;
                    {
                        let error = $root.rv.data.DigitalAudio.Device.verify(message.audioDevice);
                        if (error)
                            return "audioDevice." + error;
                    }
                }
                if (message.videoDevice != null && message.hasOwnProperty("videoDevice")) {
                    if (properties.Source === 1)
                        return "Source: multiple values";
                    properties.Source = 1;
                    {
                        let error = $root.rv.data.Media.VideoDevice.verify(message.videoDevice);
                        if (error)
                            return "videoDevice." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an AudioInput message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.AudioInput
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.AudioInput} AudioInput
             */
            AudioInput.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.AudioInput)
                    return object;
                let message = new $root.rv.data.AudioInput();
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.AudioInput.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                if (object.userDescription != null)
                    message.userDescription = String(object.userDescription);
                if (object.behaviorMode != null) {
                    if (typeof object.behaviorMode !== "object")
                        throw TypeError(".rv.data.AudioInput.behaviorMode: object expected");
                    message.behaviorMode = $root.rv.data.AudioInput.BehaviorMode.fromObject(object.behaviorMode);
                }
                if (object.audioDevice != null) {
                    if (typeof object.audioDevice !== "object")
                        throw TypeError(".rv.data.AudioInput.audioDevice: object expected");
                    message.audioDevice = $root.rv.data.DigitalAudio.Device.fromObject(object.audioDevice);
                }
                if (object.videoDevice != null) {
                    if (typeof object.videoDevice !== "object")
                        throw TypeError(".rv.data.AudioInput.videoDevice: object expected");
                    message.videoDevice = $root.rv.data.Media.VideoDevice.fromObject(object.videoDevice);
                }
                return message;
            };

            /**
             * Creates a plain object from an AudioInput message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.AudioInput
             * @static
             * @param {rv.data.AudioInput} message AudioInput
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AudioInput.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uuid = null;
                    object.userDescription = "";
                    object.behaviorMode = null;
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                if (message.userDescription != null && message.hasOwnProperty("userDescription"))
                    object.userDescription = message.userDescription;
                if (message.audioDevice != null && message.hasOwnProperty("audioDevice")) {
                    object.audioDevice = $root.rv.data.DigitalAudio.Device.toObject(message.audioDevice, options);
                    if (options.oneofs)
                        object.Source = "audioDevice";
                }
                if (message.videoDevice != null && message.hasOwnProperty("videoDevice")) {
                    object.videoDevice = $root.rv.data.Media.VideoDevice.toObject(message.videoDevice, options);
                    if (options.oneofs)
                        object.Source = "videoDevice";
                }
                if (message.behaviorMode != null && message.hasOwnProperty("behaviorMode"))
                    object.behaviorMode = $root.rv.data.AudioInput.BehaviorMode.toObject(message.behaviorMode, options);
                return object;
            };

            /**
             * Converts this AudioInput to JSON.
             * @function toJSON
             * @memberof rv.data.AudioInput
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AudioInput.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AudioInput
             * @function getTypeUrl
             * @memberof rv.data.AudioInput
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AudioInput.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.AudioInput";
            };

            AudioInput.BehaviorMode = (function() {

                /**
                 * Properties of a BehaviorMode.
                 * @memberof rv.data.AudioInput
                 * @interface IBehaviorMode
                 * @property {rv.data.AudioInput.BehaviorMode.IOn|null} [on] BehaviorMode on
                 * @property {rv.data.AudioInput.BehaviorMode.IOff|null} [off] BehaviorMode off
                 * @property {rv.data.AudioInput.BehaviorMode.IAutoOn|null} [autoOn] BehaviorMode autoOn
                 * @property {rv.data.AudioInput.BehaviorMode.IAutoOff|null} [autoOff] BehaviorMode autoOff
                 */

                /**
                 * Constructs a new BehaviorMode.
                 * @memberof rv.data.AudioInput
                 * @classdesc Represents a BehaviorMode.
                 * @implements IBehaviorMode
                 * @constructor
                 * @param {rv.data.AudioInput.IBehaviorMode=} [properties] Properties to set
                 */
                function BehaviorMode(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BehaviorMode on.
                 * @member {rv.data.AudioInput.BehaviorMode.IOn|null|undefined} on
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @instance
                 */
                BehaviorMode.prototype.on = null;

                /**
                 * BehaviorMode off.
                 * @member {rv.data.AudioInput.BehaviorMode.IOff|null|undefined} off
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @instance
                 */
                BehaviorMode.prototype.off = null;

                /**
                 * BehaviorMode autoOn.
                 * @member {rv.data.AudioInput.BehaviorMode.IAutoOn|null|undefined} autoOn
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @instance
                 */
                BehaviorMode.prototype.autoOn = null;

                /**
                 * BehaviorMode autoOff.
                 * @member {rv.data.AudioInput.BehaviorMode.IAutoOff|null|undefined} autoOff
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @instance
                 */
                BehaviorMode.prototype.autoOff = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * BehaviorMode Mode.
                 * @member {"on"|"off"|"autoOn"|"autoOff"|undefined} Mode
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @instance
                 */
                Object.defineProperty(BehaviorMode.prototype, "Mode", {
                    get: $util.oneOfGetter($oneOfFields = ["on", "off", "autoOn", "autoOff"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new BehaviorMode instance using the specified properties.
                 * @function create
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @static
                 * @param {rv.data.AudioInput.IBehaviorMode=} [properties] Properties to set
                 * @returns {rv.data.AudioInput.BehaviorMode} BehaviorMode instance
                 */
                BehaviorMode.create = function create(properties) {
                    return new BehaviorMode(properties);
                };

                /**
                 * Encodes the specified BehaviorMode message. Does not implicitly {@link rv.data.AudioInput.BehaviorMode.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @static
                 * @param {rv.data.AudioInput.IBehaviorMode} message BehaviorMode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BehaviorMode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.on != null && Object.hasOwnProperty.call(message, "on"))
                        $root.rv.data.AudioInput.BehaviorMode.On.encode(message.on, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.off != null && Object.hasOwnProperty.call(message, "off"))
                        $root.rv.data.AudioInput.BehaviorMode.Off.encode(message.off, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.autoOn != null && Object.hasOwnProperty.call(message, "autoOn"))
                        $root.rv.data.AudioInput.BehaviorMode.AutoOn.encode(message.autoOn, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.autoOff != null && Object.hasOwnProperty.call(message, "autoOff"))
                        $root.rv.data.AudioInput.BehaviorMode.AutoOff.encode(message.autoOff, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified BehaviorMode message, length delimited. Does not implicitly {@link rv.data.AudioInput.BehaviorMode.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @static
                 * @param {rv.data.AudioInput.IBehaviorMode} message BehaviorMode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BehaviorMode.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BehaviorMode message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.AudioInput.BehaviorMode} BehaviorMode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BehaviorMode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.AudioInput.BehaviorMode();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.on = $root.rv.data.AudioInput.BehaviorMode.On.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.off = $root.rv.data.AudioInput.BehaviorMode.Off.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.autoOn = $root.rv.data.AudioInput.BehaviorMode.AutoOn.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.autoOff = $root.rv.data.AudioInput.BehaviorMode.AutoOff.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BehaviorMode message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.AudioInput.BehaviorMode} BehaviorMode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BehaviorMode.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BehaviorMode message.
                 * @function verify
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BehaviorMode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.on != null && message.hasOwnProperty("on")) {
                        properties.Mode = 1;
                        {
                            let error = $root.rv.data.AudioInput.BehaviorMode.On.verify(message.on);
                            if (error)
                                return "on." + error;
                        }
                    }
                    if (message.off != null && message.hasOwnProperty("off")) {
                        if (properties.Mode === 1)
                            return "Mode: multiple values";
                        properties.Mode = 1;
                        {
                            let error = $root.rv.data.AudioInput.BehaviorMode.Off.verify(message.off);
                            if (error)
                                return "off." + error;
                        }
                    }
                    if (message.autoOn != null && message.hasOwnProperty("autoOn")) {
                        if (properties.Mode === 1)
                            return "Mode: multiple values";
                        properties.Mode = 1;
                        {
                            let error = $root.rv.data.AudioInput.BehaviorMode.AutoOn.verify(message.autoOn);
                            if (error)
                                return "autoOn." + error;
                        }
                    }
                    if (message.autoOff != null && message.hasOwnProperty("autoOff")) {
                        if (properties.Mode === 1)
                            return "Mode: multiple values";
                        properties.Mode = 1;
                        {
                            let error = $root.rv.data.AudioInput.BehaviorMode.AutoOff.verify(message.autoOff);
                            if (error)
                                return "autoOff." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a BehaviorMode message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.AudioInput.BehaviorMode} BehaviorMode
                 */
                BehaviorMode.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.AudioInput.BehaviorMode)
                        return object;
                    let message = new $root.rv.data.AudioInput.BehaviorMode();
                    if (object.on != null) {
                        if (typeof object.on !== "object")
                            throw TypeError(".rv.data.AudioInput.BehaviorMode.on: object expected");
                        message.on = $root.rv.data.AudioInput.BehaviorMode.On.fromObject(object.on);
                    }
                    if (object.off != null) {
                        if (typeof object.off !== "object")
                            throw TypeError(".rv.data.AudioInput.BehaviorMode.off: object expected");
                        message.off = $root.rv.data.AudioInput.BehaviorMode.Off.fromObject(object.off);
                    }
                    if (object.autoOn != null) {
                        if (typeof object.autoOn !== "object")
                            throw TypeError(".rv.data.AudioInput.BehaviorMode.autoOn: object expected");
                        message.autoOn = $root.rv.data.AudioInput.BehaviorMode.AutoOn.fromObject(object.autoOn);
                    }
                    if (object.autoOff != null) {
                        if (typeof object.autoOff !== "object")
                            throw TypeError(".rv.data.AudioInput.BehaviorMode.autoOff: object expected");
                        message.autoOff = $root.rv.data.AudioInput.BehaviorMode.AutoOff.fromObject(object.autoOff);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BehaviorMode message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @static
                 * @param {rv.data.AudioInput.BehaviorMode} message BehaviorMode
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BehaviorMode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.on != null && message.hasOwnProperty("on")) {
                        object.on = $root.rv.data.AudioInput.BehaviorMode.On.toObject(message.on, options);
                        if (options.oneofs)
                            object.Mode = "on";
                    }
                    if (message.off != null && message.hasOwnProperty("off")) {
                        object.off = $root.rv.data.AudioInput.BehaviorMode.Off.toObject(message.off, options);
                        if (options.oneofs)
                            object.Mode = "off";
                    }
                    if (message.autoOn != null && message.hasOwnProperty("autoOn")) {
                        object.autoOn = $root.rv.data.AudioInput.BehaviorMode.AutoOn.toObject(message.autoOn, options);
                        if (options.oneofs)
                            object.Mode = "autoOn";
                    }
                    if (message.autoOff != null && message.hasOwnProperty("autoOff")) {
                        object.autoOff = $root.rv.data.AudioInput.BehaviorMode.AutoOff.toObject(message.autoOff, options);
                        if (options.oneofs)
                            object.Mode = "autoOff";
                    }
                    return object;
                };

                /**
                 * Converts this BehaviorMode to JSON.
                 * @function toJSON
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BehaviorMode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BehaviorMode
                 * @function getTypeUrl
                 * @memberof rv.data.AudioInput.BehaviorMode
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BehaviorMode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.AudioInput.BehaviorMode";
                };

                BehaviorMode.On = (function() {

                    /**
                     * Properties of an On.
                     * @memberof rv.data.AudioInput.BehaviorMode
                     * @interface IOn
                     */

                    /**
                     * Constructs a new On.
                     * @memberof rv.data.AudioInput.BehaviorMode
                     * @classdesc Represents an On.
                     * @implements IOn
                     * @constructor
                     * @param {rv.data.AudioInput.BehaviorMode.IOn=} [properties] Properties to set
                     */
                    function On(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new On instance using the specified properties.
                     * @function create
                     * @memberof rv.data.AudioInput.BehaviorMode.On
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.IOn=} [properties] Properties to set
                     * @returns {rv.data.AudioInput.BehaviorMode.On} On instance
                     */
                    On.create = function create(properties) {
                        return new On(properties);
                    };

                    /**
                     * Encodes the specified On message. Does not implicitly {@link rv.data.AudioInput.BehaviorMode.On.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.AudioInput.BehaviorMode.On
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.IOn} message On message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    On.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified On message, length delimited. Does not implicitly {@link rv.data.AudioInput.BehaviorMode.On.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.AudioInput.BehaviorMode.On
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.IOn} message On message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    On.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an On message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.AudioInput.BehaviorMode.On
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.AudioInput.BehaviorMode.On} On
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    On.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.AudioInput.BehaviorMode.On();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an On message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.AudioInput.BehaviorMode.On
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.AudioInput.BehaviorMode.On} On
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    On.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an On message.
                     * @function verify
                     * @memberof rv.data.AudioInput.BehaviorMode.On
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    On.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates an On message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.AudioInput.BehaviorMode.On
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.AudioInput.BehaviorMode.On} On
                     */
                    On.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.AudioInput.BehaviorMode.On)
                            return object;
                        return new $root.rv.data.AudioInput.BehaviorMode.On();
                    };

                    /**
                     * Creates a plain object from an On message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.AudioInput.BehaviorMode.On
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.On} message On
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    On.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this On to JSON.
                     * @function toJSON
                     * @memberof rv.data.AudioInput.BehaviorMode.On
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    On.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for On
                     * @function getTypeUrl
                     * @memberof rv.data.AudioInput.BehaviorMode.On
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    On.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.AudioInput.BehaviorMode.On";
                    };

                    return On;
                })();

                BehaviorMode.Off = (function() {

                    /**
                     * Properties of an Off.
                     * @memberof rv.data.AudioInput.BehaviorMode
                     * @interface IOff
                     */

                    /**
                     * Constructs a new Off.
                     * @memberof rv.data.AudioInput.BehaviorMode
                     * @classdesc Represents an Off.
                     * @implements IOff
                     * @constructor
                     * @param {rv.data.AudioInput.BehaviorMode.IOff=} [properties] Properties to set
                     */
                    function Off(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Off instance using the specified properties.
                     * @function create
                     * @memberof rv.data.AudioInput.BehaviorMode.Off
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.IOff=} [properties] Properties to set
                     * @returns {rv.data.AudioInput.BehaviorMode.Off} Off instance
                     */
                    Off.create = function create(properties) {
                        return new Off(properties);
                    };

                    /**
                     * Encodes the specified Off message. Does not implicitly {@link rv.data.AudioInput.BehaviorMode.Off.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.AudioInput.BehaviorMode.Off
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.IOff} message Off message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Off.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Off message, length delimited. Does not implicitly {@link rv.data.AudioInput.BehaviorMode.Off.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.AudioInput.BehaviorMode.Off
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.IOff} message Off message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Off.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Off message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.AudioInput.BehaviorMode.Off
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.AudioInput.BehaviorMode.Off} Off
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Off.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.AudioInput.BehaviorMode.Off();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Off message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.AudioInput.BehaviorMode.Off
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.AudioInput.BehaviorMode.Off} Off
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Off.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Off message.
                     * @function verify
                     * @memberof rv.data.AudioInput.BehaviorMode.Off
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Off.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates an Off message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.AudioInput.BehaviorMode.Off
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.AudioInput.BehaviorMode.Off} Off
                     */
                    Off.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.AudioInput.BehaviorMode.Off)
                            return object;
                        return new $root.rv.data.AudioInput.BehaviorMode.Off();
                    };

                    /**
                     * Creates a plain object from an Off message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.AudioInput.BehaviorMode.Off
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.Off} message Off
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Off.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Off to JSON.
                     * @function toJSON
                     * @memberof rv.data.AudioInput.BehaviorMode.Off
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Off.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Off
                     * @function getTypeUrl
                     * @memberof rv.data.AudioInput.BehaviorMode.Off
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Off.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.AudioInput.BehaviorMode.Off";
                    };

                    return Off;
                })();

                BehaviorMode.AutoOff = (function() {

                    /**
                     * Properties of an AutoOff.
                     * @memberof rv.data.AudioInput.BehaviorMode
                     * @interface IAutoOff
                     */

                    /**
                     * Constructs a new AutoOff.
                     * @memberof rv.data.AudioInput.BehaviorMode
                     * @classdesc Represents an AutoOff.
                     * @implements IAutoOff
                     * @constructor
                     * @param {rv.data.AudioInput.BehaviorMode.IAutoOff=} [properties] Properties to set
                     */
                    function AutoOff(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new AutoOff instance using the specified properties.
                     * @function create
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOff
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.IAutoOff=} [properties] Properties to set
                     * @returns {rv.data.AudioInput.BehaviorMode.AutoOff} AutoOff instance
                     */
                    AutoOff.create = function create(properties) {
                        return new AutoOff(properties);
                    };

                    /**
                     * Encodes the specified AutoOff message. Does not implicitly {@link rv.data.AudioInput.BehaviorMode.AutoOff.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOff
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.IAutoOff} message AutoOff message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AutoOff.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified AutoOff message, length delimited. Does not implicitly {@link rv.data.AudioInput.BehaviorMode.AutoOff.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOff
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.IAutoOff} message AutoOff message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AutoOff.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an AutoOff message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOff
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.AudioInput.BehaviorMode.AutoOff} AutoOff
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AutoOff.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.AudioInput.BehaviorMode.AutoOff();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an AutoOff message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOff
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.AudioInput.BehaviorMode.AutoOff} AutoOff
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AutoOff.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an AutoOff message.
                     * @function verify
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOff
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AutoOff.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates an AutoOff message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOff
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.AudioInput.BehaviorMode.AutoOff} AutoOff
                     */
                    AutoOff.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.AudioInput.BehaviorMode.AutoOff)
                            return object;
                        return new $root.rv.data.AudioInput.BehaviorMode.AutoOff();
                    };

                    /**
                     * Creates a plain object from an AutoOff message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOff
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.AutoOff} message AutoOff
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AutoOff.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this AutoOff to JSON.
                     * @function toJSON
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOff
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AutoOff.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for AutoOff
                     * @function getTypeUrl
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOff
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    AutoOff.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.AudioInput.BehaviorMode.AutoOff";
                    };

                    return AutoOff;
                })();

                BehaviorMode.AutoOn = (function() {

                    /**
                     * Properties of an AutoOn.
                     * @memberof rv.data.AudioInput.BehaviorMode
                     * @interface IAutoOn
                     * @property {Array.<number>|null} [linkedVideoInputs] AutoOn linkedVideoInputs
                     */

                    /**
                     * Constructs a new AutoOn.
                     * @memberof rv.data.AudioInput.BehaviorMode
                     * @classdesc Represents an AutoOn.
                     * @implements IAutoOn
                     * @constructor
                     * @param {rv.data.AudioInput.BehaviorMode.IAutoOn=} [properties] Properties to set
                     */
                    function AutoOn(properties) {
                        this.linkedVideoInputs = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * AutoOn linkedVideoInputs.
                     * @member {Array.<number>} linkedVideoInputs
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOn
                     * @instance
                     */
                    AutoOn.prototype.linkedVideoInputs = $util.emptyArray;

                    /**
                     * Creates a new AutoOn instance using the specified properties.
                     * @function create
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOn
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.IAutoOn=} [properties] Properties to set
                     * @returns {rv.data.AudioInput.BehaviorMode.AutoOn} AutoOn instance
                     */
                    AutoOn.create = function create(properties) {
                        return new AutoOn(properties);
                    };

                    /**
                     * Encodes the specified AutoOn message. Does not implicitly {@link rv.data.AudioInput.BehaviorMode.AutoOn.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOn
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.IAutoOn} message AutoOn message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AutoOn.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.linkedVideoInputs != null && message.linkedVideoInputs.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (let i = 0; i < message.linkedVideoInputs.length; ++i)
                                writer.uint32(message.linkedVideoInputs[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };

                    /**
                     * Encodes the specified AutoOn message, length delimited. Does not implicitly {@link rv.data.AudioInput.BehaviorMode.AutoOn.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOn
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.IAutoOn} message AutoOn message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AutoOn.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an AutoOn message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOn
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.AudioInput.BehaviorMode.AutoOn} AutoOn
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AutoOn.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.AudioInput.BehaviorMode.AutoOn();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.linkedVideoInputs && message.linkedVideoInputs.length))
                                        message.linkedVideoInputs = [];
                                    if ((tag & 7) === 2) {
                                        let end2 = reader.uint32() + reader.pos;
                                        while (reader.pos < end2)
                                            message.linkedVideoInputs.push(reader.uint32());
                                    } else
                                        message.linkedVideoInputs.push(reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an AutoOn message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOn
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.AudioInput.BehaviorMode.AutoOn} AutoOn
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AutoOn.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an AutoOn message.
                     * @function verify
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOn
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AutoOn.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.linkedVideoInputs != null && message.hasOwnProperty("linkedVideoInputs")) {
                            if (!Array.isArray(message.linkedVideoInputs))
                                return "linkedVideoInputs: array expected";
                            for (let i = 0; i < message.linkedVideoInputs.length; ++i)
                                if (!$util.isInteger(message.linkedVideoInputs[i]))
                                    return "linkedVideoInputs: integer[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates an AutoOn message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOn
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.AudioInput.BehaviorMode.AutoOn} AutoOn
                     */
                    AutoOn.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.AudioInput.BehaviorMode.AutoOn)
                            return object;
                        let message = new $root.rv.data.AudioInput.BehaviorMode.AutoOn();
                        if (object.linkedVideoInputs) {
                            if (!Array.isArray(object.linkedVideoInputs))
                                throw TypeError(".rv.data.AudioInput.BehaviorMode.AutoOn.linkedVideoInputs: array expected");
                            message.linkedVideoInputs = [];
                            for (let i = 0; i < object.linkedVideoInputs.length; ++i)
                                message.linkedVideoInputs[i] = object.linkedVideoInputs[i] >>> 0;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an AutoOn message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOn
                     * @static
                     * @param {rv.data.AudioInput.BehaviorMode.AutoOn} message AutoOn
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AutoOn.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.linkedVideoInputs = [];
                        if (message.linkedVideoInputs && message.linkedVideoInputs.length) {
                            object.linkedVideoInputs = [];
                            for (let j = 0; j < message.linkedVideoInputs.length; ++j)
                                object.linkedVideoInputs[j] = message.linkedVideoInputs[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this AutoOn to JSON.
                     * @function toJSON
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOn
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AutoOn.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for AutoOn
                     * @function getTypeUrl
                     * @memberof rv.data.AudioInput.BehaviorMode.AutoOn
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    AutoOn.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.AudioInput.BehaviorMode.AutoOn";
                    };

                    return AutoOn;
                })();

                return BehaviorMode;
            })();

            return AudioInput;
        })();

        data.Layer = (function() {

            /**
             * Properties of a Layer.
             * @memberof rv.data
             * @interface ILayer
             * @property {rv.data.IUUID|null} [uuid] Layer uuid
             * @property {string|null} [name] Layer name
             * @property {rv.data.IColor|null} [color] Layer color
             * @property {boolean|null} [muted] Layer muted
             * @property {boolean|null} [hidden] Layer hidden
             * @property {rv.data.Layer.BlendMode|null} [blendMode] Layer blendMode
             * @property {number|null} [opacity] Layer opacity
             * @property {rv.data.IUUID|null} [selectedTargetSetUuid] Layer selectedTargetSetUuid
             * @property {rv.data.IUUID|null} [effectsPresetUuid] Layer effectsPresetUuid
             * @property {number|null} [effectsBuildDuration] Layer effectsBuildDuration
             * @property {rv.data.IUUID|null} [layerPresetUuid] Layer layerPresetUuid
             * @property {rv.data.IHotKey|null} [hotKey] Layer hotKey
             * @property {rv.data.ITransition|null} [transition] Layer transition
             * @property {Array.<rv.data.IEffect>|null} [effects] Layer effects
             * @property {rv.data.Layer.IBlending|null} [blend] Layer blend
             */

            /**
             * Constructs a new Layer.
             * @memberof rv.data
             * @classdesc Represents a Layer.
             * @implements ILayer
             * @constructor
             * @param {rv.data.ILayer=} [properties] Properties to set
             */
            function Layer(properties) {
                this.effects = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Layer uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.uuid = null;

            /**
             * Layer name.
             * @member {string} name
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.name = "";

            /**
             * Layer color.
             * @member {rv.data.IColor|null|undefined} color
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.color = null;

            /**
             * Layer muted.
             * @member {boolean} muted
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.muted = false;

            /**
             * Layer hidden.
             * @member {boolean} hidden
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.hidden = false;

            /**
             * Layer blendMode.
             * @member {rv.data.Layer.BlendMode} blendMode
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.blendMode = 0;

            /**
             * Layer opacity.
             * @member {number} opacity
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.opacity = 0;

            /**
             * Layer selectedTargetSetUuid.
             * @member {rv.data.IUUID|null|undefined} selectedTargetSetUuid
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.selectedTargetSetUuid = null;

            /**
             * Layer effectsPresetUuid.
             * @member {rv.data.IUUID|null|undefined} effectsPresetUuid
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.effectsPresetUuid = null;

            /**
             * Layer effectsBuildDuration.
             * @member {number} effectsBuildDuration
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.effectsBuildDuration = 0;

            /**
             * Layer layerPresetUuid.
             * @member {rv.data.IUUID|null|undefined} layerPresetUuid
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.layerPresetUuid = null;

            /**
             * Layer hotKey.
             * @member {rv.data.IHotKey|null|undefined} hotKey
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.hotKey = null;

            /**
             * Layer transition.
             * @member {rv.data.ITransition|null|undefined} transition
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.transition = null;

            /**
             * Layer effects.
             * @member {Array.<rv.data.IEffect>} effects
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.effects = $util.emptyArray;

            /**
             * Layer blend.
             * @member {rv.data.Layer.IBlending|null|undefined} blend
             * @memberof rv.data.Layer
             * @instance
             */
            Layer.prototype.blend = null;

            /**
             * Creates a new Layer instance using the specified properties.
             * @function create
             * @memberof rv.data.Layer
             * @static
             * @param {rv.data.ILayer=} [properties] Properties to set
             * @returns {rv.data.Layer} Layer instance
             */
            Layer.create = function create(properties) {
                return new Layer(properties);
            };

            /**
             * Encodes the specified Layer message. Does not implicitly {@link rv.data.Layer.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Layer
             * @static
             * @param {rv.data.ILayer} message Layer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Layer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    $root.rv.data.Color.encode(message.color, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.muted != null && Object.hasOwnProperty.call(message, "muted"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.muted);
                if (message.hidden != null && Object.hasOwnProperty.call(message, "hidden"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.hidden);
                if (message.blendMode != null && Object.hasOwnProperty.call(message, "blendMode"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.blendMode);
                if (message.opacity != null && Object.hasOwnProperty.call(message, "opacity"))
                    writer.uint32(/* id 7, wireType 1 =*/57).double(message.opacity);
                if (message.selectedTargetSetUuid != null && Object.hasOwnProperty.call(message, "selectedTargetSetUuid"))
                    $root.rv.data.UUID.encode(message.selectedTargetSetUuid, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.effectsPresetUuid != null && Object.hasOwnProperty.call(message, "effectsPresetUuid"))
                    $root.rv.data.UUID.encode(message.effectsPresetUuid, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.effectsBuildDuration != null && Object.hasOwnProperty.call(message, "effectsBuildDuration"))
                    writer.uint32(/* id 10, wireType 1 =*/81).double(message.effectsBuildDuration);
                if (message.layerPresetUuid != null && Object.hasOwnProperty.call(message, "layerPresetUuid"))
                    $root.rv.data.UUID.encode(message.layerPresetUuid, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.hotKey != null && Object.hasOwnProperty.call(message, "hotKey"))
                    $root.rv.data.HotKey.encode(message.hotKey, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.transition != null && Object.hasOwnProperty.call(message, "transition"))
                    $root.rv.data.Transition.encode(message.transition, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.effects != null && message.effects.length)
                    for (let i = 0; i < message.effects.length; ++i)
                        $root.rv.data.Effect.encode(message.effects[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.blend != null && Object.hasOwnProperty.call(message, "blend"))
                    $root.rv.data.Layer.Blending.encode(message.blend, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Layer message, length delimited. Does not implicitly {@link rv.data.Layer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Layer
             * @static
             * @param {rv.data.ILayer} message Layer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Layer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Layer message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Layer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Layer} Layer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Layer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Layer();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.color = $root.rv.data.Color.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.muted = reader.bool();
                            break;
                        }
                    case 5: {
                            message.hidden = reader.bool();
                            break;
                        }
                    case 6: {
                            message.blendMode = reader.int32();
                            break;
                        }
                    case 7: {
                            message.opacity = reader.double();
                            break;
                        }
                    case 8: {
                            message.selectedTargetSetUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.effectsPresetUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 10: {
                            message.effectsBuildDuration = reader.double();
                            break;
                        }
                    case 11: {
                            message.layerPresetUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.hotKey = $root.rv.data.HotKey.decode(reader, reader.uint32());
                            break;
                        }
                    case 13: {
                            message.transition = $root.rv.data.Transition.decode(reader, reader.uint32());
                            break;
                        }
                    case 14: {
                            if (!(message.effects && message.effects.length))
                                message.effects = [];
                            message.effects.push($root.rv.data.Effect.decode(reader, reader.uint32()));
                            break;
                        }
                    case 15: {
                            message.blend = $root.rv.data.Layer.Blending.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Layer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Layer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Layer} Layer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Layer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Layer message.
             * @function verify
             * @memberof rv.data.Layer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Layer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.color != null && message.hasOwnProperty("color")) {
                    let error = $root.rv.data.Color.verify(message.color);
                    if (error)
                        return "color." + error;
                }
                if (message.muted != null && message.hasOwnProperty("muted"))
                    if (typeof message.muted !== "boolean")
                        return "muted: boolean expected";
                if (message.hidden != null && message.hasOwnProperty("hidden"))
                    if (typeof message.hidden !== "boolean")
                        return "hidden: boolean expected";
                if (message.blendMode != null && message.hasOwnProperty("blendMode"))
                    switch (message.blendMode) {
                    default:
                        return "blendMode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                        break;
                    }
                if (message.opacity != null && message.hasOwnProperty("opacity"))
                    if (typeof message.opacity !== "number")
                        return "opacity: number expected";
                if (message.selectedTargetSetUuid != null && message.hasOwnProperty("selectedTargetSetUuid")) {
                    let error = $root.rv.data.UUID.verify(message.selectedTargetSetUuid);
                    if (error)
                        return "selectedTargetSetUuid." + error;
                }
                if (message.effectsPresetUuid != null && message.hasOwnProperty("effectsPresetUuid")) {
                    let error = $root.rv.data.UUID.verify(message.effectsPresetUuid);
                    if (error)
                        return "effectsPresetUuid." + error;
                }
                if (message.effectsBuildDuration != null && message.hasOwnProperty("effectsBuildDuration"))
                    if (typeof message.effectsBuildDuration !== "number")
                        return "effectsBuildDuration: number expected";
                if (message.layerPresetUuid != null && message.hasOwnProperty("layerPresetUuid")) {
                    let error = $root.rv.data.UUID.verify(message.layerPresetUuid);
                    if (error)
                        return "layerPresetUuid." + error;
                }
                if (message.hotKey != null && message.hasOwnProperty("hotKey")) {
                    let error = $root.rv.data.HotKey.verify(message.hotKey);
                    if (error)
                        return "hotKey." + error;
                }
                if (message.transition != null && message.hasOwnProperty("transition")) {
                    let error = $root.rv.data.Transition.verify(message.transition);
                    if (error)
                        return "transition." + error;
                }
                if (message.effects != null && message.hasOwnProperty("effects")) {
                    if (!Array.isArray(message.effects))
                        return "effects: array expected";
                    for (let i = 0; i < message.effects.length; ++i) {
                        let error = $root.rv.data.Effect.verify(message.effects[i]);
                        if (error)
                            return "effects." + error;
                    }
                }
                if (message.blend != null && message.hasOwnProperty("blend")) {
                    let error = $root.rv.data.Layer.Blending.verify(message.blend);
                    if (error)
                        return "blend." + error;
                }
                return null;
            };

            /**
             * Creates a Layer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Layer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Layer} Layer
             */
            Layer.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Layer)
                    return object;
                let message = new $root.rv.data.Layer();
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.Layer.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                if (object.name != null)
                    message.name = String(object.name);
                if (object.color != null) {
                    if (typeof object.color !== "object")
                        throw TypeError(".rv.data.Layer.color: object expected");
                    message.color = $root.rv.data.Color.fromObject(object.color);
                }
                if (object.muted != null)
                    message.muted = Boolean(object.muted);
                if (object.hidden != null)
                    message.hidden = Boolean(object.hidden);
                switch (object.blendMode) {
                default:
                    if (typeof object.blendMode === "number") {
                        message.blendMode = object.blendMode;
                        break;
                    }
                    break;
                case "BLEND_MODE_NORMAL":
                case 0:
                    message.blendMode = 0;
                    break;
                case "BLEND_MODE_DISSOLVE":
                case 1:
                    message.blendMode = 1;
                    break;
                case "BLEND_MODE_DARKEN":
                case 2:
                    message.blendMode = 2;
                    break;
                case "BLEND_MODE_MULTIPLY":
                case 3:
                    message.blendMode = 3;
                    break;
                case "BLEND_MODE_COLOR_BURN":
                case 4:
                    message.blendMode = 4;
                    break;
                case "BLEND_MODE_LINEAR_BURN":
                case 5:
                    message.blendMode = 5;
                    break;
                case "BLEND_MODE_DARKER_COLOR":
                case 6:
                    message.blendMode = 6;
                    break;
                case "BLEND_MODE_LIGHTEN":
                case 7:
                    message.blendMode = 7;
                    break;
                case "BLEND_MODE_SCREEN":
                case 8:
                    message.blendMode = 8;
                    break;
                case "BLEND_MODE_COLOR_DODGE":
                case 9:
                    message.blendMode = 9;
                    break;
                case "BLEND_MODE_LINEAR_DODGE":
                case 10:
                    message.blendMode = 10;
                    break;
                case "BLEND_MODE_LIGHTER_COLOR":
                case 11:
                    message.blendMode = 11;
                    break;
                case "BLEND_MODE_OVERLAY":
                case 12:
                    message.blendMode = 12;
                    break;
                case "BLEND_MODE_SOFT_LIGHT":
                case 13:
                    message.blendMode = 13;
                    break;
                case "BLEND_MODE_HARD_LIGHT":
                case 14:
                    message.blendMode = 14;
                    break;
                case "BLEND_MODE_VIVID_LIGHT":
                case 15:
                    message.blendMode = 15;
                    break;
                case "BLEND_MODE_LINEAR_LIGHT":
                case 16:
                    message.blendMode = 16;
                    break;
                case "BLEND_MODE_PIN_LIGHT":
                case 17:
                    message.blendMode = 17;
                    break;
                case "BLEND_MODE_HARD_MIX":
                case 18:
                    message.blendMode = 18;
                    break;
                case "BLEND_MODE_DIFFERENCE":
                case 19:
                    message.blendMode = 19;
                    break;
                case "BLEND_MODE_EXCLUSION":
                case 20:
                    message.blendMode = 20;
                    break;
                case "BLEND_MODE_SUBTRACT":
                case 21:
                    message.blendMode = 21;
                    break;
                case "BLEND_MODE_DIVIDE":
                case 22:
                    message.blendMode = 22;
                    break;
                case "BLEND_MODE_HUE":
                case 23:
                    message.blendMode = 23;
                    break;
                case "BLEND_MODE_SATURATION":
                case 24:
                    message.blendMode = 24;
                    break;
                case "BLEND_MODE_COLOR":
                case 25:
                    message.blendMode = 25;
                    break;
                case "BLEND_MODE_LUMINOSITY":
                case 26:
                    message.blendMode = 26;
                    break;
                }
                if (object.opacity != null)
                    message.opacity = Number(object.opacity);
                if (object.selectedTargetSetUuid != null) {
                    if (typeof object.selectedTargetSetUuid !== "object")
                        throw TypeError(".rv.data.Layer.selectedTargetSetUuid: object expected");
                    message.selectedTargetSetUuid = $root.rv.data.UUID.fromObject(object.selectedTargetSetUuid);
                }
                if (object.effectsPresetUuid != null) {
                    if (typeof object.effectsPresetUuid !== "object")
                        throw TypeError(".rv.data.Layer.effectsPresetUuid: object expected");
                    message.effectsPresetUuid = $root.rv.data.UUID.fromObject(object.effectsPresetUuid);
                }
                if (object.effectsBuildDuration != null)
                    message.effectsBuildDuration = Number(object.effectsBuildDuration);
                if (object.layerPresetUuid != null) {
                    if (typeof object.layerPresetUuid !== "object")
                        throw TypeError(".rv.data.Layer.layerPresetUuid: object expected");
                    message.layerPresetUuid = $root.rv.data.UUID.fromObject(object.layerPresetUuid);
                }
                if (object.hotKey != null) {
                    if (typeof object.hotKey !== "object")
                        throw TypeError(".rv.data.Layer.hotKey: object expected");
                    message.hotKey = $root.rv.data.HotKey.fromObject(object.hotKey);
                }
                if (object.transition != null) {
                    if (typeof object.transition !== "object")
                        throw TypeError(".rv.data.Layer.transition: object expected");
                    message.transition = $root.rv.data.Transition.fromObject(object.transition);
                }
                if (object.effects) {
                    if (!Array.isArray(object.effects))
                        throw TypeError(".rv.data.Layer.effects: array expected");
                    message.effects = [];
                    for (let i = 0; i < object.effects.length; ++i) {
                        if (typeof object.effects[i] !== "object")
                            throw TypeError(".rv.data.Layer.effects: object expected");
                        message.effects[i] = $root.rv.data.Effect.fromObject(object.effects[i]);
                    }
                }
                if (object.blend != null) {
                    if (typeof object.blend !== "object")
                        throw TypeError(".rv.data.Layer.blend: object expected");
                    message.blend = $root.rv.data.Layer.Blending.fromObject(object.blend);
                }
                return message;
            };

            /**
             * Creates a plain object from a Layer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Layer
             * @static
             * @param {rv.data.Layer} message Layer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Layer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.effects = [];
                if (options.defaults) {
                    object.uuid = null;
                    object.name = "";
                    object.color = null;
                    object.muted = false;
                    object.hidden = false;
                    object.blendMode = options.enums === String ? "BLEND_MODE_NORMAL" : 0;
                    object.opacity = 0;
                    object.selectedTargetSetUuid = null;
                    object.effectsPresetUuid = null;
                    object.effectsBuildDuration = 0;
                    object.layerPresetUuid = null;
                    object.hotKey = null;
                    object.transition = null;
                    object.blend = null;
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.color != null && message.hasOwnProperty("color"))
                    object.color = $root.rv.data.Color.toObject(message.color, options);
                if (message.muted != null && message.hasOwnProperty("muted"))
                    object.muted = message.muted;
                if (message.hidden != null && message.hasOwnProperty("hidden"))
                    object.hidden = message.hidden;
                if (message.blendMode != null && message.hasOwnProperty("blendMode"))
                    object.blendMode = options.enums === String ? $root.rv.data.Layer.BlendMode[message.blendMode] === undefined ? message.blendMode : $root.rv.data.Layer.BlendMode[message.blendMode] : message.blendMode;
                if (message.opacity != null && message.hasOwnProperty("opacity"))
                    object.opacity = options.json && !isFinite(message.opacity) ? String(message.opacity) : message.opacity;
                if (message.selectedTargetSetUuid != null && message.hasOwnProperty("selectedTargetSetUuid"))
                    object.selectedTargetSetUuid = $root.rv.data.UUID.toObject(message.selectedTargetSetUuid, options);
                if (message.effectsPresetUuid != null && message.hasOwnProperty("effectsPresetUuid"))
                    object.effectsPresetUuid = $root.rv.data.UUID.toObject(message.effectsPresetUuid, options);
                if (message.effectsBuildDuration != null && message.hasOwnProperty("effectsBuildDuration"))
                    object.effectsBuildDuration = options.json && !isFinite(message.effectsBuildDuration) ? String(message.effectsBuildDuration) : message.effectsBuildDuration;
                if (message.layerPresetUuid != null && message.hasOwnProperty("layerPresetUuid"))
                    object.layerPresetUuid = $root.rv.data.UUID.toObject(message.layerPresetUuid, options);
                if (message.hotKey != null && message.hasOwnProperty("hotKey"))
                    object.hotKey = $root.rv.data.HotKey.toObject(message.hotKey, options);
                if (message.transition != null && message.hasOwnProperty("transition"))
                    object.transition = $root.rv.data.Transition.toObject(message.transition, options);
                if (message.effects && message.effects.length) {
                    object.effects = [];
                    for (let j = 0; j < message.effects.length; ++j)
                        object.effects[j] = $root.rv.data.Effect.toObject(message.effects[j], options);
                }
                if (message.blend != null && message.hasOwnProperty("blend"))
                    object.blend = $root.rv.data.Layer.Blending.toObject(message.blend, options);
                return object;
            };

            /**
             * Converts this Layer to JSON.
             * @function toJSON
             * @memberof rv.data.Layer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Layer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Layer
             * @function getTypeUrl
             * @memberof rv.data.Layer
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Layer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Layer";
            };

            Layer.Preset = (function() {

                /**
                 * Properties of a Preset.
                 * @memberof rv.data.Layer
                 * @interface IPreset
                 * @property {rv.data.IUUID|null} [uuid] Preset uuid
                 * @property {string|null} [name] Preset name
                 * @property {rv.data.ILayer|null} [layer] Preset layer
                 */

                /**
                 * Constructs a new Preset.
                 * @memberof rv.data.Layer
                 * @classdesc Represents a Preset.
                 * @implements IPreset
                 * @constructor
                 * @param {rv.data.Layer.IPreset=} [properties] Properties to set
                 */
                function Preset(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Preset uuid.
                 * @member {rv.data.IUUID|null|undefined} uuid
                 * @memberof rv.data.Layer.Preset
                 * @instance
                 */
                Preset.prototype.uuid = null;

                /**
                 * Preset name.
                 * @member {string} name
                 * @memberof rv.data.Layer.Preset
                 * @instance
                 */
                Preset.prototype.name = "";

                /**
                 * Preset layer.
                 * @member {rv.data.ILayer|null|undefined} layer
                 * @memberof rv.data.Layer.Preset
                 * @instance
                 */
                Preset.prototype.layer = null;

                /**
                 * Creates a new Preset instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Layer.Preset
                 * @static
                 * @param {rv.data.Layer.IPreset=} [properties] Properties to set
                 * @returns {rv.data.Layer.Preset} Preset instance
                 */
                Preset.create = function create(properties) {
                    return new Preset(properties);
                };

                /**
                 * Encodes the specified Preset message. Does not implicitly {@link rv.data.Layer.Preset.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Layer.Preset
                 * @static
                 * @param {rv.data.Layer.IPreset} message Preset message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Preset.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                        $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.layer != null && Object.hasOwnProperty.call(message, "layer"))
                        $root.rv.data.Layer.encode(message.layer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Preset message, length delimited. Does not implicitly {@link rv.data.Layer.Preset.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Layer.Preset
                 * @static
                 * @param {rv.data.Layer.IPreset} message Preset message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Preset.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Preset message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Layer.Preset
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Layer.Preset} Preset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Preset.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Layer.Preset();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.name = reader.string();
                                break;
                            }
                        case 3: {
                                message.layer = $root.rv.data.Layer.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Preset message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Layer.Preset
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Layer.Preset} Preset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Preset.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Preset message.
                 * @function verify
                 * @memberof rv.data.Layer.Preset
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Preset.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uuid != null && message.hasOwnProperty("uuid")) {
                        let error = $root.rv.data.UUID.verify(message.uuid);
                        if (error)
                            return "uuid." + error;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.layer != null && message.hasOwnProperty("layer")) {
                        let error = $root.rv.data.Layer.verify(message.layer);
                        if (error)
                            return "layer." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Preset message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Layer.Preset
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Layer.Preset} Preset
                 */
                Preset.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Layer.Preset)
                        return object;
                    let message = new $root.rv.data.Layer.Preset();
                    if (object.uuid != null) {
                        if (typeof object.uuid !== "object")
                            throw TypeError(".rv.data.Layer.Preset.uuid: object expected");
                        message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.layer != null) {
                        if (typeof object.layer !== "object")
                            throw TypeError(".rv.data.Layer.Preset.layer: object expected");
                        message.layer = $root.rv.data.Layer.fromObject(object.layer);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Preset message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Layer.Preset
                 * @static
                 * @param {rv.data.Layer.Preset} message Preset
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Preset.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.uuid = null;
                        object.name = "";
                        object.layer = null;
                    }
                    if (message.uuid != null && message.hasOwnProperty("uuid"))
                        object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.layer != null && message.hasOwnProperty("layer"))
                        object.layer = $root.rv.data.Layer.toObject(message.layer, options);
                    return object;
                };

                /**
                 * Converts this Preset to JSON.
                 * @function toJSON
                 * @memberof rv.data.Layer.Preset
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Preset.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Preset
                 * @function getTypeUrl
                 * @memberof rv.data.Layer.Preset
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Preset.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Layer.Preset";
                };

                return Preset;
            })();

            Layer.Blending = (function() {

                /**
                 * Properties of a Blending.
                 * @memberof rv.data.Layer
                 * @interface IBlending
                 * @property {rv.data.Layer.Blending.IStandard|null} [standard] Blending standard
                 * @property {rv.data.Layer.Blending.IMatte|null} [matte] Blending matte
                 */

                /**
                 * Constructs a new Blending.
                 * @memberof rv.data.Layer
                 * @classdesc Represents a Blending.
                 * @implements IBlending
                 * @constructor
                 * @param {rv.data.Layer.IBlending=} [properties] Properties to set
                 */
                function Blending(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Blending standard.
                 * @member {rv.data.Layer.Blending.IStandard|null|undefined} standard
                 * @memberof rv.data.Layer.Blending
                 * @instance
                 */
                Blending.prototype.standard = null;

                /**
                 * Blending matte.
                 * @member {rv.data.Layer.Blending.IMatte|null|undefined} matte
                 * @memberof rv.data.Layer.Blending
                 * @instance
                 */
                Blending.prototype.matte = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Blending BlendingType.
                 * @member {"standard"|"matte"|undefined} BlendingType
                 * @memberof rv.data.Layer.Blending
                 * @instance
                 */
                Object.defineProperty(Blending.prototype, "BlendingType", {
                    get: $util.oneOfGetter($oneOfFields = ["standard", "matte"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Blending instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Layer.Blending
                 * @static
                 * @param {rv.data.Layer.IBlending=} [properties] Properties to set
                 * @returns {rv.data.Layer.Blending} Blending instance
                 */
                Blending.create = function create(properties) {
                    return new Blending(properties);
                };

                /**
                 * Encodes the specified Blending message. Does not implicitly {@link rv.data.Layer.Blending.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Layer.Blending
                 * @static
                 * @param {rv.data.Layer.IBlending} message Blending message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Blending.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.standard != null && Object.hasOwnProperty.call(message, "standard"))
                        $root.rv.data.Layer.Blending.Standard.encode(message.standard, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.matte != null && Object.hasOwnProperty.call(message, "matte"))
                        $root.rv.data.Layer.Blending.Matte.encode(message.matte, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Blending message, length delimited. Does not implicitly {@link rv.data.Layer.Blending.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Layer.Blending
                 * @static
                 * @param {rv.data.Layer.IBlending} message Blending message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Blending.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Blending message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Layer.Blending
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Layer.Blending} Blending
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Blending.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Layer.Blending();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.standard = $root.rv.data.Layer.Blending.Standard.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.matte = $root.rv.data.Layer.Blending.Matte.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Blending message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Layer.Blending
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Layer.Blending} Blending
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Blending.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Blending message.
                 * @function verify
                 * @memberof rv.data.Layer.Blending
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Blending.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.standard != null && message.hasOwnProperty("standard")) {
                        properties.BlendingType = 1;
                        {
                            let error = $root.rv.data.Layer.Blending.Standard.verify(message.standard);
                            if (error)
                                return "standard." + error;
                        }
                    }
                    if (message.matte != null && message.hasOwnProperty("matte")) {
                        if (properties.BlendingType === 1)
                            return "BlendingType: multiple values";
                        properties.BlendingType = 1;
                        {
                            let error = $root.rv.data.Layer.Blending.Matte.verify(message.matte);
                            if (error)
                                return "matte." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Blending message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Layer.Blending
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Layer.Blending} Blending
                 */
                Blending.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Layer.Blending)
                        return object;
                    let message = new $root.rv.data.Layer.Blending();
                    if (object.standard != null) {
                        if (typeof object.standard !== "object")
                            throw TypeError(".rv.data.Layer.Blending.standard: object expected");
                        message.standard = $root.rv.data.Layer.Blending.Standard.fromObject(object.standard);
                    }
                    if (object.matte != null) {
                        if (typeof object.matte !== "object")
                            throw TypeError(".rv.data.Layer.Blending.matte: object expected");
                        message.matte = $root.rv.data.Layer.Blending.Matte.fromObject(object.matte);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Blending message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Layer.Blending
                 * @static
                 * @param {rv.data.Layer.Blending} message Blending
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Blending.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.standard != null && message.hasOwnProperty("standard")) {
                        object.standard = $root.rv.data.Layer.Blending.Standard.toObject(message.standard, options);
                        if (options.oneofs)
                            object.BlendingType = "standard";
                    }
                    if (message.matte != null && message.hasOwnProperty("matte")) {
                        object.matte = $root.rv.data.Layer.Blending.Matte.toObject(message.matte, options);
                        if (options.oneofs)
                            object.BlendingType = "matte";
                    }
                    return object;
                };

                /**
                 * Converts this Blending to JSON.
                 * @function toJSON
                 * @memberof rv.data.Layer.Blending
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Blending.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Blending
                 * @function getTypeUrl
                 * @memberof rv.data.Layer.Blending
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Blending.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Layer.Blending";
                };

                Blending.Standard = (function() {

                    /**
                     * Properties of a Standard.
                     * @memberof rv.data.Layer.Blending
                     * @interface IStandard
                     * @property {rv.data.Layer.BlendMode|null} [mode] Standard mode
                     * @property {number|null} [opacity] Standard opacity
                     */

                    /**
                     * Constructs a new Standard.
                     * @memberof rv.data.Layer.Blending
                     * @classdesc Represents a Standard.
                     * @implements IStandard
                     * @constructor
                     * @param {rv.data.Layer.Blending.IStandard=} [properties] Properties to set
                     */
                    function Standard(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Standard mode.
                     * @member {rv.data.Layer.BlendMode} mode
                     * @memberof rv.data.Layer.Blending.Standard
                     * @instance
                     */
                    Standard.prototype.mode = 0;

                    /**
                     * Standard opacity.
                     * @member {number} opacity
                     * @memberof rv.data.Layer.Blending.Standard
                     * @instance
                     */
                    Standard.prototype.opacity = 0;

                    /**
                     * Creates a new Standard instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Layer.Blending.Standard
                     * @static
                     * @param {rv.data.Layer.Blending.IStandard=} [properties] Properties to set
                     * @returns {rv.data.Layer.Blending.Standard} Standard instance
                     */
                    Standard.create = function create(properties) {
                        return new Standard(properties);
                    };

                    /**
                     * Encodes the specified Standard message. Does not implicitly {@link rv.data.Layer.Blending.Standard.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Layer.Blending.Standard
                     * @static
                     * @param {rv.data.Layer.Blending.IStandard} message Standard message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Standard.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                        if (message.opacity != null && Object.hasOwnProperty.call(message, "opacity"))
                            writer.uint32(/* id 2, wireType 1 =*/17).double(message.opacity);
                        return writer;
                    };

                    /**
                     * Encodes the specified Standard message, length delimited. Does not implicitly {@link rv.data.Layer.Blending.Standard.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Layer.Blending.Standard
                     * @static
                     * @param {rv.data.Layer.Blending.IStandard} message Standard message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Standard.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Standard message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Layer.Blending.Standard
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Layer.Blending.Standard} Standard
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Standard.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Layer.Blending.Standard();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.mode = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.opacity = reader.double();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Standard message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Layer.Blending.Standard
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Layer.Blending.Standard} Standard
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Standard.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Standard message.
                     * @function verify
                     * @memberof rv.data.Layer.Blending.Standard
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Standard.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.mode != null && message.hasOwnProperty("mode"))
                            switch (message.mode) {
                            default:
                                return "mode: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                            case 24:
                            case 25:
                            case 26:
                                break;
                            }
                        if (message.opacity != null && message.hasOwnProperty("opacity"))
                            if (typeof message.opacity !== "number")
                                return "opacity: number expected";
                        return null;
                    };

                    /**
                     * Creates a Standard message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Layer.Blending.Standard
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Layer.Blending.Standard} Standard
                     */
                    Standard.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Layer.Blending.Standard)
                            return object;
                        let message = new $root.rv.data.Layer.Blending.Standard();
                        switch (object.mode) {
                        default:
                            if (typeof object.mode === "number") {
                                message.mode = object.mode;
                                break;
                            }
                            break;
                        case "BLEND_MODE_NORMAL":
                        case 0:
                            message.mode = 0;
                            break;
                        case "BLEND_MODE_DISSOLVE":
                        case 1:
                            message.mode = 1;
                            break;
                        case "BLEND_MODE_DARKEN":
                        case 2:
                            message.mode = 2;
                            break;
                        case "BLEND_MODE_MULTIPLY":
                        case 3:
                            message.mode = 3;
                            break;
                        case "BLEND_MODE_COLOR_BURN":
                        case 4:
                            message.mode = 4;
                            break;
                        case "BLEND_MODE_LINEAR_BURN":
                        case 5:
                            message.mode = 5;
                            break;
                        case "BLEND_MODE_DARKER_COLOR":
                        case 6:
                            message.mode = 6;
                            break;
                        case "BLEND_MODE_LIGHTEN":
                        case 7:
                            message.mode = 7;
                            break;
                        case "BLEND_MODE_SCREEN":
                        case 8:
                            message.mode = 8;
                            break;
                        case "BLEND_MODE_COLOR_DODGE":
                        case 9:
                            message.mode = 9;
                            break;
                        case "BLEND_MODE_LINEAR_DODGE":
                        case 10:
                            message.mode = 10;
                            break;
                        case "BLEND_MODE_LIGHTER_COLOR":
                        case 11:
                            message.mode = 11;
                            break;
                        case "BLEND_MODE_OVERLAY":
                        case 12:
                            message.mode = 12;
                            break;
                        case "BLEND_MODE_SOFT_LIGHT":
                        case 13:
                            message.mode = 13;
                            break;
                        case "BLEND_MODE_HARD_LIGHT":
                        case 14:
                            message.mode = 14;
                            break;
                        case "BLEND_MODE_VIVID_LIGHT":
                        case 15:
                            message.mode = 15;
                            break;
                        case "BLEND_MODE_LINEAR_LIGHT":
                        case 16:
                            message.mode = 16;
                            break;
                        case "BLEND_MODE_PIN_LIGHT":
                        case 17:
                            message.mode = 17;
                            break;
                        case "BLEND_MODE_HARD_MIX":
                        case 18:
                            message.mode = 18;
                            break;
                        case "BLEND_MODE_DIFFERENCE":
                        case 19:
                            message.mode = 19;
                            break;
                        case "BLEND_MODE_EXCLUSION":
                        case 20:
                            message.mode = 20;
                            break;
                        case "BLEND_MODE_SUBTRACT":
                        case 21:
                            message.mode = 21;
                            break;
                        case "BLEND_MODE_DIVIDE":
                        case 22:
                            message.mode = 22;
                            break;
                        case "BLEND_MODE_HUE":
                        case 23:
                            message.mode = 23;
                            break;
                        case "BLEND_MODE_SATURATION":
                        case 24:
                            message.mode = 24;
                            break;
                        case "BLEND_MODE_COLOR":
                        case 25:
                            message.mode = 25;
                            break;
                        case "BLEND_MODE_LUMINOSITY":
                        case 26:
                            message.mode = 26;
                            break;
                        }
                        if (object.opacity != null)
                            message.opacity = Number(object.opacity);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Standard message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Layer.Blending.Standard
                     * @static
                     * @param {rv.data.Layer.Blending.Standard} message Standard
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Standard.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.mode = options.enums === String ? "BLEND_MODE_NORMAL" : 0;
                            object.opacity = 0;
                        }
                        if (message.mode != null && message.hasOwnProperty("mode"))
                            object.mode = options.enums === String ? $root.rv.data.Layer.BlendMode[message.mode] === undefined ? message.mode : $root.rv.data.Layer.BlendMode[message.mode] : message.mode;
                        if (message.opacity != null && message.hasOwnProperty("opacity"))
                            object.opacity = options.json && !isFinite(message.opacity) ? String(message.opacity) : message.opacity;
                        return object;
                    };

                    /**
                     * Converts this Standard to JSON.
                     * @function toJSON
                     * @memberof rv.data.Layer.Blending.Standard
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Standard.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Standard
                     * @function getTypeUrl
                     * @memberof rv.data.Layer.Blending.Standard
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Standard.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Layer.Blending.Standard";
                    };

                    return Standard;
                })();

                Blending.Matte = (function() {

                    /**
                     * Properties of a Matte.
                     * @memberof rv.data.Layer.Blending
                     * @interface IMatte
                     * @property {rv.data.Layer.Blending.Matte.IAlpha|null} [alpha] Matte alpha
                     * @property {rv.data.Layer.Blending.Matte.ILuma|null} [luma] Matte luma
                     * @property {rv.data.Layer.Blending.Matte.IWhite|null} [white] Matte white
                     */

                    /**
                     * Constructs a new Matte.
                     * @memberof rv.data.Layer.Blending
                     * @classdesc Represents a Matte.
                     * @implements IMatte
                     * @constructor
                     * @param {rv.data.Layer.Blending.IMatte=} [properties] Properties to set
                     */
                    function Matte(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Matte alpha.
                     * @member {rv.data.Layer.Blending.Matte.IAlpha|null|undefined} alpha
                     * @memberof rv.data.Layer.Blending.Matte
                     * @instance
                     */
                    Matte.prototype.alpha = null;

                    /**
                     * Matte luma.
                     * @member {rv.data.Layer.Blending.Matte.ILuma|null|undefined} luma
                     * @memberof rv.data.Layer.Blending.Matte
                     * @instance
                     */
                    Matte.prototype.luma = null;

                    /**
                     * Matte white.
                     * @member {rv.data.Layer.Blending.Matte.IWhite|null|undefined} white
                     * @memberof rv.data.Layer.Blending.Matte
                     * @instance
                     */
                    Matte.prototype.white = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Matte MatteType.
                     * @member {"alpha"|"luma"|"white"|undefined} MatteType
                     * @memberof rv.data.Layer.Blending.Matte
                     * @instance
                     */
                    Object.defineProperty(Matte.prototype, "MatteType", {
                        get: $util.oneOfGetter($oneOfFields = ["alpha", "luma", "white"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new Matte instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Layer.Blending.Matte
                     * @static
                     * @param {rv.data.Layer.Blending.IMatte=} [properties] Properties to set
                     * @returns {rv.data.Layer.Blending.Matte} Matte instance
                     */
                    Matte.create = function create(properties) {
                        return new Matte(properties);
                    };

                    /**
                     * Encodes the specified Matte message. Does not implicitly {@link rv.data.Layer.Blending.Matte.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Layer.Blending.Matte
                     * @static
                     * @param {rv.data.Layer.Blending.IMatte} message Matte message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Matte.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.alpha != null && Object.hasOwnProperty.call(message, "alpha"))
                            $root.rv.data.Layer.Blending.Matte.Alpha.encode(message.alpha, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.luma != null && Object.hasOwnProperty.call(message, "luma"))
                            $root.rv.data.Layer.Blending.Matte.Luma.encode(message.luma, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.white != null && Object.hasOwnProperty.call(message, "white"))
                            $root.rv.data.Layer.Blending.Matte.White.encode(message.white, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Matte message, length delimited. Does not implicitly {@link rv.data.Layer.Blending.Matte.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Layer.Blending.Matte
                     * @static
                     * @param {rv.data.Layer.Blending.IMatte} message Matte message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Matte.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Matte message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Layer.Blending.Matte
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Layer.Blending.Matte} Matte
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Matte.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Layer.Blending.Matte();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.alpha = $root.rv.data.Layer.Blending.Matte.Alpha.decode(reader, reader.uint32());
                                    break;
                                }
                            case 2: {
                                    message.luma = $root.rv.data.Layer.Blending.Matte.Luma.decode(reader, reader.uint32());
                                    break;
                                }
                            case 4: {
                                    message.white = $root.rv.data.Layer.Blending.Matte.White.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Matte message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Layer.Blending.Matte
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Layer.Blending.Matte} Matte
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Matte.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Matte message.
                     * @function verify
                     * @memberof rv.data.Layer.Blending.Matte
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Matte.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.alpha != null && message.hasOwnProperty("alpha")) {
                            properties.MatteType = 1;
                            {
                                let error = $root.rv.data.Layer.Blending.Matte.Alpha.verify(message.alpha);
                                if (error)
                                    return "alpha." + error;
                            }
                        }
                        if (message.luma != null && message.hasOwnProperty("luma")) {
                            if (properties.MatteType === 1)
                                return "MatteType: multiple values";
                            properties.MatteType = 1;
                            {
                                let error = $root.rv.data.Layer.Blending.Matte.Luma.verify(message.luma);
                                if (error)
                                    return "luma." + error;
                            }
                        }
                        if (message.white != null && message.hasOwnProperty("white")) {
                            if (properties.MatteType === 1)
                                return "MatteType: multiple values";
                            properties.MatteType = 1;
                            {
                                let error = $root.rv.data.Layer.Blending.Matte.White.verify(message.white);
                                if (error)
                                    return "white." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Matte message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Layer.Blending.Matte
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Layer.Blending.Matte} Matte
                     */
                    Matte.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Layer.Blending.Matte)
                            return object;
                        let message = new $root.rv.data.Layer.Blending.Matte();
                        if (object.alpha != null) {
                            if (typeof object.alpha !== "object")
                                throw TypeError(".rv.data.Layer.Blending.Matte.alpha: object expected");
                            message.alpha = $root.rv.data.Layer.Blending.Matte.Alpha.fromObject(object.alpha);
                        }
                        if (object.luma != null) {
                            if (typeof object.luma !== "object")
                                throw TypeError(".rv.data.Layer.Blending.Matte.luma: object expected");
                            message.luma = $root.rv.data.Layer.Blending.Matte.Luma.fromObject(object.luma);
                        }
                        if (object.white != null) {
                            if (typeof object.white !== "object")
                                throw TypeError(".rv.data.Layer.Blending.Matte.white: object expected");
                            message.white = $root.rv.data.Layer.Blending.Matte.White.fromObject(object.white);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Matte message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Layer.Blending.Matte
                     * @static
                     * @param {rv.data.Layer.Blending.Matte} message Matte
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Matte.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (message.alpha != null && message.hasOwnProperty("alpha")) {
                            object.alpha = $root.rv.data.Layer.Blending.Matte.Alpha.toObject(message.alpha, options);
                            if (options.oneofs)
                                object.MatteType = "alpha";
                        }
                        if (message.luma != null && message.hasOwnProperty("luma")) {
                            object.luma = $root.rv.data.Layer.Blending.Matte.Luma.toObject(message.luma, options);
                            if (options.oneofs)
                                object.MatteType = "luma";
                        }
                        if (message.white != null && message.hasOwnProperty("white")) {
                            object.white = $root.rv.data.Layer.Blending.Matte.White.toObject(message.white, options);
                            if (options.oneofs)
                                object.MatteType = "white";
                        }
                        return object;
                    };

                    /**
                     * Converts this Matte to JSON.
                     * @function toJSON
                     * @memberof rv.data.Layer.Blending.Matte
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Matte.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Matte
                     * @function getTypeUrl
                     * @memberof rv.data.Layer.Blending.Matte
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Matte.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Layer.Blending.Matte";
                    };

                    Matte.Alpha = (function() {

                        /**
                         * Properties of an Alpha.
                         * @memberof rv.data.Layer.Blending.Matte
                         * @interface IAlpha
                         * @property {boolean|null} [inverted] Alpha inverted
                         */

                        /**
                         * Constructs a new Alpha.
                         * @memberof rv.data.Layer.Blending.Matte
                         * @classdesc Represents an Alpha.
                         * @implements IAlpha
                         * @constructor
                         * @param {rv.data.Layer.Blending.Matte.IAlpha=} [properties] Properties to set
                         */
                        function Alpha(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Alpha inverted.
                         * @member {boolean} inverted
                         * @memberof rv.data.Layer.Blending.Matte.Alpha
                         * @instance
                         */
                        Alpha.prototype.inverted = false;

                        /**
                         * Creates a new Alpha instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Layer.Blending.Matte.Alpha
                         * @static
                         * @param {rv.data.Layer.Blending.Matte.IAlpha=} [properties] Properties to set
                         * @returns {rv.data.Layer.Blending.Matte.Alpha} Alpha instance
                         */
                        Alpha.create = function create(properties) {
                            return new Alpha(properties);
                        };

                        /**
                         * Encodes the specified Alpha message. Does not implicitly {@link rv.data.Layer.Blending.Matte.Alpha.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Layer.Blending.Matte.Alpha
                         * @static
                         * @param {rv.data.Layer.Blending.Matte.IAlpha} message Alpha message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Alpha.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.inverted != null && Object.hasOwnProperty.call(message, "inverted"))
                                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.inverted);
                            return writer;
                        };

                        /**
                         * Encodes the specified Alpha message, length delimited. Does not implicitly {@link rv.data.Layer.Blending.Matte.Alpha.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Layer.Blending.Matte.Alpha
                         * @static
                         * @param {rv.data.Layer.Blending.Matte.IAlpha} message Alpha message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Alpha.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Alpha message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Layer.Blending.Matte.Alpha
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Layer.Blending.Matte.Alpha} Alpha
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Alpha.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Layer.Blending.Matte.Alpha();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.inverted = reader.bool();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Alpha message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Layer.Blending.Matte.Alpha
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Layer.Blending.Matte.Alpha} Alpha
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Alpha.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Alpha message.
                         * @function verify
                         * @memberof rv.data.Layer.Blending.Matte.Alpha
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Alpha.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.inverted != null && message.hasOwnProperty("inverted"))
                                if (typeof message.inverted !== "boolean")
                                    return "inverted: boolean expected";
                            return null;
                        };

                        /**
                         * Creates an Alpha message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Layer.Blending.Matte.Alpha
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Layer.Blending.Matte.Alpha} Alpha
                         */
                        Alpha.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Layer.Blending.Matte.Alpha)
                                return object;
                            let message = new $root.rv.data.Layer.Blending.Matte.Alpha();
                            if (object.inverted != null)
                                message.inverted = Boolean(object.inverted);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Alpha message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Layer.Blending.Matte.Alpha
                         * @static
                         * @param {rv.data.Layer.Blending.Matte.Alpha} message Alpha
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Alpha.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.inverted = false;
                            if (message.inverted != null && message.hasOwnProperty("inverted"))
                                object.inverted = message.inverted;
                            return object;
                        };

                        /**
                         * Converts this Alpha to JSON.
                         * @function toJSON
                         * @memberof rv.data.Layer.Blending.Matte.Alpha
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Alpha.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Alpha
                         * @function getTypeUrl
                         * @memberof rv.data.Layer.Blending.Matte.Alpha
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Alpha.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Layer.Blending.Matte.Alpha";
                        };

                        return Alpha;
                    })();

                    Matte.Luma = (function() {

                        /**
                         * Properties of a Luma.
                         * @memberof rv.data.Layer.Blending.Matte
                         * @interface ILuma
                         * @property {boolean|null} [inverted] Luma inverted
                         */

                        /**
                         * Constructs a new Luma.
                         * @memberof rv.data.Layer.Blending.Matte
                         * @classdesc Represents a Luma.
                         * @implements ILuma
                         * @constructor
                         * @param {rv.data.Layer.Blending.Matte.ILuma=} [properties] Properties to set
                         */
                        function Luma(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Luma inverted.
                         * @member {boolean} inverted
                         * @memberof rv.data.Layer.Blending.Matte.Luma
                         * @instance
                         */
                        Luma.prototype.inverted = false;

                        /**
                         * Creates a new Luma instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Layer.Blending.Matte.Luma
                         * @static
                         * @param {rv.data.Layer.Blending.Matte.ILuma=} [properties] Properties to set
                         * @returns {rv.data.Layer.Blending.Matte.Luma} Luma instance
                         */
                        Luma.create = function create(properties) {
                            return new Luma(properties);
                        };

                        /**
                         * Encodes the specified Luma message. Does not implicitly {@link rv.data.Layer.Blending.Matte.Luma.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Layer.Blending.Matte.Luma
                         * @static
                         * @param {rv.data.Layer.Blending.Matte.ILuma} message Luma message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Luma.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.inverted != null && Object.hasOwnProperty.call(message, "inverted"))
                                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.inverted);
                            return writer;
                        };

                        /**
                         * Encodes the specified Luma message, length delimited. Does not implicitly {@link rv.data.Layer.Blending.Matte.Luma.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Layer.Blending.Matte.Luma
                         * @static
                         * @param {rv.data.Layer.Blending.Matte.ILuma} message Luma message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Luma.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Luma message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Layer.Blending.Matte.Luma
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Layer.Blending.Matte.Luma} Luma
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Luma.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Layer.Blending.Matte.Luma();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.inverted = reader.bool();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Luma message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Layer.Blending.Matte.Luma
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Layer.Blending.Matte.Luma} Luma
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Luma.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Luma message.
                         * @function verify
                         * @memberof rv.data.Layer.Blending.Matte.Luma
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Luma.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.inverted != null && message.hasOwnProperty("inverted"))
                                if (typeof message.inverted !== "boolean")
                                    return "inverted: boolean expected";
                            return null;
                        };

                        /**
                         * Creates a Luma message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Layer.Blending.Matte.Luma
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Layer.Blending.Matte.Luma} Luma
                         */
                        Luma.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Layer.Blending.Matte.Luma)
                                return object;
                            let message = new $root.rv.data.Layer.Blending.Matte.Luma();
                            if (object.inverted != null)
                                message.inverted = Boolean(object.inverted);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Luma message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Layer.Blending.Matte.Luma
                         * @static
                         * @param {rv.data.Layer.Blending.Matte.Luma} message Luma
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Luma.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.inverted = false;
                            if (message.inverted != null && message.hasOwnProperty("inverted"))
                                object.inverted = message.inverted;
                            return object;
                        };

                        /**
                         * Converts this Luma to JSON.
                         * @function toJSON
                         * @memberof rv.data.Layer.Blending.Matte.Luma
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Luma.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Luma
                         * @function getTypeUrl
                         * @memberof rv.data.Layer.Blending.Matte.Luma
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Luma.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Layer.Blending.Matte.Luma";
                        };

                        return Luma;
                    })();

                    Matte.White = (function() {

                        /**
                         * Properties of a White.
                         * @memberof rv.data.Layer.Blending.Matte
                         * @interface IWhite
                         */

                        /**
                         * Constructs a new White.
                         * @memberof rv.data.Layer.Blending.Matte
                         * @classdesc Represents a White.
                         * @implements IWhite
                         * @constructor
                         * @param {rv.data.Layer.Blending.Matte.IWhite=} [properties] Properties to set
                         */
                        function White(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new White instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Layer.Blending.Matte.White
                         * @static
                         * @param {rv.data.Layer.Blending.Matte.IWhite=} [properties] Properties to set
                         * @returns {rv.data.Layer.Blending.Matte.White} White instance
                         */
                        White.create = function create(properties) {
                            return new White(properties);
                        };

                        /**
                         * Encodes the specified White message. Does not implicitly {@link rv.data.Layer.Blending.Matte.White.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Layer.Blending.Matte.White
                         * @static
                         * @param {rv.data.Layer.Blending.Matte.IWhite} message White message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        White.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified White message, length delimited. Does not implicitly {@link rv.data.Layer.Blending.Matte.White.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Layer.Blending.Matte.White
                         * @static
                         * @param {rv.data.Layer.Blending.Matte.IWhite} message White message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        White.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a White message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Layer.Blending.Matte.White
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Layer.Blending.Matte.White} White
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        White.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Layer.Blending.Matte.White();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a White message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Layer.Blending.Matte.White
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Layer.Blending.Matte.White} White
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        White.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a White message.
                         * @function verify
                         * @memberof rv.data.Layer.Blending.Matte.White
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        White.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a White message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Layer.Blending.Matte.White
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Layer.Blending.Matte.White} White
                         */
                        White.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Layer.Blending.Matte.White)
                                return object;
                            return new $root.rv.data.Layer.Blending.Matte.White();
                        };

                        /**
                         * Creates a plain object from a White message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Layer.Blending.Matte.White
                         * @static
                         * @param {rv.data.Layer.Blending.Matte.White} message White
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        White.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this White to JSON.
                         * @function toJSON
                         * @memberof rv.data.Layer.Blending.Matte.White
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        White.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for White
                         * @function getTypeUrl
                         * @memberof rv.data.Layer.Blending.Matte.White
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        White.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Layer.Blending.Matte.White";
                        };

                        return White;
                    })();

                    return Matte;
                })();

                return Blending;
            })();

            /**
             * BlendMode enum.
             * @name rv.data.Layer.BlendMode
             * @enum {number}
             * @property {number} BLEND_MODE_NORMAL=0 BLEND_MODE_NORMAL value
             * @property {number} BLEND_MODE_DISSOLVE=1 BLEND_MODE_DISSOLVE value
             * @property {number} BLEND_MODE_DARKEN=2 BLEND_MODE_DARKEN value
             * @property {number} BLEND_MODE_MULTIPLY=3 BLEND_MODE_MULTIPLY value
             * @property {number} BLEND_MODE_COLOR_BURN=4 BLEND_MODE_COLOR_BURN value
             * @property {number} BLEND_MODE_LINEAR_BURN=5 BLEND_MODE_LINEAR_BURN value
             * @property {number} BLEND_MODE_DARKER_COLOR=6 BLEND_MODE_DARKER_COLOR value
             * @property {number} BLEND_MODE_LIGHTEN=7 BLEND_MODE_LIGHTEN value
             * @property {number} BLEND_MODE_SCREEN=8 BLEND_MODE_SCREEN value
             * @property {number} BLEND_MODE_COLOR_DODGE=9 BLEND_MODE_COLOR_DODGE value
             * @property {number} BLEND_MODE_LINEAR_DODGE=10 BLEND_MODE_LINEAR_DODGE value
             * @property {number} BLEND_MODE_LIGHTER_COLOR=11 BLEND_MODE_LIGHTER_COLOR value
             * @property {number} BLEND_MODE_OVERLAY=12 BLEND_MODE_OVERLAY value
             * @property {number} BLEND_MODE_SOFT_LIGHT=13 BLEND_MODE_SOFT_LIGHT value
             * @property {number} BLEND_MODE_HARD_LIGHT=14 BLEND_MODE_HARD_LIGHT value
             * @property {number} BLEND_MODE_VIVID_LIGHT=15 BLEND_MODE_VIVID_LIGHT value
             * @property {number} BLEND_MODE_LINEAR_LIGHT=16 BLEND_MODE_LINEAR_LIGHT value
             * @property {number} BLEND_MODE_PIN_LIGHT=17 BLEND_MODE_PIN_LIGHT value
             * @property {number} BLEND_MODE_HARD_MIX=18 BLEND_MODE_HARD_MIX value
             * @property {number} BLEND_MODE_DIFFERENCE=19 BLEND_MODE_DIFFERENCE value
             * @property {number} BLEND_MODE_EXCLUSION=20 BLEND_MODE_EXCLUSION value
             * @property {number} BLEND_MODE_SUBTRACT=21 BLEND_MODE_SUBTRACT value
             * @property {number} BLEND_MODE_DIVIDE=22 BLEND_MODE_DIVIDE value
             * @property {number} BLEND_MODE_HUE=23 BLEND_MODE_HUE value
             * @property {number} BLEND_MODE_SATURATION=24 BLEND_MODE_SATURATION value
             * @property {number} BLEND_MODE_COLOR=25 BLEND_MODE_COLOR value
             * @property {number} BLEND_MODE_LUMINOSITY=26 BLEND_MODE_LUMINOSITY value
             */
            Layer.BlendMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "BLEND_MODE_NORMAL"] = 0;
                values[valuesById[1] = "BLEND_MODE_DISSOLVE"] = 1;
                values[valuesById[2] = "BLEND_MODE_DARKEN"] = 2;
                values[valuesById[3] = "BLEND_MODE_MULTIPLY"] = 3;
                values[valuesById[4] = "BLEND_MODE_COLOR_BURN"] = 4;
                values[valuesById[5] = "BLEND_MODE_LINEAR_BURN"] = 5;
                values[valuesById[6] = "BLEND_MODE_DARKER_COLOR"] = 6;
                values[valuesById[7] = "BLEND_MODE_LIGHTEN"] = 7;
                values[valuesById[8] = "BLEND_MODE_SCREEN"] = 8;
                values[valuesById[9] = "BLEND_MODE_COLOR_DODGE"] = 9;
                values[valuesById[10] = "BLEND_MODE_LINEAR_DODGE"] = 10;
                values[valuesById[11] = "BLEND_MODE_LIGHTER_COLOR"] = 11;
                values[valuesById[12] = "BLEND_MODE_OVERLAY"] = 12;
                values[valuesById[13] = "BLEND_MODE_SOFT_LIGHT"] = 13;
                values[valuesById[14] = "BLEND_MODE_HARD_LIGHT"] = 14;
                values[valuesById[15] = "BLEND_MODE_VIVID_LIGHT"] = 15;
                values[valuesById[16] = "BLEND_MODE_LINEAR_LIGHT"] = 16;
                values[valuesById[17] = "BLEND_MODE_PIN_LIGHT"] = 17;
                values[valuesById[18] = "BLEND_MODE_HARD_MIX"] = 18;
                values[valuesById[19] = "BLEND_MODE_DIFFERENCE"] = 19;
                values[valuesById[20] = "BLEND_MODE_EXCLUSION"] = 20;
                values[valuesById[21] = "BLEND_MODE_SUBTRACT"] = 21;
                values[valuesById[22] = "BLEND_MODE_DIVIDE"] = 22;
                values[valuesById[23] = "BLEND_MODE_HUE"] = 23;
                values[valuesById[24] = "BLEND_MODE_SATURATION"] = 24;
                values[valuesById[25] = "BLEND_MODE_COLOR"] = 25;
                values[valuesById[26] = "BLEND_MODE_LUMINOSITY"] = 26;
                return values;
            })();

            return Layer;
        })();

        data.HotKey = (function() {

            /**
             * Properties of a HotKey.
             * @memberof rv.data
             * @interface IHotKey
             * @property {rv.data.KeyCode|null} [code] HotKey code
             * @property {string|null} [controlIdentifier] HotKey controlIdentifier
             */

            /**
             * Constructs a new HotKey.
             * @memberof rv.data
             * @classdesc Represents a HotKey.
             * @implements IHotKey
             * @constructor
             * @param {rv.data.IHotKey=} [properties] Properties to set
             */
            function HotKey(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HotKey code.
             * @member {rv.data.KeyCode} code
             * @memberof rv.data.HotKey
             * @instance
             */
            HotKey.prototype.code = 0;

            /**
             * HotKey controlIdentifier.
             * @member {string} controlIdentifier
             * @memberof rv.data.HotKey
             * @instance
             */
            HotKey.prototype.controlIdentifier = "";

            /**
             * Creates a new HotKey instance using the specified properties.
             * @function create
             * @memberof rv.data.HotKey
             * @static
             * @param {rv.data.IHotKey=} [properties] Properties to set
             * @returns {rv.data.HotKey} HotKey instance
             */
            HotKey.create = function create(properties) {
                return new HotKey(properties);
            };

            /**
             * Encodes the specified HotKey message. Does not implicitly {@link rv.data.HotKey.verify|verify} messages.
             * @function encode
             * @memberof rv.data.HotKey
             * @static
             * @param {rv.data.IHotKey} message HotKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HotKey.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.controlIdentifier != null && Object.hasOwnProperty.call(message, "controlIdentifier"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.controlIdentifier);
                return writer;
            };

            /**
             * Encodes the specified HotKey message, length delimited. Does not implicitly {@link rv.data.HotKey.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.HotKey
             * @static
             * @param {rv.data.IHotKey} message HotKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HotKey.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HotKey message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.HotKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.HotKey} HotKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HotKey.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.HotKey();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.code = reader.int32();
                            break;
                        }
                    case 2: {
                            message.controlIdentifier = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HotKey message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.HotKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.HotKey} HotKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HotKey.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HotKey message.
             * @function verify
             * @memberof rv.data.HotKey
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HotKey.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 39:
                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 58:
                    case 59:
                    case 60:
                    case 61:
                    case 62:
                    case 63:
                    case 64:
                    case 65:
                    case 66:
                    case 67:
                    case 68:
                    case 69:
                    case 70:
                    case 71:
                    case 72:
                    case 73:
                    case 74:
                    case 75:
                    case 76:
                    case 77:
                    case 78:
                    case 79:
                    case 80:
                    case 81:
                    case 82:
                    case 83:
                    case 84:
                    case 85:
                    case 86:
                    case 87:
                    case 88:
                    case 89:
                    case 90:
                    case 91:
                    case 92:
                    case 93:
                    case 94:
                    case 95:
                    case 96:
                    case 97:
                    case 98:
                    case 99:
                    case 100:
                    case 101:
                    case 102:
                    case 103:
                    case 104:
                    case 105:
                    case 106:
                    case 107:
                    case 108:
                    case 109:
                    case 110:
                    case 111:
                    case 112:
                    case 113:
                    case 114:
                    case 115:
                    case 116:
                    case 117:
                        break;
                    }
                if (message.controlIdentifier != null && message.hasOwnProperty("controlIdentifier"))
                    if (!$util.isString(message.controlIdentifier))
                        return "controlIdentifier: string expected";
                return null;
            };

            /**
             * Creates a HotKey message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.HotKey
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.HotKey} HotKey
             */
            HotKey.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.HotKey)
                    return object;
                let message = new $root.rv.data.HotKey();
                switch (object.code) {
                default:
                    if (typeof object.code === "number") {
                        message.code = object.code;
                        break;
                    }
                    break;
                case "KEY_CODE_UNKNOWN":
                case 0:
                    message.code = 0;
                    break;
                case "KEY_CODE_ANSI_A":
                case 1:
                    message.code = 1;
                    break;
                case "KEY_CODE_ANSI_B":
                case 2:
                    message.code = 2;
                    break;
                case "KEY_CODE_ANSI_C":
                case 3:
                    message.code = 3;
                    break;
                case "KEY_CODE_ANSI_D":
                case 4:
                    message.code = 4;
                    break;
                case "KEY_CODE_ANSI_E":
                case 5:
                    message.code = 5;
                    break;
                case "KEY_CODE_ANSI_F":
                case 6:
                    message.code = 6;
                    break;
                case "KEY_CODE_ANSI_G":
                case 7:
                    message.code = 7;
                    break;
                case "KEY_CODE_ANSI_H":
                case 8:
                    message.code = 8;
                    break;
                case "KEY_CODE_ANSI_I":
                case 9:
                    message.code = 9;
                    break;
                case "KEY_CODE_ANSI_J":
                case 10:
                    message.code = 10;
                    break;
                case "KEY_CODE_ANSI_K":
                case 11:
                    message.code = 11;
                    break;
                case "KEY_CODE_ANSI_L":
                case 12:
                    message.code = 12;
                    break;
                case "KEY_CODE_ANSI_M":
                case 13:
                    message.code = 13;
                    break;
                case "KEY_CODE_ANSI_N":
                case 14:
                    message.code = 14;
                    break;
                case "KEY_CODE_ANSI_O":
                case 15:
                    message.code = 15;
                    break;
                case "KEY_CODE_ANSI_P":
                case 16:
                    message.code = 16;
                    break;
                case "KEY_CODE_ANSI_Q":
                case 17:
                    message.code = 17;
                    break;
                case "KEY_CODE_ANSI_R":
                case 18:
                    message.code = 18;
                    break;
                case "KEY_CODE_ANSI_S":
                case 19:
                    message.code = 19;
                    break;
                case "KEY_CODE_ANSI_T":
                case 20:
                    message.code = 20;
                    break;
                case "KEY_CODE_ANSI_U":
                case 21:
                    message.code = 21;
                    break;
                case "KEY_CODE_ANSI_V":
                case 22:
                    message.code = 22;
                    break;
                case "KEY_CODE_ANSI_W":
                case 23:
                    message.code = 23;
                    break;
                case "KEY_CODE_ANSI_X":
                case 24:
                    message.code = 24;
                    break;
                case "KEY_CODE_ANSI_Y":
                case 25:
                    message.code = 25;
                    break;
                case "KEY_CODE_ANSI_Z":
                case 26:
                    message.code = 26;
                    break;
                case "KEY_CODE_ANSI_0":
                case 27:
                    message.code = 27;
                    break;
                case "KEY_CODE_ANSI_1":
                case 28:
                    message.code = 28;
                    break;
                case "KEY_CODE_ANSI_2":
                case 29:
                    message.code = 29;
                    break;
                case "KEY_CODE_ANSI_3":
                case 30:
                    message.code = 30;
                    break;
                case "KEY_CODE_ANSI_4":
                case 31:
                    message.code = 31;
                    break;
                case "KEY_CODE_ANSI_5":
                case 32:
                    message.code = 32;
                    break;
                case "KEY_CODE_ANSI_6":
                case 33:
                    message.code = 33;
                    break;
                case "KEY_CODE_ANSI_7":
                case 34:
                    message.code = 34;
                    break;
                case "KEY_CODE_ANSI_8":
                case 35:
                    message.code = 35;
                    break;
                case "KEY_CODE_ANSI_9":
                case 36:
                    message.code = 36;
                    break;
                case "KEY_CODE_ANSI_EQUAL":
                case 37:
                    message.code = 37;
                    break;
                case "KEY_CODE_ANSI_MINUS":
                case 38:
                    message.code = 38;
                    break;
                case "KEY_CODE_ANSI_RIGHT_BRACKET":
                case 39:
                    message.code = 39;
                    break;
                case "KEY_CODE_ANSI_LEFT_BRACKET":
                case 40:
                    message.code = 40;
                    break;
                case "KEY_CODE_ANSI_QUOTE":
                case 41:
                    message.code = 41;
                    break;
                case "KEY_CODE_ANSI_SEMICOLON":
                case 42:
                    message.code = 42;
                    break;
                case "KEY_CODE_ANSI_BACKSLASH":
                case 43:
                    message.code = 43;
                    break;
                case "KEY_CODE_ANSI_COMMA":
                case 44:
                    message.code = 44;
                    break;
                case "KEY_CODE_ANSI_SLASH":
                case 45:
                    message.code = 45;
                    break;
                case "KEY_CODE_ANSI_PERIOD":
                case 46:
                    message.code = 46;
                    break;
                case "KEY_CODE_ANSI_GRAVE":
                case 47:
                    message.code = 47;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_DECIMAL":
                case 48:
                    message.code = 48;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_PLUS":
                case 49:
                    message.code = 49;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_CLEAR":
                case 50:
                    message.code = 50;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_DIVIDE":
                case 51:
                    message.code = 51;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_ENTER":
                case 52:
                    message.code = 52;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_MINUS":
                case 53:
                    message.code = 53;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_EQUALS":
                case 54:
                    message.code = 54;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_0":
                case 55:
                    message.code = 55;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_1":
                case 56:
                    message.code = 56;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_2":
                case 57:
                    message.code = 57;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_3":
                case 58:
                    message.code = 58;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_4":
                case 59:
                    message.code = 59;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_5":
                case 60:
                    message.code = 60;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_6":
                case 61:
                    message.code = 61;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_7":
                case 62:
                    message.code = 62;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_8":
                case 63:
                    message.code = 63;
                    break;
                case "KEY_CODE_ANSI_KEYPAD_9":
                case 64:
                    message.code = 64;
                    break;
                case "KEY_CODE_F1":
                case 65:
                    message.code = 65;
                    break;
                case "KEY_CODE_F2":
                case 66:
                    message.code = 66;
                    break;
                case "KEY_CODE_F3":
                case 67:
                    message.code = 67;
                    break;
                case "KEY_CODE_F4":
                case 68:
                    message.code = 68;
                    break;
                case "KEY_CODE_F5":
                case 69:
                    message.code = 69;
                    break;
                case "KEY_CODE_F6":
                case 70:
                    message.code = 70;
                    break;
                case "KEY_CODE_F7":
                case 71:
                    message.code = 71;
                    break;
                case "KEY_CODE_F8":
                case 72:
                    message.code = 72;
                    break;
                case "KEY_CODE_F9":
                case 73:
                    message.code = 73;
                    break;
                case "KEY_CODE_F10":
                case 74:
                    message.code = 74;
                    break;
                case "KEY_CODE_F11":
                case 75:
                    message.code = 75;
                    break;
                case "KEY_CODE_F12":
                case 76:
                    message.code = 76;
                    break;
                case "KEY_CODE_F13":
                case 77:
                    message.code = 77;
                    break;
                case "KEY_CODE_F14":
                case 78:
                    message.code = 78;
                    break;
                case "KEY_CODE_F15":
                case 79:
                    message.code = 79;
                    break;
                case "KEY_CODE_F16":
                case 80:
                    message.code = 80;
                    break;
                case "KEY_CODE_F17":
                case 81:
                    message.code = 81;
                    break;
                case "KEY_CODE_F18":
                case 82:
                    message.code = 82;
                    break;
                case "KEY_CODE_F19":
                case 83:
                    message.code = 83;
                    break;
                case "KEY_CODE_F20":
                case 84:
                    message.code = 84;
                    break;
                case "KEY_CODE_FUNCTION":
                case 85:
                    message.code = 85;
                    break;
                case "KEY_CODE_RETURN":
                case 86:
                    message.code = 86;
                    break;
                case "KEY_CODE_TAB":
                case 87:
                    message.code = 87;
                    break;
                case "KEY_CODE_SPACE":
                case 88:
                    message.code = 88;
                    break;
                case "KEY_CODE_DELETE":
                case 89:
                    message.code = 89;
                    break;
                case "KEY_CODE_ESCAPE":
                case 90:
                    message.code = 90;
                    break;
                case "KEY_CODE_COMMAND":
                case 91:
                    message.code = 91;
                    break;
                case "KEY_CODE_SHIFT":
                case 92:
                    message.code = 92;
                    break;
                case "KEY_CODE_CAPS_LOCK":
                case 93:
                    message.code = 93;
                    break;
                case "KEY_CODE_OPTION":
                case 94:
                    message.code = 94;
                    break;
                case "KEY_CODE_CONTROL":
                case 95:
                    message.code = 95;
                    break;
                case "KEY_CODE_RIGHT_SHIFT":
                case 96:
                    message.code = 96;
                    break;
                case "KEY_CODE_RIGHT_OPTION":
                case 97:
                    message.code = 97;
                    break;
                case "KEY_CODE_RIGHT_CONTROL":
                case 98:
                    message.code = 98;
                    break;
                case "KEY_CODE_VOLUME_UP":
                case 99:
                    message.code = 99;
                    break;
                case "KEY_CODE_VOLUME_DOWN":
                case 100:
                    message.code = 100;
                    break;
                case "KEY_CODE_MUTE":
                case 101:
                    message.code = 101;
                    break;
                case "KEY_CODE_HELP":
                case 102:
                    message.code = 102;
                    break;
                case "KEY_CODE_HOME":
                case 103:
                    message.code = 103;
                    break;
                case "KEY_CODE_PAGE_UP":
                case 104:
                    message.code = 104;
                    break;
                case "KEY_CODE_FORWARD_DELETE":
                case 105:
                    message.code = 105;
                    break;
                case "KEY_CODE_END":
                case 106:
                    message.code = 106;
                    break;
                case "KEY_CODE_PAGE_DOWN":
                case 107:
                    message.code = 107;
                    break;
                case "KEY_CODE_LEFT_ARROW":
                case 108:
                    message.code = 108;
                    break;
                case "KEY_CODE_RIGHT_ARROW":
                case 109:
                    message.code = 109;
                    break;
                case "KEY_CODE_DOWN_ARROW":
                case 110:
                    message.code = 110;
                    break;
                case "KEY_CODE_UP_ARROW":
                case 111:
                    message.code = 111;
                    break;
                case "KEY_CODE_ISO_SELECTION":
                case 112:
                    message.code = 112;
                    break;
                case "KEY_CODE_JIS_YEN":
                case 113:
                    message.code = 113;
                    break;
                case "KEY_CODE_JIS_UNDERSCORE":
                case 114:
                    message.code = 114;
                    break;
                case "KEY_CODE_JIS_KEYPAD_COMMA":
                case 115:
                    message.code = 115;
                    break;
                case "KEY_CODE_JIS_EISU":
                case 116:
                    message.code = 116;
                    break;
                case "KEY_CODE_JIS_KANA":
                case 117:
                    message.code = 117;
                    break;
                }
                if (object.controlIdentifier != null)
                    message.controlIdentifier = String(object.controlIdentifier);
                return message;
            };

            /**
             * Creates a plain object from a HotKey message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.HotKey
             * @static
             * @param {rv.data.HotKey} message HotKey
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HotKey.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.code = options.enums === String ? "KEY_CODE_UNKNOWN" : 0;
                    object.controlIdentifier = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.rv.data.KeyCode[message.code] === undefined ? message.code : $root.rv.data.KeyCode[message.code] : message.code;
                if (message.controlIdentifier != null && message.hasOwnProperty("controlIdentifier"))
                    object.controlIdentifier = message.controlIdentifier;
                return object;
            };

            /**
             * Converts this HotKey to JSON.
             * @function toJSON
             * @memberof rv.data.HotKey
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HotKey.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for HotKey
             * @function getTypeUrl
             * @memberof rv.data.HotKey
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            HotKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.HotKey";
            };

            return HotKey;
        })();

        /**
         * KeyCode enum.
         * @name rv.data.KeyCode
         * @enum {number}
         * @property {number} KEY_CODE_UNKNOWN=0 KEY_CODE_UNKNOWN value
         * @property {number} KEY_CODE_ANSI_A=1 KEY_CODE_ANSI_A value
         * @property {number} KEY_CODE_ANSI_B=2 KEY_CODE_ANSI_B value
         * @property {number} KEY_CODE_ANSI_C=3 KEY_CODE_ANSI_C value
         * @property {number} KEY_CODE_ANSI_D=4 KEY_CODE_ANSI_D value
         * @property {number} KEY_CODE_ANSI_E=5 KEY_CODE_ANSI_E value
         * @property {number} KEY_CODE_ANSI_F=6 KEY_CODE_ANSI_F value
         * @property {number} KEY_CODE_ANSI_G=7 KEY_CODE_ANSI_G value
         * @property {number} KEY_CODE_ANSI_H=8 KEY_CODE_ANSI_H value
         * @property {number} KEY_CODE_ANSI_I=9 KEY_CODE_ANSI_I value
         * @property {number} KEY_CODE_ANSI_J=10 KEY_CODE_ANSI_J value
         * @property {number} KEY_CODE_ANSI_K=11 KEY_CODE_ANSI_K value
         * @property {number} KEY_CODE_ANSI_L=12 KEY_CODE_ANSI_L value
         * @property {number} KEY_CODE_ANSI_M=13 KEY_CODE_ANSI_M value
         * @property {number} KEY_CODE_ANSI_N=14 KEY_CODE_ANSI_N value
         * @property {number} KEY_CODE_ANSI_O=15 KEY_CODE_ANSI_O value
         * @property {number} KEY_CODE_ANSI_P=16 KEY_CODE_ANSI_P value
         * @property {number} KEY_CODE_ANSI_Q=17 KEY_CODE_ANSI_Q value
         * @property {number} KEY_CODE_ANSI_R=18 KEY_CODE_ANSI_R value
         * @property {number} KEY_CODE_ANSI_S=19 KEY_CODE_ANSI_S value
         * @property {number} KEY_CODE_ANSI_T=20 KEY_CODE_ANSI_T value
         * @property {number} KEY_CODE_ANSI_U=21 KEY_CODE_ANSI_U value
         * @property {number} KEY_CODE_ANSI_V=22 KEY_CODE_ANSI_V value
         * @property {number} KEY_CODE_ANSI_W=23 KEY_CODE_ANSI_W value
         * @property {number} KEY_CODE_ANSI_X=24 KEY_CODE_ANSI_X value
         * @property {number} KEY_CODE_ANSI_Y=25 KEY_CODE_ANSI_Y value
         * @property {number} KEY_CODE_ANSI_Z=26 KEY_CODE_ANSI_Z value
         * @property {number} KEY_CODE_ANSI_0=27 KEY_CODE_ANSI_0 value
         * @property {number} KEY_CODE_ANSI_1=28 KEY_CODE_ANSI_1 value
         * @property {number} KEY_CODE_ANSI_2=29 KEY_CODE_ANSI_2 value
         * @property {number} KEY_CODE_ANSI_3=30 KEY_CODE_ANSI_3 value
         * @property {number} KEY_CODE_ANSI_4=31 KEY_CODE_ANSI_4 value
         * @property {number} KEY_CODE_ANSI_5=32 KEY_CODE_ANSI_5 value
         * @property {number} KEY_CODE_ANSI_6=33 KEY_CODE_ANSI_6 value
         * @property {number} KEY_CODE_ANSI_7=34 KEY_CODE_ANSI_7 value
         * @property {number} KEY_CODE_ANSI_8=35 KEY_CODE_ANSI_8 value
         * @property {number} KEY_CODE_ANSI_9=36 KEY_CODE_ANSI_9 value
         * @property {number} KEY_CODE_ANSI_EQUAL=37 KEY_CODE_ANSI_EQUAL value
         * @property {number} KEY_CODE_ANSI_MINUS=38 KEY_CODE_ANSI_MINUS value
         * @property {number} KEY_CODE_ANSI_RIGHT_BRACKET=39 KEY_CODE_ANSI_RIGHT_BRACKET value
         * @property {number} KEY_CODE_ANSI_LEFT_BRACKET=40 KEY_CODE_ANSI_LEFT_BRACKET value
         * @property {number} KEY_CODE_ANSI_QUOTE=41 KEY_CODE_ANSI_QUOTE value
         * @property {number} KEY_CODE_ANSI_SEMICOLON=42 KEY_CODE_ANSI_SEMICOLON value
         * @property {number} KEY_CODE_ANSI_BACKSLASH=43 KEY_CODE_ANSI_BACKSLASH value
         * @property {number} KEY_CODE_ANSI_COMMA=44 KEY_CODE_ANSI_COMMA value
         * @property {number} KEY_CODE_ANSI_SLASH=45 KEY_CODE_ANSI_SLASH value
         * @property {number} KEY_CODE_ANSI_PERIOD=46 KEY_CODE_ANSI_PERIOD value
         * @property {number} KEY_CODE_ANSI_GRAVE=47 KEY_CODE_ANSI_GRAVE value
         * @property {number} KEY_CODE_ANSI_KEYPAD_DECIMAL=48 KEY_CODE_ANSI_KEYPAD_DECIMAL value
         * @property {number} KEY_CODE_ANSI_KEYPAD_PLUS=49 KEY_CODE_ANSI_KEYPAD_PLUS value
         * @property {number} KEY_CODE_ANSI_KEYPAD_CLEAR=50 KEY_CODE_ANSI_KEYPAD_CLEAR value
         * @property {number} KEY_CODE_ANSI_KEYPAD_DIVIDE=51 KEY_CODE_ANSI_KEYPAD_DIVIDE value
         * @property {number} KEY_CODE_ANSI_KEYPAD_ENTER=52 KEY_CODE_ANSI_KEYPAD_ENTER value
         * @property {number} KEY_CODE_ANSI_KEYPAD_MINUS=53 KEY_CODE_ANSI_KEYPAD_MINUS value
         * @property {number} KEY_CODE_ANSI_KEYPAD_EQUALS=54 KEY_CODE_ANSI_KEYPAD_EQUALS value
         * @property {number} KEY_CODE_ANSI_KEYPAD_0=55 KEY_CODE_ANSI_KEYPAD_0 value
         * @property {number} KEY_CODE_ANSI_KEYPAD_1=56 KEY_CODE_ANSI_KEYPAD_1 value
         * @property {number} KEY_CODE_ANSI_KEYPAD_2=57 KEY_CODE_ANSI_KEYPAD_2 value
         * @property {number} KEY_CODE_ANSI_KEYPAD_3=58 KEY_CODE_ANSI_KEYPAD_3 value
         * @property {number} KEY_CODE_ANSI_KEYPAD_4=59 KEY_CODE_ANSI_KEYPAD_4 value
         * @property {number} KEY_CODE_ANSI_KEYPAD_5=60 KEY_CODE_ANSI_KEYPAD_5 value
         * @property {number} KEY_CODE_ANSI_KEYPAD_6=61 KEY_CODE_ANSI_KEYPAD_6 value
         * @property {number} KEY_CODE_ANSI_KEYPAD_7=62 KEY_CODE_ANSI_KEYPAD_7 value
         * @property {number} KEY_CODE_ANSI_KEYPAD_8=63 KEY_CODE_ANSI_KEYPAD_8 value
         * @property {number} KEY_CODE_ANSI_KEYPAD_9=64 KEY_CODE_ANSI_KEYPAD_9 value
         * @property {number} KEY_CODE_F1=65 KEY_CODE_F1 value
         * @property {number} KEY_CODE_F2=66 KEY_CODE_F2 value
         * @property {number} KEY_CODE_F3=67 KEY_CODE_F3 value
         * @property {number} KEY_CODE_F4=68 KEY_CODE_F4 value
         * @property {number} KEY_CODE_F5=69 KEY_CODE_F5 value
         * @property {number} KEY_CODE_F6=70 KEY_CODE_F6 value
         * @property {number} KEY_CODE_F7=71 KEY_CODE_F7 value
         * @property {number} KEY_CODE_F8=72 KEY_CODE_F8 value
         * @property {number} KEY_CODE_F9=73 KEY_CODE_F9 value
         * @property {number} KEY_CODE_F10=74 KEY_CODE_F10 value
         * @property {number} KEY_CODE_F11=75 KEY_CODE_F11 value
         * @property {number} KEY_CODE_F12=76 KEY_CODE_F12 value
         * @property {number} KEY_CODE_F13=77 KEY_CODE_F13 value
         * @property {number} KEY_CODE_F14=78 KEY_CODE_F14 value
         * @property {number} KEY_CODE_F15=79 KEY_CODE_F15 value
         * @property {number} KEY_CODE_F16=80 KEY_CODE_F16 value
         * @property {number} KEY_CODE_F17=81 KEY_CODE_F17 value
         * @property {number} KEY_CODE_F18=82 KEY_CODE_F18 value
         * @property {number} KEY_CODE_F19=83 KEY_CODE_F19 value
         * @property {number} KEY_CODE_F20=84 KEY_CODE_F20 value
         * @property {number} KEY_CODE_FUNCTION=85 KEY_CODE_FUNCTION value
         * @property {number} KEY_CODE_RETURN=86 KEY_CODE_RETURN value
         * @property {number} KEY_CODE_TAB=87 KEY_CODE_TAB value
         * @property {number} KEY_CODE_SPACE=88 KEY_CODE_SPACE value
         * @property {number} KEY_CODE_DELETE=89 KEY_CODE_DELETE value
         * @property {number} KEY_CODE_ESCAPE=90 KEY_CODE_ESCAPE value
         * @property {number} KEY_CODE_COMMAND=91 KEY_CODE_COMMAND value
         * @property {number} KEY_CODE_SHIFT=92 KEY_CODE_SHIFT value
         * @property {number} KEY_CODE_CAPS_LOCK=93 KEY_CODE_CAPS_LOCK value
         * @property {number} KEY_CODE_OPTION=94 KEY_CODE_OPTION value
         * @property {number} KEY_CODE_CONTROL=95 KEY_CODE_CONTROL value
         * @property {number} KEY_CODE_RIGHT_SHIFT=96 KEY_CODE_RIGHT_SHIFT value
         * @property {number} KEY_CODE_RIGHT_OPTION=97 KEY_CODE_RIGHT_OPTION value
         * @property {number} KEY_CODE_RIGHT_CONTROL=98 KEY_CODE_RIGHT_CONTROL value
         * @property {number} KEY_CODE_VOLUME_UP=99 KEY_CODE_VOLUME_UP value
         * @property {number} KEY_CODE_VOLUME_DOWN=100 KEY_CODE_VOLUME_DOWN value
         * @property {number} KEY_CODE_MUTE=101 KEY_CODE_MUTE value
         * @property {number} KEY_CODE_HELP=102 KEY_CODE_HELP value
         * @property {number} KEY_CODE_HOME=103 KEY_CODE_HOME value
         * @property {number} KEY_CODE_PAGE_UP=104 KEY_CODE_PAGE_UP value
         * @property {number} KEY_CODE_FORWARD_DELETE=105 KEY_CODE_FORWARD_DELETE value
         * @property {number} KEY_CODE_END=106 KEY_CODE_END value
         * @property {number} KEY_CODE_PAGE_DOWN=107 KEY_CODE_PAGE_DOWN value
         * @property {number} KEY_CODE_LEFT_ARROW=108 KEY_CODE_LEFT_ARROW value
         * @property {number} KEY_CODE_RIGHT_ARROW=109 KEY_CODE_RIGHT_ARROW value
         * @property {number} KEY_CODE_DOWN_ARROW=110 KEY_CODE_DOWN_ARROW value
         * @property {number} KEY_CODE_UP_ARROW=111 KEY_CODE_UP_ARROW value
         * @property {number} KEY_CODE_ISO_SELECTION=112 KEY_CODE_ISO_SELECTION value
         * @property {number} KEY_CODE_JIS_YEN=113 KEY_CODE_JIS_YEN value
         * @property {number} KEY_CODE_JIS_UNDERSCORE=114 KEY_CODE_JIS_UNDERSCORE value
         * @property {number} KEY_CODE_JIS_KEYPAD_COMMA=115 KEY_CODE_JIS_KEYPAD_COMMA value
         * @property {number} KEY_CODE_JIS_EISU=116 KEY_CODE_JIS_EISU value
         * @property {number} KEY_CODE_JIS_KANA=117 KEY_CODE_JIS_KANA value
         */
        data.KeyCode = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "KEY_CODE_UNKNOWN"] = 0;
            values[valuesById[1] = "KEY_CODE_ANSI_A"] = 1;
            values[valuesById[2] = "KEY_CODE_ANSI_B"] = 2;
            values[valuesById[3] = "KEY_CODE_ANSI_C"] = 3;
            values[valuesById[4] = "KEY_CODE_ANSI_D"] = 4;
            values[valuesById[5] = "KEY_CODE_ANSI_E"] = 5;
            values[valuesById[6] = "KEY_CODE_ANSI_F"] = 6;
            values[valuesById[7] = "KEY_CODE_ANSI_G"] = 7;
            values[valuesById[8] = "KEY_CODE_ANSI_H"] = 8;
            values[valuesById[9] = "KEY_CODE_ANSI_I"] = 9;
            values[valuesById[10] = "KEY_CODE_ANSI_J"] = 10;
            values[valuesById[11] = "KEY_CODE_ANSI_K"] = 11;
            values[valuesById[12] = "KEY_CODE_ANSI_L"] = 12;
            values[valuesById[13] = "KEY_CODE_ANSI_M"] = 13;
            values[valuesById[14] = "KEY_CODE_ANSI_N"] = 14;
            values[valuesById[15] = "KEY_CODE_ANSI_O"] = 15;
            values[valuesById[16] = "KEY_CODE_ANSI_P"] = 16;
            values[valuesById[17] = "KEY_CODE_ANSI_Q"] = 17;
            values[valuesById[18] = "KEY_CODE_ANSI_R"] = 18;
            values[valuesById[19] = "KEY_CODE_ANSI_S"] = 19;
            values[valuesById[20] = "KEY_CODE_ANSI_T"] = 20;
            values[valuesById[21] = "KEY_CODE_ANSI_U"] = 21;
            values[valuesById[22] = "KEY_CODE_ANSI_V"] = 22;
            values[valuesById[23] = "KEY_CODE_ANSI_W"] = 23;
            values[valuesById[24] = "KEY_CODE_ANSI_X"] = 24;
            values[valuesById[25] = "KEY_CODE_ANSI_Y"] = 25;
            values[valuesById[26] = "KEY_CODE_ANSI_Z"] = 26;
            values[valuesById[27] = "KEY_CODE_ANSI_0"] = 27;
            values[valuesById[28] = "KEY_CODE_ANSI_1"] = 28;
            values[valuesById[29] = "KEY_CODE_ANSI_2"] = 29;
            values[valuesById[30] = "KEY_CODE_ANSI_3"] = 30;
            values[valuesById[31] = "KEY_CODE_ANSI_4"] = 31;
            values[valuesById[32] = "KEY_CODE_ANSI_5"] = 32;
            values[valuesById[33] = "KEY_CODE_ANSI_6"] = 33;
            values[valuesById[34] = "KEY_CODE_ANSI_7"] = 34;
            values[valuesById[35] = "KEY_CODE_ANSI_8"] = 35;
            values[valuesById[36] = "KEY_CODE_ANSI_9"] = 36;
            values[valuesById[37] = "KEY_CODE_ANSI_EQUAL"] = 37;
            values[valuesById[38] = "KEY_CODE_ANSI_MINUS"] = 38;
            values[valuesById[39] = "KEY_CODE_ANSI_RIGHT_BRACKET"] = 39;
            values[valuesById[40] = "KEY_CODE_ANSI_LEFT_BRACKET"] = 40;
            values[valuesById[41] = "KEY_CODE_ANSI_QUOTE"] = 41;
            values[valuesById[42] = "KEY_CODE_ANSI_SEMICOLON"] = 42;
            values[valuesById[43] = "KEY_CODE_ANSI_BACKSLASH"] = 43;
            values[valuesById[44] = "KEY_CODE_ANSI_COMMA"] = 44;
            values[valuesById[45] = "KEY_CODE_ANSI_SLASH"] = 45;
            values[valuesById[46] = "KEY_CODE_ANSI_PERIOD"] = 46;
            values[valuesById[47] = "KEY_CODE_ANSI_GRAVE"] = 47;
            values[valuesById[48] = "KEY_CODE_ANSI_KEYPAD_DECIMAL"] = 48;
            values[valuesById[49] = "KEY_CODE_ANSI_KEYPAD_PLUS"] = 49;
            values[valuesById[50] = "KEY_CODE_ANSI_KEYPAD_CLEAR"] = 50;
            values[valuesById[51] = "KEY_CODE_ANSI_KEYPAD_DIVIDE"] = 51;
            values[valuesById[52] = "KEY_CODE_ANSI_KEYPAD_ENTER"] = 52;
            values[valuesById[53] = "KEY_CODE_ANSI_KEYPAD_MINUS"] = 53;
            values[valuesById[54] = "KEY_CODE_ANSI_KEYPAD_EQUALS"] = 54;
            values[valuesById[55] = "KEY_CODE_ANSI_KEYPAD_0"] = 55;
            values[valuesById[56] = "KEY_CODE_ANSI_KEYPAD_1"] = 56;
            values[valuesById[57] = "KEY_CODE_ANSI_KEYPAD_2"] = 57;
            values[valuesById[58] = "KEY_CODE_ANSI_KEYPAD_3"] = 58;
            values[valuesById[59] = "KEY_CODE_ANSI_KEYPAD_4"] = 59;
            values[valuesById[60] = "KEY_CODE_ANSI_KEYPAD_5"] = 60;
            values[valuesById[61] = "KEY_CODE_ANSI_KEYPAD_6"] = 61;
            values[valuesById[62] = "KEY_CODE_ANSI_KEYPAD_7"] = 62;
            values[valuesById[63] = "KEY_CODE_ANSI_KEYPAD_8"] = 63;
            values[valuesById[64] = "KEY_CODE_ANSI_KEYPAD_9"] = 64;
            values[valuesById[65] = "KEY_CODE_F1"] = 65;
            values[valuesById[66] = "KEY_CODE_F2"] = 66;
            values[valuesById[67] = "KEY_CODE_F3"] = 67;
            values[valuesById[68] = "KEY_CODE_F4"] = 68;
            values[valuesById[69] = "KEY_CODE_F5"] = 69;
            values[valuesById[70] = "KEY_CODE_F6"] = 70;
            values[valuesById[71] = "KEY_CODE_F7"] = 71;
            values[valuesById[72] = "KEY_CODE_F8"] = 72;
            values[valuesById[73] = "KEY_CODE_F9"] = 73;
            values[valuesById[74] = "KEY_CODE_F10"] = 74;
            values[valuesById[75] = "KEY_CODE_F11"] = 75;
            values[valuesById[76] = "KEY_CODE_F12"] = 76;
            values[valuesById[77] = "KEY_CODE_F13"] = 77;
            values[valuesById[78] = "KEY_CODE_F14"] = 78;
            values[valuesById[79] = "KEY_CODE_F15"] = 79;
            values[valuesById[80] = "KEY_CODE_F16"] = 80;
            values[valuesById[81] = "KEY_CODE_F17"] = 81;
            values[valuesById[82] = "KEY_CODE_F18"] = 82;
            values[valuesById[83] = "KEY_CODE_F19"] = 83;
            values[valuesById[84] = "KEY_CODE_F20"] = 84;
            values[valuesById[85] = "KEY_CODE_FUNCTION"] = 85;
            values[valuesById[86] = "KEY_CODE_RETURN"] = 86;
            values[valuesById[87] = "KEY_CODE_TAB"] = 87;
            values[valuesById[88] = "KEY_CODE_SPACE"] = 88;
            values[valuesById[89] = "KEY_CODE_DELETE"] = 89;
            values[valuesById[90] = "KEY_CODE_ESCAPE"] = 90;
            values[valuesById[91] = "KEY_CODE_COMMAND"] = 91;
            values[valuesById[92] = "KEY_CODE_SHIFT"] = 92;
            values[valuesById[93] = "KEY_CODE_CAPS_LOCK"] = 93;
            values[valuesById[94] = "KEY_CODE_OPTION"] = 94;
            values[valuesById[95] = "KEY_CODE_CONTROL"] = 95;
            values[valuesById[96] = "KEY_CODE_RIGHT_SHIFT"] = 96;
            values[valuesById[97] = "KEY_CODE_RIGHT_OPTION"] = 97;
            values[valuesById[98] = "KEY_CODE_RIGHT_CONTROL"] = 98;
            values[valuesById[99] = "KEY_CODE_VOLUME_UP"] = 99;
            values[valuesById[100] = "KEY_CODE_VOLUME_DOWN"] = 100;
            values[valuesById[101] = "KEY_CODE_MUTE"] = 101;
            values[valuesById[102] = "KEY_CODE_HELP"] = 102;
            values[valuesById[103] = "KEY_CODE_HOME"] = 103;
            values[valuesById[104] = "KEY_CODE_PAGE_UP"] = 104;
            values[valuesById[105] = "KEY_CODE_FORWARD_DELETE"] = 105;
            values[valuesById[106] = "KEY_CODE_END"] = 106;
            values[valuesById[107] = "KEY_CODE_PAGE_DOWN"] = 107;
            values[valuesById[108] = "KEY_CODE_LEFT_ARROW"] = 108;
            values[valuesById[109] = "KEY_CODE_RIGHT_ARROW"] = 109;
            values[valuesById[110] = "KEY_CODE_DOWN_ARROW"] = 110;
            values[valuesById[111] = "KEY_CODE_UP_ARROW"] = 111;
            values[valuesById[112] = "KEY_CODE_ISO_SELECTION"] = 112;
            values[valuesById[113] = "KEY_CODE_JIS_YEN"] = 113;
            values[valuesById[114] = "KEY_CODE_JIS_UNDERSCORE"] = 114;
            values[valuesById[115] = "KEY_CODE_JIS_KEYPAD_COMMA"] = 115;
            values[valuesById[116] = "KEY_CODE_JIS_EISU"] = 116;
            values[valuesById[117] = "KEY_CODE_JIS_KANA"] = 117;
            return values;
        })();

        data.Message = (function() {

            /**
             * Properties of a Message.
             * @memberof rv.data
             * @interface IMessage
             * @property {rv.data.IUUID|null} [uuid] Message uuid
             * @property {string|null} [title] Message title
             * @property {number|null} [timeToRemove] Message timeToRemove
             * @property {boolean|null} [visibleOnNetwork] Message visibleOnNetwork
             * @property {rv.data.ITemplateIdentification|null} [template] Message template
             * @property {rv.data.Message.ClearType|null} [clearType] Message clearType
             * @property {string|null} [messageText] Message messageText
             * @property {Array.<rv.data.Message.IToken>|null} [tokens] Message tokens
             * @property {Array.<rv.data.Message.ITokenValue>|null} [tokenValues] Message tokenValues
             */

            /**
             * Constructs a new Message.
             * @memberof rv.data
             * @classdesc Represents a Message.
             * @implements IMessage
             * @constructor
             * @param {rv.data.IMessage=} [properties] Properties to set
             */
            function Message(properties) {
                this.tokens = [];
                this.tokenValues = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Message uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.Message
             * @instance
             */
            Message.prototype.uuid = null;

            /**
             * Message title.
             * @member {string} title
             * @memberof rv.data.Message
             * @instance
             */
            Message.prototype.title = "";

            /**
             * Message timeToRemove.
             * @member {number} timeToRemove
             * @memberof rv.data.Message
             * @instance
             */
            Message.prototype.timeToRemove = 0;

            /**
             * Message visibleOnNetwork.
             * @member {boolean} visibleOnNetwork
             * @memberof rv.data.Message
             * @instance
             */
            Message.prototype.visibleOnNetwork = false;

            /**
             * Message template.
             * @member {rv.data.ITemplateIdentification|null|undefined} template
             * @memberof rv.data.Message
             * @instance
             */
            Message.prototype.template = null;

            /**
             * Message clearType.
             * @member {rv.data.Message.ClearType} clearType
             * @memberof rv.data.Message
             * @instance
             */
            Message.prototype.clearType = 0;

            /**
             * Message messageText.
             * @member {string} messageText
             * @memberof rv.data.Message
             * @instance
             */
            Message.prototype.messageText = "";

            /**
             * Message tokens.
             * @member {Array.<rv.data.Message.IToken>} tokens
             * @memberof rv.data.Message
             * @instance
             */
            Message.prototype.tokens = $util.emptyArray;

            /**
             * Message tokenValues.
             * @member {Array.<rv.data.Message.ITokenValue>} tokenValues
             * @memberof rv.data.Message
             * @instance
             */
            Message.prototype.tokenValues = $util.emptyArray;

            /**
             * Creates a new Message instance using the specified properties.
             * @function create
             * @memberof rv.data.Message
             * @static
             * @param {rv.data.IMessage=} [properties] Properties to set
             * @returns {rv.data.Message} Message instance
             */
            Message.create = function create(properties) {
                return new Message(properties);
            };

            /**
             * Encodes the specified Message message. Does not implicitly {@link rv.data.Message.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Message
             * @static
             * @param {rv.data.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                if (message.timeToRemove != null && Object.hasOwnProperty.call(message, "timeToRemove"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.timeToRemove);
                if (message.visibleOnNetwork != null && Object.hasOwnProperty.call(message, "visibleOnNetwork"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.visibleOnNetwork);
                if (message.template != null && Object.hasOwnProperty.call(message, "template"))
                    $root.rv.data.TemplateIdentification.encode(message.template, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.clearType != null && Object.hasOwnProperty.call(message, "clearType"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.clearType);
                if (message.messageText != null && Object.hasOwnProperty.call(message, "messageText"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.messageText);
                if (message.tokens != null && message.tokens.length)
                    for (let i = 0; i < message.tokens.length; ++i)
                        $root.rv.data.Message.Token.encode(message.tokens[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.tokenValues != null && message.tokenValues.length)
                    for (let i = 0; i < message.tokenValues.length; ++i)
                        $root.rv.data.Message.TokenValue.encode(message.tokenValues[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Message message, length delimited. Does not implicitly {@link rv.data.Message.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Message
             * @static
             * @param {rv.data.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Message message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Message();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.title = reader.string();
                            break;
                        }
                    case 3: {
                            message.timeToRemove = reader.double();
                            break;
                        }
                    case 4: {
                            message.visibleOnNetwork = reader.bool();
                            break;
                        }
                    case 6: {
                            message.template = $root.rv.data.TemplateIdentification.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.clearType = reader.int32();
                            break;
                        }
                    case 10: {
                            message.messageText = reader.string();
                            break;
                        }
                    case 11: {
                            if (!(message.tokens && message.tokens.length))
                                message.tokens = [];
                            message.tokens.push($root.rv.data.Message.Token.decode(reader, reader.uint32()));
                            break;
                        }
                    case 12: {
                            if (!(message.tokenValues && message.tokenValues.length))
                                message.tokenValues = [];
                            message.tokenValues.push($root.rv.data.Message.TokenValue.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Message message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Message message.
             * @function verify
             * @memberof rv.data.Message
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Message.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.timeToRemove != null && message.hasOwnProperty("timeToRemove"))
                    if (typeof message.timeToRemove !== "number")
                        return "timeToRemove: number expected";
                if (message.visibleOnNetwork != null && message.hasOwnProperty("visibleOnNetwork"))
                    if (typeof message.visibleOnNetwork !== "boolean")
                        return "visibleOnNetwork: boolean expected";
                if (message.template != null && message.hasOwnProperty("template")) {
                    let error = $root.rv.data.TemplateIdentification.verify(message.template);
                    if (error)
                        return "template." + error;
                }
                if (message.clearType != null && message.hasOwnProperty("clearType"))
                    switch (message.clearType) {
                    default:
                        return "clearType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.messageText != null && message.hasOwnProperty("messageText"))
                    if (!$util.isString(message.messageText))
                        return "messageText: string expected";
                if (message.tokens != null && message.hasOwnProperty("tokens")) {
                    if (!Array.isArray(message.tokens))
                        return "tokens: array expected";
                    for (let i = 0; i < message.tokens.length; ++i) {
                        let error = $root.rv.data.Message.Token.verify(message.tokens[i]);
                        if (error)
                            return "tokens." + error;
                    }
                }
                if (message.tokenValues != null && message.hasOwnProperty("tokenValues")) {
                    if (!Array.isArray(message.tokenValues))
                        return "tokenValues: array expected";
                    for (let i = 0; i < message.tokenValues.length; ++i) {
                        let error = $root.rv.data.Message.TokenValue.verify(message.tokenValues[i]);
                        if (error)
                            return "tokenValues." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Message message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Message
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Message} Message
             */
            Message.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Message)
                    return object;
                let message = new $root.rv.data.Message();
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.Message.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                if (object.title != null)
                    message.title = String(object.title);
                if (object.timeToRemove != null)
                    message.timeToRemove = Number(object.timeToRemove);
                if (object.visibleOnNetwork != null)
                    message.visibleOnNetwork = Boolean(object.visibleOnNetwork);
                if (object.template != null) {
                    if (typeof object.template !== "object")
                        throw TypeError(".rv.data.Message.template: object expected");
                    message.template = $root.rv.data.TemplateIdentification.fromObject(object.template);
                }
                switch (object.clearType) {
                default:
                    if (typeof object.clearType === "number") {
                        message.clearType = object.clearType;
                        break;
                    }
                    break;
                case "CLEAR_TYPE_MANUAL":
                case 0:
                    message.clearType = 0;
                    break;
                case "CLEAR_TYPE_AFTER_TIME":
                case 1:
                    message.clearType = 1;
                    break;
                case "CLEAR_TYPE_AFTER_TIMERS":
                case 2:
                    message.clearType = 2;
                    break;
                }
                if (object.messageText != null)
                    message.messageText = String(object.messageText);
                if (object.tokens) {
                    if (!Array.isArray(object.tokens))
                        throw TypeError(".rv.data.Message.tokens: array expected");
                    message.tokens = [];
                    for (let i = 0; i < object.tokens.length; ++i) {
                        if (typeof object.tokens[i] !== "object")
                            throw TypeError(".rv.data.Message.tokens: object expected");
                        message.tokens[i] = $root.rv.data.Message.Token.fromObject(object.tokens[i]);
                    }
                }
                if (object.tokenValues) {
                    if (!Array.isArray(object.tokenValues))
                        throw TypeError(".rv.data.Message.tokenValues: array expected");
                    message.tokenValues = [];
                    for (let i = 0; i < object.tokenValues.length; ++i) {
                        if (typeof object.tokenValues[i] !== "object")
                            throw TypeError(".rv.data.Message.tokenValues: object expected");
                        message.tokenValues[i] = $root.rv.data.Message.TokenValue.fromObject(object.tokenValues[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Message message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Message
             * @static
             * @param {rv.data.Message} message Message
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Message.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.tokens = [];
                    object.tokenValues = [];
                }
                if (options.defaults) {
                    object.uuid = null;
                    object.title = "";
                    object.timeToRemove = 0;
                    object.visibleOnNetwork = false;
                    object.template = null;
                    object.clearType = options.enums === String ? "CLEAR_TYPE_MANUAL" : 0;
                    object.messageText = "";
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.timeToRemove != null && message.hasOwnProperty("timeToRemove"))
                    object.timeToRemove = options.json && !isFinite(message.timeToRemove) ? String(message.timeToRemove) : message.timeToRemove;
                if (message.visibleOnNetwork != null && message.hasOwnProperty("visibleOnNetwork"))
                    object.visibleOnNetwork = message.visibleOnNetwork;
                if (message.template != null && message.hasOwnProperty("template"))
                    object.template = $root.rv.data.TemplateIdentification.toObject(message.template, options);
                if (message.clearType != null && message.hasOwnProperty("clearType"))
                    object.clearType = options.enums === String ? $root.rv.data.Message.ClearType[message.clearType] === undefined ? message.clearType : $root.rv.data.Message.ClearType[message.clearType] : message.clearType;
                if (message.messageText != null && message.hasOwnProperty("messageText"))
                    object.messageText = message.messageText;
                if (message.tokens && message.tokens.length) {
                    object.tokens = [];
                    for (let j = 0; j < message.tokens.length; ++j)
                        object.tokens[j] = $root.rv.data.Message.Token.toObject(message.tokens[j], options);
                }
                if (message.tokenValues && message.tokenValues.length) {
                    object.tokenValues = [];
                    for (let j = 0; j < message.tokenValues.length; ++j)
                        object.tokenValues[j] = $root.rv.data.Message.TokenValue.toObject(message.tokenValues[j], options);
                }
                return object;
            };

            /**
             * Converts this Message to JSON.
             * @function toJSON
             * @memberof rv.data.Message
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Message.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Message
             * @function getTypeUrl
             * @memberof rv.data.Message
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Message.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Message";
            };

            Message.Token = (function() {

                /**
                 * Properties of a Token.
                 * @memberof rv.data.Message
                 * @interface IToken
                 * @property {rv.data.IUUID|null} [uuid] Token uuid
                 * @property {rv.data.Message.Token.ITokenTypeText|null} [text] Token text
                 * @property {rv.data.Message.Token.ITokenTypeTimer|null} [timer] Token timer
                 * @property {rv.data.Message.Token.ITokenTypeClock|null} [clock] Token clock
                 */

                /**
                 * Constructs a new Token.
                 * @memberof rv.data.Message
                 * @classdesc Represents a Token.
                 * @implements IToken
                 * @constructor
                 * @param {rv.data.Message.IToken=} [properties] Properties to set
                 */
                function Token(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Token uuid.
                 * @member {rv.data.IUUID|null|undefined} uuid
                 * @memberof rv.data.Message.Token
                 * @instance
                 */
                Token.prototype.uuid = null;

                /**
                 * Token text.
                 * @member {rv.data.Message.Token.ITokenTypeText|null|undefined} text
                 * @memberof rv.data.Message.Token
                 * @instance
                 */
                Token.prototype.text = null;

                /**
                 * Token timer.
                 * @member {rv.data.Message.Token.ITokenTypeTimer|null|undefined} timer
                 * @memberof rv.data.Message.Token
                 * @instance
                 */
                Token.prototype.timer = null;

                /**
                 * Token clock.
                 * @member {rv.data.Message.Token.ITokenTypeClock|null|undefined} clock
                 * @memberof rv.data.Message.Token
                 * @instance
                 */
                Token.prototype.clock = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Token TokenType.
                 * @member {"text"|"timer"|"clock"|undefined} TokenType
                 * @memberof rv.data.Message.Token
                 * @instance
                 */
                Object.defineProperty(Token.prototype, "TokenType", {
                    get: $util.oneOfGetter($oneOfFields = ["text", "timer", "clock"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Token instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Message.Token
                 * @static
                 * @param {rv.data.Message.IToken=} [properties] Properties to set
                 * @returns {rv.data.Message.Token} Token instance
                 */
                Token.create = function create(properties) {
                    return new Token(properties);
                };

                /**
                 * Encodes the specified Token message. Does not implicitly {@link rv.data.Message.Token.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Message.Token
                 * @static
                 * @param {rv.data.Message.IToken} message Token message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Token.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                        $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                        $root.rv.data.Message.Token.TokenTypeText.encode(message.text, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.timer != null && Object.hasOwnProperty.call(message, "timer"))
                        $root.rv.data.Message.Token.TokenTypeTimer.encode(message.timer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.clock != null && Object.hasOwnProperty.call(message, "clock"))
                        $root.rv.data.Message.Token.TokenTypeClock.encode(message.clock, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Token message, length delimited. Does not implicitly {@link rv.data.Message.Token.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Message.Token
                 * @static
                 * @param {rv.data.Message.IToken} message Token message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Token.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Token message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Message.Token
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Message.Token} Token
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Token.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Message.Token();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.text = $root.rv.data.Message.Token.TokenTypeText.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.timer = $root.rv.data.Message.Token.TokenTypeTimer.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.clock = $root.rv.data.Message.Token.TokenTypeClock.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Token message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Message.Token
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Message.Token} Token
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Token.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Token message.
                 * @function verify
                 * @memberof rv.data.Message.Token
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Token.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.uuid != null && message.hasOwnProperty("uuid")) {
                        let error = $root.rv.data.UUID.verify(message.uuid);
                        if (error)
                            return "uuid." + error;
                    }
                    if (message.text != null && message.hasOwnProperty("text")) {
                        properties.TokenType = 1;
                        {
                            let error = $root.rv.data.Message.Token.TokenTypeText.verify(message.text);
                            if (error)
                                return "text." + error;
                        }
                    }
                    if (message.timer != null && message.hasOwnProperty("timer")) {
                        if (properties.TokenType === 1)
                            return "TokenType: multiple values";
                        properties.TokenType = 1;
                        {
                            let error = $root.rv.data.Message.Token.TokenTypeTimer.verify(message.timer);
                            if (error)
                                return "timer." + error;
                        }
                    }
                    if (message.clock != null && message.hasOwnProperty("clock")) {
                        if (properties.TokenType === 1)
                            return "TokenType: multiple values";
                        properties.TokenType = 1;
                        {
                            let error = $root.rv.data.Message.Token.TokenTypeClock.verify(message.clock);
                            if (error)
                                return "clock." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Token message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Message.Token
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Message.Token} Token
                 */
                Token.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Message.Token)
                        return object;
                    let message = new $root.rv.data.Message.Token();
                    if (object.uuid != null) {
                        if (typeof object.uuid !== "object")
                            throw TypeError(".rv.data.Message.Token.uuid: object expected");
                        message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                    }
                    if (object.text != null) {
                        if (typeof object.text !== "object")
                            throw TypeError(".rv.data.Message.Token.text: object expected");
                        message.text = $root.rv.data.Message.Token.TokenTypeText.fromObject(object.text);
                    }
                    if (object.timer != null) {
                        if (typeof object.timer !== "object")
                            throw TypeError(".rv.data.Message.Token.timer: object expected");
                        message.timer = $root.rv.data.Message.Token.TokenTypeTimer.fromObject(object.timer);
                    }
                    if (object.clock != null) {
                        if (typeof object.clock !== "object")
                            throw TypeError(".rv.data.Message.Token.clock: object expected");
                        message.clock = $root.rv.data.Message.Token.TokenTypeClock.fromObject(object.clock);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Token message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Message.Token
                 * @static
                 * @param {rv.data.Message.Token} message Token
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Token.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.uuid = null;
                    if (message.uuid != null && message.hasOwnProperty("uuid"))
                        object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                    if (message.text != null && message.hasOwnProperty("text")) {
                        object.text = $root.rv.data.Message.Token.TokenTypeText.toObject(message.text, options);
                        if (options.oneofs)
                            object.TokenType = "text";
                    }
                    if (message.timer != null && message.hasOwnProperty("timer")) {
                        object.timer = $root.rv.data.Message.Token.TokenTypeTimer.toObject(message.timer, options);
                        if (options.oneofs)
                            object.TokenType = "timer";
                    }
                    if (message.clock != null && message.hasOwnProperty("clock")) {
                        object.clock = $root.rv.data.Message.Token.TokenTypeClock.toObject(message.clock, options);
                        if (options.oneofs)
                            object.TokenType = "clock";
                    }
                    return object;
                };

                /**
                 * Converts this Token to JSON.
                 * @function toJSON
                 * @memberof rv.data.Message.Token
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Token.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Token
                 * @function getTypeUrl
                 * @memberof rv.data.Message.Token
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Token.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Message.Token";
                };

                Token.TokenTypeText = (function() {

                    /**
                     * Properties of a TokenTypeText.
                     * @memberof rv.data.Message.Token
                     * @interface ITokenTypeText
                     * @property {string|null} [name] TokenTypeText name
                     */

                    /**
                     * Constructs a new TokenTypeText.
                     * @memberof rv.data.Message.Token
                     * @classdesc Represents a TokenTypeText.
                     * @implements ITokenTypeText
                     * @constructor
                     * @param {rv.data.Message.Token.ITokenTypeText=} [properties] Properties to set
                     */
                    function TokenTypeText(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TokenTypeText name.
                     * @member {string} name
                     * @memberof rv.data.Message.Token.TokenTypeText
                     * @instance
                     */
                    TokenTypeText.prototype.name = "";

                    /**
                     * Creates a new TokenTypeText instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Message.Token.TokenTypeText
                     * @static
                     * @param {rv.data.Message.Token.ITokenTypeText=} [properties] Properties to set
                     * @returns {rv.data.Message.Token.TokenTypeText} TokenTypeText instance
                     */
                    TokenTypeText.create = function create(properties) {
                        return new TokenTypeText(properties);
                    };

                    /**
                     * Encodes the specified TokenTypeText message. Does not implicitly {@link rv.data.Message.Token.TokenTypeText.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Message.Token.TokenTypeText
                     * @static
                     * @param {rv.data.Message.Token.ITokenTypeText} message TokenTypeText message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenTypeText.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        return writer;
                    };

                    /**
                     * Encodes the specified TokenTypeText message, length delimited. Does not implicitly {@link rv.data.Message.Token.TokenTypeText.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Message.Token.TokenTypeText
                     * @static
                     * @param {rv.data.Message.Token.ITokenTypeText} message TokenTypeText message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenTypeText.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TokenTypeText message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Message.Token.TokenTypeText
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Message.Token.TokenTypeText} TokenTypeText
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenTypeText.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Message.Token.TokenTypeText();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.name = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TokenTypeText message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Message.Token.TokenTypeText
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Message.Token.TokenTypeText} TokenTypeText
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenTypeText.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TokenTypeText message.
                     * @function verify
                     * @memberof rv.data.Message.Token.TokenTypeText
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenTypeText.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        return null;
                    };

                    /**
                     * Creates a TokenTypeText message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Message.Token.TokenTypeText
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Message.Token.TokenTypeText} TokenTypeText
                     */
                    TokenTypeText.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Message.Token.TokenTypeText)
                            return object;
                        let message = new $root.rv.data.Message.Token.TokenTypeText();
                        if (object.name != null)
                            message.name = String(object.name);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TokenTypeText message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Message.Token.TokenTypeText
                     * @static
                     * @param {rv.data.Message.Token.TokenTypeText} message TokenTypeText
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenTypeText.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.name = "";
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        return object;
                    };

                    /**
                     * Converts this TokenTypeText to JSON.
                     * @function toJSON
                     * @memberof rv.data.Message.Token.TokenTypeText
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenTypeText.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for TokenTypeText
                     * @function getTypeUrl
                     * @memberof rv.data.Message.Token.TokenTypeText
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    TokenTypeText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Message.Token.TokenTypeText";
                    };

                    return TokenTypeText;
                })();

                Token.TokenTypeTimer = (function() {

                    /**
                     * Properties of a TokenTypeTimer.
                     * @memberof rv.data.Message.Token
                     * @interface ITokenTypeTimer
                     * @property {string|null} [name] TokenTypeTimer name
                     * @property {rv.data.IUUID|null} [timerUuid] TokenTypeTimer timerUuid
                     */

                    /**
                     * Constructs a new TokenTypeTimer.
                     * @memberof rv.data.Message.Token
                     * @classdesc Represents a TokenTypeTimer.
                     * @implements ITokenTypeTimer
                     * @constructor
                     * @param {rv.data.Message.Token.ITokenTypeTimer=} [properties] Properties to set
                     */
                    function TokenTypeTimer(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TokenTypeTimer name.
                     * @member {string} name
                     * @memberof rv.data.Message.Token.TokenTypeTimer
                     * @instance
                     */
                    TokenTypeTimer.prototype.name = "";

                    /**
                     * TokenTypeTimer timerUuid.
                     * @member {rv.data.IUUID|null|undefined} timerUuid
                     * @memberof rv.data.Message.Token.TokenTypeTimer
                     * @instance
                     */
                    TokenTypeTimer.prototype.timerUuid = null;

                    /**
                     * Creates a new TokenTypeTimer instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Message.Token.TokenTypeTimer
                     * @static
                     * @param {rv.data.Message.Token.ITokenTypeTimer=} [properties] Properties to set
                     * @returns {rv.data.Message.Token.TokenTypeTimer} TokenTypeTimer instance
                     */
                    TokenTypeTimer.create = function create(properties) {
                        return new TokenTypeTimer(properties);
                    };

                    /**
                     * Encodes the specified TokenTypeTimer message. Does not implicitly {@link rv.data.Message.Token.TokenTypeTimer.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Message.Token.TokenTypeTimer
                     * @static
                     * @param {rv.data.Message.Token.ITokenTypeTimer} message TokenTypeTimer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenTypeTimer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.timerUuid != null && Object.hasOwnProperty.call(message, "timerUuid"))
                            $root.rv.data.UUID.encode(message.timerUuid, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified TokenTypeTimer message, length delimited. Does not implicitly {@link rv.data.Message.Token.TokenTypeTimer.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Message.Token.TokenTypeTimer
                     * @static
                     * @param {rv.data.Message.Token.ITokenTypeTimer} message TokenTypeTimer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenTypeTimer.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TokenTypeTimer message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Message.Token.TokenTypeTimer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Message.Token.TokenTypeTimer} TokenTypeTimer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenTypeTimer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Message.Token.TokenTypeTimer();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.name = reader.string();
                                    break;
                                }
                            case 2: {
                                    message.timerUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TokenTypeTimer message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Message.Token.TokenTypeTimer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Message.Token.TokenTypeTimer} TokenTypeTimer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenTypeTimer.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TokenTypeTimer message.
                     * @function verify
                     * @memberof rv.data.Message.Token.TokenTypeTimer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenTypeTimer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.timerUuid != null && message.hasOwnProperty("timerUuid")) {
                            let error = $root.rv.data.UUID.verify(message.timerUuid);
                            if (error)
                                return "timerUuid." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a TokenTypeTimer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Message.Token.TokenTypeTimer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Message.Token.TokenTypeTimer} TokenTypeTimer
                     */
                    TokenTypeTimer.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Message.Token.TokenTypeTimer)
                            return object;
                        let message = new $root.rv.data.Message.Token.TokenTypeTimer();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.timerUuid != null) {
                            if (typeof object.timerUuid !== "object")
                                throw TypeError(".rv.data.Message.Token.TokenTypeTimer.timerUuid: object expected");
                            message.timerUuid = $root.rv.data.UUID.fromObject(object.timerUuid);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a TokenTypeTimer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Message.Token.TokenTypeTimer
                     * @static
                     * @param {rv.data.Message.Token.TokenTypeTimer} message TokenTypeTimer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenTypeTimer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.timerUuid = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.timerUuid != null && message.hasOwnProperty("timerUuid"))
                            object.timerUuid = $root.rv.data.UUID.toObject(message.timerUuid, options);
                        return object;
                    };

                    /**
                     * Converts this TokenTypeTimer to JSON.
                     * @function toJSON
                     * @memberof rv.data.Message.Token.TokenTypeTimer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenTypeTimer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for TokenTypeTimer
                     * @function getTypeUrl
                     * @memberof rv.data.Message.Token.TokenTypeTimer
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    TokenTypeTimer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Message.Token.TokenTypeTimer";
                    };

                    return TokenTypeTimer;
                })();

                Token.TokenTypeClock = (function() {

                    /**
                     * Properties of a TokenTypeClock.
                     * @memberof rv.data.Message.Token
                     * @interface ITokenTypeClock
                     */

                    /**
                     * Constructs a new TokenTypeClock.
                     * @memberof rv.data.Message.Token
                     * @classdesc Represents a TokenTypeClock.
                     * @implements ITokenTypeClock
                     * @constructor
                     * @param {rv.data.Message.Token.ITokenTypeClock=} [properties] Properties to set
                     */
                    function TokenTypeClock(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new TokenTypeClock instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Message.Token.TokenTypeClock
                     * @static
                     * @param {rv.data.Message.Token.ITokenTypeClock=} [properties] Properties to set
                     * @returns {rv.data.Message.Token.TokenTypeClock} TokenTypeClock instance
                     */
                    TokenTypeClock.create = function create(properties) {
                        return new TokenTypeClock(properties);
                    };

                    /**
                     * Encodes the specified TokenTypeClock message. Does not implicitly {@link rv.data.Message.Token.TokenTypeClock.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Message.Token.TokenTypeClock
                     * @static
                     * @param {rv.data.Message.Token.ITokenTypeClock} message TokenTypeClock message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenTypeClock.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified TokenTypeClock message, length delimited. Does not implicitly {@link rv.data.Message.Token.TokenTypeClock.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Message.Token.TokenTypeClock
                     * @static
                     * @param {rv.data.Message.Token.ITokenTypeClock} message TokenTypeClock message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenTypeClock.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TokenTypeClock message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Message.Token.TokenTypeClock
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Message.Token.TokenTypeClock} TokenTypeClock
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenTypeClock.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Message.Token.TokenTypeClock();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TokenTypeClock message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Message.Token.TokenTypeClock
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Message.Token.TokenTypeClock} TokenTypeClock
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenTypeClock.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TokenTypeClock message.
                     * @function verify
                     * @memberof rv.data.Message.Token.TokenTypeClock
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenTypeClock.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a TokenTypeClock message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Message.Token.TokenTypeClock
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Message.Token.TokenTypeClock} TokenTypeClock
                     */
                    TokenTypeClock.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Message.Token.TokenTypeClock)
                            return object;
                        return new $root.rv.data.Message.Token.TokenTypeClock();
                    };

                    /**
                     * Creates a plain object from a TokenTypeClock message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Message.Token.TokenTypeClock
                     * @static
                     * @param {rv.data.Message.Token.TokenTypeClock} message TokenTypeClock
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenTypeClock.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this TokenTypeClock to JSON.
                     * @function toJSON
                     * @memberof rv.data.Message.Token.TokenTypeClock
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenTypeClock.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for TokenTypeClock
                     * @function getTypeUrl
                     * @memberof rv.data.Message.Token.TokenTypeClock
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    TokenTypeClock.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Message.Token.TokenTypeClock";
                    };

                    return TokenTypeClock;
                })();

                return Token;
            })();

            Message.TokenValue = (function() {

                /**
                 * Properties of a TokenValue.
                 * @memberof rv.data.Message
                 * @interface ITokenValue
                 * @property {rv.data.IUUID|null} [tokenId] TokenValue tokenId
                 * @property {string|null} [tokenName] TokenValue tokenName
                 * @property {rv.data.Message.TokenValue.ITokenValueText|null} [text] TokenValue text
                 * @property {rv.data.Message.TokenValue.ITokenValueTimer|null} [timer] TokenValue timer
                 * @property {rv.data.Message.TokenValue.ITokenValueClock|null} [clock] TokenValue clock
                 */

                /**
                 * Constructs a new TokenValue.
                 * @memberof rv.data.Message
                 * @classdesc Represents a TokenValue.
                 * @implements ITokenValue
                 * @constructor
                 * @param {rv.data.Message.ITokenValue=} [properties] Properties to set
                 */
                function TokenValue(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TokenValue tokenId.
                 * @member {rv.data.IUUID|null|undefined} tokenId
                 * @memberof rv.data.Message.TokenValue
                 * @instance
                 */
                TokenValue.prototype.tokenId = null;

                /**
                 * TokenValue tokenName.
                 * @member {string} tokenName
                 * @memberof rv.data.Message.TokenValue
                 * @instance
                 */
                TokenValue.prototype.tokenName = "";

                /**
                 * TokenValue text.
                 * @member {rv.data.Message.TokenValue.ITokenValueText|null|undefined} text
                 * @memberof rv.data.Message.TokenValue
                 * @instance
                 */
                TokenValue.prototype.text = null;

                /**
                 * TokenValue timer.
                 * @member {rv.data.Message.TokenValue.ITokenValueTimer|null|undefined} timer
                 * @memberof rv.data.Message.TokenValue
                 * @instance
                 */
                TokenValue.prototype.timer = null;

                /**
                 * TokenValue clock.
                 * @member {rv.data.Message.TokenValue.ITokenValueClock|null|undefined} clock
                 * @memberof rv.data.Message.TokenValue
                 * @instance
                 */
                TokenValue.prototype.clock = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * TokenValue TokenValueType.
                 * @member {"text"|"timer"|"clock"|undefined} TokenValueType
                 * @memberof rv.data.Message.TokenValue
                 * @instance
                 */
                Object.defineProperty(TokenValue.prototype, "TokenValueType", {
                    get: $util.oneOfGetter($oneOfFields = ["text", "timer", "clock"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new TokenValue instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Message.TokenValue
                 * @static
                 * @param {rv.data.Message.ITokenValue=} [properties] Properties to set
                 * @returns {rv.data.Message.TokenValue} TokenValue instance
                 */
                TokenValue.create = function create(properties) {
                    return new TokenValue(properties);
                };

                /**
                 * Encodes the specified TokenValue message. Does not implicitly {@link rv.data.Message.TokenValue.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Message.TokenValue
                 * @static
                 * @param {rv.data.Message.ITokenValue} message TokenValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TokenValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                        $root.rv.data.UUID.encode(message.tokenId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                        $root.rv.data.Message.TokenValue.TokenValueText.encode(message.text, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.timer != null && Object.hasOwnProperty.call(message, "timer"))
                        $root.rv.data.Message.TokenValue.TokenValueTimer.encode(message.timer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.clock != null && Object.hasOwnProperty.call(message, "clock"))
                        $root.rv.data.Message.TokenValue.TokenValueClock.encode(message.clock, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.tokenName != null && Object.hasOwnProperty.call(message, "tokenName"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.tokenName);
                    return writer;
                };

                /**
                 * Encodes the specified TokenValue message, length delimited. Does not implicitly {@link rv.data.Message.TokenValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Message.TokenValue
                 * @static
                 * @param {rv.data.Message.ITokenValue} message TokenValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TokenValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TokenValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Message.TokenValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Message.TokenValue} TokenValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TokenValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Message.TokenValue();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.tokenId = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.tokenName = reader.string();
                                break;
                            }
                        case 2: {
                                message.text = $root.rv.data.Message.TokenValue.TokenValueText.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.timer = $root.rv.data.Message.TokenValue.TokenValueTimer.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.clock = $root.rv.data.Message.TokenValue.TokenValueClock.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TokenValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Message.TokenValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Message.TokenValue} TokenValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TokenValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TokenValue message.
                 * @function verify
                 * @memberof rv.data.Message.TokenValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TokenValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.tokenId != null && message.hasOwnProperty("tokenId")) {
                        let error = $root.rv.data.UUID.verify(message.tokenId);
                        if (error)
                            return "tokenId." + error;
                    }
                    if (message.tokenName != null && message.hasOwnProperty("tokenName"))
                        if (!$util.isString(message.tokenName))
                            return "tokenName: string expected";
                    if (message.text != null && message.hasOwnProperty("text")) {
                        properties.TokenValueType = 1;
                        {
                            let error = $root.rv.data.Message.TokenValue.TokenValueText.verify(message.text);
                            if (error)
                                return "text." + error;
                        }
                    }
                    if (message.timer != null && message.hasOwnProperty("timer")) {
                        if (properties.TokenValueType === 1)
                            return "TokenValueType: multiple values";
                        properties.TokenValueType = 1;
                        {
                            let error = $root.rv.data.Message.TokenValue.TokenValueTimer.verify(message.timer);
                            if (error)
                                return "timer." + error;
                        }
                    }
                    if (message.clock != null && message.hasOwnProperty("clock")) {
                        if (properties.TokenValueType === 1)
                            return "TokenValueType: multiple values";
                        properties.TokenValueType = 1;
                        {
                            let error = $root.rv.data.Message.TokenValue.TokenValueClock.verify(message.clock);
                            if (error)
                                return "clock." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TokenValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Message.TokenValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Message.TokenValue} TokenValue
                 */
                TokenValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Message.TokenValue)
                        return object;
                    let message = new $root.rv.data.Message.TokenValue();
                    if (object.tokenId != null) {
                        if (typeof object.tokenId !== "object")
                            throw TypeError(".rv.data.Message.TokenValue.tokenId: object expected");
                        message.tokenId = $root.rv.data.UUID.fromObject(object.tokenId);
                    }
                    if (object.tokenName != null)
                        message.tokenName = String(object.tokenName);
                    if (object.text != null) {
                        if (typeof object.text !== "object")
                            throw TypeError(".rv.data.Message.TokenValue.text: object expected");
                        message.text = $root.rv.data.Message.TokenValue.TokenValueText.fromObject(object.text);
                    }
                    if (object.timer != null) {
                        if (typeof object.timer !== "object")
                            throw TypeError(".rv.data.Message.TokenValue.timer: object expected");
                        message.timer = $root.rv.data.Message.TokenValue.TokenValueTimer.fromObject(object.timer);
                    }
                    if (object.clock != null) {
                        if (typeof object.clock !== "object")
                            throw TypeError(".rv.data.Message.TokenValue.clock: object expected");
                        message.clock = $root.rv.data.Message.TokenValue.TokenValueClock.fromObject(object.clock);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TokenValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Message.TokenValue
                 * @static
                 * @param {rv.data.Message.TokenValue} message TokenValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TokenValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.tokenId = null;
                        object.tokenName = "";
                    }
                    if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                        object.tokenId = $root.rv.data.UUID.toObject(message.tokenId, options);
                    if (message.text != null && message.hasOwnProperty("text")) {
                        object.text = $root.rv.data.Message.TokenValue.TokenValueText.toObject(message.text, options);
                        if (options.oneofs)
                            object.TokenValueType = "text";
                    }
                    if (message.timer != null && message.hasOwnProperty("timer")) {
                        object.timer = $root.rv.data.Message.TokenValue.TokenValueTimer.toObject(message.timer, options);
                        if (options.oneofs)
                            object.TokenValueType = "timer";
                    }
                    if (message.clock != null && message.hasOwnProperty("clock")) {
                        object.clock = $root.rv.data.Message.TokenValue.TokenValueClock.toObject(message.clock, options);
                        if (options.oneofs)
                            object.TokenValueType = "clock";
                    }
                    if (message.tokenName != null && message.hasOwnProperty("tokenName"))
                        object.tokenName = message.tokenName;
                    return object;
                };

                /**
                 * Converts this TokenValue to JSON.
                 * @function toJSON
                 * @memberof rv.data.Message.TokenValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TokenValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TokenValue
                 * @function getTypeUrl
                 * @memberof rv.data.Message.TokenValue
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TokenValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Message.TokenValue";
                };

                TokenValue.TokenValueText = (function() {

                    /**
                     * Properties of a TokenValueText.
                     * @memberof rv.data.Message.TokenValue
                     * @interface ITokenValueText
                     * @property {string|null} [value] TokenValueText value
                     */

                    /**
                     * Constructs a new TokenValueText.
                     * @memberof rv.data.Message.TokenValue
                     * @classdesc Represents a TokenValueText.
                     * @implements ITokenValueText
                     * @constructor
                     * @param {rv.data.Message.TokenValue.ITokenValueText=} [properties] Properties to set
                     */
                    function TokenValueText(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TokenValueText value.
                     * @member {string} value
                     * @memberof rv.data.Message.TokenValue.TokenValueText
                     * @instance
                     */
                    TokenValueText.prototype.value = "";

                    /**
                     * Creates a new TokenValueText instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Message.TokenValue.TokenValueText
                     * @static
                     * @param {rv.data.Message.TokenValue.ITokenValueText=} [properties] Properties to set
                     * @returns {rv.data.Message.TokenValue.TokenValueText} TokenValueText instance
                     */
                    TokenValueText.create = function create(properties) {
                        return new TokenValueText(properties);
                    };

                    /**
                     * Encodes the specified TokenValueText message. Does not implicitly {@link rv.data.Message.TokenValue.TokenValueText.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Message.TokenValue.TokenValueText
                     * @static
                     * @param {rv.data.Message.TokenValue.ITokenValueText} message TokenValueText message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenValueText.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                        return writer;
                    };

                    /**
                     * Encodes the specified TokenValueText message, length delimited. Does not implicitly {@link rv.data.Message.TokenValue.TokenValueText.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Message.TokenValue.TokenValueText
                     * @static
                     * @param {rv.data.Message.TokenValue.ITokenValueText} message TokenValueText message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenValueText.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TokenValueText message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Message.TokenValue.TokenValueText
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Message.TokenValue.TokenValueText} TokenValueText
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenValueText.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Message.TokenValue.TokenValueText();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.value = reader.string();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TokenValueText message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Message.TokenValue.TokenValueText
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Message.TokenValue.TokenValueText} TokenValueText
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenValueText.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TokenValueText message.
                     * @function verify
                     * @memberof rv.data.Message.TokenValue.TokenValueText
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenValueText.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isString(message.value))
                                return "value: string expected";
                        return null;
                    };

                    /**
                     * Creates a TokenValueText message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Message.TokenValue.TokenValueText
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Message.TokenValue.TokenValueText} TokenValueText
                     */
                    TokenValueText.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Message.TokenValue.TokenValueText)
                            return object;
                        let message = new $root.rv.data.Message.TokenValue.TokenValueText();
                        if (object.value != null)
                            message.value = String(object.value);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TokenValueText message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Message.TokenValue.TokenValueText
                     * @static
                     * @param {rv.data.Message.TokenValue.TokenValueText} message TokenValueText
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenValueText.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.value = "";
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = message.value;
                        return object;
                    };

                    /**
                     * Converts this TokenValueText to JSON.
                     * @function toJSON
                     * @memberof rv.data.Message.TokenValue.TokenValueText
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenValueText.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for TokenValueText
                     * @function getTypeUrl
                     * @memberof rv.data.Message.TokenValue.TokenValueText
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    TokenValueText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Message.TokenValue.TokenValueText";
                    };

                    return TokenValueText;
                })();

                TokenValue.TokenValueTimer = (function() {

                    /**
                     * Properties of a TokenValueTimer.
                     * @memberof rv.data.Message.TokenValue
                     * @interface ITokenValueTimer
                     * @property {rv.data.Timer.IConfiguration|null} [configuration] TokenValueTimer configuration
                     * @property {rv.data.Timer.IFormat|null} [format] TokenValueTimer format
                     */

                    /**
                     * Constructs a new TokenValueTimer.
                     * @memberof rv.data.Message.TokenValue
                     * @classdesc Represents a TokenValueTimer.
                     * @implements ITokenValueTimer
                     * @constructor
                     * @param {rv.data.Message.TokenValue.ITokenValueTimer=} [properties] Properties to set
                     */
                    function TokenValueTimer(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TokenValueTimer configuration.
                     * @member {rv.data.Timer.IConfiguration|null|undefined} configuration
                     * @memberof rv.data.Message.TokenValue.TokenValueTimer
                     * @instance
                     */
                    TokenValueTimer.prototype.configuration = null;

                    /**
                     * TokenValueTimer format.
                     * @member {rv.data.Timer.IFormat|null|undefined} format
                     * @memberof rv.data.Message.TokenValue.TokenValueTimer
                     * @instance
                     */
                    TokenValueTimer.prototype.format = null;

                    /**
                     * Creates a new TokenValueTimer instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Message.TokenValue.TokenValueTimer
                     * @static
                     * @param {rv.data.Message.TokenValue.ITokenValueTimer=} [properties] Properties to set
                     * @returns {rv.data.Message.TokenValue.TokenValueTimer} TokenValueTimer instance
                     */
                    TokenValueTimer.create = function create(properties) {
                        return new TokenValueTimer(properties);
                    };

                    /**
                     * Encodes the specified TokenValueTimer message. Does not implicitly {@link rv.data.Message.TokenValue.TokenValueTimer.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Message.TokenValue.TokenValueTimer
                     * @static
                     * @param {rv.data.Message.TokenValue.ITokenValueTimer} message TokenValueTimer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenValueTimer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.configuration != null && Object.hasOwnProperty.call(message, "configuration"))
                            $root.rv.data.Timer.Configuration.encode(message.configuration, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                            $root.rv.data.Timer.Format.encode(message.format, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified TokenValueTimer message, length delimited. Does not implicitly {@link rv.data.Message.TokenValue.TokenValueTimer.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Message.TokenValue.TokenValueTimer
                     * @static
                     * @param {rv.data.Message.TokenValue.ITokenValueTimer} message TokenValueTimer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenValueTimer.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TokenValueTimer message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Message.TokenValue.TokenValueTimer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Message.TokenValue.TokenValueTimer} TokenValueTimer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenValueTimer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Message.TokenValue.TokenValueTimer();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.configuration = $root.rv.data.Timer.Configuration.decode(reader, reader.uint32());
                                    break;
                                }
                            case 2: {
                                    message.format = $root.rv.data.Timer.Format.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TokenValueTimer message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Message.TokenValue.TokenValueTimer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Message.TokenValue.TokenValueTimer} TokenValueTimer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenValueTimer.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TokenValueTimer message.
                     * @function verify
                     * @memberof rv.data.Message.TokenValue.TokenValueTimer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenValueTimer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.configuration != null && message.hasOwnProperty("configuration")) {
                            let error = $root.rv.data.Timer.Configuration.verify(message.configuration);
                            if (error)
                                return "configuration." + error;
                        }
                        if (message.format != null && message.hasOwnProperty("format")) {
                            let error = $root.rv.data.Timer.Format.verify(message.format);
                            if (error)
                                return "format." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a TokenValueTimer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Message.TokenValue.TokenValueTimer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Message.TokenValue.TokenValueTimer} TokenValueTimer
                     */
                    TokenValueTimer.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Message.TokenValue.TokenValueTimer)
                            return object;
                        let message = new $root.rv.data.Message.TokenValue.TokenValueTimer();
                        if (object.configuration != null) {
                            if (typeof object.configuration !== "object")
                                throw TypeError(".rv.data.Message.TokenValue.TokenValueTimer.configuration: object expected");
                            message.configuration = $root.rv.data.Timer.Configuration.fromObject(object.configuration);
                        }
                        if (object.format != null) {
                            if (typeof object.format !== "object")
                                throw TypeError(".rv.data.Message.TokenValue.TokenValueTimer.format: object expected");
                            message.format = $root.rv.data.Timer.Format.fromObject(object.format);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a TokenValueTimer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Message.TokenValue.TokenValueTimer
                     * @static
                     * @param {rv.data.Message.TokenValue.TokenValueTimer} message TokenValueTimer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenValueTimer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.configuration = null;
                            object.format = null;
                        }
                        if (message.configuration != null && message.hasOwnProperty("configuration"))
                            object.configuration = $root.rv.data.Timer.Configuration.toObject(message.configuration, options);
                        if (message.format != null && message.hasOwnProperty("format"))
                            object.format = $root.rv.data.Timer.Format.toObject(message.format, options);
                        return object;
                    };

                    /**
                     * Converts this TokenValueTimer to JSON.
                     * @function toJSON
                     * @memberof rv.data.Message.TokenValue.TokenValueTimer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenValueTimer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for TokenValueTimer
                     * @function getTypeUrl
                     * @memberof rv.data.Message.TokenValue.TokenValueTimer
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    TokenValueTimer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Message.TokenValue.TokenValueTimer";
                    };

                    return TokenValueTimer;
                })();

                TokenValue.TokenValueClock = (function() {

                    /**
                     * Properties of a TokenValueClock.
                     * @memberof rv.data.Message.TokenValue
                     * @interface ITokenValueClock
                     * @property {rv.data.Clock.IFormat|null} [format] TokenValueClock format
                     */

                    /**
                     * Constructs a new TokenValueClock.
                     * @memberof rv.data.Message.TokenValue
                     * @classdesc Represents a TokenValueClock.
                     * @implements ITokenValueClock
                     * @constructor
                     * @param {rv.data.Message.TokenValue.ITokenValueClock=} [properties] Properties to set
                     */
                    function TokenValueClock(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TokenValueClock format.
                     * @member {rv.data.Clock.IFormat|null|undefined} format
                     * @memberof rv.data.Message.TokenValue.TokenValueClock
                     * @instance
                     */
                    TokenValueClock.prototype.format = null;

                    /**
                     * Creates a new TokenValueClock instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Message.TokenValue.TokenValueClock
                     * @static
                     * @param {rv.data.Message.TokenValue.ITokenValueClock=} [properties] Properties to set
                     * @returns {rv.data.Message.TokenValue.TokenValueClock} TokenValueClock instance
                     */
                    TokenValueClock.create = function create(properties) {
                        return new TokenValueClock(properties);
                    };

                    /**
                     * Encodes the specified TokenValueClock message. Does not implicitly {@link rv.data.Message.TokenValue.TokenValueClock.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Message.TokenValue.TokenValueClock
                     * @static
                     * @param {rv.data.Message.TokenValue.ITokenValueClock} message TokenValueClock message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenValueClock.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                            $root.rv.data.Clock.Format.encode(message.format, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified TokenValueClock message, length delimited. Does not implicitly {@link rv.data.Message.TokenValue.TokenValueClock.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Message.TokenValue.TokenValueClock
                     * @static
                     * @param {rv.data.Message.TokenValue.ITokenValueClock} message TokenValueClock message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenValueClock.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TokenValueClock message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Message.TokenValue.TokenValueClock
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Message.TokenValue.TokenValueClock} TokenValueClock
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenValueClock.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Message.TokenValue.TokenValueClock();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.format = $root.rv.data.Clock.Format.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TokenValueClock message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Message.TokenValue.TokenValueClock
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Message.TokenValue.TokenValueClock} TokenValueClock
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenValueClock.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TokenValueClock message.
                     * @function verify
                     * @memberof rv.data.Message.TokenValue.TokenValueClock
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenValueClock.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.format != null && message.hasOwnProperty("format")) {
                            let error = $root.rv.data.Clock.Format.verify(message.format);
                            if (error)
                                return "format." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a TokenValueClock message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Message.TokenValue.TokenValueClock
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Message.TokenValue.TokenValueClock} TokenValueClock
                     */
                    TokenValueClock.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Message.TokenValue.TokenValueClock)
                            return object;
                        let message = new $root.rv.data.Message.TokenValue.TokenValueClock();
                        if (object.format != null) {
                            if (typeof object.format !== "object")
                                throw TypeError(".rv.data.Message.TokenValue.TokenValueClock.format: object expected");
                            message.format = $root.rv.data.Clock.Format.fromObject(object.format);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a TokenValueClock message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Message.TokenValue.TokenValueClock
                     * @static
                     * @param {rv.data.Message.TokenValue.TokenValueClock} message TokenValueClock
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenValueClock.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.format = null;
                        if (message.format != null && message.hasOwnProperty("format"))
                            object.format = $root.rv.data.Clock.Format.toObject(message.format, options);
                        return object;
                    };

                    /**
                     * Converts this TokenValueClock to JSON.
                     * @function toJSON
                     * @memberof rv.data.Message.TokenValue.TokenValueClock
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenValueClock.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for TokenValueClock
                     * @function getTypeUrl
                     * @memberof rv.data.Message.TokenValue.TokenValueClock
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    TokenValueClock.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Message.TokenValue.TokenValueClock";
                    };

                    return TokenValueClock;
                })();

                return TokenValue;
            })();

            /**
             * ClearType enum.
             * @name rv.data.Message.ClearType
             * @enum {number}
             * @property {number} CLEAR_TYPE_MANUAL=0 CLEAR_TYPE_MANUAL value
             * @property {number} CLEAR_TYPE_AFTER_TIME=1 CLEAR_TYPE_AFTER_TIME value
             * @property {number} CLEAR_TYPE_AFTER_TIMERS=2 CLEAR_TYPE_AFTER_TIMERS value
             */
            Message.ClearType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CLEAR_TYPE_MANUAL"] = 0;
                values[valuesById[1] = "CLEAR_TYPE_AFTER_TIME"] = 1;
                values[valuesById[2] = "CLEAR_TYPE_AFTER_TIMERS"] = 2;
                return values;
            })();

            return Message;
        })();

        data.MessageDocument = (function() {

            /**
             * Properties of a MessageDocument.
             * @memberof rv.data
             * @interface IMessageDocument
             * @property {rv.data.IApplicationInfo|null} [applicationInfo] MessageDocument applicationInfo
             * @property {Array.<rv.data.IMessage>|null} [messages] MessageDocument messages
             */

            /**
             * Constructs a new MessageDocument.
             * @memberof rv.data
             * @classdesc Represents a MessageDocument.
             * @implements IMessageDocument
             * @constructor
             * @param {rv.data.IMessageDocument=} [properties] Properties to set
             */
            function MessageDocument(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageDocument applicationInfo.
             * @member {rv.data.IApplicationInfo|null|undefined} applicationInfo
             * @memberof rv.data.MessageDocument
             * @instance
             */
            MessageDocument.prototype.applicationInfo = null;

            /**
             * MessageDocument messages.
             * @member {Array.<rv.data.IMessage>} messages
             * @memberof rv.data.MessageDocument
             * @instance
             */
            MessageDocument.prototype.messages = $util.emptyArray;

            /**
             * Creates a new MessageDocument instance using the specified properties.
             * @function create
             * @memberof rv.data.MessageDocument
             * @static
             * @param {rv.data.IMessageDocument=} [properties] Properties to set
             * @returns {rv.data.MessageDocument} MessageDocument instance
             */
            MessageDocument.create = function create(properties) {
                return new MessageDocument(properties);
            };

            /**
             * Encodes the specified MessageDocument message. Does not implicitly {@link rv.data.MessageDocument.verify|verify} messages.
             * @function encode
             * @memberof rv.data.MessageDocument
             * @static
             * @param {rv.data.IMessageDocument} message MessageDocument message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageDocument.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.applicationInfo != null && Object.hasOwnProperty.call(message, "applicationInfo"))
                    $root.rv.data.ApplicationInfo.encode(message.applicationInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.rv.data.Message.encode(message.messages[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MessageDocument message, length delimited. Does not implicitly {@link rv.data.MessageDocument.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.MessageDocument
             * @static
             * @param {rv.data.IMessageDocument} message MessageDocument message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageDocument.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageDocument message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.MessageDocument
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.MessageDocument} MessageDocument
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageDocument.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.MessageDocument();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.applicationInfo = $root.rv.data.ApplicationInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.rv.data.Message.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageDocument message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.MessageDocument
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.MessageDocument} MessageDocument
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageDocument.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageDocument message.
             * @function verify
             * @memberof rv.data.MessageDocument
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageDocument.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.applicationInfo != null && message.hasOwnProperty("applicationInfo")) {
                    let error = $root.rv.data.ApplicationInfo.verify(message.applicationInfo);
                    if (error)
                        return "applicationInfo." + error;
                }
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.rv.data.Message.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MessageDocument message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.MessageDocument
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.MessageDocument} MessageDocument
             */
            MessageDocument.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.MessageDocument)
                    return object;
                let message = new $root.rv.data.MessageDocument();
                if (object.applicationInfo != null) {
                    if (typeof object.applicationInfo !== "object")
                        throw TypeError(".rv.data.MessageDocument.applicationInfo: object expected");
                    message.applicationInfo = $root.rv.data.ApplicationInfo.fromObject(object.applicationInfo);
                }
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".rv.data.MessageDocument.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".rv.data.MessageDocument.messages: object expected");
                        message.messages[i] = $root.rv.data.Message.fromObject(object.messages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageDocument message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.MessageDocument
             * @static
             * @param {rv.data.MessageDocument} message MessageDocument
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageDocument.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (options.defaults)
                    object.applicationInfo = null;
                if (message.applicationInfo != null && message.hasOwnProperty("applicationInfo"))
                    object.applicationInfo = $root.rv.data.ApplicationInfo.toObject(message.applicationInfo, options);
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.rv.data.Message.toObject(message.messages[j], options);
                }
                return object;
            };

            /**
             * Converts this MessageDocument to JSON.
             * @function toJSON
             * @memberof rv.data.MessageDocument
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageDocument.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MessageDocument
             * @function getTypeUrl
             * @memberof rv.data.MessageDocument
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MessageDocument.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.MessageDocument";
            };

            return MessageDocument;
        })();

        data.ApplicationInfo = (function() {

            /**
             * Properties of an ApplicationInfo.
             * @memberof rv.data
             * @interface IApplicationInfo
             * @property {rv.data.ApplicationInfo.Platform|null} [platform] ApplicationInfo platform
             * @property {rv.data.IVersion|null} [platformVersion] ApplicationInfo platformVersion
             * @property {rv.data.ApplicationInfo.Application|null} [application] ApplicationInfo application
             * @property {rv.data.IVersion|null} [applicationVersion] ApplicationInfo applicationVersion
             */

            /**
             * Constructs a new ApplicationInfo.
             * @memberof rv.data
             * @classdesc Represents an ApplicationInfo.
             * @implements IApplicationInfo
             * @constructor
             * @param {rv.data.IApplicationInfo=} [properties] Properties to set
             */
            function ApplicationInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ApplicationInfo platform.
             * @member {rv.data.ApplicationInfo.Platform} platform
             * @memberof rv.data.ApplicationInfo
             * @instance
             */
            ApplicationInfo.prototype.platform = 0;

            /**
             * ApplicationInfo platformVersion.
             * @member {rv.data.IVersion|null|undefined} platformVersion
             * @memberof rv.data.ApplicationInfo
             * @instance
             */
            ApplicationInfo.prototype.platformVersion = null;

            /**
             * ApplicationInfo application.
             * @member {rv.data.ApplicationInfo.Application} application
             * @memberof rv.data.ApplicationInfo
             * @instance
             */
            ApplicationInfo.prototype.application = 0;

            /**
             * ApplicationInfo applicationVersion.
             * @member {rv.data.IVersion|null|undefined} applicationVersion
             * @memberof rv.data.ApplicationInfo
             * @instance
             */
            ApplicationInfo.prototype.applicationVersion = null;

            /**
             * Creates a new ApplicationInfo instance using the specified properties.
             * @function create
             * @memberof rv.data.ApplicationInfo
             * @static
             * @param {rv.data.IApplicationInfo=} [properties] Properties to set
             * @returns {rv.data.ApplicationInfo} ApplicationInfo instance
             */
            ApplicationInfo.create = function create(properties) {
                return new ApplicationInfo(properties);
            };

            /**
             * Encodes the specified ApplicationInfo message. Does not implicitly {@link rv.data.ApplicationInfo.verify|verify} messages.
             * @function encode
             * @memberof rv.data.ApplicationInfo
             * @static
             * @param {rv.data.IApplicationInfo} message ApplicationInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplicationInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.platform);
                if (message.platformVersion != null && Object.hasOwnProperty.call(message, "platformVersion"))
                    $root.rv.data.Version.encode(message.platformVersion, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.application != null && Object.hasOwnProperty.call(message, "application"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.application);
                if (message.applicationVersion != null && Object.hasOwnProperty.call(message, "applicationVersion"))
                    $root.rv.data.Version.encode(message.applicationVersion, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ApplicationInfo message, length delimited. Does not implicitly {@link rv.data.ApplicationInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.ApplicationInfo
             * @static
             * @param {rv.data.IApplicationInfo} message ApplicationInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplicationInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ApplicationInfo message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.ApplicationInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.ApplicationInfo} ApplicationInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplicationInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.ApplicationInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.platform = reader.int32();
                            break;
                        }
                    case 2: {
                            message.platformVersion = $root.rv.data.Version.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.application = reader.int32();
                            break;
                        }
                    case 4: {
                            message.applicationVersion = $root.rv.data.Version.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ApplicationInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.ApplicationInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.ApplicationInfo} ApplicationInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplicationInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ApplicationInfo message.
             * @function verify
             * @memberof rv.data.ApplicationInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApplicationInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.platform != null && message.hasOwnProperty("platform"))
                    switch (message.platform) {
                    default:
                        return "platform: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.platformVersion != null && message.hasOwnProperty("platformVersion")) {
                    let error = $root.rv.data.Version.verify(message.platformVersion);
                    if (error)
                        return "platformVersion." + error;
                }
                if (message.application != null && message.hasOwnProperty("application"))
                    switch (message.application) {
                    default:
                        return "application: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.applicationVersion != null && message.hasOwnProperty("applicationVersion")) {
                    let error = $root.rv.data.Version.verify(message.applicationVersion);
                    if (error)
                        return "applicationVersion." + error;
                }
                return null;
            };

            /**
             * Creates an ApplicationInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.ApplicationInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.ApplicationInfo} ApplicationInfo
             */
            ApplicationInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.ApplicationInfo)
                    return object;
                let message = new $root.rv.data.ApplicationInfo();
                switch (object.platform) {
                default:
                    if (typeof object.platform === "number") {
                        message.platform = object.platform;
                        break;
                    }
                    break;
                case "PLATFORM_UNDEFINED":
                case 0:
                    message.platform = 0;
                    break;
                case "PLATFORM_MACOS":
                case 1:
                    message.platform = 1;
                    break;
                case "PLATFORM_WINDOWS":
                case 2:
                    message.platform = 2;
                    break;
                }
                if (object.platformVersion != null) {
                    if (typeof object.platformVersion !== "object")
                        throw TypeError(".rv.data.ApplicationInfo.platformVersion: object expected");
                    message.platformVersion = $root.rv.data.Version.fromObject(object.platformVersion);
                }
                switch (object.application) {
                default:
                    if (typeof object.application === "number") {
                        message.application = object.application;
                        break;
                    }
                    break;
                case "APPLICATION_UNDEFINED":
                case 0:
                    message.application = 0;
                    break;
                case "APPLICATION_PROPRESENTER":
                case 1:
                    message.application = 1;
                    break;
                case "APPLICATION_PVP":
                case 2:
                    message.application = 2;
                    break;
                case "APPLICATION_PROVIDEOSERVER":
                case 3:
                    message.application = 3;
                    break;
                case "APPLICATION_SCOREBOARD":
                case 4:
                    message.application = 4;
                    break;
                }
                if (object.applicationVersion != null) {
                    if (typeof object.applicationVersion !== "object")
                        throw TypeError(".rv.data.ApplicationInfo.applicationVersion: object expected");
                    message.applicationVersion = $root.rv.data.Version.fromObject(object.applicationVersion);
                }
                return message;
            };

            /**
             * Creates a plain object from an ApplicationInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.ApplicationInfo
             * @static
             * @param {rv.data.ApplicationInfo} message ApplicationInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ApplicationInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.platform = options.enums === String ? "PLATFORM_UNDEFINED" : 0;
                    object.platformVersion = null;
                    object.application = options.enums === String ? "APPLICATION_UNDEFINED" : 0;
                    object.applicationVersion = null;
                }
                if (message.platform != null && message.hasOwnProperty("platform"))
                    object.platform = options.enums === String ? $root.rv.data.ApplicationInfo.Platform[message.platform] === undefined ? message.platform : $root.rv.data.ApplicationInfo.Platform[message.platform] : message.platform;
                if (message.platformVersion != null && message.hasOwnProperty("platformVersion"))
                    object.platformVersion = $root.rv.data.Version.toObject(message.platformVersion, options);
                if (message.application != null && message.hasOwnProperty("application"))
                    object.application = options.enums === String ? $root.rv.data.ApplicationInfo.Application[message.application] === undefined ? message.application : $root.rv.data.ApplicationInfo.Application[message.application] : message.application;
                if (message.applicationVersion != null && message.hasOwnProperty("applicationVersion"))
                    object.applicationVersion = $root.rv.data.Version.toObject(message.applicationVersion, options);
                return object;
            };

            /**
             * Converts this ApplicationInfo to JSON.
             * @function toJSON
             * @memberof rv.data.ApplicationInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ApplicationInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ApplicationInfo
             * @function getTypeUrl
             * @memberof rv.data.ApplicationInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ApplicationInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.ApplicationInfo";
            };

            /**
             * Platform enum.
             * @name rv.data.ApplicationInfo.Platform
             * @enum {number}
             * @property {number} PLATFORM_UNDEFINED=0 PLATFORM_UNDEFINED value
             * @property {number} PLATFORM_MACOS=1 PLATFORM_MACOS value
             * @property {number} PLATFORM_WINDOWS=2 PLATFORM_WINDOWS value
             */
            ApplicationInfo.Platform = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "PLATFORM_UNDEFINED"] = 0;
                values[valuesById[1] = "PLATFORM_MACOS"] = 1;
                values[valuesById[2] = "PLATFORM_WINDOWS"] = 2;
                return values;
            })();

            /**
             * Application enum.
             * @name rv.data.ApplicationInfo.Application
             * @enum {number}
             * @property {number} APPLICATION_UNDEFINED=0 APPLICATION_UNDEFINED value
             * @property {number} APPLICATION_PROPRESENTER=1 APPLICATION_PROPRESENTER value
             * @property {number} APPLICATION_PVP=2 APPLICATION_PVP value
             * @property {number} APPLICATION_PROVIDEOSERVER=3 APPLICATION_PROVIDEOSERVER value
             * @property {number} APPLICATION_SCOREBOARD=4 APPLICATION_SCOREBOARD value
             */
            ApplicationInfo.Application = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "APPLICATION_UNDEFINED"] = 0;
                values[valuesById[1] = "APPLICATION_PROPRESENTER"] = 1;
                values[valuesById[2] = "APPLICATION_PVP"] = 2;
                values[valuesById[3] = "APPLICATION_PROVIDEOSERVER"] = 3;
                values[valuesById[4] = "APPLICATION_SCOREBOARD"] = 4;
                return values;
            })();

            return ApplicationInfo;
        })();

        data.Version = (function() {

            /**
             * Properties of a Version.
             * @memberof rv.data
             * @interface IVersion
             * @property {number|null} [majorVersion] Version majorVersion
             * @property {number|null} [minorVersion] Version minorVersion
             * @property {number|null} [patchVersion] Version patchVersion
             * @property {string|null} [build] Version build
             */

            /**
             * Constructs a new Version.
             * @memberof rv.data
             * @classdesc Represents a Version.
             * @implements IVersion
             * @constructor
             * @param {rv.data.IVersion=} [properties] Properties to set
             */
            function Version(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Version majorVersion.
             * @member {number} majorVersion
             * @memberof rv.data.Version
             * @instance
             */
            Version.prototype.majorVersion = 0;

            /**
             * Version minorVersion.
             * @member {number} minorVersion
             * @memberof rv.data.Version
             * @instance
             */
            Version.prototype.minorVersion = 0;

            /**
             * Version patchVersion.
             * @member {number} patchVersion
             * @memberof rv.data.Version
             * @instance
             */
            Version.prototype.patchVersion = 0;

            /**
             * Version build.
             * @member {string} build
             * @memberof rv.data.Version
             * @instance
             */
            Version.prototype.build = "";

            /**
             * Creates a new Version instance using the specified properties.
             * @function create
             * @memberof rv.data.Version
             * @static
             * @param {rv.data.IVersion=} [properties] Properties to set
             * @returns {rv.data.Version} Version instance
             */
            Version.create = function create(properties) {
                return new Version(properties);
            };

            /**
             * Encodes the specified Version message. Does not implicitly {@link rv.data.Version.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Version
             * @static
             * @param {rv.data.IVersion} message Version message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Version.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.majorVersion != null && Object.hasOwnProperty.call(message, "majorVersion"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.majorVersion);
                if (message.minorVersion != null && Object.hasOwnProperty.call(message, "minorVersion"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.minorVersion);
                if (message.patchVersion != null && Object.hasOwnProperty.call(message, "patchVersion"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.patchVersion);
                if (message.build != null && Object.hasOwnProperty.call(message, "build"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.build);
                return writer;
            };

            /**
             * Encodes the specified Version message, length delimited. Does not implicitly {@link rv.data.Version.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Version
             * @static
             * @param {rv.data.IVersion} message Version message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Version.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Version message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Version
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Version} Version
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Version.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Version();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.majorVersion = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.minorVersion = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.patchVersion = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.build = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Version message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Version
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Version} Version
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Version.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Version message.
             * @function verify
             * @memberof rv.data.Version
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Version.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.majorVersion != null && message.hasOwnProperty("majorVersion"))
                    if (!$util.isInteger(message.majorVersion))
                        return "majorVersion: integer expected";
                if (message.minorVersion != null && message.hasOwnProperty("minorVersion"))
                    if (!$util.isInteger(message.minorVersion))
                        return "minorVersion: integer expected";
                if (message.patchVersion != null && message.hasOwnProperty("patchVersion"))
                    if (!$util.isInteger(message.patchVersion))
                        return "patchVersion: integer expected";
                if (message.build != null && message.hasOwnProperty("build"))
                    if (!$util.isString(message.build))
                        return "build: string expected";
                return null;
            };

            /**
             * Creates a Version message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Version
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Version} Version
             */
            Version.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Version)
                    return object;
                let message = new $root.rv.data.Version();
                if (object.majorVersion != null)
                    message.majorVersion = object.majorVersion >>> 0;
                if (object.minorVersion != null)
                    message.minorVersion = object.minorVersion >>> 0;
                if (object.patchVersion != null)
                    message.patchVersion = object.patchVersion >>> 0;
                if (object.build != null)
                    message.build = String(object.build);
                return message;
            };

            /**
             * Creates a plain object from a Version message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Version
             * @static
             * @param {rv.data.Version} message Version
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Version.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.majorVersion = 0;
                    object.minorVersion = 0;
                    object.patchVersion = 0;
                    object.build = "";
                }
                if (message.majorVersion != null && message.hasOwnProperty("majorVersion"))
                    object.majorVersion = message.majorVersion;
                if (message.minorVersion != null && message.hasOwnProperty("minorVersion"))
                    object.minorVersion = message.minorVersion;
                if (message.patchVersion != null && message.hasOwnProperty("patchVersion"))
                    object.patchVersion = message.patchVersion;
                if (message.build != null && message.hasOwnProperty("build"))
                    object.build = message.build;
                return object;
            };

            /**
             * Converts this Version to JSON.
             * @function toJSON
             * @memberof rv.data.Version
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Version.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Version
             * @function getTypeUrl
             * @memberof rv.data.Version
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Version.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Version";
            };

            return Version;
        })();

        data.TemplateIdentification = (function() {

            /**
             * Properties of a TemplateIdentification.
             * @memberof rv.data
             * @interface ITemplateIdentification
             * @property {rv.data.IUUID|null} [uuid] TemplateIdentification uuid
             * @property {string|null} [name] TemplateIdentification name
             * @property {rv.data.IUUID|null} [slideUuid] TemplateIdentification slideUuid
             * @property {string|null} [slideName] TemplateIdentification slideName
             * @property {number|null} [slideIndex] TemplateIdentification slideIndex
             */

            /**
             * Constructs a new TemplateIdentification.
             * @memberof rv.data
             * @classdesc Represents a TemplateIdentification.
             * @implements ITemplateIdentification
             * @constructor
             * @param {rv.data.ITemplateIdentification=} [properties] Properties to set
             */
            function TemplateIdentification(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TemplateIdentification uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.TemplateIdentification
             * @instance
             */
            TemplateIdentification.prototype.uuid = null;

            /**
             * TemplateIdentification name.
             * @member {string} name
             * @memberof rv.data.TemplateIdentification
             * @instance
             */
            TemplateIdentification.prototype.name = "";

            /**
             * TemplateIdentification slideUuid.
             * @member {rv.data.IUUID|null|undefined} slideUuid
             * @memberof rv.data.TemplateIdentification
             * @instance
             */
            TemplateIdentification.prototype.slideUuid = null;

            /**
             * TemplateIdentification slideName.
             * @member {string} slideName
             * @memberof rv.data.TemplateIdentification
             * @instance
             */
            TemplateIdentification.prototype.slideName = "";

            /**
             * TemplateIdentification slideIndex.
             * @member {number} slideIndex
             * @memberof rv.data.TemplateIdentification
             * @instance
             */
            TemplateIdentification.prototype.slideIndex = 0;

            /**
             * Creates a new TemplateIdentification instance using the specified properties.
             * @function create
             * @memberof rv.data.TemplateIdentification
             * @static
             * @param {rv.data.ITemplateIdentification=} [properties] Properties to set
             * @returns {rv.data.TemplateIdentification} TemplateIdentification instance
             */
            TemplateIdentification.create = function create(properties) {
                return new TemplateIdentification(properties);
            };

            /**
             * Encodes the specified TemplateIdentification message. Does not implicitly {@link rv.data.TemplateIdentification.verify|verify} messages.
             * @function encode
             * @memberof rv.data.TemplateIdentification
             * @static
             * @param {rv.data.ITemplateIdentification} message TemplateIdentification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TemplateIdentification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.slideUuid != null && Object.hasOwnProperty.call(message, "slideUuid"))
                    $root.rv.data.UUID.encode(message.slideUuid, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.slideName != null && Object.hasOwnProperty.call(message, "slideName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.slideName);
                if (message.slideIndex != null && Object.hasOwnProperty.call(message, "slideIndex"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.slideIndex);
                return writer;
            };

            /**
             * Encodes the specified TemplateIdentification message, length delimited. Does not implicitly {@link rv.data.TemplateIdentification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.TemplateIdentification
             * @static
             * @param {rv.data.ITemplateIdentification} message TemplateIdentification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TemplateIdentification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TemplateIdentification message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.TemplateIdentification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.TemplateIdentification} TemplateIdentification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TemplateIdentification.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.TemplateIdentification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.slideUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.slideName = reader.string();
                            break;
                        }
                    case 5: {
                            message.slideIndex = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TemplateIdentification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.TemplateIdentification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.TemplateIdentification} TemplateIdentification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TemplateIdentification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TemplateIdentification message.
             * @function verify
             * @memberof rv.data.TemplateIdentification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TemplateIdentification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.slideUuid != null && message.hasOwnProperty("slideUuid")) {
                    let error = $root.rv.data.UUID.verify(message.slideUuid);
                    if (error)
                        return "slideUuid." + error;
                }
                if (message.slideName != null && message.hasOwnProperty("slideName"))
                    if (!$util.isString(message.slideName))
                        return "slideName: string expected";
                if (message.slideIndex != null && message.hasOwnProperty("slideIndex"))
                    if (!$util.isInteger(message.slideIndex))
                        return "slideIndex: integer expected";
                return null;
            };

            /**
             * Creates a TemplateIdentification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.TemplateIdentification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.TemplateIdentification} TemplateIdentification
             */
            TemplateIdentification.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.TemplateIdentification)
                    return object;
                let message = new $root.rv.data.TemplateIdentification();
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.TemplateIdentification.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                if (object.name != null)
                    message.name = String(object.name);
                if (object.slideUuid != null) {
                    if (typeof object.slideUuid !== "object")
                        throw TypeError(".rv.data.TemplateIdentification.slideUuid: object expected");
                    message.slideUuid = $root.rv.data.UUID.fromObject(object.slideUuid);
                }
                if (object.slideName != null)
                    message.slideName = String(object.slideName);
                if (object.slideIndex != null)
                    message.slideIndex = object.slideIndex >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a TemplateIdentification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.TemplateIdentification
             * @static
             * @param {rv.data.TemplateIdentification} message TemplateIdentification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TemplateIdentification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uuid = null;
                    object.name = "";
                    object.slideUuid = null;
                    object.slideName = "";
                    object.slideIndex = 0;
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.slideUuid != null && message.hasOwnProperty("slideUuid"))
                    object.slideUuid = $root.rv.data.UUID.toObject(message.slideUuid, options);
                if (message.slideName != null && message.hasOwnProperty("slideName"))
                    object.slideName = message.slideName;
                if (message.slideIndex != null && message.hasOwnProperty("slideIndex"))
                    object.slideIndex = message.slideIndex;
                return object;
            };

            /**
             * Converts this TemplateIdentification to JSON.
             * @function toJSON
             * @memberof rv.data.TemplateIdentification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TemplateIdentification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TemplateIdentification
             * @function getTypeUrl
             * @memberof rv.data.TemplateIdentification
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TemplateIdentification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.TemplateIdentification";
            };

            return TemplateIdentification;
        })();

        data.Clock = (function() {

            /**
             * Properties of a Clock.
             * @memberof rv.data
             * @interface IClock
             * @property {string|null} [format] Clock format
             */

            /**
             * Constructs a new Clock.
             * @memberof rv.data
             * @classdesc Represents a Clock.
             * @implements IClock
             * @constructor
             * @param {rv.data.IClock=} [properties] Properties to set
             */
            function Clock(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Clock format.
             * @member {string} format
             * @memberof rv.data.Clock
             * @instance
             */
            Clock.prototype.format = "";

            /**
             * Creates a new Clock instance using the specified properties.
             * @function create
             * @memberof rv.data.Clock
             * @static
             * @param {rv.data.IClock=} [properties] Properties to set
             * @returns {rv.data.Clock} Clock instance
             */
            Clock.create = function create(properties) {
                return new Clock(properties);
            };

            /**
             * Encodes the specified Clock message. Does not implicitly {@link rv.data.Clock.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Clock
             * @static
             * @param {rv.data.IClock} message Clock message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Clock.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.format);
                return writer;
            };

            /**
             * Encodes the specified Clock message, length delimited. Does not implicitly {@link rv.data.Clock.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Clock
             * @static
             * @param {rv.data.IClock} message Clock message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Clock.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Clock message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Clock
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Clock} Clock
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Clock.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Clock();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.format = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Clock message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Clock
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Clock} Clock
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Clock.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Clock message.
             * @function verify
             * @memberof rv.data.Clock
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Clock.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.format != null && message.hasOwnProperty("format"))
                    if (!$util.isString(message.format))
                        return "format: string expected";
                return null;
            };

            /**
             * Creates a Clock message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Clock
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Clock} Clock
             */
            Clock.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Clock)
                    return object;
                let message = new $root.rv.data.Clock();
                if (object.format != null)
                    message.format = String(object.format);
                return message;
            };

            /**
             * Creates a plain object from a Clock message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Clock
             * @static
             * @param {rv.data.Clock} message Clock
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Clock.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.format = "";
                if (message.format != null && message.hasOwnProperty("format"))
                    object.format = message.format;
                return object;
            };

            /**
             * Converts this Clock to JSON.
             * @function toJSON
             * @memberof rv.data.Clock
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Clock.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Clock
             * @function getTypeUrl
             * @memberof rv.data.Clock
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Clock.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Clock";
            };

            Clock.Format = (function() {

                /**
                 * Properties of a Format.
                 * @memberof rv.data.Clock
                 * @interface IFormat
                 * @property {rv.data.Clock.Format.DateFormatterStyle|null} [dateType] Format dateType
                 * @property {rv.data.Clock.Format.DateFormatterStyle|null} [timeFormat] Format timeFormat
                 * @property {boolean|null} [militaryTimeEnabled] Format militaryTimeEnabled
                 */

                /**
                 * Constructs a new Format.
                 * @memberof rv.data.Clock
                 * @classdesc Represents a Format.
                 * @implements IFormat
                 * @constructor
                 * @param {rv.data.Clock.IFormat=} [properties] Properties to set
                 */
                function Format(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Format dateType.
                 * @member {rv.data.Clock.Format.DateFormatterStyle} dateType
                 * @memberof rv.data.Clock.Format
                 * @instance
                 */
                Format.prototype.dateType = 0;

                /**
                 * Format timeFormat.
                 * @member {rv.data.Clock.Format.DateFormatterStyle} timeFormat
                 * @memberof rv.data.Clock.Format
                 * @instance
                 */
                Format.prototype.timeFormat = 0;

                /**
                 * Format militaryTimeEnabled.
                 * @member {boolean} militaryTimeEnabled
                 * @memberof rv.data.Clock.Format
                 * @instance
                 */
                Format.prototype.militaryTimeEnabled = false;

                /**
                 * Creates a new Format instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Clock.Format
                 * @static
                 * @param {rv.data.Clock.IFormat=} [properties] Properties to set
                 * @returns {rv.data.Clock.Format} Format instance
                 */
                Format.create = function create(properties) {
                    return new Format(properties);
                };

                /**
                 * Encodes the specified Format message. Does not implicitly {@link rv.data.Clock.Format.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Clock.Format
                 * @static
                 * @param {rv.data.Clock.IFormat} message Format message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Format.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.dateType != null && Object.hasOwnProperty.call(message, "dateType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.dateType);
                    if (message.timeFormat != null && Object.hasOwnProperty.call(message, "timeFormat"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.timeFormat);
                    if (message.militaryTimeEnabled != null && Object.hasOwnProperty.call(message, "militaryTimeEnabled"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.militaryTimeEnabled);
                    return writer;
                };

                /**
                 * Encodes the specified Format message, length delimited. Does not implicitly {@link rv.data.Clock.Format.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Clock.Format
                 * @static
                 * @param {rv.data.Clock.IFormat} message Format message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Format.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Format message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Clock.Format
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Clock.Format} Format
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Format.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Clock.Format();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2: {
                                message.dateType = reader.int32();
                                break;
                            }
                        case 3: {
                                message.timeFormat = reader.int32();
                                break;
                            }
                        case 4: {
                                message.militaryTimeEnabled = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Format message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Clock.Format
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Clock.Format} Format
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Format.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Format message.
                 * @function verify
                 * @memberof rv.data.Clock.Format
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Format.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.dateType != null && message.hasOwnProperty("dateType"))
                        switch (message.dateType) {
                        default:
                            return "dateType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.timeFormat != null && message.hasOwnProperty("timeFormat"))
                        switch (message.timeFormat) {
                        default:
                            return "timeFormat: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.militaryTimeEnabled != null && message.hasOwnProperty("militaryTimeEnabled"))
                        if (typeof message.militaryTimeEnabled !== "boolean")
                            return "militaryTimeEnabled: boolean expected";
                    return null;
                };

                /**
                 * Creates a Format message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Clock.Format
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Clock.Format} Format
                 */
                Format.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Clock.Format)
                        return object;
                    let message = new $root.rv.data.Clock.Format();
                    switch (object.dateType) {
                    default:
                        if (typeof object.dateType === "number") {
                            message.dateType = object.dateType;
                            break;
                        }
                        break;
                    case "DATE_FORMATTER_STYLE_NONE":
                    case 0:
                        message.dateType = 0;
                        break;
                    case "DATE_FORMATTER_STYLE_SHORT":
                    case 1:
                        message.dateType = 1;
                        break;
                    case "DATE_FORMATTER_STYLE_MEDIUM":
                    case 2:
                        message.dateType = 2;
                        break;
                    case "DATE_FORMATTER_STYLE_LONG":
                    case 3:
                        message.dateType = 3;
                        break;
                    case "DATE_FORMATTER_STYLE_FULL":
                    case 4:
                        message.dateType = 4;
                        break;
                    }
                    switch (object.timeFormat) {
                    default:
                        if (typeof object.timeFormat === "number") {
                            message.timeFormat = object.timeFormat;
                            break;
                        }
                        break;
                    case "DATE_FORMATTER_STYLE_NONE":
                    case 0:
                        message.timeFormat = 0;
                        break;
                    case "DATE_FORMATTER_STYLE_SHORT":
                    case 1:
                        message.timeFormat = 1;
                        break;
                    case "DATE_FORMATTER_STYLE_MEDIUM":
                    case 2:
                        message.timeFormat = 2;
                        break;
                    case "DATE_FORMATTER_STYLE_LONG":
                    case 3:
                        message.timeFormat = 3;
                        break;
                    case "DATE_FORMATTER_STYLE_FULL":
                    case 4:
                        message.timeFormat = 4;
                        break;
                    }
                    if (object.militaryTimeEnabled != null)
                        message.militaryTimeEnabled = Boolean(object.militaryTimeEnabled);
                    return message;
                };

                /**
                 * Creates a plain object from a Format message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Clock.Format
                 * @static
                 * @param {rv.data.Clock.Format} message Format
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Format.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.dateType = options.enums === String ? "DATE_FORMATTER_STYLE_NONE" : 0;
                        object.timeFormat = options.enums === String ? "DATE_FORMATTER_STYLE_NONE" : 0;
                        object.militaryTimeEnabled = false;
                    }
                    if (message.dateType != null && message.hasOwnProperty("dateType"))
                        object.dateType = options.enums === String ? $root.rv.data.Clock.Format.DateFormatterStyle[message.dateType] === undefined ? message.dateType : $root.rv.data.Clock.Format.DateFormatterStyle[message.dateType] : message.dateType;
                    if (message.timeFormat != null && message.hasOwnProperty("timeFormat"))
                        object.timeFormat = options.enums === String ? $root.rv.data.Clock.Format.DateFormatterStyle[message.timeFormat] === undefined ? message.timeFormat : $root.rv.data.Clock.Format.DateFormatterStyle[message.timeFormat] : message.timeFormat;
                    if (message.militaryTimeEnabled != null && message.hasOwnProperty("militaryTimeEnabled"))
                        object.militaryTimeEnabled = message.militaryTimeEnabled;
                    return object;
                };

                /**
                 * Converts this Format to JSON.
                 * @function toJSON
                 * @memberof rv.data.Clock.Format
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Format.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Format
                 * @function getTypeUrl
                 * @memberof rv.data.Clock.Format
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Format.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Clock.Format";
                };

                /**
                 * DateFormatterStyle enum.
                 * @name rv.data.Clock.Format.DateFormatterStyle
                 * @enum {number}
                 * @property {number} DATE_FORMATTER_STYLE_NONE=0 DATE_FORMATTER_STYLE_NONE value
                 * @property {number} DATE_FORMATTER_STYLE_SHORT=1 DATE_FORMATTER_STYLE_SHORT value
                 * @property {number} DATE_FORMATTER_STYLE_MEDIUM=2 DATE_FORMATTER_STYLE_MEDIUM value
                 * @property {number} DATE_FORMATTER_STYLE_LONG=3 DATE_FORMATTER_STYLE_LONG value
                 * @property {number} DATE_FORMATTER_STYLE_FULL=4 DATE_FORMATTER_STYLE_FULL value
                 */
                Format.DateFormatterStyle = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "DATE_FORMATTER_STYLE_NONE"] = 0;
                    values[valuesById[1] = "DATE_FORMATTER_STYLE_SHORT"] = 1;
                    values[valuesById[2] = "DATE_FORMATTER_STYLE_MEDIUM"] = 2;
                    values[valuesById[3] = "DATE_FORMATTER_STYLE_LONG"] = 3;
                    values[valuesById[4] = "DATE_FORMATTER_STYLE_FULL"] = 4;
                    return values;
                })();

                return Format;
            })();

            return Clock;
        })();

        data.Timer = (function() {

            /**
             * Properties of a Timer.
             * @memberof rv.data
             * @interface ITimer
             * @property {rv.data.IUUID|null} [uuid] Timer uuid
             * @property {string|null} [name] Timer name
             * @property {rv.data.Timer.IConfiguration|null} [configuration] Timer configuration
             */

            /**
             * Constructs a new Timer.
             * @memberof rv.data
             * @classdesc Represents a Timer.
             * @implements ITimer
             * @constructor
             * @param {rv.data.ITimer=} [properties] Properties to set
             */
            function Timer(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timer uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.Timer
             * @instance
             */
            Timer.prototype.uuid = null;

            /**
             * Timer name.
             * @member {string} name
             * @memberof rv.data.Timer
             * @instance
             */
            Timer.prototype.name = "";

            /**
             * Timer configuration.
             * @member {rv.data.Timer.IConfiguration|null|undefined} configuration
             * @memberof rv.data.Timer
             * @instance
             */
            Timer.prototype.configuration = null;

            /**
             * Creates a new Timer instance using the specified properties.
             * @function create
             * @memberof rv.data.Timer
             * @static
             * @param {rv.data.ITimer=} [properties] Properties to set
             * @returns {rv.data.Timer} Timer instance
             */
            Timer.create = function create(properties) {
                return new Timer(properties);
            };

            /**
             * Encodes the specified Timer message. Does not implicitly {@link rv.data.Timer.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Timer
             * @static
             * @param {rv.data.ITimer} message Timer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.configuration != null && Object.hasOwnProperty.call(message, "configuration"))
                    $root.rv.data.Timer.Configuration.encode(message.configuration, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Timer message, length delimited. Does not implicitly {@link rv.data.Timer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Timer
             * @static
             * @param {rv.data.ITimer} message Timer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Timer message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Timer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Timer} Timer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Timer();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 10: {
                            message.configuration = $root.rv.data.Timer.Configuration.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Timer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Timer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Timer} Timer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Timer message.
             * @function verify
             * @memberof rv.data.Timer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.configuration != null && message.hasOwnProperty("configuration")) {
                    let error = $root.rv.data.Timer.Configuration.verify(message.configuration);
                    if (error)
                        return "configuration." + error;
                }
                return null;
            };

            /**
             * Creates a Timer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Timer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Timer} Timer
             */
            Timer.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Timer)
                    return object;
                let message = new $root.rv.data.Timer();
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.Timer.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                if (object.name != null)
                    message.name = String(object.name);
                if (object.configuration != null) {
                    if (typeof object.configuration !== "object")
                        throw TypeError(".rv.data.Timer.configuration: object expected");
                    message.configuration = $root.rv.data.Timer.Configuration.fromObject(object.configuration);
                }
                return message;
            };

            /**
             * Creates a plain object from a Timer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Timer
             * @static
             * @param {rv.data.Timer} message Timer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uuid = null;
                    object.name = "";
                    object.configuration = null;
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.configuration != null && message.hasOwnProperty("configuration"))
                    object.configuration = $root.rv.data.Timer.Configuration.toObject(message.configuration, options);
                return object;
            };

            /**
             * Converts this Timer to JSON.
             * @function toJSON
             * @memberof rv.data.Timer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Timer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Timer
             * @function getTypeUrl
             * @memberof rv.data.Timer
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Timer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Timer";
            };

            Timer.Format = (function() {

                /**
                 * Properties of a Format.
                 * @memberof rv.data.Timer
                 * @interface IFormat
                 * @property {rv.data.Timer.Format.Style|null} [hour] Format hour
                 * @property {rv.data.Timer.Format.Style|null} [minute] Format minute
                 * @property {rv.data.Timer.Format.Style|null} [second] Format second
                 * @property {rv.data.Timer.Format.Style|null} [millisecond] Format millisecond
                 * @property {boolean|null} [isWallClockTime] Format isWallClockTime
                 * @property {boolean|null} [is_24HourTime] Format is_24HourTime
                 * @property {boolean|null} [showMillisecondsUnderMinuteOnly] Format showMillisecondsUnderMinuteOnly
                 */

                /**
                 * Constructs a new Format.
                 * @memberof rv.data.Timer
                 * @classdesc Represents a Format.
                 * @implements IFormat
                 * @constructor
                 * @param {rv.data.Timer.IFormat=} [properties] Properties to set
                 */
                function Format(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Format hour.
                 * @member {rv.data.Timer.Format.Style} hour
                 * @memberof rv.data.Timer.Format
                 * @instance
                 */
                Format.prototype.hour = 0;

                /**
                 * Format minute.
                 * @member {rv.data.Timer.Format.Style} minute
                 * @memberof rv.data.Timer.Format
                 * @instance
                 */
                Format.prototype.minute = 0;

                /**
                 * Format second.
                 * @member {rv.data.Timer.Format.Style} second
                 * @memberof rv.data.Timer.Format
                 * @instance
                 */
                Format.prototype.second = 0;

                /**
                 * Format millisecond.
                 * @member {rv.data.Timer.Format.Style} millisecond
                 * @memberof rv.data.Timer.Format
                 * @instance
                 */
                Format.prototype.millisecond = 0;

                /**
                 * Format isWallClockTime.
                 * @member {boolean} isWallClockTime
                 * @memberof rv.data.Timer.Format
                 * @instance
                 */
                Format.prototype.isWallClockTime = false;

                /**
                 * Format is_24HourTime.
                 * @member {boolean} is_24HourTime
                 * @memberof rv.data.Timer.Format
                 * @instance
                 */
                Format.prototype.is_24HourTime = false;

                /**
                 * Format showMillisecondsUnderMinuteOnly.
                 * @member {boolean} showMillisecondsUnderMinuteOnly
                 * @memberof rv.data.Timer.Format
                 * @instance
                 */
                Format.prototype.showMillisecondsUnderMinuteOnly = false;

                /**
                 * Creates a new Format instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Timer.Format
                 * @static
                 * @param {rv.data.Timer.IFormat=} [properties] Properties to set
                 * @returns {rv.data.Timer.Format} Format instance
                 */
                Format.create = function create(properties) {
                    return new Format(properties);
                };

                /**
                 * Encodes the specified Format message. Does not implicitly {@link rv.data.Timer.Format.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Timer.Format
                 * @static
                 * @param {rv.data.Timer.IFormat} message Format message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Format.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.hour != null && Object.hasOwnProperty.call(message, "hour"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hour);
                    if (message.minute != null && Object.hasOwnProperty.call(message, "minute"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.minute);
                    if (message.second != null && Object.hasOwnProperty.call(message, "second"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.second);
                    if (message.millisecond != null && Object.hasOwnProperty.call(message, "millisecond"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.millisecond);
                    if (message.isWallClockTime != null && Object.hasOwnProperty.call(message, "isWallClockTime"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isWallClockTime);
                    if (message.is_24HourTime != null && Object.hasOwnProperty.call(message, "is_24HourTime"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.is_24HourTime);
                    if (message.showMillisecondsUnderMinuteOnly != null && Object.hasOwnProperty.call(message, "showMillisecondsUnderMinuteOnly"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.showMillisecondsUnderMinuteOnly);
                    return writer;
                };

                /**
                 * Encodes the specified Format message, length delimited. Does not implicitly {@link rv.data.Timer.Format.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Timer.Format
                 * @static
                 * @param {rv.data.Timer.IFormat} message Format message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Format.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Format message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Timer.Format
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Timer.Format} Format
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Format.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Timer.Format();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.hour = reader.int32();
                                break;
                            }
                        case 2: {
                                message.minute = reader.int32();
                                break;
                            }
                        case 3: {
                                message.second = reader.int32();
                                break;
                            }
                        case 4: {
                                message.millisecond = reader.int32();
                                break;
                            }
                        case 5: {
                                message.isWallClockTime = reader.bool();
                                break;
                            }
                        case 6: {
                                message.is_24HourTime = reader.bool();
                                break;
                            }
                        case 7: {
                                message.showMillisecondsUnderMinuteOnly = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Format message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Timer.Format
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Timer.Format} Format
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Format.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Format message.
                 * @function verify
                 * @memberof rv.data.Timer.Format
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Format.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.hour != null && message.hasOwnProperty("hour"))
                        switch (message.hour) {
                        default:
                            return "hour: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.minute != null && message.hasOwnProperty("minute"))
                        switch (message.minute) {
                        default:
                            return "minute: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.second != null && message.hasOwnProperty("second"))
                        switch (message.second) {
                        default:
                            return "second: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.millisecond != null && message.hasOwnProperty("millisecond"))
                        switch (message.millisecond) {
                        default:
                            return "millisecond: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.isWallClockTime != null && message.hasOwnProperty("isWallClockTime"))
                        if (typeof message.isWallClockTime !== "boolean")
                            return "isWallClockTime: boolean expected";
                    if (message.is_24HourTime != null && message.hasOwnProperty("is_24HourTime"))
                        if (typeof message.is_24HourTime !== "boolean")
                            return "is_24HourTime: boolean expected";
                    if (message.showMillisecondsUnderMinuteOnly != null && message.hasOwnProperty("showMillisecondsUnderMinuteOnly"))
                        if (typeof message.showMillisecondsUnderMinuteOnly !== "boolean")
                            return "showMillisecondsUnderMinuteOnly: boolean expected";
                    return null;
                };

                /**
                 * Creates a Format message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Timer.Format
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Timer.Format} Format
                 */
                Format.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Timer.Format)
                        return object;
                    let message = new $root.rv.data.Timer.Format();
                    switch (object.hour) {
                    default:
                        if (typeof object.hour === "number") {
                            message.hour = object.hour;
                            break;
                        }
                        break;
                    case "STYE_NONE":
                    case 0:
                        message.hour = 0;
                        break;
                    case "STYLE_SHORT":
                    case 1:
                        message.hour = 1;
                        break;
                    case "STYLE_LONG":
                    case 2:
                        message.hour = 2;
                        break;
                    case "STYLE_REMOVE_SHORT":
                    case 3:
                        message.hour = 3;
                        break;
                    case "STYLE_REMOVE_LONG":
                    case 4:
                        message.hour = 4;
                        break;
                    }
                    switch (object.minute) {
                    default:
                        if (typeof object.minute === "number") {
                            message.minute = object.minute;
                            break;
                        }
                        break;
                    case "STYE_NONE":
                    case 0:
                        message.minute = 0;
                        break;
                    case "STYLE_SHORT":
                    case 1:
                        message.minute = 1;
                        break;
                    case "STYLE_LONG":
                    case 2:
                        message.minute = 2;
                        break;
                    case "STYLE_REMOVE_SHORT":
                    case 3:
                        message.minute = 3;
                        break;
                    case "STYLE_REMOVE_LONG":
                    case 4:
                        message.minute = 4;
                        break;
                    }
                    switch (object.second) {
                    default:
                        if (typeof object.second === "number") {
                            message.second = object.second;
                            break;
                        }
                        break;
                    case "STYE_NONE":
                    case 0:
                        message.second = 0;
                        break;
                    case "STYLE_SHORT":
                    case 1:
                        message.second = 1;
                        break;
                    case "STYLE_LONG":
                    case 2:
                        message.second = 2;
                        break;
                    case "STYLE_REMOVE_SHORT":
                    case 3:
                        message.second = 3;
                        break;
                    case "STYLE_REMOVE_LONG":
                    case 4:
                        message.second = 4;
                        break;
                    }
                    switch (object.millisecond) {
                    default:
                        if (typeof object.millisecond === "number") {
                            message.millisecond = object.millisecond;
                            break;
                        }
                        break;
                    case "STYE_NONE":
                    case 0:
                        message.millisecond = 0;
                        break;
                    case "STYLE_SHORT":
                    case 1:
                        message.millisecond = 1;
                        break;
                    case "STYLE_LONG":
                    case 2:
                        message.millisecond = 2;
                        break;
                    case "STYLE_REMOVE_SHORT":
                    case 3:
                        message.millisecond = 3;
                        break;
                    case "STYLE_REMOVE_LONG":
                    case 4:
                        message.millisecond = 4;
                        break;
                    }
                    if (object.isWallClockTime != null)
                        message.isWallClockTime = Boolean(object.isWallClockTime);
                    if (object.is_24HourTime != null)
                        message.is_24HourTime = Boolean(object.is_24HourTime);
                    if (object.showMillisecondsUnderMinuteOnly != null)
                        message.showMillisecondsUnderMinuteOnly = Boolean(object.showMillisecondsUnderMinuteOnly);
                    return message;
                };

                /**
                 * Creates a plain object from a Format message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Timer.Format
                 * @static
                 * @param {rv.data.Timer.Format} message Format
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Format.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.hour = options.enums === String ? "STYE_NONE" : 0;
                        object.minute = options.enums === String ? "STYE_NONE" : 0;
                        object.second = options.enums === String ? "STYE_NONE" : 0;
                        object.millisecond = options.enums === String ? "STYE_NONE" : 0;
                        object.isWallClockTime = false;
                        object.is_24HourTime = false;
                        object.showMillisecondsUnderMinuteOnly = false;
                    }
                    if (message.hour != null && message.hasOwnProperty("hour"))
                        object.hour = options.enums === String ? $root.rv.data.Timer.Format.Style[message.hour] === undefined ? message.hour : $root.rv.data.Timer.Format.Style[message.hour] : message.hour;
                    if (message.minute != null && message.hasOwnProperty("minute"))
                        object.minute = options.enums === String ? $root.rv.data.Timer.Format.Style[message.minute] === undefined ? message.minute : $root.rv.data.Timer.Format.Style[message.minute] : message.minute;
                    if (message.second != null && message.hasOwnProperty("second"))
                        object.second = options.enums === String ? $root.rv.data.Timer.Format.Style[message.second] === undefined ? message.second : $root.rv.data.Timer.Format.Style[message.second] : message.second;
                    if (message.millisecond != null && message.hasOwnProperty("millisecond"))
                        object.millisecond = options.enums === String ? $root.rv.data.Timer.Format.Style[message.millisecond] === undefined ? message.millisecond : $root.rv.data.Timer.Format.Style[message.millisecond] : message.millisecond;
                    if (message.isWallClockTime != null && message.hasOwnProperty("isWallClockTime"))
                        object.isWallClockTime = message.isWallClockTime;
                    if (message.is_24HourTime != null && message.hasOwnProperty("is_24HourTime"))
                        object.is_24HourTime = message.is_24HourTime;
                    if (message.showMillisecondsUnderMinuteOnly != null && message.hasOwnProperty("showMillisecondsUnderMinuteOnly"))
                        object.showMillisecondsUnderMinuteOnly = message.showMillisecondsUnderMinuteOnly;
                    return object;
                };

                /**
                 * Converts this Format to JSON.
                 * @function toJSON
                 * @memberof rv.data.Timer.Format
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Format.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Format
                 * @function getTypeUrl
                 * @memberof rv.data.Timer.Format
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Format.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Timer.Format";
                };

                /**
                 * Style enum.
                 * @name rv.data.Timer.Format.Style
                 * @enum {number}
                 * @property {number} STYE_NONE=0 STYE_NONE value
                 * @property {number} STYLE_SHORT=1 STYLE_SHORT value
                 * @property {number} STYLE_LONG=2 STYLE_LONG value
                 * @property {number} STYLE_REMOVE_SHORT=3 STYLE_REMOVE_SHORT value
                 * @property {number} STYLE_REMOVE_LONG=4 STYLE_REMOVE_LONG value
                 */
                Format.Style = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STYE_NONE"] = 0;
                    values[valuesById[1] = "STYLE_SHORT"] = 1;
                    values[valuesById[2] = "STYLE_LONG"] = 2;
                    values[valuesById[3] = "STYLE_REMOVE_SHORT"] = 3;
                    values[valuesById[4] = "STYLE_REMOVE_LONG"] = 4;
                    return values;
                })();

                return Format;
            })();

            Timer.Configuration = (function() {

                /**
                 * Properties of a Configuration.
                 * @memberof rv.data.Timer
                 * @interface IConfiguration
                 * @property {boolean|null} [allowsOverrun] Configuration allowsOverrun
                 * @property {rv.data.Timer.Configuration.ITimerTypeCountdown|null} [countdown] Configuration countdown
                 * @property {rv.data.Timer.Configuration.ITimerTypeCountdownToTime|null} [countdownToTime] Configuration countdownToTime
                 * @property {rv.data.Timer.Configuration.ITimerTypeElapsedTime|null} [elapsedTime] Configuration elapsedTime
                 */

                /**
                 * Constructs a new Configuration.
                 * @memberof rv.data.Timer
                 * @classdesc Represents a Configuration.
                 * @implements IConfiguration
                 * @constructor
                 * @param {rv.data.Timer.IConfiguration=} [properties] Properties to set
                 */
                function Configuration(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Configuration allowsOverrun.
                 * @member {boolean} allowsOverrun
                 * @memberof rv.data.Timer.Configuration
                 * @instance
                 */
                Configuration.prototype.allowsOverrun = false;

                /**
                 * Configuration countdown.
                 * @member {rv.data.Timer.Configuration.ITimerTypeCountdown|null|undefined} countdown
                 * @memberof rv.data.Timer.Configuration
                 * @instance
                 */
                Configuration.prototype.countdown = null;

                /**
                 * Configuration countdownToTime.
                 * @member {rv.data.Timer.Configuration.ITimerTypeCountdownToTime|null|undefined} countdownToTime
                 * @memberof rv.data.Timer.Configuration
                 * @instance
                 */
                Configuration.prototype.countdownToTime = null;

                /**
                 * Configuration elapsedTime.
                 * @member {rv.data.Timer.Configuration.ITimerTypeElapsedTime|null|undefined} elapsedTime
                 * @memberof rv.data.Timer.Configuration
                 * @instance
                 */
                Configuration.prototype.elapsedTime = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Configuration TimerType.
                 * @member {"countdown"|"countdownToTime"|"elapsedTime"|undefined} TimerType
                 * @memberof rv.data.Timer.Configuration
                 * @instance
                 */
                Object.defineProperty(Configuration.prototype, "TimerType", {
                    get: $util.oneOfGetter($oneOfFields = ["countdown", "countdownToTime", "elapsedTime"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Configuration instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Timer.Configuration
                 * @static
                 * @param {rv.data.Timer.IConfiguration=} [properties] Properties to set
                 * @returns {rv.data.Timer.Configuration} Configuration instance
                 */
                Configuration.create = function create(properties) {
                    return new Configuration(properties);
                };

                /**
                 * Encodes the specified Configuration message. Does not implicitly {@link rv.data.Timer.Configuration.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Timer.Configuration
                 * @static
                 * @param {rv.data.Timer.IConfiguration} message Configuration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Configuration.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.countdown != null && Object.hasOwnProperty.call(message, "countdown"))
                        $root.rv.data.Timer.Configuration.TimerTypeCountdown.encode(message.countdown, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.countdownToTime != null && Object.hasOwnProperty.call(message, "countdownToTime"))
                        $root.rv.data.Timer.Configuration.TimerTypeCountdownToTime.encode(message.countdownToTime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.elapsedTime != null && Object.hasOwnProperty.call(message, "elapsedTime"))
                        $root.rv.data.Timer.Configuration.TimerTypeElapsedTime.encode(message.elapsedTime, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.allowsOverrun != null && Object.hasOwnProperty.call(message, "allowsOverrun"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.allowsOverrun);
                    return writer;
                };

                /**
                 * Encodes the specified Configuration message, length delimited. Does not implicitly {@link rv.data.Timer.Configuration.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Timer.Configuration
                 * @static
                 * @param {rv.data.Timer.IConfiguration} message Configuration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Configuration.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Configuration message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Timer.Configuration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Timer.Configuration} Configuration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Configuration.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Timer.Configuration();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 4: {
                                message.allowsOverrun = reader.bool();
                                break;
                            }
                        case 1: {
                                message.countdown = $root.rv.data.Timer.Configuration.TimerTypeCountdown.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.countdownToTime = $root.rv.data.Timer.Configuration.TimerTypeCountdownToTime.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.elapsedTime = $root.rv.data.Timer.Configuration.TimerTypeElapsedTime.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Configuration message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Timer.Configuration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Timer.Configuration} Configuration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Configuration.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Configuration message.
                 * @function verify
                 * @memberof rv.data.Timer.Configuration
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Configuration.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.allowsOverrun != null && message.hasOwnProperty("allowsOverrun"))
                        if (typeof message.allowsOverrun !== "boolean")
                            return "allowsOverrun: boolean expected";
                    if (message.countdown != null && message.hasOwnProperty("countdown")) {
                        properties.TimerType = 1;
                        {
                            let error = $root.rv.data.Timer.Configuration.TimerTypeCountdown.verify(message.countdown);
                            if (error)
                                return "countdown." + error;
                        }
                    }
                    if (message.countdownToTime != null && message.hasOwnProperty("countdownToTime")) {
                        if (properties.TimerType === 1)
                            return "TimerType: multiple values";
                        properties.TimerType = 1;
                        {
                            let error = $root.rv.data.Timer.Configuration.TimerTypeCountdownToTime.verify(message.countdownToTime);
                            if (error)
                                return "countdownToTime." + error;
                        }
                    }
                    if (message.elapsedTime != null && message.hasOwnProperty("elapsedTime")) {
                        if (properties.TimerType === 1)
                            return "TimerType: multiple values";
                        properties.TimerType = 1;
                        {
                            let error = $root.rv.data.Timer.Configuration.TimerTypeElapsedTime.verify(message.elapsedTime);
                            if (error)
                                return "elapsedTime." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Configuration message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Timer.Configuration
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Timer.Configuration} Configuration
                 */
                Configuration.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Timer.Configuration)
                        return object;
                    let message = new $root.rv.data.Timer.Configuration();
                    if (object.allowsOverrun != null)
                        message.allowsOverrun = Boolean(object.allowsOverrun);
                    if (object.countdown != null) {
                        if (typeof object.countdown !== "object")
                            throw TypeError(".rv.data.Timer.Configuration.countdown: object expected");
                        message.countdown = $root.rv.data.Timer.Configuration.TimerTypeCountdown.fromObject(object.countdown);
                    }
                    if (object.countdownToTime != null) {
                        if (typeof object.countdownToTime !== "object")
                            throw TypeError(".rv.data.Timer.Configuration.countdownToTime: object expected");
                        message.countdownToTime = $root.rv.data.Timer.Configuration.TimerTypeCountdownToTime.fromObject(object.countdownToTime);
                    }
                    if (object.elapsedTime != null) {
                        if (typeof object.elapsedTime !== "object")
                            throw TypeError(".rv.data.Timer.Configuration.elapsedTime: object expected");
                        message.elapsedTime = $root.rv.data.Timer.Configuration.TimerTypeElapsedTime.fromObject(object.elapsedTime);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Configuration message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Timer.Configuration
                 * @static
                 * @param {rv.data.Timer.Configuration} message Configuration
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Configuration.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.allowsOverrun = false;
                    if (message.countdown != null && message.hasOwnProperty("countdown")) {
                        object.countdown = $root.rv.data.Timer.Configuration.TimerTypeCountdown.toObject(message.countdown, options);
                        if (options.oneofs)
                            object.TimerType = "countdown";
                    }
                    if (message.countdownToTime != null && message.hasOwnProperty("countdownToTime")) {
                        object.countdownToTime = $root.rv.data.Timer.Configuration.TimerTypeCountdownToTime.toObject(message.countdownToTime, options);
                        if (options.oneofs)
                            object.TimerType = "countdownToTime";
                    }
                    if (message.elapsedTime != null && message.hasOwnProperty("elapsedTime")) {
                        object.elapsedTime = $root.rv.data.Timer.Configuration.TimerTypeElapsedTime.toObject(message.elapsedTime, options);
                        if (options.oneofs)
                            object.TimerType = "elapsedTime";
                    }
                    if (message.allowsOverrun != null && message.hasOwnProperty("allowsOverrun"))
                        object.allowsOverrun = message.allowsOverrun;
                    return object;
                };

                /**
                 * Converts this Configuration to JSON.
                 * @function toJSON
                 * @memberof rv.data.Timer.Configuration
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Configuration.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Configuration
                 * @function getTypeUrl
                 * @memberof rv.data.Timer.Configuration
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Configuration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Timer.Configuration";
                };

                Configuration.TimerTypeCountdown = (function() {

                    /**
                     * Properties of a TimerTypeCountdown.
                     * @memberof rv.data.Timer.Configuration
                     * @interface ITimerTypeCountdown
                     * @property {number|null} [duration] TimerTypeCountdown duration
                     */

                    /**
                     * Constructs a new TimerTypeCountdown.
                     * @memberof rv.data.Timer.Configuration
                     * @classdesc Represents a TimerTypeCountdown.
                     * @implements ITimerTypeCountdown
                     * @constructor
                     * @param {rv.data.Timer.Configuration.ITimerTypeCountdown=} [properties] Properties to set
                     */
                    function TimerTypeCountdown(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TimerTypeCountdown duration.
                     * @member {number} duration
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdown
                     * @instance
                     */
                    TimerTypeCountdown.prototype.duration = 0;

                    /**
                     * Creates a new TimerTypeCountdown instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdown
                     * @static
                     * @param {rv.data.Timer.Configuration.ITimerTypeCountdown=} [properties] Properties to set
                     * @returns {rv.data.Timer.Configuration.TimerTypeCountdown} TimerTypeCountdown instance
                     */
                    TimerTypeCountdown.create = function create(properties) {
                        return new TimerTypeCountdown(properties);
                    };

                    /**
                     * Encodes the specified TimerTypeCountdown message. Does not implicitly {@link rv.data.Timer.Configuration.TimerTypeCountdown.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdown
                     * @static
                     * @param {rv.data.Timer.Configuration.ITimerTypeCountdown} message TimerTypeCountdown message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TimerTypeCountdown.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                            writer.uint32(/* id 1, wireType 1 =*/9).double(message.duration);
                        return writer;
                    };

                    /**
                     * Encodes the specified TimerTypeCountdown message, length delimited. Does not implicitly {@link rv.data.Timer.Configuration.TimerTypeCountdown.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdown
                     * @static
                     * @param {rv.data.Timer.Configuration.ITimerTypeCountdown} message TimerTypeCountdown message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TimerTypeCountdown.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TimerTypeCountdown message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdown
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Timer.Configuration.TimerTypeCountdown} TimerTypeCountdown
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TimerTypeCountdown.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Timer.Configuration.TimerTypeCountdown();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.duration = reader.double();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TimerTypeCountdown message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdown
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Timer.Configuration.TimerTypeCountdown} TimerTypeCountdown
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TimerTypeCountdown.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TimerTypeCountdown message.
                     * @function verify
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdown
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TimerTypeCountdown.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.duration != null && message.hasOwnProperty("duration"))
                            if (typeof message.duration !== "number")
                                return "duration: number expected";
                        return null;
                    };

                    /**
                     * Creates a TimerTypeCountdown message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdown
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Timer.Configuration.TimerTypeCountdown} TimerTypeCountdown
                     */
                    TimerTypeCountdown.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Timer.Configuration.TimerTypeCountdown)
                            return object;
                        let message = new $root.rv.data.Timer.Configuration.TimerTypeCountdown();
                        if (object.duration != null)
                            message.duration = Number(object.duration);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TimerTypeCountdown message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdown
                     * @static
                     * @param {rv.data.Timer.Configuration.TimerTypeCountdown} message TimerTypeCountdown
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TimerTypeCountdown.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.duration = 0;
                        if (message.duration != null && message.hasOwnProperty("duration"))
                            object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
                        return object;
                    };

                    /**
                     * Converts this TimerTypeCountdown to JSON.
                     * @function toJSON
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdown
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TimerTypeCountdown.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for TimerTypeCountdown
                     * @function getTypeUrl
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdown
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    TimerTypeCountdown.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Timer.Configuration.TimerTypeCountdown";
                    };

                    return TimerTypeCountdown;
                })();

                Configuration.TimerTypeCountdownToTime = (function() {

                    /**
                     * Properties of a TimerTypeCountdownToTime.
                     * @memberof rv.data.Timer.Configuration
                     * @interface ITimerTypeCountdownToTime
                     * @property {number|null} [timeOfDay] TimerTypeCountdownToTime timeOfDay
                     * @property {rv.data.Timer.Configuration.TimerTypeCountdownToTime.TimePeriod|null} [period] TimerTypeCountdownToTime period
                     */

                    /**
                     * Constructs a new TimerTypeCountdownToTime.
                     * @memberof rv.data.Timer.Configuration
                     * @classdesc Represents a TimerTypeCountdownToTime.
                     * @implements ITimerTypeCountdownToTime
                     * @constructor
                     * @param {rv.data.Timer.Configuration.ITimerTypeCountdownToTime=} [properties] Properties to set
                     */
                    function TimerTypeCountdownToTime(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TimerTypeCountdownToTime timeOfDay.
                     * @member {number} timeOfDay
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdownToTime
                     * @instance
                     */
                    TimerTypeCountdownToTime.prototype.timeOfDay = 0;

                    /**
                     * TimerTypeCountdownToTime period.
                     * @member {rv.data.Timer.Configuration.TimerTypeCountdownToTime.TimePeriod} period
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdownToTime
                     * @instance
                     */
                    TimerTypeCountdownToTime.prototype.period = 0;

                    /**
                     * Creates a new TimerTypeCountdownToTime instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdownToTime
                     * @static
                     * @param {rv.data.Timer.Configuration.ITimerTypeCountdownToTime=} [properties] Properties to set
                     * @returns {rv.data.Timer.Configuration.TimerTypeCountdownToTime} TimerTypeCountdownToTime instance
                     */
                    TimerTypeCountdownToTime.create = function create(properties) {
                        return new TimerTypeCountdownToTime(properties);
                    };

                    /**
                     * Encodes the specified TimerTypeCountdownToTime message. Does not implicitly {@link rv.data.Timer.Configuration.TimerTypeCountdownToTime.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdownToTime
                     * @static
                     * @param {rv.data.Timer.Configuration.ITimerTypeCountdownToTime} message TimerTypeCountdownToTime message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TimerTypeCountdownToTime.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.timeOfDay != null && Object.hasOwnProperty.call(message, "timeOfDay"))
                            writer.uint32(/* id 1, wireType 1 =*/9).double(message.timeOfDay);
                        if (message.period != null && Object.hasOwnProperty.call(message, "period"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.period);
                        return writer;
                    };

                    /**
                     * Encodes the specified TimerTypeCountdownToTime message, length delimited. Does not implicitly {@link rv.data.Timer.Configuration.TimerTypeCountdownToTime.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdownToTime
                     * @static
                     * @param {rv.data.Timer.Configuration.ITimerTypeCountdownToTime} message TimerTypeCountdownToTime message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TimerTypeCountdownToTime.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TimerTypeCountdownToTime message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdownToTime
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Timer.Configuration.TimerTypeCountdownToTime} TimerTypeCountdownToTime
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TimerTypeCountdownToTime.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Timer.Configuration.TimerTypeCountdownToTime();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.timeOfDay = reader.double();
                                    break;
                                }
                            case 2: {
                                    message.period = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TimerTypeCountdownToTime message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdownToTime
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Timer.Configuration.TimerTypeCountdownToTime} TimerTypeCountdownToTime
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TimerTypeCountdownToTime.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TimerTypeCountdownToTime message.
                     * @function verify
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdownToTime
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TimerTypeCountdownToTime.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.timeOfDay != null && message.hasOwnProperty("timeOfDay"))
                            if (typeof message.timeOfDay !== "number")
                                return "timeOfDay: number expected";
                        if (message.period != null && message.hasOwnProperty("period"))
                            switch (message.period) {
                            default:
                                return "period: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a TimerTypeCountdownToTime message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdownToTime
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Timer.Configuration.TimerTypeCountdownToTime} TimerTypeCountdownToTime
                     */
                    TimerTypeCountdownToTime.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Timer.Configuration.TimerTypeCountdownToTime)
                            return object;
                        let message = new $root.rv.data.Timer.Configuration.TimerTypeCountdownToTime();
                        if (object.timeOfDay != null)
                            message.timeOfDay = Number(object.timeOfDay);
                        switch (object.period) {
                        default:
                            if (typeof object.period === "number") {
                                message.period = object.period;
                                break;
                            }
                            break;
                        case "TIME_PERIOD_AM":
                        case 0:
                            message.period = 0;
                            break;
                        case "TIME_PERIOD_PM":
                        case 1:
                            message.period = 1;
                            break;
                        case "TIME_PERIOD_24":
                        case 2:
                            message.period = 2;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a TimerTypeCountdownToTime message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdownToTime
                     * @static
                     * @param {rv.data.Timer.Configuration.TimerTypeCountdownToTime} message TimerTypeCountdownToTime
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TimerTypeCountdownToTime.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.timeOfDay = 0;
                            object.period = options.enums === String ? "TIME_PERIOD_AM" : 0;
                        }
                        if (message.timeOfDay != null && message.hasOwnProperty("timeOfDay"))
                            object.timeOfDay = options.json && !isFinite(message.timeOfDay) ? String(message.timeOfDay) : message.timeOfDay;
                        if (message.period != null && message.hasOwnProperty("period"))
                            object.period = options.enums === String ? $root.rv.data.Timer.Configuration.TimerTypeCountdownToTime.TimePeriod[message.period] === undefined ? message.period : $root.rv.data.Timer.Configuration.TimerTypeCountdownToTime.TimePeriod[message.period] : message.period;
                        return object;
                    };

                    /**
                     * Converts this TimerTypeCountdownToTime to JSON.
                     * @function toJSON
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdownToTime
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TimerTypeCountdownToTime.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for TimerTypeCountdownToTime
                     * @function getTypeUrl
                     * @memberof rv.data.Timer.Configuration.TimerTypeCountdownToTime
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    TimerTypeCountdownToTime.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Timer.Configuration.TimerTypeCountdownToTime";
                    };

                    /**
                     * TimePeriod enum.
                     * @name rv.data.Timer.Configuration.TimerTypeCountdownToTime.TimePeriod
                     * @enum {number}
                     * @property {number} TIME_PERIOD_AM=0 TIME_PERIOD_AM value
                     * @property {number} TIME_PERIOD_PM=1 TIME_PERIOD_PM value
                     * @property {number} TIME_PERIOD_24=2 TIME_PERIOD_24 value
                     */
                    TimerTypeCountdownToTime.TimePeriod = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "TIME_PERIOD_AM"] = 0;
                        values[valuesById[1] = "TIME_PERIOD_PM"] = 1;
                        values[valuesById[2] = "TIME_PERIOD_24"] = 2;
                        return values;
                    })();

                    return TimerTypeCountdownToTime;
                })();

                Configuration.TimerTypeElapsedTime = (function() {

                    /**
                     * Properties of a TimerTypeElapsedTime.
                     * @memberof rv.data.Timer.Configuration
                     * @interface ITimerTypeElapsedTime
                     * @property {number|null} [startTime] TimerTypeElapsedTime startTime
                     * @property {number|null} [endTime] TimerTypeElapsedTime endTime
                     * @property {boolean|null} [hasEndTime] TimerTypeElapsedTime hasEndTime
                     */

                    /**
                     * Constructs a new TimerTypeElapsedTime.
                     * @memberof rv.data.Timer.Configuration
                     * @classdesc Represents a TimerTypeElapsedTime.
                     * @implements ITimerTypeElapsedTime
                     * @constructor
                     * @param {rv.data.Timer.Configuration.ITimerTypeElapsedTime=} [properties] Properties to set
                     */
                    function TimerTypeElapsedTime(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TimerTypeElapsedTime startTime.
                     * @member {number} startTime
                     * @memberof rv.data.Timer.Configuration.TimerTypeElapsedTime
                     * @instance
                     */
                    TimerTypeElapsedTime.prototype.startTime = 0;

                    /**
                     * TimerTypeElapsedTime endTime.
                     * @member {number} endTime
                     * @memberof rv.data.Timer.Configuration.TimerTypeElapsedTime
                     * @instance
                     */
                    TimerTypeElapsedTime.prototype.endTime = 0;

                    /**
                     * TimerTypeElapsedTime hasEndTime.
                     * @member {boolean} hasEndTime
                     * @memberof rv.data.Timer.Configuration.TimerTypeElapsedTime
                     * @instance
                     */
                    TimerTypeElapsedTime.prototype.hasEndTime = false;

                    /**
                     * Creates a new TimerTypeElapsedTime instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Timer.Configuration.TimerTypeElapsedTime
                     * @static
                     * @param {rv.data.Timer.Configuration.ITimerTypeElapsedTime=} [properties] Properties to set
                     * @returns {rv.data.Timer.Configuration.TimerTypeElapsedTime} TimerTypeElapsedTime instance
                     */
                    TimerTypeElapsedTime.create = function create(properties) {
                        return new TimerTypeElapsedTime(properties);
                    };

                    /**
                     * Encodes the specified TimerTypeElapsedTime message. Does not implicitly {@link rv.data.Timer.Configuration.TimerTypeElapsedTime.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Timer.Configuration.TimerTypeElapsedTime
                     * @static
                     * @param {rv.data.Timer.Configuration.ITimerTypeElapsedTime} message TimerTypeElapsedTime message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TimerTypeElapsedTime.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                            writer.uint32(/* id 1, wireType 1 =*/9).double(message.startTime);
                        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                            writer.uint32(/* id 2, wireType 1 =*/17).double(message.endTime);
                        if (message.hasEndTime != null && Object.hasOwnProperty.call(message, "hasEndTime"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.hasEndTime);
                        return writer;
                    };

                    /**
                     * Encodes the specified TimerTypeElapsedTime message, length delimited. Does not implicitly {@link rv.data.Timer.Configuration.TimerTypeElapsedTime.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Timer.Configuration.TimerTypeElapsedTime
                     * @static
                     * @param {rv.data.Timer.Configuration.ITimerTypeElapsedTime} message TimerTypeElapsedTime message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TimerTypeElapsedTime.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TimerTypeElapsedTime message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Timer.Configuration.TimerTypeElapsedTime
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Timer.Configuration.TimerTypeElapsedTime} TimerTypeElapsedTime
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TimerTypeElapsedTime.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Timer.Configuration.TimerTypeElapsedTime();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.startTime = reader.double();
                                    break;
                                }
                            case 2: {
                                    message.endTime = reader.double();
                                    break;
                                }
                            case 3: {
                                    message.hasEndTime = reader.bool();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TimerTypeElapsedTime message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Timer.Configuration.TimerTypeElapsedTime
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Timer.Configuration.TimerTypeElapsedTime} TimerTypeElapsedTime
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TimerTypeElapsedTime.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TimerTypeElapsedTime message.
                     * @function verify
                     * @memberof rv.data.Timer.Configuration.TimerTypeElapsedTime
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TimerTypeElapsedTime.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.startTime != null && message.hasOwnProperty("startTime"))
                            if (typeof message.startTime !== "number")
                                return "startTime: number expected";
                        if (message.endTime != null && message.hasOwnProperty("endTime"))
                            if (typeof message.endTime !== "number")
                                return "endTime: number expected";
                        if (message.hasEndTime != null && message.hasOwnProperty("hasEndTime"))
                            if (typeof message.hasEndTime !== "boolean")
                                return "hasEndTime: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a TimerTypeElapsedTime message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Timer.Configuration.TimerTypeElapsedTime
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Timer.Configuration.TimerTypeElapsedTime} TimerTypeElapsedTime
                     */
                    TimerTypeElapsedTime.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Timer.Configuration.TimerTypeElapsedTime)
                            return object;
                        let message = new $root.rv.data.Timer.Configuration.TimerTypeElapsedTime();
                        if (object.startTime != null)
                            message.startTime = Number(object.startTime);
                        if (object.endTime != null)
                            message.endTime = Number(object.endTime);
                        if (object.hasEndTime != null)
                            message.hasEndTime = Boolean(object.hasEndTime);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TimerTypeElapsedTime message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Timer.Configuration.TimerTypeElapsedTime
                     * @static
                     * @param {rv.data.Timer.Configuration.TimerTypeElapsedTime} message TimerTypeElapsedTime
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TimerTypeElapsedTime.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.startTime = 0;
                            object.endTime = 0;
                            object.hasEndTime = false;
                        }
                        if (message.startTime != null && message.hasOwnProperty("startTime"))
                            object.startTime = options.json && !isFinite(message.startTime) ? String(message.startTime) : message.startTime;
                        if (message.endTime != null && message.hasOwnProperty("endTime"))
                            object.endTime = options.json && !isFinite(message.endTime) ? String(message.endTime) : message.endTime;
                        if (message.hasEndTime != null && message.hasOwnProperty("hasEndTime"))
                            object.hasEndTime = message.hasEndTime;
                        return object;
                    };

                    /**
                     * Converts this TimerTypeElapsedTime to JSON.
                     * @function toJSON
                     * @memberof rv.data.Timer.Configuration.TimerTypeElapsedTime
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TimerTypeElapsedTime.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for TimerTypeElapsedTime
                     * @function getTypeUrl
                     * @memberof rv.data.Timer.Configuration.TimerTypeElapsedTime
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    TimerTypeElapsedTime.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Timer.Configuration.TimerTypeElapsedTime";
                    };

                    return TimerTypeElapsedTime;
                })();

                return Configuration;
            })();

            return Timer;
        })();

        data.TimersDocument = (function() {

            /**
             * Properties of a TimersDocument.
             * @memberof rv.data
             * @interface ITimersDocument
             * @property {rv.data.IApplicationInfo|null} [applicationInfo] TimersDocument applicationInfo
             * @property {rv.data.IClock|null} [clock] TimersDocument clock
             * @property {Array.<rv.data.ITimer>|null} [timers] TimersDocument timers
             */

            /**
             * Constructs a new TimersDocument.
             * @memberof rv.data
             * @classdesc Represents a TimersDocument.
             * @implements ITimersDocument
             * @constructor
             * @param {rv.data.ITimersDocument=} [properties] Properties to set
             */
            function TimersDocument(properties) {
                this.timers = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TimersDocument applicationInfo.
             * @member {rv.data.IApplicationInfo|null|undefined} applicationInfo
             * @memberof rv.data.TimersDocument
             * @instance
             */
            TimersDocument.prototype.applicationInfo = null;

            /**
             * TimersDocument clock.
             * @member {rv.data.IClock|null|undefined} clock
             * @memberof rv.data.TimersDocument
             * @instance
             */
            TimersDocument.prototype.clock = null;

            /**
             * TimersDocument timers.
             * @member {Array.<rv.data.ITimer>} timers
             * @memberof rv.data.TimersDocument
             * @instance
             */
            TimersDocument.prototype.timers = $util.emptyArray;

            /**
             * Creates a new TimersDocument instance using the specified properties.
             * @function create
             * @memberof rv.data.TimersDocument
             * @static
             * @param {rv.data.ITimersDocument=} [properties] Properties to set
             * @returns {rv.data.TimersDocument} TimersDocument instance
             */
            TimersDocument.create = function create(properties) {
                return new TimersDocument(properties);
            };

            /**
             * Encodes the specified TimersDocument message. Does not implicitly {@link rv.data.TimersDocument.verify|verify} messages.
             * @function encode
             * @memberof rv.data.TimersDocument
             * @static
             * @param {rv.data.ITimersDocument} message TimersDocument message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimersDocument.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.applicationInfo != null && Object.hasOwnProperty.call(message, "applicationInfo"))
                    $root.rv.data.ApplicationInfo.encode(message.applicationInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.clock != null && Object.hasOwnProperty.call(message, "clock"))
                    $root.rv.data.Clock.encode(message.clock, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.timers != null && message.timers.length)
                    for (let i = 0; i < message.timers.length; ++i)
                        $root.rv.data.Timer.encode(message.timers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TimersDocument message, length delimited. Does not implicitly {@link rv.data.TimersDocument.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.TimersDocument
             * @static
             * @param {rv.data.ITimersDocument} message TimersDocument message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimersDocument.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TimersDocument message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.TimersDocument
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.TimersDocument} TimersDocument
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimersDocument.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.TimersDocument();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.applicationInfo = $root.rv.data.ApplicationInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.clock = $root.rv.data.Clock.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            if (!(message.timers && message.timers.length))
                                message.timers = [];
                            message.timers.push($root.rv.data.Timer.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TimersDocument message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.TimersDocument
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.TimersDocument} TimersDocument
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimersDocument.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TimersDocument message.
             * @function verify
             * @memberof rv.data.TimersDocument
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TimersDocument.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.applicationInfo != null && message.hasOwnProperty("applicationInfo")) {
                    let error = $root.rv.data.ApplicationInfo.verify(message.applicationInfo);
                    if (error)
                        return "applicationInfo." + error;
                }
                if (message.clock != null && message.hasOwnProperty("clock")) {
                    let error = $root.rv.data.Clock.verify(message.clock);
                    if (error)
                        return "clock." + error;
                }
                if (message.timers != null && message.hasOwnProperty("timers")) {
                    if (!Array.isArray(message.timers))
                        return "timers: array expected";
                    for (let i = 0; i < message.timers.length; ++i) {
                        let error = $root.rv.data.Timer.verify(message.timers[i]);
                        if (error)
                            return "timers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TimersDocument message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.TimersDocument
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.TimersDocument} TimersDocument
             */
            TimersDocument.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.TimersDocument)
                    return object;
                let message = new $root.rv.data.TimersDocument();
                if (object.applicationInfo != null) {
                    if (typeof object.applicationInfo !== "object")
                        throw TypeError(".rv.data.TimersDocument.applicationInfo: object expected");
                    message.applicationInfo = $root.rv.data.ApplicationInfo.fromObject(object.applicationInfo);
                }
                if (object.clock != null) {
                    if (typeof object.clock !== "object")
                        throw TypeError(".rv.data.TimersDocument.clock: object expected");
                    message.clock = $root.rv.data.Clock.fromObject(object.clock);
                }
                if (object.timers) {
                    if (!Array.isArray(object.timers))
                        throw TypeError(".rv.data.TimersDocument.timers: array expected");
                    message.timers = [];
                    for (let i = 0; i < object.timers.length; ++i) {
                        if (typeof object.timers[i] !== "object")
                            throw TypeError(".rv.data.TimersDocument.timers: object expected");
                        message.timers[i] = $root.rv.data.Timer.fromObject(object.timers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a TimersDocument message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.TimersDocument
             * @static
             * @param {rv.data.TimersDocument} message TimersDocument
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TimersDocument.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.timers = [];
                if (options.defaults) {
                    object.applicationInfo = null;
                    object.clock = null;
                }
                if (message.applicationInfo != null && message.hasOwnProperty("applicationInfo"))
                    object.applicationInfo = $root.rv.data.ApplicationInfo.toObject(message.applicationInfo, options);
                if (message.clock != null && message.hasOwnProperty("clock"))
                    object.clock = $root.rv.data.Clock.toObject(message.clock, options);
                if (message.timers && message.timers.length) {
                    object.timers = [];
                    for (let j = 0; j < message.timers.length; ++j)
                        object.timers[j] = $root.rv.data.Timer.toObject(message.timers[j], options);
                }
                return object;
            };

            /**
             * Converts this TimersDocument to JSON.
             * @function toJSON
             * @memberof rv.data.TimersDocument
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TimersDocument.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TimersDocument
             * @function getTypeUrl
             * @memberof rv.data.TimersDocument
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TimersDocument.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.TimersDocument";
            };

            return TimersDocument;
        })();

        data.PropSlide = (function() {

            /**
             * Properties of a PropSlide.
             * @memberof rv.data
             * @interface IPropSlide
             * @property {rv.data.ISlide|null} [baseSlide] PropSlide baseSlide
             * @property {rv.data.ITransition|null} [transition] PropSlide transition
             */

            /**
             * Constructs a new PropSlide.
             * @memberof rv.data
             * @classdesc Represents a PropSlide.
             * @implements IPropSlide
             * @constructor
             * @param {rv.data.IPropSlide=} [properties] Properties to set
             */
            function PropSlide(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PropSlide baseSlide.
             * @member {rv.data.ISlide|null|undefined} baseSlide
             * @memberof rv.data.PropSlide
             * @instance
             */
            PropSlide.prototype.baseSlide = null;

            /**
             * PropSlide transition.
             * @member {rv.data.ITransition|null|undefined} transition
             * @memberof rv.data.PropSlide
             * @instance
             */
            PropSlide.prototype.transition = null;

            /**
             * Creates a new PropSlide instance using the specified properties.
             * @function create
             * @memberof rv.data.PropSlide
             * @static
             * @param {rv.data.IPropSlide=} [properties] Properties to set
             * @returns {rv.data.PropSlide} PropSlide instance
             */
            PropSlide.create = function create(properties) {
                return new PropSlide(properties);
            };

            /**
             * Encodes the specified PropSlide message. Does not implicitly {@link rv.data.PropSlide.verify|verify} messages.
             * @function encode
             * @memberof rv.data.PropSlide
             * @static
             * @param {rv.data.IPropSlide} message PropSlide message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropSlide.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.baseSlide != null && Object.hasOwnProperty.call(message, "baseSlide"))
                    $root.rv.data.Slide.encode(message.baseSlide, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.transition != null && Object.hasOwnProperty.call(message, "transition"))
                    $root.rv.data.Transition.encode(message.transition, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PropSlide message, length delimited. Does not implicitly {@link rv.data.PropSlide.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.PropSlide
             * @static
             * @param {rv.data.IPropSlide} message PropSlide message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PropSlide.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PropSlide message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.PropSlide
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.PropSlide} PropSlide
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropSlide.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.PropSlide();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.baseSlide = $root.rv.data.Slide.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.transition = $root.rv.data.Transition.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PropSlide message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.PropSlide
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.PropSlide} PropSlide
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PropSlide.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PropSlide message.
             * @function verify
             * @memberof rv.data.PropSlide
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PropSlide.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.baseSlide != null && message.hasOwnProperty("baseSlide")) {
                    let error = $root.rv.data.Slide.verify(message.baseSlide);
                    if (error)
                        return "baseSlide." + error;
                }
                if (message.transition != null && message.hasOwnProperty("transition")) {
                    let error = $root.rv.data.Transition.verify(message.transition);
                    if (error)
                        return "transition." + error;
                }
                return null;
            };

            /**
             * Creates a PropSlide message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.PropSlide
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.PropSlide} PropSlide
             */
            PropSlide.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.PropSlide)
                    return object;
                let message = new $root.rv.data.PropSlide();
                if (object.baseSlide != null) {
                    if (typeof object.baseSlide !== "object")
                        throw TypeError(".rv.data.PropSlide.baseSlide: object expected");
                    message.baseSlide = $root.rv.data.Slide.fromObject(object.baseSlide);
                }
                if (object.transition != null) {
                    if (typeof object.transition !== "object")
                        throw TypeError(".rv.data.PropSlide.transition: object expected");
                    message.transition = $root.rv.data.Transition.fromObject(object.transition);
                }
                return message;
            };

            /**
             * Creates a plain object from a PropSlide message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.PropSlide
             * @static
             * @param {rv.data.PropSlide} message PropSlide
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PropSlide.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.baseSlide = null;
                    object.transition = null;
                }
                if (message.baseSlide != null && message.hasOwnProperty("baseSlide"))
                    object.baseSlide = $root.rv.data.Slide.toObject(message.baseSlide, options);
                if (message.transition != null && message.hasOwnProperty("transition"))
                    object.transition = $root.rv.data.Transition.toObject(message.transition, options);
                return object;
            };

            /**
             * Converts this PropSlide to JSON.
             * @function toJSON
             * @memberof rv.data.PropSlide
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PropSlide.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PropSlide
             * @function getTypeUrl
             * @memberof rv.data.PropSlide
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PropSlide.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.PropSlide";
            };

            return PropSlide;
        })();

        data.Slide = (function() {

            /**
             * Properties of a Slide.
             * @memberof rv.data
             * @interface ISlide
             * @property {Array.<rv.data.Slide.IElement>|null} [elements] Slide elements
             * @property {Array.<rv.data.IUUID>|null} [elementBuildOrder] Slide elementBuildOrder
             * @property {Array.<rv.data.IAlignmentGuide>|null} [guidelines] Slide guidelines
             * @property {boolean|null} [drawsBackgroundColor] Slide drawsBackgroundColor
             * @property {rv.data.IColor|null} [backgroundColor] Slide backgroundColor
             * @property {rv.data.Graphics.ISize|null} [size] Slide size
             * @property {rv.data.IUUID|null} [uuid] Slide uuid
             */

            /**
             * Constructs a new Slide.
             * @memberof rv.data
             * @classdesc Represents a Slide.
             * @implements ISlide
             * @constructor
             * @param {rv.data.ISlide=} [properties] Properties to set
             */
            function Slide(properties) {
                this.elements = [];
                this.elementBuildOrder = [];
                this.guidelines = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Slide elements.
             * @member {Array.<rv.data.Slide.IElement>} elements
             * @memberof rv.data.Slide
             * @instance
             */
            Slide.prototype.elements = $util.emptyArray;

            /**
             * Slide elementBuildOrder.
             * @member {Array.<rv.data.IUUID>} elementBuildOrder
             * @memberof rv.data.Slide
             * @instance
             */
            Slide.prototype.elementBuildOrder = $util.emptyArray;

            /**
             * Slide guidelines.
             * @member {Array.<rv.data.IAlignmentGuide>} guidelines
             * @memberof rv.data.Slide
             * @instance
             */
            Slide.prototype.guidelines = $util.emptyArray;

            /**
             * Slide drawsBackgroundColor.
             * @member {boolean} drawsBackgroundColor
             * @memberof rv.data.Slide
             * @instance
             */
            Slide.prototype.drawsBackgroundColor = false;

            /**
             * Slide backgroundColor.
             * @member {rv.data.IColor|null|undefined} backgroundColor
             * @memberof rv.data.Slide
             * @instance
             */
            Slide.prototype.backgroundColor = null;

            /**
             * Slide size.
             * @member {rv.data.Graphics.ISize|null|undefined} size
             * @memberof rv.data.Slide
             * @instance
             */
            Slide.prototype.size = null;

            /**
             * Slide uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.Slide
             * @instance
             */
            Slide.prototype.uuid = null;

            /**
             * Creates a new Slide instance using the specified properties.
             * @function create
             * @memberof rv.data.Slide
             * @static
             * @param {rv.data.ISlide=} [properties] Properties to set
             * @returns {rv.data.Slide} Slide instance
             */
            Slide.create = function create(properties) {
                return new Slide(properties);
            };

            /**
             * Encodes the specified Slide message. Does not implicitly {@link rv.data.Slide.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Slide
             * @static
             * @param {rv.data.ISlide} message Slide message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Slide.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.elements != null && message.elements.length)
                    for (let i = 0; i < message.elements.length; ++i)
                        $root.rv.data.Slide.Element.encode(message.elements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.elementBuildOrder != null && message.elementBuildOrder.length)
                    for (let i = 0; i < message.elementBuildOrder.length; ++i)
                        $root.rv.data.UUID.encode(message.elementBuildOrder[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.guidelines != null && message.guidelines.length)
                    for (let i = 0; i < message.guidelines.length; ++i)
                        $root.rv.data.AlignmentGuide.encode(message.guidelines[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.drawsBackgroundColor != null && Object.hasOwnProperty.call(message, "drawsBackgroundColor"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.drawsBackgroundColor);
                if (message.backgroundColor != null && Object.hasOwnProperty.call(message, "backgroundColor"))
                    $root.rv.data.Color.encode(message.backgroundColor, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    $root.rv.data.Graphics.Size.encode(message.size, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Slide message, length delimited. Does not implicitly {@link rv.data.Slide.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Slide
             * @static
             * @param {rv.data.ISlide} message Slide message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Slide.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Slide message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Slide
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Slide} Slide
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Slide.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.elements && message.elements.length))
                                message.elements = [];
                            message.elements.push($root.rv.data.Slide.Element.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.elementBuildOrder && message.elementBuildOrder.length))
                                message.elementBuildOrder = [];
                            message.elementBuildOrder.push($root.rv.data.UUID.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            if (!(message.guidelines && message.guidelines.length))
                                message.guidelines = [];
                            message.guidelines.push($root.rv.data.AlignmentGuide.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            message.drawsBackgroundColor = reader.bool();
                            break;
                        }
                    case 5: {
                            message.backgroundColor = $root.rv.data.Color.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.size = $root.rv.data.Graphics.Size.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Slide message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Slide
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Slide} Slide
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Slide.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Slide message.
             * @function verify
             * @memberof rv.data.Slide
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Slide.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.elements != null && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (let i = 0; i < message.elements.length; ++i) {
                        let error = $root.rv.data.Slide.Element.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                if (message.elementBuildOrder != null && message.hasOwnProperty("elementBuildOrder")) {
                    if (!Array.isArray(message.elementBuildOrder))
                        return "elementBuildOrder: array expected";
                    for (let i = 0; i < message.elementBuildOrder.length; ++i) {
                        let error = $root.rv.data.UUID.verify(message.elementBuildOrder[i]);
                        if (error)
                            return "elementBuildOrder." + error;
                    }
                }
                if (message.guidelines != null && message.hasOwnProperty("guidelines")) {
                    if (!Array.isArray(message.guidelines))
                        return "guidelines: array expected";
                    for (let i = 0; i < message.guidelines.length; ++i) {
                        let error = $root.rv.data.AlignmentGuide.verify(message.guidelines[i]);
                        if (error)
                            return "guidelines." + error;
                    }
                }
                if (message.drawsBackgroundColor != null && message.hasOwnProperty("drawsBackgroundColor"))
                    if (typeof message.drawsBackgroundColor !== "boolean")
                        return "drawsBackgroundColor: boolean expected";
                if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor")) {
                    let error = $root.rv.data.Color.verify(message.backgroundColor);
                    if (error)
                        return "backgroundColor." + error;
                }
                if (message.size != null && message.hasOwnProperty("size")) {
                    let error = $root.rv.data.Graphics.Size.verify(message.size);
                    if (error)
                        return "size." + error;
                }
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                return null;
            };

            /**
             * Creates a Slide message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Slide
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Slide} Slide
             */
            Slide.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Slide)
                    return object;
                let message = new $root.rv.data.Slide();
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".rv.data.Slide.elements: array expected");
                    message.elements = [];
                    for (let i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".rv.data.Slide.elements: object expected");
                        message.elements[i] = $root.rv.data.Slide.Element.fromObject(object.elements[i]);
                    }
                }
                if (object.elementBuildOrder) {
                    if (!Array.isArray(object.elementBuildOrder))
                        throw TypeError(".rv.data.Slide.elementBuildOrder: array expected");
                    message.elementBuildOrder = [];
                    for (let i = 0; i < object.elementBuildOrder.length; ++i) {
                        if (typeof object.elementBuildOrder[i] !== "object")
                            throw TypeError(".rv.data.Slide.elementBuildOrder: object expected");
                        message.elementBuildOrder[i] = $root.rv.data.UUID.fromObject(object.elementBuildOrder[i]);
                    }
                }
                if (object.guidelines) {
                    if (!Array.isArray(object.guidelines))
                        throw TypeError(".rv.data.Slide.guidelines: array expected");
                    message.guidelines = [];
                    for (let i = 0; i < object.guidelines.length; ++i) {
                        if (typeof object.guidelines[i] !== "object")
                            throw TypeError(".rv.data.Slide.guidelines: object expected");
                        message.guidelines[i] = $root.rv.data.AlignmentGuide.fromObject(object.guidelines[i]);
                    }
                }
                if (object.drawsBackgroundColor != null)
                    message.drawsBackgroundColor = Boolean(object.drawsBackgroundColor);
                if (object.backgroundColor != null) {
                    if (typeof object.backgroundColor !== "object")
                        throw TypeError(".rv.data.Slide.backgroundColor: object expected");
                    message.backgroundColor = $root.rv.data.Color.fromObject(object.backgroundColor);
                }
                if (object.size != null) {
                    if (typeof object.size !== "object")
                        throw TypeError(".rv.data.Slide.size: object expected");
                    message.size = $root.rv.data.Graphics.Size.fromObject(object.size);
                }
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.Slide.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                return message;
            };

            /**
             * Creates a plain object from a Slide message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Slide
             * @static
             * @param {rv.data.Slide} message Slide
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Slide.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.elements = [];
                    object.elementBuildOrder = [];
                    object.guidelines = [];
                }
                if (options.defaults) {
                    object.drawsBackgroundColor = false;
                    object.backgroundColor = null;
                    object.size = null;
                    object.uuid = null;
                }
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (let j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.rv.data.Slide.Element.toObject(message.elements[j], options);
                }
                if (message.elementBuildOrder && message.elementBuildOrder.length) {
                    object.elementBuildOrder = [];
                    for (let j = 0; j < message.elementBuildOrder.length; ++j)
                        object.elementBuildOrder[j] = $root.rv.data.UUID.toObject(message.elementBuildOrder[j], options);
                }
                if (message.guidelines && message.guidelines.length) {
                    object.guidelines = [];
                    for (let j = 0; j < message.guidelines.length; ++j)
                        object.guidelines[j] = $root.rv.data.AlignmentGuide.toObject(message.guidelines[j], options);
                }
                if (message.drawsBackgroundColor != null && message.hasOwnProperty("drawsBackgroundColor"))
                    object.drawsBackgroundColor = message.drawsBackgroundColor;
                if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor"))
                    object.backgroundColor = $root.rv.data.Color.toObject(message.backgroundColor, options);
                if (message.size != null && message.hasOwnProperty("size"))
                    object.size = $root.rv.data.Graphics.Size.toObject(message.size, options);
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                return object;
            };

            /**
             * Converts this Slide to JSON.
             * @function toJSON
             * @memberof rv.data.Slide
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Slide.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Slide
             * @function getTypeUrl
             * @memberof rv.data.Slide
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Slide.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Slide";
            };

            Slide.Element = (function() {

                /**
                 * Properties of an Element.
                 * @memberof rv.data.Slide
                 * @interface IElement
                 * @property {rv.data.Graphics.IElement|null} [element] Element element
                 * @property {rv.data.Slide.Element.IBuild|null} [buildIn] Element buildIn
                 * @property {rv.data.Slide.Element.IBuild|null} [buildOut] Element buildOut
                 * @property {number|null} [info] Element info
                 * @property {rv.data.Slide.Element.TextRevealType|null} [revealType] Element revealType
                 * @property {Array.<rv.data.Slide.Element.IDataLink>|null} [dataLinks] Element dataLinks
                 * @property {Array.<rv.data.Slide.Element.IChildBuild>|null} [childBuilds] Element childBuilds
                 * @property {number|null} [revealFromIndex] Element revealFromIndex
                 * @property {rv.data.Slide.Element.ITextScroller|null} [textScroller] Element textScroller
                 */

                /**
                 * Constructs a new Element.
                 * @memberof rv.data.Slide
                 * @classdesc Represents an Element.
                 * @implements IElement
                 * @constructor
                 * @param {rv.data.Slide.IElement=} [properties] Properties to set
                 */
                function Element(properties) {
                    this.dataLinks = [];
                    this.childBuilds = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Element element.
                 * @member {rv.data.Graphics.IElement|null|undefined} element
                 * @memberof rv.data.Slide.Element
                 * @instance
                 */
                Element.prototype.element = null;

                /**
                 * Element buildIn.
                 * @member {rv.data.Slide.Element.IBuild|null|undefined} buildIn
                 * @memberof rv.data.Slide.Element
                 * @instance
                 */
                Element.prototype.buildIn = null;

                /**
                 * Element buildOut.
                 * @member {rv.data.Slide.Element.IBuild|null|undefined} buildOut
                 * @memberof rv.data.Slide.Element
                 * @instance
                 */
                Element.prototype.buildOut = null;

                /**
                 * Element info.
                 * @member {number} info
                 * @memberof rv.data.Slide.Element
                 * @instance
                 */
                Element.prototype.info = 0;

                /**
                 * Element revealType.
                 * @member {rv.data.Slide.Element.TextRevealType} revealType
                 * @memberof rv.data.Slide.Element
                 * @instance
                 */
                Element.prototype.revealType = 0;

                /**
                 * Element dataLinks.
                 * @member {Array.<rv.data.Slide.Element.IDataLink>} dataLinks
                 * @memberof rv.data.Slide.Element
                 * @instance
                 */
                Element.prototype.dataLinks = $util.emptyArray;

                /**
                 * Element childBuilds.
                 * @member {Array.<rv.data.Slide.Element.IChildBuild>} childBuilds
                 * @memberof rv.data.Slide.Element
                 * @instance
                 */
                Element.prototype.childBuilds = $util.emptyArray;

                /**
                 * Element revealFromIndex.
                 * @member {number} revealFromIndex
                 * @memberof rv.data.Slide.Element
                 * @instance
                 */
                Element.prototype.revealFromIndex = 0;

                /**
                 * Element textScroller.
                 * @member {rv.data.Slide.Element.ITextScroller|null|undefined} textScroller
                 * @memberof rv.data.Slide.Element
                 * @instance
                 */
                Element.prototype.textScroller = null;

                /**
                 * Creates a new Element instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Slide.Element
                 * @static
                 * @param {rv.data.Slide.IElement=} [properties] Properties to set
                 * @returns {rv.data.Slide.Element} Element instance
                 */
                Element.create = function create(properties) {
                    return new Element(properties);
                };

                /**
                 * Encodes the specified Element message. Does not implicitly {@link rv.data.Slide.Element.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Slide.Element
                 * @static
                 * @param {rv.data.Slide.IElement} message Element message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Element.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.element != null && Object.hasOwnProperty.call(message, "element"))
                        $root.rv.data.Graphics.Element.encode(message.element, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.buildIn != null && Object.hasOwnProperty.call(message, "buildIn"))
                        $root.rv.data.Slide.Element.Build.encode(message.buildIn, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.buildOut != null && Object.hasOwnProperty.call(message, "buildOut"))
                        $root.rv.data.Slide.Element.Build.encode(message.buildOut, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.info);
                    if (message.revealType != null && Object.hasOwnProperty.call(message, "revealType"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.revealType);
                    if (message.dataLinks != null && message.dataLinks.length)
                        for (let i = 0; i < message.dataLinks.length; ++i)
                            $root.rv.data.Slide.Element.DataLink.encode(message.dataLinks[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.childBuilds != null && message.childBuilds.length)
                        for (let i = 0; i < message.childBuilds.length; ++i)
                            $root.rv.data.Slide.Element.ChildBuild.encode(message.childBuilds[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.revealFromIndex != null && Object.hasOwnProperty.call(message, "revealFromIndex"))
                        writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.revealFromIndex);
                    if (message.textScroller != null && Object.hasOwnProperty.call(message, "textScroller"))
                        $root.rv.data.Slide.Element.TextScroller.encode(message.textScroller, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Element message, length delimited. Does not implicitly {@link rv.data.Slide.Element.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Slide.Element
                 * @static
                 * @param {rv.data.Slide.IElement} message Element message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Element.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Element message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Slide.Element
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Slide.Element} Element
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Element.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.element = $root.rv.data.Graphics.Element.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.buildIn = $root.rv.data.Slide.Element.Build.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.buildOut = $root.rv.data.Slide.Element.Build.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.info = reader.uint32();
                                break;
                            }
                        case 5: {
                                message.revealType = reader.int32();
                                break;
                            }
                        case 6: {
                                if (!(message.dataLinks && message.dataLinks.length))
                                    message.dataLinks = [];
                                message.dataLinks.push($root.rv.data.Slide.Element.DataLink.decode(reader, reader.uint32()));
                                break;
                            }
                        case 7: {
                                if (!(message.childBuilds && message.childBuilds.length))
                                    message.childBuilds = [];
                                message.childBuilds.push($root.rv.data.Slide.Element.ChildBuild.decode(reader, reader.uint32()));
                                break;
                            }
                        case 8: {
                                message.revealFromIndex = reader.uint32();
                                break;
                            }
                        case 9: {
                                message.textScroller = $root.rv.data.Slide.Element.TextScroller.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Element message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Slide.Element
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Slide.Element} Element
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Element.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Element message.
                 * @function verify
                 * @memberof rv.data.Slide.Element
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Element.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.element != null && message.hasOwnProperty("element")) {
                        let error = $root.rv.data.Graphics.Element.verify(message.element);
                        if (error)
                            return "element." + error;
                    }
                    if (message.buildIn != null && message.hasOwnProperty("buildIn")) {
                        let error = $root.rv.data.Slide.Element.Build.verify(message.buildIn);
                        if (error)
                            return "buildIn." + error;
                    }
                    if (message.buildOut != null && message.hasOwnProperty("buildOut")) {
                        let error = $root.rv.data.Slide.Element.Build.verify(message.buildOut);
                        if (error)
                            return "buildOut." + error;
                    }
                    if (message.info != null && message.hasOwnProperty("info"))
                        if (!$util.isInteger(message.info))
                            return "info: integer expected";
                    if (message.revealType != null && message.hasOwnProperty("revealType"))
                        switch (message.revealType) {
                        default:
                            return "revealType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.dataLinks != null && message.hasOwnProperty("dataLinks")) {
                        if (!Array.isArray(message.dataLinks))
                            return "dataLinks: array expected";
                        for (let i = 0; i < message.dataLinks.length; ++i) {
                            let error = $root.rv.data.Slide.Element.DataLink.verify(message.dataLinks[i]);
                            if (error)
                                return "dataLinks." + error;
                        }
                    }
                    if (message.childBuilds != null && message.hasOwnProperty("childBuilds")) {
                        if (!Array.isArray(message.childBuilds))
                            return "childBuilds: array expected";
                        for (let i = 0; i < message.childBuilds.length; ++i) {
                            let error = $root.rv.data.Slide.Element.ChildBuild.verify(message.childBuilds[i]);
                            if (error)
                                return "childBuilds." + error;
                        }
                    }
                    if (message.revealFromIndex != null && message.hasOwnProperty("revealFromIndex"))
                        if (!$util.isInteger(message.revealFromIndex))
                            return "revealFromIndex: integer expected";
                    if (message.textScroller != null && message.hasOwnProperty("textScroller")) {
                        let error = $root.rv.data.Slide.Element.TextScroller.verify(message.textScroller);
                        if (error)
                            return "textScroller." + error;
                    }
                    return null;
                };

                /**
                 * Creates an Element message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Slide.Element
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Slide.Element} Element
                 */
                Element.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Slide.Element)
                        return object;
                    let message = new $root.rv.data.Slide.Element();
                    if (object.element != null) {
                        if (typeof object.element !== "object")
                            throw TypeError(".rv.data.Slide.Element.element: object expected");
                        message.element = $root.rv.data.Graphics.Element.fromObject(object.element);
                    }
                    if (object.buildIn != null) {
                        if (typeof object.buildIn !== "object")
                            throw TypeError(".rv.data.Slide.Element.buildIn: object expected");
                        message.buildIn = $root.rv.data.Slide.Element.Build.fromObject(object.buildIn);
                    }
                    if (object.buildOut != null) {
                        if (typeof object.buildOut !== "object")
                            throw TypeError(".rv.data.Slide.Element.buildOut: object expected");
                        message.buildOut = $root.rv.data.Slide.Element.Build.fromObject(object.buildOut);
                    }
                    if (object.info != null)
                        message.info = object.info >>> 0;
                    switch (object.revealType) {
                    default:
                        if (typeof object.revealType === "number") {
                            message.revealType = object.revealType;
                            break;
                        }
                        break;
                    case "TEXT_REVEAL_TYPE_NONE":
                    case 0:
                        message.revealType = 0;
                        break;
                    case "TEXT_REVEAL_TYPE_BULLET":
                    case 1:
                        message.revealType = 1;
                        break;
                    case "TEXT_REVEAL_TYPE_UNDERLINE":
                    case 2:
                        message.revealType = 2;
                        break;
                    }
                    if (object.dataLinks) {
                        if (!Array.isArray(object.dataLinks))
                            throw TypeError(".rv.data.Slide.Element.dataLinks: array expected");
                        message.dataLinks = [];
                        for (let i = 0; i < object.dataLinks.length; ++i) {
                            if (typeof object.dataLinks[i] !== "object")
                                throw TypeError(".rv.data.Slide.Element.dataLinks: object expected");
                            message.dataLinks[i] = $root.rv.data.Slide.Element.DataLink.fromObject(object.dataLinks[i]);
                        }
                    }
                    if (object.childBuilds) {
                        if (!Array.isArray(object.childBuilds))
                            throw TypeError(".rv.data.Slide.Element.childBuilds: array expected");
                        message.childBuilds = [];
                        for (let i = 0; i < object.childBuilds.length; ++i) {
                            if (typeof object.childBuilds[i] !== "object")
                                throw TypeError(".rv.data.Slide.Element.childBuilds: object expected");
                            message.childBuilds[i] = $root.rv.data.Slide.Element.ChildBuild.fromObject(object.childBuilds[i]);
                        }
                    }
                    if (object.revealFromIndex != null)
                        message.revealFromIndex = object.revealFromIndex >>> 0;
                    if (object.textScroller != null) {
                        if (typeof object.textScroller !== "object")
                            throw TypeError(".rv.data.Slide.Element.textScroller: object expected");
                        message.textScroller = $root.rv.data.Slide.Element.TextScroller.fromObject(object.textScroller);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Element message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Slide.Element
                 * @static
                 * @param {rv.data.Slide.Element} message Element
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Element.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.dataLinks = [];
                        object.childBuilds = [];
                    }
                    if (options.defaults) {
                        object.element = null;
                        object.buildIn = null;
                        object.buildOut = null;
                        object.info = 0;
                        object.revealType = options.enums === String ? "TEXT_REVEAL_TYPE_NONE" : 0;
                        object.revealFromIndex = 0;
                        object.textScroller = null;
                    }
                    if (message.element != null && message.hasOwnProperty("element"))
                        object.element = $root.rv.data.Graphics.Element.toObject(message.element, options);
                    if (message.buildIn != null && message.hasOwnProperty("buildIn"))
                        object.buildIn = $root.rv.data.Slide.Element.Build.toObject(message.buildIn, options);
                    if (message.buildOut != null && message.hasOwnProperty("buildOut"))
                        object.buildOut = $root.rv.data.Slide.Element.Build.toObject(message.buildOut, options);
                    if (message.info != null && message.hasOwnProperty("info"))
                        object.info = message.info;
                    if (message.revealType != null && message.hasOwnProperty("revealType"))
                        object.revealType = options.enums === String ? $root.rv.data.Slide.Element.TextRevealType[message.revealType] === undefined ? message.revealType : $root.rv.data.Slide.Element.TextRevealType[message.revealType] : message.revealType;
                    if (message.dataLinks && message.dataLinks.length) {
                        object.dataLinks = [];
                        for (let j = 0; j < message.dataLinks.length; ++j)
                            object.dataLinks[j] = $root.rv.data.Slide.Element.DataLink.toObject(message.dataLinks[j], options);
                    }
                    if (message.childBuilds && message.childBuilds.length) {
                        object.childBuilds = [];
                        for (let j = 0; j < message.childBuilds.length; ++j)
                            object.childBuilds[j] = $root.rv.data.Slide.Element.ChildBuild.toObject(message.childBuilds[j], options);
                    }
                    if (message.revealFromIndex != null && message.hasOwnProperty("revealFromIndex"))
                        object.revealFromIndex = message.revealFromIndex;
                    if (message.textScroller != null && message.hasOwnProperty("textScroller"))
                        object.textScroller = $root.rv.data.Slide.Element.TextScroller.toObject(message.textScroller, options);
                    return object;
                };

                /**
                 * Converts this Element to JSON.
                 * @function toJSON
                 * @memberof rv.data.Slide.Element
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Element.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Element
                 * @function getTypeUrl
                 * @memberof rv.data.Slide.Element
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Element.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Slide.Element";
                };

                Element.Build = (function() {

                    /**
                     * Properties of a Build.
                     * @memberof rv.data.Slide.Element
                     * @interface IBuild
                     * @property {rv.data.IUUID|null} [uuid] Build uuid
                     * @property {rv.data.IUUID|null} [elementUUID] Build elementUUID
                     * @property {rv.data.Slide.Element.Build.Start|null} [start] Build start
                     * @property {number|null} [delayTime] Build delayTime
                     * @property {rv.data.ITransition|null} [transition] Build transition
                     */

                    /**
                     * Constructs a new Build.
                     * @memberof rv.data.Slide.Element
                     * @classdesc Represents a Build.
                     * @implements IBuild
                     * @constructor
                     * @param {rv.data.Slide.Element.IBuild=} [properties] Properties to set
                     */
                    function Build(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Build uuid.
                     * @member {rv.data.IUUID|null|undefined} uuid
                     * @memberof rv.data.Slide.Element.Build
                     * @instance
                     */
                    Build.prototype.uuid = null;

                    /**
                     * Build elementUUID.
                     * @member {rv.data.IUUID|null|undefined} elementUUID
                     * @memberof rv.data.Slide.Element.Build
                     * @instance
                     */
                    Build.prototype.elementUUID = null;

                    /**
                     * Build start.
                     * @member {rv.data.Slide.Element.Build.Start} start
                     * @memberof rv.data.Slide.Element.Build
                     * @instance
                     */
                    Build.prototype.start = 0;

                    /**
                     * Build delayTime.
                     * @member {number} delayTime
                     * @memberof rv.data.Slide.Element.Build
                     * @instance
                     */
                    Build.prototype.delayTime = 0;

                    /**
                     * Build transition.
                     * @member {rv.data.ITransition|null|undefined} transition
                     * @memberof rv.data.Slide.Element.Build
                     * @instance
                     */
                    Build.prototype.transition = null;

                    /**
                     * Creates a new Build instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Slide.Element.Build
                     * @static
                     * @param {rv.data.Slide.Element.IBuild=} [properties] Properties to set
                     * @returns {rv.data.Slide.Element.Build} Build instance
                     */
                    Build.create = function create(properties) {
                        return new Build(properties);
                    };

                    /**
                     * Encodes the specified Build message. Does not implicitly {@link rv.data.Slide.Element.Build.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Slide.Element.Build
                     * @static
                     * @param {rv.data.Slide.Element.IBuild} message Build message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Build.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                            $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.elementUUID != null && Object.hasOwnProperty.call(message, "elementUUID"))
                            $root.rv.data.UUID.encode(message.elementUUID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.start);
                        if (message.delayTime != null && Object.hasOwnProperty.call(message, "delayTime"))
                            writer.uint32(/* id 4, wireType 1 =*/33).double(message.delayTime);
                        if (message.transition != null && Object.hasOwnProperty.call(message, "transition"))
                            $root.rv.data.Transition.encode(message.transition, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Build message, length delimited. Does not implicitly {@link rv.data.Slide.Element.Build.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Slide.Element.Build
                     * @static
                     * @param {rv.data.Slide.Element.IBuild} message Build message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Build.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Build message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Slide.Element.Build
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Slide.Element.Build} Build
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Build.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.Build();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                    break;
                                }
                            case 2: {
                                    message.elementUUID = $root.rv.data.UUID.decode(reader, reader.uint32());
                                    break;
                                }
                            case 3: {
                                    message.start = reader.int32();
                                    break;
                                }
                            case 4: {
                                    message.delayTime = reader.double();
                                    break;
                                }
                            case 5: {
                                    message.transition = $root.rv.data.Transition.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Build message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Slide.Element.Build
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Slide.Element.Build} Build
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Build.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Build message.
                     * @function verify
                     * @memberof rv.data.Slide.Element.Build
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Build.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.uuid != null && message.hasOwnProperty("uuid")) {
                            let error = $root.rv.data.UUID.verify(message.uuid);
                            if (error)
                                return "uuid." + error;
                        }
                        if (message.elementUUID != null && message.hasOwnProperty("elementUUID")) {
                            let error = $root.rv.data.UUID.verify(message.elementUUID);
                            if (error)
                                return "elementUUID." + error;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            switch (message.start) {
                            default:
                                return "start: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.delayTime != null && message.hasOwnProperty("delayTime"))
                            if (typeof message.delayTime !== "number")
                                return "delayTime: number expected";
                        if (message.transition != null && message.hasOwnProperty("transition")) {
                            let error = $root.rv.data.Transition.verify(message.transition);
                            if (error)
                                return "transition." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Build message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Slide.Element.Build
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Slide.Element.Build} Build
                     */
                    Build.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Slide.Element.Build)
                            return object;
                        let message = new $root.rv.data.Slide.Element.Build();
                        if (object.uuid != null) {
                            if (typeof object.uuid !== "object")
                                throw TypeError(".rv.data.Slide.Element.Build.uuid: object expected");
                            message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                        }
                        if (object.elementUUID != null) {
                            if (typeof object.elementUUID !== "object")
                                throw TypeError(".rv.data.Slide.Element.Build.elementUUID: object expected");
                            message.elementUUID = $root.rv.data.UUID.fromObject(object.elementUUID);
                        }
                        switch (object.start) {
                        default:
                            if (typeof object.start === "number") {
                                message.start = object.start;
                                break;
                            }
                            break;
                        case "START_ON_CLICK":
                        case 0:
                            message.start = 0;
                            break;
                        case "START_WITH_PREVIOUS":
                        case 1:
                            message.start = 1;
                            break;
                        case "START_AFTER_PREVIOUS":
                        case 2:
                            message.start = 2;
                            break;
                        case "START_WITH_SLIDE":
                        case 3:
                            message.start = 3;
                            break;
                        }
                        if (object.delayTime != null)
                            message.delayTime = Number(object.delayTime);
                        if (object.transition != null) {
                            if (typeof object.transition !== "object")
                                throw TypeError(".rv.data.Slide.Element.Build.transition: object expected");
                            message.transition = $root.rv.data.Transition.fromObject(object.transition);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Build message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Slide.Element.Build
                     * @static
                     * @param {rv.data.Slide.Element.Build} message Build
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Build.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.uuid = null;
                            object.elementUUID = null;
                            object.start = options.enums === String ? "START_ON_CLICK" : 0;
                            object.delayTime = 0;
                            object.transition = null;
                        }
                        if (message.uuid != null && message.hasOwnProperty("uuid"))
                            object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                        if (message.elementUUID != null && message.hasOwnProperty("elementUUID"))
                            object.elementUUID = $root.rv.data.UUID.toObject(message.elementUUID, options);
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = options.enums === String ? $root.rv.data.Slide.Element.Build.Start[message.start] === undefined ? message.start : $root.rv.data.Slide.Element.Build.Start[message.start] : message.start;
                        if (message.delayTime != null && message.hasOwnProperty("delayTime"))
                            object.delayTime = options.json && !isFinite(message.delayTime) ? String(message.delayTime) : message.delayTime;
                        if (message.transition != null && message.hasOwnProperty("transition"))
                            object.transition = $root.rv.data.Transition.toObject(message.transition, options);
                        return object;
                    };

                    /**
                     * Converts this Build to JSON.
                     * @function toJSON
                     * @memberof rv.data.Slide.Element.Build
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Build.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Build
                     * @function getTypeUrl
                     * @memberof rv.data.Slide.Element.Build
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Build.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Slide.Element.Build";
                    };

                    /**
                     * Start enum.
                     * @name rv.data.Slide.Element.Build.Start
                     * @enum {number}
                     * @property {number} START_ON_CLICK=0 START_ON_CLICK value
                     * @property {number} START_WITH_PREVIOUS=1 START_WITH_PREVIOUS value
                     * @property {number} START_AFTER_PREVIOUS=2 START_AFTER_PREVIOUS value
                     * @property {number} START_WITH_SLIDE=3 START_WITH_SLIDE value
                     */
                    Build.Start = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "START_ON_CLICK"] = 0;
                        values[valuesById[1] = "START_WITH_PREVIOUS"] = 1;
                        values[valuesById[2] = "START_AFTER_PREVIOUS"] = 2;
                        values[valuesById[3] = "START_WITH_SLIDE"] = 3;
                        return values;
                    })();

                    return Build;
                })();

                Element.ChildBuild = (function() {

                    /**
                     * Properties of a ChildBuild.
                     * @memberof rv.data.Slide.Element
                     * @interface IChildBuild
                     * @property {rv.data.IUUID|null} [uuid] ChildBuild uuid
                     * @property {rv.data.Slide.Element.Build.Start|null} [start] ChildBuild start
                     * @property {number|null} [delayTime] ChildBuild delayTime
                     * @property {number|null} [index] ChildBuild index
                     */

                    /**
                     * Constructs a new ChildBuild.
                     * @memberof rv.data.Slide.Element
                     * @classdesc Represents a ChildBuild.
                     * @implements IChildBuild
                     * @constructor
                     * @param {rv.data.Slide.Element.IChildBuild=} [properties] Properties to set
                     */
                    function ChildBuild(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ChildBuild uuid.
                     * @member {rv.data.IUUID|null|undefined} uuid
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @instance
                     */
                    ChildBuild.prototype.uuid = null;

                    /**
                     * ChildBuild start.
                     * @member {rv.data.Slide.Element.Build.Start} start
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @instance
                     */
                    ChildBuild.prototype.start = 0;

                    /**
                     * ChildBuild delayTime.
                     * @member {number} delayTime
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @instance
                     */
                    ChildBuild.prototype.delayTime = 0;

                    /**
                     * ChildBuild index.
                     * @member {number} index
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @instance
                     */
                    ChildBuild.prototype.index = 0;

                    /**
                     * Creates a new ChildBuild instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @static
                     * @param {rv.data.Slide.Element.IChildBuild=} [properties] Properties to set
                     * @returns {rv.data.Slide.Element.ChildBuild} ChildBuild instance
                     */
                    ChildBuild.create = function create(properties) {
                        return new ChildBuild(properties);
                    };

                    /**
                     * Encodes the specified ChildBuild message. Does not implicitly {@link rv.data.Slide.Element.ChildBuild.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @static
                     * @param {rv.data.Slide.Element.IChildBuild} message ChildBuild message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChildBuild.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                            $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.start);
                        if (message.delayTime != null && Object.hasOwnProperty.call(message, "delayTime"))
                            writer.uint32(/* id 3, wireType 1 =*/25).double(message.delayTime);
                        if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.index);
                        return writer;
                    };

                    /**
                     * Encodes the specified ChildBuild message, length delimited. Does not implicitly {@link rv.data.Slide.Element.ChildBuild.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @static
                     * @param {rv.data.Slide.Element.IChildBuild} message ChildBuild message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChildBuild.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChildBuild message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Slide.Element.ChildBuild} ChildBuild
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChildBuild.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.ChildBuild();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                    break;
                                }
                            case 2: {
                                    message.start = reader.int32();
                                    break;
                                }
                            case 3: {
                                    message.delayTime = reader.double();
                                    break;
                                }
                            case 4: {
                                    message.index = reader.uint32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChildBuild message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Slide.Element.ChildBuild} ChildBuild
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChildBuild.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChildBuild message.
                     * @function verify
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChildBuild.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.uuid != null && message.hasOwnProperty("uuid")) {
                            let error = $root.rv.data.UUID.verify(message.uuid);
                            if (error)
                                return "uuid." + error;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            switch (message.start) {
                            default:
                                return "start: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.delayTime != null && message.hasOwnProperty("delayTime"))
                            if (typeof message.delayTime !== "number")
                                return "delayTime: number expected";
                        if (message.index != null && message.hasOwnProperty("index"))
                            if (!$util.isInteger(message.index))
                                return "index: integer expected";
                        return null;
                    };

                    /**
                     * Creates a ChildBuild message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Slide.Element.ChildBuild} ChildBuild
                     */
                    ChildBuild.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Slide.Element.ChildBuild)
                            return object;
                        let message = new $root.rv.data.Slide.Element.ChildBuild();
                        if (object.uuid != null) {
                            if (typeof object.uuid !== "object")
                                throw TypeError(".rv.data.Slide.Element.ChildBuild.uuid: object expected");
                            message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                        }
                        switch (object.start) {
                        default:
                            if (typeof object.start === "number") {
                                message.start = object.start;
                                break;
                            }
                            break;
                        case "START_ON_CLICK":
                        case 0:
                            message.start = 0;
                            break;
                        case "START_WITH_PREVIOUS":
                        case 1:
                            message.start = 1;
                            break;
                        case "START_AFTER_PREVIOUS":
                        case 2:
                            message.start = 2;
                            break;
                        case "START_WITH_SLIDE":
                        case 3:
                            message.start = 3;
                            break;
                        }
                        if (object.delayTime != null)
                            message.delayTime = Number(object.delayTime);
                        if (object.index != null)
                            message.index = object.index >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a ChildBuild message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @static
                     * @param {rv.data.Slide.Element.ChildBuild} message ChildBuild
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChildBuild.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.uuid = null;
                            object.start = options.enums === String ? "START_ON_CLICK" : 0;
                            object.delayTime = 0;
                            object.index = 0;
                        }
                        if (message.uuid != null && message.hasOwnProperty("uuid"))
                            object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = options.enums === String ? $root.rv.data.Slide.Element.Build.Start[message.start] === undefined ? message.start : $root.rv.data.Slide.Element.Build.Start[message.start] : message.start;
                        if (message.delayTime != null && message.hasOwnProperty("delayTime"))
                            object.delayTime = options.json && !isFinite(message.delayTime) ? String(message.delayTime) : message.delayTime;
                        if (message.index != null && message.hasOwnProperty("index"))
                            object.index = message.index;
                        return object;
                    };

                    /**
                     * Converts this ChildBuild to JSON.
                     * @function toJSON
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChildBuild.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for ChildBuild
                     * @function getTypeUrl
                     * @memberof rv.data.Slide.Element.ChildBuild
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    ChildBuild.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Slide.Element.ChildBuild";
                    };

                    return ChildBuild;
                })();

                Element.DataLink = (function() {

                    /**
                     * Properties of a DataLink.
                     * @memberof rv.data.Slide.Element
                     * @interface IDataLink
                     * @property {rv.data.Slide.Element.DataLink.ITicker|null} [ticker] DataLink ticker
                     * @property {rv.data.Slide.Element.DataLink.IAlternateElementText|null} [alternateText] DataLink alternateText
                     * @property {rv.data.Slide.Element.DataLink.ITimerText|null} [timerText] DataLink timerText
                     * @property {rv.data.Slide.Element.DataLink.IClockText|null} [clockText] DataLink clockText
                     * @property {rv.data.Slide.Element.DataLink.IChordChart|null} [chordChart] DataLink chordChart
                     * @property {rv.data.Slide.Element.DataLink.IOutputScreen|null} [outputScreen] DataLink outputScreen
                     * @property {rv.data.Slide.Element.DataLink.IPCOLive|null} [pcoLive] DataLink pcoLive
                     * @property {rv.data.Slide.Element.DataLink.IAlternateElementFill|null} [alternateFill] DataLink alternateFill
                     * @property {rv.data.Slide.Element.DataLink.IVisibilityLink|null} [visibilityLink] DataLink visibilityLink
                     * @property {rv.data.Slide.Element.DataLink.ISlideText|null} [slideText] DataLink slideText
                     * @property {rv.data.Slide.Element.DataLink.IStageMessage|null} [stageMessage] DataLink stageMessage
                     * @property {rv.data.Slide.Element.DataLink.IVideoCountdown|null} [videoCountdown] DataLink videoCountdown
                     * @property {rv.data.Slide.Element.DataLink.ISlideImage|null} [slideImage] DataLink slideImage
                     * @property {rv.data.Slide.Element.DataLink.ICCLIText|null} [ccliText] DataLink ccliText
                     * @property {rv.data.Slide.Element.DataLink.IGroupName|null} [groupName] DataLink groupName
                     * @property {rv.data.Slide.Element.DataLink.IGroupColor|null} [groupColor] DataLink groupColor
                     * @property {rv.data.Slide.Element.DataLink.IPresentationNotes|null} [presentationNotes] DataLink presentationNotes
                     * @property {rv.data.Slide.Element.DataLink.IPlaylistItem|null} [playlistItem] DataLink playlistItem
                     * @property {rv.data.Slide.Element.DataLink.IAutoAdvanceTimeRemaining|null} [autoAdvanceTimeRemaining] DataLink autoAdvanceTimeRemaining
                     * @property {rv.data.Slide.Element.DataLink.ICaptureStatusText|null} [captureStatusText] DataLink captureStatusText
                     * @property {rv.data.Slide.Element.DataLink.ICaptureStatusColor|null} [captureStatusColor] DataLink captureStatusColor
                     * @property {rv.data.Slide.Element.DataLink.ISlideCount|null} [slideCount] DataLink slideCount
                     * @property {rv.data.Slide.Element.DataLink.IAudioCountdown|null} [audioCountdown] DataLink audioCountdown
                     * @property {rv.data.Slide.Element.DataLink.IPresentation|null} [presentation] DataLink presentation
                     * @property {rv.data.Slide.Element.DataLink.ISlideLabelText|null} [slide_Label_Text] DataLink slide_Label_Text
                     * @property {rv.data.Slide.Element.DataLink.ISlideLabelColor|null} [slide_Label_Color] DataLink slide_Label_Color
                     * @property {rv.data.Slide.Element.DataLink.IRSSFeed|null} [rssFeed] DataLink rssFeed
                     * @property {rv.data.Slide.Element.DataLink.IFileFeed|null} [fileFeed] DataLink fileFeed
                     * @property {rv.data.Slide.Element.DataLink.IChordProChart|null} [chordProChart] DataLink chordProChart
                     * @property {rv.data.Slide.Element.DataLink.IPlaybackMarkerText|null} [playbackMarkerText] DataLink playbackMarkerText
                     * @property {rv.data.Slide.Element.DataLink.IPlaybackMarkerIdentifier|null} [playbackMarkerColor] DataLink playbackMarkerColor
                     * @property {rv.data.Slide.Element.DataLink.ITimecodeText|null} [timecodeText] DataLink timecodeText
                     * @property {rv.data.Slide.Element.DataLink.ITimecodeStatus|null} [timecodeStatus] DataLink timecodeStatus
                     */

                    /**
                     * Constructs a new DataLink.
                     * @memberof rv.data.Slide.Element
                     * @classdesc Represents a DataLink.
                     * @implements IDataLink
                     * @constructor
                     * @param {rv.data.Slide.Element.IDataLink=} [properties] Properties to set
                     */
                    function DataLink(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * DataLink ticker.
                     * @member {rv.data.Slide.Element.DataLink.ITicker|null|undefined} ticker
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.ticker = null;

                    /**
                     * DataLink alternateText.
                     * @member {rv.data.Slide.Element.DataLink.IAlternateElementText|null|undefined} alternateText
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.alternateText = null;

                    /**
                     * DataLink timerText.
                     * @member {rv.data.Slide.Element.DataLink.ITimerText|null|undefined} timerText
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.timerText = null;

                    /**
                     * DataLink clockText.
                     * @member {rv.data.Slide.Element.DataLink.IClockText|null|undefined} clockText
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.clockText = null;

                    /**
                     * DataLink chordChart.
                     * @member {rv.data.Slide.Element.DataLink.IChordChart|null|undefined} chordChart
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.chordChart = null;

                    /**
                     * DataLink outputScreen.
                     * @member {rv.data.Slide.Element.DataLink.IOutputScreen|null|undefined} outputScreen
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.outputScreen = null;

                    /**
                     * DataLink pcoLive.
                     * @member {rv.data.Slide.Element.DataLink.IPCOLive|null|undefined} pcoLive
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.pcoLive = null;

                    /**
                     * DataLink alternateFill.
                     * @member {rv.data.Slide.Element.DataLink.IAlternateElementFill|null|undefined} alternateFill
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.alternateFill = null;

                    /**
                     * DataLink visibilityLink.
                     * @member {rv.data.Slide.Element.DataLink.IVisibilityLink|null|undefined} visibilityLink
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.visibilityLink = null;

                    /**
                     * DataLink slideText.
                     * @member {rv.data.Slide.Element.DataLink.ISlideText|null|undefined} slideText
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.slideText = null;

                    /**
                     * DataLink stageMessage.
                     * @member {rv.data.Slide.Element.DataLink.IStageMessage|null|undefined} stageMessage
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.stageMessage = null;

                    /**
                     * DataLink videoCountdown.
                     * @member {rv.data.Slide.Element.DataLink.IVideoCountdown|null|undefined} videoCountdown
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.videoCountdown = null;

                    /**
                     * DataLink slideImage.
                     * @member {rv.data.Slide.Element.DataLink.ISlideImage|null|undefined} slideImage
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.slideImage = null;

                    /**
                     * DataLink ccliText.
                     * @member {rv.data.Slide.Element.DataLink.ICCLIText|null|undefined} ccliText
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.ccliText = null;

                    /**
                     * DataLink groupName.
                     * @member {rv.data.Slide.Element.DataLink.IGroupName|null|undefined} groupName
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.groupName = null;

                    /**
                     * DataLink groupColor.
                     * @member {rv.data.Slide.Element.DataLink.IGroupColor|null|undefined} groupColor
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.groupColor = null;

                    /**
                     * DataLink presentationNotes.
                     * @member {rv.data.Slide.Element.DataLink.IPresentationNotes|null|undefined} presentationNotes
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.presentationNotes = null;

                    /**
                     * DataLink playlistItem.
                     * @member {rv.data.Slide.Element.DataLink.IPlaylistItem|null|undefined} playlistItem
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.playlistItem = null;

                    /**
                     * DataLink autoAdvanceTimeRemaining.
                     * @member {rv.data.Slide.Element.DataLink.IAutoAdvanceTimeRemaining|null|undefined} autoAdvanceTimeRemaining
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.autoAdvanceTimeRemaining = null;

                    /**
                     * DataLink captureStatusText.
                     * @member {rv.data.Slide.Element.DataLink.ICaptureStatusText|null|undefined} captureStatusText
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.captureStatusText = null;

                    /**
                     * DataLink captureStatusColor.
                     * @member {rv.data.Slide.Element.DataLink.ICaptureStatusColor|null|undefined} captureStatusColor
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.captureStatusColor = null;

                    /**
                     * DataLink slideCount.
                     * @member {rv.data.Slide.Element.DataLink.ISlideCount|null|undefined} slideCount
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.slideCount = null;

                    /**
                     * DataLink audioCountdown.
                     * @member {rv.data.Slide.Element.DataLink.IAudioCountdown|null|undefined} audioCountdown
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.audioCountdown = null;

                    /**
                     * DataLink presentation.
                     * @member {rv.data.Slide.Element.DataLink.IPresentation|null|undefined} presentation
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.presentation = null;

                    /**
                     * DataLink slide_Label_Text.
                     * @member {rv.data.Slide.Element.DataLink.ISlideLabelText|null|undefined} slide_Label_Text
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.slide_Label_Text = null;

                    /**
                     * DataLink slide_Label_Color.
                     * @member {rv.data.Slide.Element.DataLink.ISlideLabelColor|null|undefined} slide_Label_Color
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.slide_Label_Color = null;

                    /**
                     * DataLink rssFeed.
                     * @member {rv.data.Slide.Element.DataLink.IRSSFeed|null|undefined} rssFeed
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.rssFeed = null;

                    /**
                     * DataLink fileFeed.
                     * @member {rv.data.Slide.Element.DataLink.IFileFeed|null|undefined} fileFeed
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.fileFeed = null;

                    /**
                     * DataLink chordProChart.
                     * @member {rv.data.Slide.Element.DataLink.IChordProChart|null|undefined} chordProChart
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.chordProChart = null;

                    /**
                     * DataLink playbackMarkerText.
                     * @member {rv.data.Slide.Element.DataLink.IPlaybackMarkerText|null|undefined} playbackMarkerText
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.playbackMarkerText = null;

                    /**
                     * DataLink playbackMarkerColor.
                     * @member {rv.data.Slide.Element.DataLink.IPlaybackMarkerIdentifier|null|undefined} playbackMarkerColor
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.playbackMarkerColor = null;

                    /**
                     * DataLink timecodeText.
                     * @member {rv.data.Slide.Element.DataLink.ITimecodeText|null|undefined} timecodeText
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.timecodeText = null;

                    /**
                     * DataLink timecodeStatus.
                     * @member {rv.data.Slide.Element.DataLink.ITimecodeStatus|null|undefined} timecodeStatus
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    DataLink.prototype.timecodeStatus = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * DataLink PropertyType.
                     * @member {"ticker"|"alternateText"|"timerText"|"clockText"|"chordChart"|"outputScreen"|"pcoLive"|"alternateFill"|"visibilityLink"|"slideText"|"stageMessage"|"videoCountdown"|"slideImage"|"ccliText"|"groupName"|"groupColor"|"presentationNotes"|"playlistItem"|"autoAdvanceTimeRemaining"|"captureStatusText"|"captureStatusColor"|"slideCount"|"audioCountdown"|"presentation"|"slide_Label_Text"|"slide_Label_Color"|"rssFeed"|"fileFeed"|"chordProChart"|"playbackMarkerText"|"playbackMarkerColor"|"timecodeText"|"timecodeStatus"|undefined} PropertyType
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     */
                    Object.defineProperty(DataLink.prototype, "PropertyType", {
                        get: $util.oneOfGetter($oneOfFields = ["ticker", "alternateText", "timerText", "clockText", "chordChart", "outputScreen", "pcoLive", "alternateFill", "visibilityLink", "slideText", "stageMessage", "videoCountdown", "slideImage", "ccliText", "groupName", "groupColor", "presentationNotes", "playlistItem", "autoAdvanceTimeRemaining", "captureStatusText", "captureStatusColor", "slideCount", "audioCountdown", "presentation", "slide_Label_Text", "slide_Label_Color", "rssFeed", "fileFeed", "chordProChart", "playbackMarkerText", "playbackMarkerColor", "timecodeText", "timecodeStatus"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new DataLink instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Slide.Element.DataLink
                     * @static
                     * @param {rv.data.Slide.Element.IDataLink=} [properties] Properties to set
                     * @returns {rv.data.Slide.Element.DataLink} DataLink instance
                     */
                    DataLink.create = function create(properties) {
                        return new DataLink(properties);
                    };

                    /**
                     * Encodes the specified DataLink message. Does not implicitly {@link rv.data.Slide.Element.DataLink.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Slide.Element.DataLink
                     * @static
                     * @param {rv.data.Slide.Element.IDataLink} message DataLink message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DataLink.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ticker != null && Object.hasOwnProperty.call(message, "ticker"))
                            $root.rv.data.Slide.Element.DataLink.Ticker.encode(message.ticker, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.alternateText != null && Object.hasOwnProperty.call(message, "alternateText"))
                            $root.rv.data.Slide.Element.DataLink.AlternateElementText.encode(message.alternateText, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.timerText != null && Object.hasOwnProperty.call(message, "timerText"))
                            $root.rv.data.Slide.Element.DataLink.TimerText.encode(message.timerText, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.clockText != null && Object.hasOwnProperty.call(message, "clockText"))
                            $root.rv.data.Slide.Element.DataLink.ClockText.encode(message.clockText, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.chordChart != null && Object.hasOwnProperty.call(message, "chordChart"))
                            $root.rv.data.Slide.Element.DataLink.ChordChart.encode(message.chordChart, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.outputScreen != null && Object.hasOwnProperty.call(message, "outputScreen"))
                            $root.rv.data.Slide.Element.DataLink.OutputScreen.encode(message.outputScreen, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.pcoLive != null && Object.hasOwnProperty.call(message, "pcoLive"))
                            $root.rv.data.Slide.Element.DataLink.PCOLive.encode(message.pcoLive, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.alternateFill != null && Object.hasOwnProperty.call(message, "alternateFill"))
                            $root.rv.data.Slide.Element.DataLink.AlternateElementFill.encode(message.alternateFill, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.visibilityLink != null && Object.hasOwnProperty.call(message, "visibilityLink"))
                            $root.rv.data.Slide.Element.DataLink.VisibilityLink.encode(message.visibilityLink, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.slideText != null && Object.hasOwnProperty.call(message, "slideText"))
                            $root.rv.data.Slide.Element.DataLink.SlideText.encode(message.slideText, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.stageMessage != null && Object.hasOwnProperty.call(message, "stageMessage"))
                            $root.rv.data.Slide.Element.DataLink.StageMessage.encode(message.stageMessage, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        if (message.videoCountdown != null && Object.hasOwnProperty.call(message, "videoCountdown"))
                            $root.rv.data.Slide.Element.DataLink.VideoCountdown.encode(message.videoCountdown, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        if (message.slideImage != null && Object.hasOwnProperty.call(message, "slideImage"))
                            $root.rv.data.Slide.Element.DataLink.SlideImage.encode(message.slideImage, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                        if (message.ccliText != null && Object.hasOwnProperty.call(message, "ccliText"))
                            $root.rv.data.Slide.Element.DataLink.CCLIText.encode(message.ccliText, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                        if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                            $root.rv.data.Slide.Element.DataLink.GroupName.encode(message.groupName, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                        if (message.groupColor != null && Object.hasOwnProperty.call(message, "groupColor"))
                            $root.rv.data.Slide.Element.DataLink.GroupColor.encode(message.groupColor, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                        if (message.presentationNotes != null && Object.hasOwnProperty.call(message, "presentationNotes"))
                            $root.rv.data.Slide.Element.DataLink.PresentationNotes.encode(message.presentationNotes, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                        if (message.playlistItem != null && Object.hasOwnProperty.call(message, "playlistItem"))
                            $root.rv.data.Slide.Element.DataLink.PlaylistItem.encode(message.playlistItem, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                        if (message.autoAdvanceTimeRemaining != null && Object.hasOwnProperty.call(message, "autoAdvanceTimeRemaining"))
                            $root.rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining.encode(message.autoAdvanceTimeRemaining, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                        if (message.captureStatusText != null && Object.hasOwnProperty.call(message, "captureStatusText"))
                            $root.rv.data.Slide.Element.DataLink.CaptureStatusText.encode(message.captureStatusText, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                        if (message.captureStatusColor != null && Object.hasOwnProperty.call(message, "captureStatusColor"))
                            $root.rv.data.Slide.Element.DataLink.CaptureStatusColor.encode(message.captureStatusColor, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                        if (message.slideCount != null && Object.hasOwnProperty.call(message, "slideCount"))
                            $root.rv.data.Slide.Element.DataLink.SlideCount.encode(message.slideCount, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                        if (message.audioCountdown != null && Object.hasOwnProperty.call(message, "audioCountdown"))
                            $root.rv.data.Slide.Element.DataLink.AudioCountdown.encode(message.audioCountdown, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                        if (message.presentation != null && Object.hasOwnProperty.call(message, "presentation"))
                            $root.rv.data.Slide.Element.DataLink.Presentation.encode(message.presentation, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                        if (message.slide_Label_Text != null && Object.hasOwnProperty.call(message, "slide_Label_Text"))
                            $root.rv.data.Slide.Element.DataLink.SlideLabelText.encode(message.slide_Label_Text, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                        if (message.slide_Label_Color != null && Object.hasOwnProperty.call(message, "slide_Label_Color"))
                            $root.rv.data.Slide.Element.DataLink.SlideLabelColor.encode(message.slide_Label_Color, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                        if (message.rssFeed != null && Object.hasOwnProperty.call(message, "rssFeed"))
                            $root.rv.data.Slide.Element.DataLink.RSSFeed.encode(message.rssFeed, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
                        if (message.fileFeed != null && Object.hasOwnProperty.call(message, "fileFeed"))
                            $root.rv.data.Slide.Element.DataLink.FileFeed.encode(message.fileFeed, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
                        if (message.chordProChart != null && Object.hasOwnProperty.call(message, "chordProChart"))
                            $root.rv.data.Slide.Element.DataLink.ChordProChart.encode(message.chordProChart, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
                        if (message.playbackMarkerText != null && Object.hasOwnProperty.call(message, "playbackMarkerText"))
                            $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.encode(message.playbackMarkerText, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                        if (message.playbackMarkerColor != null && Object.hasOwnProperty.call(message, "playbackMarkerColor"))
                            $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.encode(message.playbackMarkerColor, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
                        if (message.timecodeText != null && Object.hasOwnProperty.call(message, "timecodeText"))
                            $root.rv.data.Slide.Element.DataLink.TimecodeText.encode(message.timecodeText, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
                        if (message.timecodeStatus != null && Object.hasOwnProperty.call(message, "timecodeStatus"))
                            $root.rv.data.Slide.Element.DataLink.TimecodeStatus.encode(message.timecodeStatus, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified DataLink message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Slide.Element.DataLink
                     * @static
                     * @param {rv.data.Slide.Element.IDataLink} message DataLink message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DataLink.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a DataLink message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Slide.Element.DataLink
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Slide.Element.DataLink} DataLink
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DataLink.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.ticker = $root.rv.data.Slide.Element.DataLink.Ticker.decode(reader, reader.uint32());
                                    break;
                                }
                            case 2: {
                                    message.alternateText = $root.rv.data.Slide.Element.DataLink.AlternateElementText.decode(reader, reader.uint32());
                                    break;
                                }
                            case 3: {
                                    message.timerText = $root.rv.data.Slide.Element.DataLink.TimerText.decode(reader, reader.uint32());
                                    break;
                                }
                            case 4: {
                                    message.clockText = $root.rv.data.Slide.Element.DataLink.ClockText.decode(reader, reader.uint32());
                                    break;
                                }
                            case 5: {
                                    message.chordChart = $root.rv.data.Slide.Element.DataLink.ChordChart.decode(reader, reader.uint32());
                                    break;
                                }
                            case 6: {
                                    message.outputScreen = $root.rv.data.Slide.Element.DataLink.OutputScreen.decode(reader, reader.uint32());
                                    break;
                                }
                            case 7: {
                                    message.pcoLive = $root.rv.data.Slide.Element.DataLink.PCOLive.decode(reader, reader.uint32());
                                    break;
                                }
                            case 8: {
                                    message.alternateFill = $root.rv.data.Slide.Element.DataLink.AlternateElementFill.decode(reader, reader.uint32());
                                    break;
                                }
                            case 9: {
                                    message.visibilityLink = $root.rv.data.Slide.Element.DataLink.VisibilityLink.decode(reader, reader.uint32());
                                    break;
                                }
                            case 10: {
                                    message.slideText = $root.rv.data.Slide.Element.DataLink.SlideText.decode(reader, reader.uint32());
                                    break;
                                }
                            case 11: {
                                    message.stageMessage = $root.rv.data.Slide.Element.DataLink.StageMessage.decode(reader, reader.uint32());
                                    break;
                                }
                            case 12: {
                                    message.videoCountdown = $root.rv.data.Slide.Element.DataLink.VideoCountdown.decode(reader, reader.uint32());
                                    break;
                                }
                            case 13: {
                                    message.slideImage = $root.rv.data.Slide.Element.DataLink.SlideImage.decode(reader, reader.uint32());
                                    break;
                                }
                            case 14: {
                                    message.ccliText = $root.rv.data.Slide.Element.DataLink.CCLIText.decode(reader, reader.uint32());
                                    break;
                                }
                            case 15: {
                                    message.groupName = $root.rv.data.Slide.Element.DataLink.GroupName.decode(reader, reader.uint32());
                                    break;
                                }
                            case 16: {
                                    message.groupColor = $root.rv.data.Slide.Element.DataLink.GroupColor.decode(reader, reader.uint32());
                                    break;
                                }
                            case 17: {
                                    message.presentationNotes = $root.rv.data.Slide.Element.DataLink.PresentationNotes.decode(reader, reader.uint32());
                                    break;
                                }
                            case 18: {
                                    message.playlistItem = $root.rv.data.Slide.Element.DataLink.PlaylistItem.decode(reader, reader.uint32());
                                    break;
                                }
                            case 19: {
                                    message.autoAdvanceTimeRemaining = $root.rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining.decode(reader, reader.uint32());
                                    break;
                                }
                            case 20: {
                                    message.captureStatusText = $root.rv.data.Slide.Element.DataLink.CaptureStatusText.decode(reader, reader.uint32());
                                    break;
                                }
                            case 21: {
                                    message.captureStatusColor = $root.rv.data.Slide.Element.DataLink.CaptureStatusColor.decode(reader, reader.uint32());
                                    break;
                                }
                            case 22: {
                                    message.slideCount = $root.rv.data.Slide.Element.DataLink.SlideCount.decode(reader, reader.uint32());
                                    break;
                                }
                            case 23: {
                                    message.audioCountdown = $root.rv.data.Slide.Element.DataLink.AudioCountdown.decode(reader, reader.uint32());
                                    break;
                                }
                            case 24: {
                                    message.presentation = $root.rv.data.Slide.Element.DataLink.Presentation.decode(reader, reader.uint32());
                                    break;
                                }
                            case 25: {
                                    message.slide_Label_Text = $root.rv.data.Slide.Element.DataLink.SlideLabelText.decode(reader, reader.uint32());
                                    break;
                                }
                            case 26: {
                                    message.slide_Label_Color = $root.rv.data.Slide.Element.DataLink.SlideLabelColor.decode(reader, reader.uint32());
                                    break;
                                }
                            case 27: {
                                    message.rssFeed = $root.rv.data.Slide.Element.DataLink.RSSFeed.decode(reader, reader.uint32());
                                    break;
                                }
                            case 28: {
                                    message.fileFeed = $root.rv.data.Slide.Element.DataLink.FileFeed.decode(reader, reader.uint32());
                                    break;
                                }
                            case 29: {
                                    message.chordProChart = $root.rv.data.Slide.Element.DataLink.ChordProChart.decode(reader, reader.uint32());
                                    break;
                                }
                            case 30: {
                                    message.playbackMarkerText = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.decode(reader, reader.uint32());
                                    break;
                                }
                            case 32: {
                                    message.playbackMarkerColor = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.decode(reader, reader.uint32());
                                    break;
                                }
                            case 33: {
                                    message.timecodeText = $root.rv.data.Slide.Element.DataLink.TimecodeText.decode(reader, reader.uint32());
                                    break;
                                }
                            case 34: {
                                    message.timecodeStatus = $root.rv.data.Slide.Element.DataLink.TimecodeStatus.decode(reader, reader.uint32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a DataLink message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Slide.Element.DataLink
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Slide.Element.DataLink} DataLink
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DataLink.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a DataLink message.
                     * @function verify
                     * @memberof rv.data.Slide.Element.DataLink
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DataLink.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.ticker != null && message.hasOwnProperty("ticker")) {
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.Ticker.verify(message.ticker);
                                if (error)
                                    return "ticker." + error;
                            }
                        }
                        if (message.alternateText != null && message.hasOwnProperty("alternateText")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.AlternateElementText.verify(message.alternateText);
                                if (error)
                                    return "alternateText." + error;
                            }
                        }
                        if (message.timerText != null && message.hasOwnProperty("timerText")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.TimerText.verify(message.timerText);
                                if (error)
                                    return "timerText." + error;
                            }
                        }
                        if (message.clockText != null && message.hasOwnProperty("clockText")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.ClockText.verify(message.clockText);
                                if (error)
                                    return "clockText." + error;
                            }
                        }
                        if (message.chordChart != null && message.hasOwnProperty("chordChart")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.ChordChart.verify(message.chordChart);
                                if (error)
                                    return "chordChart." + error;
                            }
                        }
                        if (message.outputScreen != null && message.hasOwnProperty("outputScreen")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.OutputScreen.verify(message.outputScreen);
                                if (error)
                                    return "outputScreen." + error;
                            }
                        }
                        if (message.pcoLive != null && message.hasOwnProperty("pcoLive")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.PCOLive.verify(message.pcoLive);
                                if (error)
                                    return "pcoLive." + error;
                            }
                        }
                        if (message.alternateFill != null && message.hasOwnProperty("alternateFill")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.AlternateElementFill.verify(message.alternateFill);
                                if (error)
                                    return "alternateFill." + error;
                            }
                        }
                        if (message.visibilityLink != null && message.hasOwnProperty("visibilityLink")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.VisibilityLink.verify(message.visibilityLink);
                                if (error)
                                    return "visibilityLink." + error;
                            }
                        }
                        if (message.slideText != null && message.hasOwnProperty("slideText")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.SlideText.verify(message.slideText);
                                if (error)
                                    return "slideText." + error;
                            }
                        }
                        if (message.stageMessage != null && message.hasOwnProperty("stageMessage")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.StageMessage.verify(message.stageMessage);
                                if (error)
                                    return "stageMessage." + error;
                            }
                        }
                        if (message.videoCountdown != null && message.hasOwnProperty("videoCountdown")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.VideoCountdown.verify(message.videoCountdown);
                                if (error)
                                    return "videoCountdown." + error;
                            }
                        }
                        if (message.slideImage != null && message.hasOwnProperty("slideImage")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.SlideImage.verify(message.slideImage);
                                if (error)
                                    return "slideImage." + error;
                            }
                        }
                        if (message.ccliText != null && message.hasOwnProperty("ccliText")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.CCLIText.verify(message.ccliText);
                                if (error)
                                    return "ccliText." + error;
                            }
                        }
                        if (message.groupName != null && message.hasOwnProperty("groupName")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.GroupName.verify(message.groupName);
                                if (error)
                                    return "groupName." + error;
                            }
                        }
                        if (message.groupColor != null && message.hasOwnProperty("groupColor")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.GroupColor.verify(message.groupColor);
                                if (error)
                                    return "groupColor." + error;
                            }
                        }
                        if (message.presentationNotes != null && message.hasOwnProperty("presentationNotes")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.PresentationNotes.verify(message.presentationNotes);
                                if (error)
                                    return "presentationNotes." + error;
                            }
                        }
                        if (message.playlistItem != null && message.hasOwnProperty("playlistItem")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.PlaylistItem.verify(message.playlistItem);
                                if (error)
                                    return "playlistItem." + error;
                            }
                        }
                        if (message.autoAdvanceTimeRemaining != null && message.hasOwnProperty("autoAdvanceTimeRemaining")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining.verify(message.autoAdvanceTimeRemaining);
                                if (error)
                                    return "autoAdvanceTimeRemaining." + error;
                            }
                        }
                        if (message.captureStatusText != null && message.hasOwnProperty("captureStatusText")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.CaptureStatusText.verify(message.captureStatusText);
                                if (error)
                                    return "captureStatusText." + error;
                            }
                        }
                        if (message.captureStatusColor != null && message.hasOwnProperty("captureStatusColor")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.CaptureStatusColor.verify(message.captureStatusColor);
                                if (error)
                                    return "captureStatusColor." + error;
                            }
                        }
                        if (message.slideCount != null && message.hasOwnProperty("slideCount")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.SlideCount.verify(message.slideCount);
                                if (error)
                                    return "slideCount." + error;
                            }
                        }
                        if (message.audioCountdown != null && message.hasOwnProperty("audioCountdown")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.AudioCountdown.verify(message.audioCountdown);
                                if (error)
                                    return "audioCountdown." + error;
                            }
                        }
                        if (message.presentation != null && message.hasOwnProperty("presentation")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.Presentation.verify(message.presentation);
                                if (error)
                                    return "presentation." + error;
                            }
                        }
                        if (message.slide_Label_Text != null && message.hasOwnProperty("slide_Label_Text")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.SlideLabelText.verify(message.slide_Label_Text);
                                if (error)
                                    return "slide_Label_Text." + error;
                            }
                        }
                        if (message.slide_Label_Color != null && message.hasOwnProperty("slide_Label_Color")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.SlideLabelColor.verify(message.slide_Label_Color);
                                if (error)
                                    return "slide_Label_Color." + error;
                            }
                        }
                        if (message.rssFeed != null && message.hasOwnProperty("rssFeed")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.RSSFeed.verify(message.rssFeed);
                                if (error)
                                    return "rssFeed." + error;
                            }
                        }
                        if (message.fileFeed != null && message.hasOwnProperty("fileFeed")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.FileFeed.verify(message.fileFeed);
                                if (error)
                                    return "fileFeed." + error;
                            }
                        }
                        if (message.chordProChart != null && message.hasOwnProperty("chordProChart")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.ChordProChart.verify(message.chordProChart);
                                if (error)
                                    return "chordProChart." + error;
                            }
                        }
                        if (message.playbackMarkerText != null && message.hasOwnProperty("playbackMarkerText")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.verify(message.playbackMarkerText);
                                if (error)
                                    return "playbackMarkerText." + error;
                            }
                        }
                        if (message.playbackMarkerColor != null && message.hasOwnProperty("playbackMarkerColor")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.verify(message.playbackMarkerColor);
                                if (error)
                                    return "playbackMarkerColor." + error;
                            }
                        }
                        if (message.timecodeText != null && message.hasOwnProperty("timecodeText")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.TimecodeText.verify(message.timecodeText);
                                if (error)
                                    return "timecodeText." + error;
                            }
                        }
                        if (message.timecodeStatus != null && message.hasOwnProperty("timecodeStatus")) {
                            if (properties.PropertyType === 1)
                                return "PropertyType: multiple values";
                            properties.PropertyType = 1;
                            {
                                let error = $root.rv.data.Slide.Element.DataLink.TimecodeStatus.verify(message.timecodeStatus);
                                if (error)
                                    return "timecodeStatus." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a DataLink message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Slide.Element.DataLink
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Slide.Element.DataLink} DataLink
                     */
                    DataLink.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Slide.Element.DataLink)
                            return object;
                        let message = new $root.rv.data.Slide.Element.DataLink();
                        if (object.ticker != null) {
                            if (typeof object.ticker !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.ticker: object expected");
                            message.ticker = $root.rv.data.Slide.Element.DataLink.Ticker.fromObject(object.ticker);
                        }
                        if (object.alternateText != null) {
                            if (typeof object.alternateText !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.alternateText: object expected");
                            message.alternateText = $root.rv.data.Slide.Element.DataLink.AlternateElementText.fromObject(object.alternateText);
                        }
                        if (object.timerText != null) {
                            if (typeof object.timerText !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.timerText: object expected");
                            message.timerText = $root.rv.data.Slide.Element.DataLink.TimerText.fromObject(object.timerText);
                        }
                        if (object.clockText != null) {
                            if (typeof object.clockText !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.clockText: object expected");
                            message.clockText = $root.rv.data.Slide.Element.DataLink.ClockText.fromObject(object.clockText);
                        }
                        if (object.chordChart != null) {
                            if (typeof object.chordChart !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.chordChart: object expected");
                            message.chordChart = $root.rv.data.Slide.Element.DataLink.ChordChart.fromObject(object.chordChart);
                        }
                        if (object.outputScreen != null) {
                            if (typeof object.outputScreen !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.outputScreen: object expected");
                            message.outputScreen = $root.rv.data.Slide.Element.DataLink.OutputScreen.fromObject(object.outputScreen);
                        }
                        if (object.pcoLive != null) {
                            if (typeof object.pcoLive !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.pcoLive: object expected");
                            message.pcoLive = $root.rv.data.Slide.Element.DataLink.PCOLive.fromObject(object.pcoLive);
                        }
                        if (object.alternateFill != null) {
                            if (typeof object.alternateFill !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.alternateFill: object expected");
                            message.alternateFill = $root.rv.data.Slide.Element.DataLink.AlternateElementFill.fromObject(object.alternateFill);
                        }
                        if (object.visibilityLink != null) {
                            if (typeof object.visibilityLink !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.visibilityLink: object expected");
                            message.visibilityLink = $root.rv.data.Slide.Element.DataLink.VisibilityLink.fromObject(object.visibilityLink);
                        }
                        if (object.slideText != null) {
                            if (typeof object.slideText !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.slideText: object expected");
                            message.slideText = $root.rv.data.Slide.Element.DataLink.SlideText.fromObject(object.slideText);
                        }
                        if (object.stageMessage != null) {
                            if (typeof object.stageMessage !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.stageMessage: object expected");
                            message.stageMessage = $root.rv.data.Slide.Element.DataLink.StageMessage.fromObject(object.stageMessage);
                        }
                        if (object.videoCountdown != null) {
                            if (typeof object.videoCountdown !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.videoCountdown: object expected");
                            message.videoCountdown = $root.rv.data.Slide.Element.DataLink.VideoCountdown.fromObject(object.videoCountdown);
                        }
                        if (object.slideImage != null) {
                            if (typeof object.slideImage !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.slideImage: object expected");
                            message.slideImage = $root.rv.data.Slide.Element.DataLink.SlideImage.fromObject(object.slideImage);
                        }
                        if (object.ccliText != null) {
                            if (typeof object.ccliText !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.ccliText: object expected");
                            message.ccliText = $root.rv.data.Slide.Element.DataLink.CCLIText.fromObject(object.ccliText);
                        }
                        if (object.groupName != null) {
                            if (typeof object.groupName !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.groupName: object expected");
                            message.groupName = $root.rv.data.Slide.Element.DataLink.GroupName.fromObject(object.groupName);
                        }
                        if (object.groupColor != null) {
                            if (typeof object.groupColor !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.groupColor: object expected");
                            message.groupColor = $root.rv.data.Slide.Element.DataLink.GroupColor.fromObject(object.groupColor);
                        }
                        if (object.presentationNotes != null) {
                            if (typeof object.presentationNotes !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.presentationNotes: object expected");
                            message.presentationNotes = $root.rv.data.Slide.Element.DataLink.PresentationNotes.fromObject(object.presentationNotes);
                        }
                        if (object.playlistItem != null) {
                            if (typeof object.playlistItem !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.playlistItem: object expected");
                            message.playlistItem = $root.rv.data.Slide.Element.DataLink.PlaylistItem.fromObject(object.playlistItem);
                        }
                        if (object.autoAdvanceTimeRemaining != null) {
                            if (typeof object.autoAdvanceTimeRemaining !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.autoAdvanceTimeRemaining: object expected");
                            message.autoAdvanceTimeRemaining = $root.rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining.fromObject(object.autoAdvanceTimeRemaining);
                        }
                        if (object.captureStatusText != null) {
                            if (typeof object.captureStatusText !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.captureStatusText: object expected");
                            message.captureStatusText = $root.rv.data.Slide.Element.DataLink.CaptureStatusText.fromObject(object.captureStatusText);
                        }
                        if (object.captureStatusColor != null) {
                            if (typeof object.captureStatusColor !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.captureStatusColor: object expected");
                            message.captureStatusColor = $root.rv.data.Slide.Element.DataLink.CaptureStatusColor.fromObject(object.captureStatusColor);
                        }
                        if (object.slideCount != null) {
                            if (typeof object.slideCount !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.slideCount: object expected");
                            message.slideCount = $root.rv.data.Slide.Element.DataLink.SlideCount.fromObject(object.slideCount);
                        }
                        if (object.audioCountdown != null) {
                            if (typeof object.audioCountdown !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.audioCountdown: object expected");
                            message.audioCountdown = $root.rv.data.Slide.Element.DataLink.AudioCountdown.fromObject(object.audioCountdown);
                        }
                        if (object.presentation != null) {
                            if (typeof object.presentation !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.presentation: object expected");
                            message.presentation = $root.rv.data.Slide.Element.DataLink.Presentation.fromObject(object.presentation);
                        }
                        if (object.slide_Label_Text != null) {
                            if (typeof object.slide_Label_Text !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.slide_Label_Text: object expected");
                            message.slide_Label_Text = $root.rv.data.Slide.Element.DataLink.SlideLabelText.fromObject(object.slide_Label_Text);
                        }
                        if (object.slide_Label_Color != null) {
                            if (typeof object.slide_Label_Color !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.slide_Label_Color: object expected");
                            message.slide_Label_Color = $root.rv.data.Slide.Element.DataLink.SlideLabelColor.fromObject(object.slide_Label_Color);
                        }
                        if (object.rssFeed != null) {
                            if (typeof object.rssFeed !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.rssFeed: object expected");
                            message.rssFeed = $root.rv.data.Slide.Element.DataLink.RSSFeed.fromObject(object.rssFeed);
                        }
                        if (object.fileFeed != null) {
                            if (typeof object.fileFeed !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.fileFeed: object expected");
                            message.fileFeed = $root.rv.data.Slide.Element.DataLink.FileFeed.fromObject(object.fileFeed);
                        }
                        if (object.chordProChart != null) {
                            if (typeof object.chordProChart !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.chordProChart: object expected");
                            message.chordProChart = $root.rv.data.Slide.Element.DataLink.ChordProChart.fromObject(object.chordProChart);
                        }
                        if (object.playbackMarkerText != null) {
                            if (typeof object.playbackMarkerText !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.playbackMarkerText: object expected");
                            message.playbackMarkerText = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.fromObject(object.playbackMarkerText);
                        }
                        if (object.playbackMarkerColor != null) {
                            if (typeof object.playbackMarkerColor !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.playbackMarkerColor: object expected");
                            message.playbackMarkerColor = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.fromObject(object.playbackMarkerColor);
                        }
                        if (object.timecodeText != null) {
                            if (typeof object.timecodeText !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.timecodeText: object expected");
                            message.timecodeText = $root.rv.data.Slide.Element.DataLink.TimecodeText.fromObject(object.timecodeText);
                        }
                        if (object.timecodeStatus != null) {
                            if (typeof object.timecodeStatus !== "object")
                                throw TypeError(".rv.data.Slide.Element.DataLink.timecodeStatus: object expected");
                            message.timecodeStatus = $root.rv.data.Slide.Element.DataLink.TimecodeStatus.fromObject(object.timecodeStatus);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a DataLink message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Slide.Element.DataLink
                     * @static
                     * @param {rv.data.Slide.Element.DataLink} message DataLink
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DataLink.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (message.ticker != null && message.hasOwnProperty("ticker")) {
                            object.ticker = $root.rv.data.Slide.Element.DataLink.Ticker.toObject(message.ticker, options);
                            if (options.oneofs)
                                object.PropertyType = "ticker";
                        }
                        if (message.alternateText != null && message.hasOwnProperty("alternateText")) {
                            object.alternateText = $root.rv.data.Slide.Element.DataLink.AlternateElementText.toObject(message.alternateText, options);
                            if (options.oneofs)
                                object.PropertyType = "alternateText";
                        }
                        if (message.timerText != null && message.hasOwnProperty("timerText")) {
                            object.timerText = $root.rv.data.Slide.Element.DataLink.TimerText.toObject(message.timerText, options);
                            if (options.oneofs)
                                object.PropertyType = "timerText";
                        }
                        if (message.clockText != null && message.hasOwnProperty("clockText")) {
                            object.clockText = $root.rv.data.Slide.Element.DataLink.ClockText.toObject(message.clockText, options);
                            if (options.oneofs)
                                object.PropertyType = "clockText";
                        }
                        if (message.chordChart != null && message.hasOwnProperty("chordChart")) {
                            object.chordChart = $root.rv.data.Slide.Element.DataLink.ChordChart.toObject(message.chordChart, options);
                            if (options.oneofs)
                                object.PropertyType = "chordChart";
                        }
                        if (message.outputScreen != null && message.hasOwnProperty("outputScreen")) {
                            object.outputScreen = $root.rv.data.Slide.Element.DataLink.OutputScreen.toObject(message.outputScreen, options);
                            if (options.oneofs)
                                object.PropertyType = "outputScreen";
                        }
                        if (message.pcoLive != null && message.hasOwnProperty("pcoLive")) {
                            object.pcoLive = $root.rv.data.Slide.Element.DataLink.PCOLive.toObject(message.pcoLive, options);
                            if (options.oneofs)
                                object.PropertyType = "pcoLive";
                        }
                        if (message.alternateFill != null && message.hasOwnProperty("alternateFill")) {
                            object.alternateFill = $root.rv.data.Slide.Element.DataLink.AlternateElementFill.toObject(message.alternateFill, options);
                            if (options.oneofs)
                                object.PropertyType = "alternateFill";
                        }
                        if (message.visibilityLink != null && message.hasOwnProperty("visibilityLink")) {
                            object.visibilityLink = $root.rv.data.Slide.Element.DataLink.VisibilityLink.toObject(message.visibilityLink, options);
                            if (options.oneofs)
                                object.PropertyType = "visibilityLink";
                        }
                        if (message.slideText != null && message.hasOwnProperty("slideText")) {
                            object.slideText = $root.rv.data.Slide.Element.DataLink.SlideText.toObject(message.slideText, options);
                            if (options.oneofs)
                                object.PropertyType = "slideText";
                        }
                        if (message.stageMessage != null && message.hasOwnProperty("stageMessage")) {
                            object.stageMessage = $root.rv.data.Slide.Element.DataLink.StageMessage.toObject(message.stageMessage, options);
                            if (options.oneofs)
                                object.PropertyType = "stageMessage";
                        }
                        if (message.videoCountdown != null && message.hasOwnProperty("videoCountdown")) {
                            object.videoCountdown = $root.rv.data.Slide.Element.DataLink.VideoCountdown.toObject(message.videoCountdown, options);
                            if (options.oneofs)
                                object.PropertyType = "videoCountdown";
                        }
                        if (message.slideImage != null && message.hasOwnProperty("slideImage")) {
                            object.slideImage = $root.rv.data.Slide.Element.DataLink.SlideImage.toObject(message.slideImage, options);
                            if (options.oneofs)
                                object.PropertyType = "slideImage";
                        }
                        if (message.ccliText != null && message.hasOwnProperty("ccliText")) {
                            object.ccliText = $root.rv.data.Slide.Element.DataLink.CCLIText.toObject(message.ccliText, options);
                            if (options.oneofs)
                                object.PropertyType = "ccliText";
                        }
                        if (message.groupName != null && message.hasOwnProperty("groupName")) {
                            object.groupName = $root.rv.data.Slide.Element.DataLink.GroupName.toObject(message.groupName, options);
                            if (options.oneofs)
                                object.PropertyType = "groupName";
                        }
                        if (message.groupColor != null && message.hasOwnProperty("groupColor")) {
                            object.groupColor = $root.rv.data.Slide.Element.DataLink.GroupColor.toObject(message.groupColor, options);
                            if (options.oneofs)
                                object.PropertyType = "groupColor";
                        }
                        if (message.presentationNotes != null && message.hasOwnProperty("presentationNotes")) {
                            object.presentationNotes = $root.rv.data.Slide.Element.DataLink.PresentationNotes.toObject(message.presentationNotes, options);
                            if (options.oneofs)
                                object.PropertyType = "presentationNotes";
                        }
                        if (message.playlistItem != null && message.hasOwnProperty("playlistItem")) {
                            object.playlistItem = $root.rv.data.Slide.Element.DataLink.PlaylistItem.toObject(message.playlistItem, options);
                            if (options.oneofs)
                                object.PropertyType = "playlistItem";
                        }
                        if (message.autoAdvanceTimeRemaining != null && message.hasOwnProperty("autoAdvanceTimeRemaining")) {
                            object.autoAdvanceTimeRemaining = $root.rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining.toObject(message.autoAdvanceTimeRemaining, options);
                            if (options.oneofs)
                                object.PropertyType = "autoAdvanceTimeRemaining";
                        }
                        if (message.captureStatusText != null && message.hasOwnProperty("captureStatusText")) {
                            object.captureStatusText = $root.rv.data.Slide.Element.DataLink.CaptureStatusText.toObject(message.captureStatusText, options);
                            if (options.oneofs)
                                object.PropertyType = "captureStatusText";
                        }
                        if (message.captureStatusColor != null && message.hasOwnProperty("captureStatusColor")) {
                            object.captureStatusColor = $root.rv.data.Slide.Element.DataLink.CaptureStatusColor.toObject(message.captureStatusColor, options);
                            if (options.oneofs)
                                object.PropertyType = "captureStatusColor";
                        }
                        if (message.slideCount != null && message.hasOwnProperty("slideCount")) {
                            object.slideCount = $root.rv.data.Slide.Element.DataLink.SlideCount.toObject(message.slideCount, options);
                            if (options.oneofs)
                                object.PropertyType = "slideCount";
                        }
                        if (message.audioCountdown != null && message.hasOwnProperty("audioCountdown")) {
                            object.audioCountdown = $root.rv.data.Slide.Element.DataLink.AudioCountdown.toObject(message.audioCountdown, options);
                            if (options.oneofs)
                                object.PropertyType = "audioCountdown";
                        }
                        if (message.presentation != null && message.hasOwnProperty("presentation")) {
                            object.presentation = $root.rv.data.Slide.Element.DataLink.Presentation.toObject(message.presentation, options);
                            if (options.oneofs)
                                object.PropertyType = "presentation";
                        }
                        if (message.slide_Label_Text != null && message.hasOwnProperty("slide_Label_Text")) {
                            object.slide_Label_Text = $root.rv.data.Slide.Element.DataLink.SlideLabelText.toObject(message.slide_Label_Text, options);
                            if (options.oneofs)
                                object.PropertyType = "slide_Label_Text";
                        }
                        if (message.slide_Label_Color != null && message.hasOwnProperty("slide_Label_Color")) {
                            object.slide_Label_Color = $root.rv.data.Slide.Element.DataLink.SlideLabelColor.toObject(message.slide_Label_Color, options);
                            if (options.oneofs)
                                object.PropertyType = "slide_Label_Color";
                        }
                        if (message.rssFeed != null && message.hasOwnProperty("rssFeed")) {
                            object.rssFeed = $root.rv.data.Slide.Element.DataLink.RSSFeed.toObject(message.rssFeed, options);
                            if (options.oneofs)
                                object.PropertyType = "rssFeed";
                        }
                        if (message.fileFeed != null && message.hasOwnProperty("fileFeed")) {
                            object.fileFeed = $root.rv.data.Slide.Element.DataLink.FileFeed.toObject(message.fileFeed, options);
                            if (options.oneofs)
                                object.PropertyType = "fileFeed";
                        }
                        if (message.chordProChart != null && message.hasOwnProperty("chordProChart")) {
                            object.chordProChart = $root.rv.data.Slide.Element.DataLink.ChordProChart.toObject(message.chordProChart, options);
                            if (options.oneofs)
                                object.PropertyType = "chordProChart";
                        }
                        if (message.playbackMarkerText != null && message.hasOwnProperty("playbackMarkerText")) {
                            object.playbackMarkerText = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.toObject(message.playbackMarkerText, options);
                            if (options.oneofs)
                                object.PropertyType = "playbackMarkerText";
                        }
                        if (message.playbackMarkerColor != null && message.hasOwnProperty("playbackMarkerColor")) {
                            object.playbackMarkerColor = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.toObject(message.playbackMarkerColor, options);
                            if (options.oneofs)
                                object.PropertyType = "playbackMarkerColor";
                        }
                        if (message.timecodeText != null && message.hasOwnProperty("timecodeText")) {
                            object.timecodeText = $root.rv.data.Slide.Element.DataLink.TimecodeText.toObject(message.timecodeText, options);
                            if (options.oneofs)
                                object.PropertyType = "timecodeText";
                        }
                        if (message.timecodeStatus != null && message.hasOwnProperty("timecodeStatus")) {
                            object.timecodeStatus = $root.rv.data.Slide.Element.DataLink.TimecodeStatus.toObject(message.timecodeStatus, options);
                            if (options.oneofs)
                                object.PropertyType = "timecodeStatus";
                        }
                        return object;
                    };

                    /**
                     * Converts this DataLink to JSON.
                     * @function toJSON
                     * @memberof rv.data.Slide.Element.DataLink
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DataLink.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for DataLink
                     * @function getTypeUrl
                     * @memberof rv.data.Slide.Element.DataLink
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    DataLink.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Slide.Element.DataLink";
                    };

                    DataLink.RSSFeed = (function() {

                        /**
                         * Properties of a RSSFeed.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IRSSFeed
                         * @property {rv.data.IURL|null} [url] RSSFeed url
                         * @property {rv.data.Slide.Element.DataLink.RSSFeed.ContentType|null} [content] RSSFeed content
                         * @property {string|null} [textDelimiter] RSSFeed textDelimiter
                         */

                        /**
                         * Constructs a new RSSFeed.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a RSSFeed.
                         * @implements IRSSFeed
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IRSSFeed=} [properties] Properties to set
                         */
                        function RSSFeed(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * RSSFeed url.
                         * @member {rv.data.IURL|null|undefined} url
                         * @memberof rv.data.Slide.Element.DataLink.RSSFeed
                         * @instance
                         */
                        RSSFeed.prototype.url = null;

                        /**
                         * RSSFeed content.
                         * @member {rv.data.Slide.Element.DataLink.RSSFeed.ContentType} content
                         * @memberof rv.data.Slide.Element.DataLink.RSSFeed
                         * @instance
                         */
                        RSSFeed.prototype.content = 0;

                        /**
                         * RSSFeed textDelimiter.
                         * @member {string} textDelimiter
                         * @memberof rv.data.Slide.Element.DataLink.RSSFeed
                         * @instance
                         */
                        RSSFeed.prototype.textDelimiter = "";

                        /**
                         * Creates a new RSSFeed instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.RSSFeed
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IRSSFeed=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.RSSFeed} RSSFeed instance
                         */
                        RSSFeed.create = function create(properties) {
                            return new RSSFeed(properties);
                        };

                        /**
                         * Encodes the specified RSSFeed message. Does not implicitly {@link rv.data.Slide.Element.DataLink.RSSFeed.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.RSSFeed
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IRSSFeed} message RSSFeed message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        RSSFeed.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                                $root.rv.data.URL.encode(message.url, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.content);
                            if (message.textDelimiter != null && Object.hasOwnProperty.call(message, "textDelimiter"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.textDelimiter);
                            return writer;
                        };

                        /**
                         * Encodes the specified RSSFeed message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.RSSFeed.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.RSSFeed
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IRSSFeed} message RSSFeed message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        RSSFeed.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a RSSFeed message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.RSSFeed
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.RSSFeed} RSSFeed
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        RSSFeed.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.RSSFeed();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.url = $root.rv.data.URL.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.content = reader.int32();
                                        break;
                                    }
                                case 3: {
                                        message.textDelimiter = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a RSSFeed message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.RSSFeed
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.RSSFeed} RSSFeed
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        RSSFeed.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a RSSFeed message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.RSSFeed
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        RSSFeed.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.url != null && message.hasOwnProperty("url")) {
                                let error = $root.rv.data.URL.verify(message.url);
                                if (error)
                                    return "url." + error;
                            }
                            if (message.content != null && message.hasOwnProperty("content"))
                                switch (message.content) {
                                default:
                                    return "content: enum value expected";
                                case 0:
                                case 1:
                                    break;
                                }
                            if (message.textDelimiter != null && message.hasOwnProperty("textDelimiter"))
                                if (!$util.isString(message.textDelimiter))
                                    return "textDelimiter: string expected";
                            return null;
                        };

                        /**
                         * Creates a RSSFeed message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.RSSFeed
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.RSSFeed} RSSFeed
                         */
                        RSSFeed.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.RSSFeed)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.RSSFeed();
                            if (object.url != null) {
                                if (typeof object.url !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.RSSFeed.url: object expected");
                                message.url = $root.rv.data.URL.fromObject(object.url);
                            }
                            switch (object.content) {
                            default:
                                if (typeof object.content === "number") {
                                    message.content = object.content;
                                    break;
                                }
                                break;
                            case "CONTENT_TYPE_TITLE_ONLY":
                            case 0:
                                message.content = 0;
                                break;
                            case "CONTENT_TYPE_TITLE_AND_DESCRIPTION":
                            case 1:
                                message.content = 1;
                                break;
                            }
                            if (object.textDelimiter != null)
                                message.textDelimiter = String(object.textDelimiter);
                            return message;
                        };

                        /**
                         * Creates a plain object from a RSSFeed message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.RSSFeed
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.RSSFeed} message RSSFeed
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        RSSFeed.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.url = null;
                                object.content = options.enums === String ? "CONTENT_TYPE_TITLE_ONLY" : 0;
                                object.textDelimiter = "";
                            }
                            if (message.url != null && message.hasOwnProperty("url"))
                                object.url = $root.rv.data.URL.toObject(message.url, options);
                            if (message.content != null && message.hasOwnProperty("content"))
                                object.content = options.enums === String ? $root.rv.data.Slide.Element.DataLink.RSSFeed.ContentType[message.content] === undefined ? message.content : $root.rv.data.Slide.Element.DataLink.RSSFeed.ContentType[message.content] : message.content;
                            if (message.textDelimiter != null && message.hasOwnProperty("textDelimiter"))
                                object.textDelimiter = message.textDelimiter;
                            return object;
                        };

                        /**
                         * Converts this RSSFeed to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.RSSFeed
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        RSSFeed.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for RSSFeed
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.RSSFeed
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        RSSFeed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.RSSFeed";
                        };

                        /**
                         * ContentType enum.
                         * @name rv.data.Slide.Element.DataLink.RSSFeed.ContentType
                         * @enum {number}
                         * @property {number} CONTENT_TYPE_TITLE_ONLY=0 CONTENT_TYPE_TITLE_ONLY value
                         * @property {number} CONTENT_TYPE_TITLE_AND_DESCRIPTION=1 CONTENT_TYPE_TITLE_AND_DESCRIPTION value
                         */
                        RSSFeed.ContentType = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "CONTENT_TYPE_TITLE_ONLY"] = 0;
                            values[valuesById[1] = "CONTENT_TYPE_TITLE_AND_DESCRIPTION"] = 1;
                            return values;
                        })();

                        return RSSFeed;
                    })();

                    DataLink.FileFeed = (function() {

                        /**
                         * Properties of a FileFeed.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IFileFeed
                         * @property {rv.data.IURL|null} [url] FileFeed url
                         */

                        /**
                         * Constructs a new FileFeed.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a FileFeed.
                         * @implements IFileFeed
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IFileFeed=} [properties] Properties to set
                         */
                        function FileFeed(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * FileFeed url.
                         * @member {rv.data.IURL|null|undefined} url
                         * @memberof rv.data.Slide.Element.DataLink.FileFeed
                         * @instance
                         */
                        FileFeed.prototype.url = null;

                        /**
                         * Creates a new FileFeed instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.FileFeed
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IFileFeed=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.FileFeed} FileFeed instance
                         */
                        FileFeed.create = function create(properties) {
                            return new FileFeed(properties);
                        };

                        /**
                         * Encodes the specified FileFeed message. Does not implicitly {@link rv.data.Slide.Element.DataLink.FileFeed.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.FileFeed
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IFileFeed} message FileFeed message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FileFeed.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                                $root.rv.data.URL.encode(message.url, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified FileFeed message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.FileFeed.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.FileFeed
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IFileFeed} message FileFeed message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FileFeed.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a FileFeed message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.FileFeed
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.FileFeed} FileFeed
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FileFeed.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.FileFeed();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.url = $root.rv.data.URL.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a FileFeed message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.FileFeed
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.FileFeed} FileFeed
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FileFeed.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a FileFeed message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.FileFeed
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        FileFeed.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.url != null && message.hasOwnProperty("url")) {
                                let error = $root.rv.data.URL.verify(message.url);
                                if (error)
                                    return "url." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a FileFeed message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.FileFeed
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.FileFeed} FileFeed
                         */
                        FileFeed.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.FileFeed)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.FileFeed();
                            if (object.url != null) {
                                if (typeof object.url !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.FileFeed.url: object expected");
                                message.url = $root.rv.data.URL.fromObject(object.url);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a FileFeed message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.FileFeed
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.FileFeed} message FileFeed
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        FileFeed.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.url = null;
                            if (message.url != null && message.hasOwnProperty("url"))
                                object.url = $root.rv.data.URL.toObject(message.url, options);
                            return object;
                        };

                        /**
                         * Converts this FileFeed to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.FileFeed
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        FileFeed.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for FileFeed
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.FileFeed
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        FileFeed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.FileFeed";
                        };

                        return FileFeed;
                    })();

                    DataLink.Ticker = (function() {

                        /**
                         * Properties of a Ticker.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface ITicker
                         * @property {number|null} [playRate] Ticker playRate
                         * @property {boolean|null} [shouldLoop] Ticker shouldLoop
                         * @property {number|null} [loopDelay] Ticker loopDelay
                         * @property {string|null} [textDelimiter] Ticker textDelimiter
                         * @property {rv.data.Slide.Element.DataLink.Ticker.ITextType|null} [textType] Ticker textType
                         * @property {rv.data.Slide.Element.DataLink.Ticker.IRSSType|null} [rssType] Ticker rssType
                         * @property {rv.data.Slide.Element.DataLink.Ticker.IFileType|null} [fileType] Ticker fileType
                         */

                        /**
                         * Constructs a new Ticker.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a Ticker.
                         * @implements ITicker
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.ITicker=} [properties] Properties to set
                         */
                        function Ticker(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Ticker playRate.
                         * @member {number} playRate
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @instance
                         */
                        Ticker.prototype.playRate = 0;

                        /**
                         * Ticker shouldLoop.
                         * @member {boolean} shouldLoop
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @instance
                         */
                        Ticker.prototype.shouldLoop = false;

                        /**
                         * Ticker loopDelay.
                         * @member {number} loopDelay
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @instance
                         */
                        Ticker.prototype.loopDelay = 0;

                        /**
                         * Ticker textDelimiter.
                         * @member {string} textDelimiter
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @instance
                         */
                        Ticker.prototype.textDelimiter = "";

                        /**
                         * Ticker textType.
                         * @member {rv.data.Slide.Element.DataLink.Ticker.ITextType|null|undefined} textType
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @instance
                         */
                        Ticker.prototype.textType = null;

                        /**
                         * Ticker rssType.
                         * @member {rv.data.Slide.Element.DataLink.Ticker.IRSSType|null|undefined} rssType
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @instance
                         */
                        Ticker.prototype.rssType = null;

                        /**
                         * Ticker fileType.
                         * @member {rv.data.Slide.Element.DataLink.Ticker.IFileType|null|undefined} fileType
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @instance
                         */
                        Ticker.prototype.fileType = null;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * Ticker SourceType.
                         * @member {"textType"|"rssType"|"fileType"|undefined} SourceType
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @instance
                         */
                        Object.defineProperty(Ticker.prototype, "SourceType", {
                            get: $util.oneOfGetter($oneOfFields = ["textType", "rssType", "fileType"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Creates a new Ticker instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ITicker=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.Ticker} Ticker instance
                         */
                        Ticker.create = function create(properties) {
                            return new Ticker(properties);
                        };

                        /**
                         * Encodes the specified Ticker message. Does not implicitly {@link rv.data.Slide.Element.DataLink.Ticker.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ITicker} message Ticker message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Ticker.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.textType != null && Object.hasOwnProperty.call(message, "textType"))
                                $root.rv.data.Slide.Element.DataLink.Ticker.TextType.encode(message.textType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.rssType != null && Object.hasOwnProperty.call(message, "rssType"))
                                $root.rv.data.Slide.Element.DataLink.Ticker.RSSType.encode(message.rssType, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.fileType != null && Object.hasOwnProperty.call(message, "fileType"))
                                $root.rv.data.Slide.Element.DataLink.Ticker.FileType.encode(message.fileType, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.playRate != null && Object.hasOwnProperty.call(message, "playRate"))
                                writer.uint32(/* id 4, wireType 1 =*/33).double(message.playRate);
                            if (message.shouldLoop != null && Object.hasOwnProperty.call(message, "shouldLoop"))
                                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.shouldLoop);
                            if (message.loopDelay != null && Object.hasOwnProperty.call(message, "loopDelay"))
                                writer.uint32(/* id 6, wireType 1 =*/49).double(message.loopDelay);
                            if (message.textDelimiter != null && Object.hasOwnProperty.call(message, "textDelimiter"))
                                writer.uint32(/* id 7, wireType 2 =*/58).string(message.textDelimiter);
                            return writer;
                        };

                        /**
                         * Encodes the specified Ticker message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.Ticker.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ITicker} message Ticker message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Ticker.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Ticker message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.Ticker} Ticker
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Ticker.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.Ticker();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 4: {
                                        message.playRate = reader.double();
                                        break;
                                    }
                                case 5: {
                                        message.shouldLoop = reader.bool();
                                        break;
                                    }
                                case 6: {
                                        message.loopDelay = reader.double();
                                        break;
                                    }
                                case 7: {
                                        message.textDelimiter = reader.string();
                                        break;
                                    }
                                case 1: {
                                        message.textType = $root.rv.data.Slide.Element.DataLink.Ticker.TextType.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.rssType = $root.rv.data.Slide.Element.DataLink.Ticker.RSSType.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 3: {
                                        message.fileType = $root.rv.data.Slide.Element.DataLink.Ticker.FileType.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Ticker message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.Ticker} Ticker
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Ticker.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Ticker message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Ticker.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.playRate != null && message.hasOwnProperty("playRate"))
                                if (typeof message.playRate !== "number")
                                    return "playRate: number expected";
                            if (message.shouldLoop != null && message.hasOwnProperty("shouldLoop"))
                                if (typeof message.shouldLoop !== "boolean")
                                    return "shouldLoop: boolean expected";
                            if (message.loopDelay != null && message.hasOwnProperty("loopDelay"))
                                if (typeof message.loopDelay !== "number")
                                    return "loopDelay: number expected";
                            if (message.textDelimiter != null && message.hasOwnProperty("textDelimiter"))
                                if (!$util.isString(message.textDelimiter))
                                    return "textDelimiter: string expected";
                            if (message.textType != null && message.hasOwnProperty("textType")) {
                                properties.SourceType = 1;
                                {
                                    let error = $root.rv.data.Slide.Element.DataLink.Ticker.TextType.verify(message.textType);
                                    if (error)
                                        return "textType." + error;
                                }
                            }
                            if (message.rssType != null && message.hasOwnProperty("rssType")) {
                                if (properties.SourceType === 1)
                                    return "SourceType: multiple values";
                                properties.SourceType = 1;
                                {
                                    let error = $root.rv.data.Slide.Element.DataLink.Ticker.RSSType.verify(message.rssType);
                                    if (error)
                                        return "rssType." + error;
                                }
                            }
                            if (message.fileType != null && message.hasOwnProperty("fileType")) {
                                if (properties.SourceType === 1)
                                    return "SourceType: multiple values";
                                properties.SourceType = 1;
                                {
                                    let error = $root.rv.data.Slide.Element.DataLink.Ticker.FileType.verify(message.fileType);
                                    if (error)
                                        return "fileType." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Ticker message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.Ticker} Ticker
                         */
                        Ticker.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.Ticker)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.Ticker();
                            if (object.playRate != null)
                                message.playRate = Number(object.playRate);
                            if (object.shouldLoop != null)
                                message.shouldLoop = Boolean(object.shouldLoop);
                            if (object.loopDelay != null)
                                message.loopDelay = Number(object.loopDelay);
                            if (object.textDelimiter != null)
                                message.textDelimiter = String(object.textDelimiter);
                            if (object.textType != null) {
                                if (typeof object.textType !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.Ticker.textType: object expected");
                                message.textType = $root.rv.data.Slide.Element.DataLink.Ticker.TextType.fromObject(object.textType);
                            }
                            if (object.rssType != null) {
                                if (typeof object.rssType !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.Ticker.rssType: object expected");
                                message.rssType = $root.rv.data.Slide.Element.DataLink.Ticker.RSSType.fromObject(object.rssType);
                            }
                            if (object.fileType != null) {
                                if (typeof object.fileType !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.Ticker.fileType: object expected");
                                message.fileType = $root.rv.data.Slide.Element.DataLink.Ticker.FileType.fromObject(object.fileType);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Ticker message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.Ticker} message Ticker
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Ticker.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.playRate = 0;
                                object.shouldLoop = false;
                                object.loopDelay = 0;
                                object.textDelimiter = "";
                            }
                            if (message.textType != null && message.hasOwnProperty("textType")) {
                                object.textType = $root.rv.data.Slide.Element.DataLink.Ticker.TextType.toObject(message.textType, options);
                                if (options.oneofs)
                                    object.SourceType = "textType";
                            }
                            if (message.rssType != null && message.hasOwnProperty("rssType")) {
                                object.rssType = $root.rv.data.Slide.Element.DataLink.Ticker.RSSType.toObject(message.rssType, options);
                                if (options.oneofs)
                                    object.SourceType = "rssType";
                            }
                            if (message.fileType != null && message.hasOwnProperty("fileType")) {
                                object.fileType = $root.rv.data.Slide.Element.DataLink.Ticker.FileType.toObject(message.fileType, options);
                                if (options.oneofs)
                                    object.SourceType = "fileType";
                            }
                            if (message.playRate != null && message.hasOwnProperty("playRate"))
                                object.playRate = options.json && !isFinite(message.playRate) ? String(message.playRate) : message.playRate;
                            if (message.shouldLoop != null && message.hasOwnProperty("shouldLoop"))
                                object.shouldLoop = message.shouldLoop;
                            if (message.loopDelay != null && message.hasOwnProperty("loopDelay"))
                                object.loopDelay = options.json && !isFinite(message.loopDelay) ? String(message.loopDelay) : message.loopDelay;
                            if (message.textDelimiter != null && message.hasOwnProperty("textDelimiter"))
                                object.textDelimiter = message.textDelimiter;
                            return object;
                        };

                        /**
                         * Converts this Ticker to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Ticker.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Ticker
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.Ticker
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Ticker.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.Ticker";
                        };

                        Ticker.TextType = (function() {

                            /**
                             * Properties of a TextType.
                             * @memberof rv.data.Slide.Element.DataLink.Ticker
                             * @interface ITextType
                             * @property {string|null} [text] TextType text
                             */

                            /**
                             * Constructs a new TextType.
                             * @memberof rv.data.Slide.Element.DataLink.Ticker
                             * @classdesc Represents a TextType.
                             * @implements ITextType
                             * @constructor
                             * @param {rv.data.Slide.Element.DataLink.Ticker.ITextType=} [properties] Properties to set
                             */
                            function TextType(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * TextType text.
                             * @member {string} text
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.TextType
                             * @instance
                             */
                            TextType.prototype.text = "";

                            /**
                             * Creates a new TextType instance using the specified properties.
                             * @function create
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.TextType
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.Ticker.ITextType=} [properties] Properties to set
                             * @returns {rv.data.Slide.Element.DataLink.Ticker.TextType} TextType instance
                             */
                            TextType.create = function create(properties) {
                                return new TextType(properties);
                            };

                            /**
                             * Encodes the specified TextType message. Does not implicitly {@link rv.data.Slide.Element.DataLink.Ticker.TextType.verify|verify} messages.
                             * @function encode
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.TextType
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.Ticker.ITextType} message TextType message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TextType.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                                return writer;
                            };

                            /**
                             * Encodes the specified TextType message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.Ticker.TextType.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.TextType
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.Ticker.ITextType} message TextType message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TextType.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a TextType message from the specified reader or buffer.
                             * @function decode
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.TextType
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {rv.data.Slide.Element.DataLink.Ticker.TextType} TextType
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TextType.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.Ticker.TextType();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.text = reader.string();
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a TextType message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.TextType
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {rv.data.Slide.Element.DataLink.Ticker.TextType} TextType
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TextType.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a TextType message.
                             * @function verify
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.TextType
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            TextType.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.text != null && message.hasOwnProperty("text"))
                                    if (!$util.isString(message.text))
                                        return "text: string expected";
                                return null;
                            };

                            /**
                             * Creates a TextType message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.TextType
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {rv.data.Slide.Element.DataLink.Ticker.TextType} TextType
                             */
                            TextType.fromObject = function fromObject(object) {
                                if (object instanceof $root.rv.data.Slide.Element.DataLink.Ticker.TextType)
                                    return object;
                                let message = new $root.rv.data.Slide.Element.DataLink.Ticker.TextType();
                                if (object.text != null)
                                    message.text = String(object.text);
                                return message;
                            };

                            /**
                             * Creates a plain object from a TextType message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.TextType
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.Ticker.TextType} message TextType
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            TextType.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults)
                                    object.text = "";
                                if (message.text != null && message.hasOwnProperty("text"))
                                    object.text = message.text;
                                return object;
                            };

                            /**
                             * Converts this TextType to JSON.
                             * @function toJSON
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.TextType
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            TextType.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for TextType
                             * @function getTypeUrl
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.TextType
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            TextType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.Ticker.TextType";
                            };

                            return TextType;
                        })();

                        Ticker.RSSType = (function() {

                            /**
                             * Properties of a RSSType.
                             * @memberof rv.data.Slide.Element.DataLink.Ticker
                             * @interface IRSSType
                             * @property {rv.data.IURL|null} [url] RSSType url
                             * @property {rv.data.Slide.Element.DataLink.Ticker.RSSType.ContentType|null} [content] RSSType content
                             */

                            /**
                             * Constructs a new RSSType.
                             * @memberof rv.data.Slide.Element.DataLink.Ticker
                             * @classdesc Represents a RSSType.
                             * @implements IRSSType
                             * @constructor
                             * @param {rv.data.Slide.Element.DataLink.Ticker.IRSSType=} [properties] Properties to set
                             */
                            function RSSType(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * RSSType url.
                             * @member {rv.data.IURL|null|undefined} url
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.RSSType
                             * @instance
                             */
                            RSSType.prototype.url = null;

                            /**
                             * RSSType content.
                             * @member {rv.data.Slide.Element.DataLink.Ticker.RSSType.ContentType} content
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.RSSType
                             * @instance
                             */
                            RSSType.prototype.content = 0;

                            /**
                             * Creates a new RSSType instance using the specified properties.
                             * @function create
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.RSSType
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.Ticker.IRSSType=} [properties] Properties to set
                             * @returns {rv.data.Slide.Element.DataLink.Ticker.RSSType} RSSType instance
                             */
                            RSSType.create = function create(properties) {
                                return new RSSType(properties);
                            };

                            /**
                             * Encodes the specified RSSType message. Does not implicitly {@link rv.data.Slide.Element.DataLink.Ticker.RSSType.verify|verify} messages.
                             * @function encode
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.RSSType
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.Ticker.IRSSType} message RSSType message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            RSSType.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                                    $root.rv.data.URL.encode(message.url, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.content);
                                return writer;
                            };

                            /**
                             * Encodes the specified RSSType message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.Ticker.RSSType.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.RSSType
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.Ticker.IRSSType} message RSSType message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            RSSType.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a RSSType message from the specified reader or buffer.
                             * @function decode
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.RSSType
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {rv.data.Slide.Element.DataLink.Ticker.RSSType} RSSType
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            RSSType.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.Ticker.RSSType();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.url = $root.rv.data.URL.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 2: {
                                            message.content = reader.int32();
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a RSSType message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.RSSType
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {rv.data.Slide.Element.DataLink.Ticker.RSSType} RSSType
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            RSSType.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a RSSType message.
                             * @function verify
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.RSSType
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            RSSType.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.url != null && message.hasOwnProperty("url")) {
                                    let error = $root.rv.data.URL.verify(message.url);
                                    if (error)
                                        return "url." + error;
                                }
                                if (message.content != null && message.hasOwnProperty("content"))
                                    switch (message.content) {
                                    default:
                                        return "content: enum value expected";
                                    case 0:
                                    case 1:
                                        break;
                                    }
                                return null;
                            };

                            /**
                             * Creates a RSSType message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.RSSType
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {rv.data.Slide.Element.DataLink.Ticker.RSSType} RSSType
                             */
                            RSSType.fromObject = function fromObject(object) {
                                if (object instanceof $root.rv.data.Slide.Element.DataLink.Ticker.RSSType)
                                    return object;
                                let message = new $root.rv.data.Slide.Element.DataLink.Ticker.RSSType();
                                if (object.url != null) {
                                    if (typeof object.url !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.Ticker.RSSType.url: object expected");
                                    message.url = $root.rv.data.URL.fromObject(object.url);
                                }
                                switch (object.content) {
                                default:
                                    if (typeof object.content === "number") {
                                        message.content = object.content;
                                        break;
                                    }
                                    break;
                                case "CONTENT_TYPE_TITLE_ONLY":
                                case 0:
                                    message.content = 0;
                                    break;
                                case "CONTENT_TYPE_TITLE_AND_DESCRIPTION":
                                case 1:
                                    message.content = 1;
                                    break;
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a RSSType message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.RSSType
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.Ticker.RSSType} message RSSType
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            RSSType.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.url = null;
                                    object.content = options.enums === String ? "CONTENT_TYPE_TITLE_ONLY" : 0;
                                }
                                if (message.url != null && message.hasOwnProperty("url"))
                                    object.url = $root.rv.data.URL.toObject(message.url, options);
                                if (message.content != null && message.hasOwnProperty("content"))
                                    object.content = options.enums === String ? $root.rv.data.Slide.Element.DataLink.Ticker.RSSType.ContentType[message.content] === undefined ? message.content : $root.rv.data.Slide.Element.DataLink.Ticker.RSSType.ContentType[message.content] : message.content;
                                return object;
                            };

                            /**
                             * Converts this RSSType to JSON.
                             * @function toJSON
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.RSSType
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            RSSType.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for RSSType
                             * @function getTypeUrl
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.RSSType
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            RSSType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.Ticker.RSSType";
                            };

                            /**
                             * ContentType enum.
                             * @name rv.data.Slide.Element.DataLink.Ticker.RSSType.ContentType
                             * @enum {number}
                             * @property {number} CONTENT_TYPE_TITLE_ONLY=0 CONTENT_TYPE_TITLE_ONLY value
                             * @property {number} CONTENT_TYPE_TITLE_AND_DESCRIPTION=1 CONTENT_TYPE_TITLE_AND_DESCRIPTION value
                             */
                            RSSType.ContentType = (function() {
                                const valuesById = {}, values = Object.create(valuesById);
                                values[valuesById[0] = "CONTENT_TYPE_TITLE_ONLY"] = 0;
                                values[valuesById[1] = "CONTENT_TYPE_TITLE_AND_DESCRIPTION"] = 1;
                                return values;
                            })();

                            return RSSType;
                        })();

                        Ticker.FileType = (function() {

                            /**
                             * Properties of a FileType.
                             * @memberof rv.data.Slide.Element.DataLink.Ticker
                             * @interface IFileType
                             * @property {rv.data.IURL|null} [url] FileType url
                             */

                            /**
                             * Constructs a new FileType.
                             * @memberof rv.data.Slide.Element.DataLink.Ticker
                             * @classdesc Represents a FileType.
                             * @implements IFileType
                             * @constructor
                             * @param {rv.data.Slide.Element.DataLink.Ticker.IFileType=} [properties] Properties to set
                             */
                            function FileType(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * FileType url.
                             * @member {rv.data.IURL|null|undefined} url
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.FileType
                             * @instance
                             */
                            FileType.prototype.url = null;

                            /**
                             * Creates a new FileType instance using the specified properties.
                             * @function create
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.FileType
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.Ticker.IFileType=} [properties] Properties to set
                             * @returns {rv.data.Slide.Element.DataLink.Ticker.FileType} FileType instance
                             */
                            FileType.create = function create(properties) {
                                return new FileType(properties);
                            };

                            /**
                             * Encodes the specified FileType message. Does not implicitly {@link rv.data.Slide.Element.DataLink.Ticker.FileType.verify|verify} messages.
                             * @function encode
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.FileType
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.Ticker.IFileType} message FileType message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            FileType.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                                    $root.rv.data.URL.encode(message.url, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified FileType message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.Ticker.FileType.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.FileType
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.Ticker.IFileType} message FileType message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            FileType.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a FileType message from the specified reader or buffer.
                             * @function decode
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.FileType
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {rv.data.Slide.Element.DataLink.Ticker.FileType} FileType
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            FileType.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.Ticker.FileType();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.url = $root.rv.data.URL.decode(reader, reader.uint32());
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a FileType message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.FileType
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {rv.data.Slide.Element.DataLink.Ticker.FileType} FileType
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            FileType.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a FileType message.
                             * @function verify
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.FileType
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            FileType.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.url != null && message.hasOwnProperty("url")) {
                                    let error = $root.rv.data.URL.verify(message.url);
                                    if (error)
                                        return "url." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a FileType message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.FileType
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {rv.data.Slide.Element.DataLink.Ticker.FileType} FileType
                             */
                            FileType.fromObject = function fromObject(object) {
                                if (object instanceof $root.rv.data.Slide.Element.DataLink.Ticker.FileType)
                                    return object;
                                let message = new $root.rv.data.Slide.Element.DataLink.Ticker.FileType();
                                if (object.url != null) {
                                    if (typeof object.url !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.Ticker.FileType.url: object expected");
                                    message.url = $root.rv.data.URL.fromObject(object.url);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a FileType message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.FileType
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.Ticker.FileType} message FileType
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            FileType.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults)
                                    object.url = null;
                                if (message.url != null && message.hasOwnProperty("url"))
                                    object.url = $root.rv.data.URL.toObject(message.url, options);
                                return object;
                            };

                            /**
                             * Converts this FileType to JSON.
                             * @function toJSON
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.FileType
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            FileType.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for FileType
                             * @function getTypeUrl
                             * @memberof rv.data.Slide.Element.DataLink.Ticker.FileType
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            FileType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.Ticker.FileType";
                            };

                            return FileType;
                        })();

                        return Ticker;
                    })();

                    DataLink.AlternateElementText = (function() {

                        /**
                         * Properties of an AlternateElementText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IAlternateElementText
                         * @property {rv.data.IUUID|null} [otherElementUuid] AlternateElementText otherElementUuid
                         * @property {string|null} [otherElementName] AlternateElementText otherElementName
                         * @property {number|null} [textTransformOptions] AlternateElementText textTransformOptions
                         * @property {rv.data.Slide.Element.DataLink.AlternateElementText.TextTransformOption|null} [textTransform] AlternateElementText textTransform
                         */

                        /**
                         * Constructs a new AlternateElementText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents an AlternateElementText.
                         * @implements IAlternateElementText
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IAlternateElementText=} [properties] Properties to set
                         */
                        function AlternateElementText(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * AlternateElementText otherElementUuid.
                         * @member {rv.data.IUUID|null|undefined} otherElementUuid
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @instance
                         */
                        AlternateElementText.prototype.otherElementUuid = null;

                        /**
                         * AlternateElementText otherElementName.
                         * @member {string} otherElementName
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @instance
                         */
                        AlternateElementText.prototype.otherElementName = "";

                        /**
                         * AlternateElementText textTransformOptions.
                         * @member {number} textTransformOptions
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @instance
                         */
                        AlternateElementText.prototype.textTransformOptions = 0;

                        /**
                         * AlternateElementText textTransform.
                         * @member {rv.data.Slide.Element.DataLink.AlternateElementText.TextTransformOption} textTransform
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @instance
                         */
                        AlternateElementText.prototype.textTransform = 0;

                        /**
                         * Creates a new AlternateElementText instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IAlternateElementText=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.AlternateElementText} AlternateElementText instance
                         */
                        AlternateElementText.create = function create(properties) {
                            return new AlternateElementText(properties);
                        };

                        /**
                         * Encodes the specified AlternateElementText message. Does not implicitly {@link rv.data.Slide.Element.DataLink.AlternateElementText.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IAlternateElementText} message AlternateElementText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        AlternateElementText.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.otherElementUuid != null && Object.hasOwnProperty.call(message, "otherElementUuid"))
                                $root.rv.data.UUID.encode(message.otherElementUuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.otherElementName != null && Object.hasOwnProperty.call(message, "otherElementName"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.otherElementName);
                            if (message.textTransformOptions != null && Object.hasOwnProperty.call(message, "textTransformOptions"))
                                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.textTransformOptions);
                            if (message.textTransform != null && Object.hasOwnProperty.call(message, "textTransform"))
                                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.textTransform);
                            return writer;
                        };

                        /**
                         * Encodes the specified AlternateElementText message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.AlternateElementText.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IAlternateElementText} message AlternateElementText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        AlternateElementText.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an AlternateElementText message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.AlternateElementText} AlternateElementText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        AlternateElementText.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.AlternateElementText();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.otherElementUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.otherElementName = reader.string();
                                        break;
                                    }
                                case 3: {
                                        message.textTransformOptions = reader.uint32();
                                        break;
                                    }
                                case 4: {
                                        message.textTransform = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an AlternateElementText message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.AlternateElementText} AlternateElementText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        AlternateElementText.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an AlternateElementText message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        AlternateElementText.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.otherElementUuid != null && message.hasOwnProperty("otherElementUuid")) {
                                let error = $root.rv.data.UUID.verify(message.otherElementUuid);
                                if (error)
                                    return "otherElementUuid." + error;
                            }
                            if (message.otherElementName != null && message.hasOwnProperty("otherElementName"))
                                if (!$util.isString(message.otherElementName))
                                    return "otherElementName: string expected";
                            if (message.textTransformOptions != null && message.hasOwnProperty("textTransformOptions"))
                                if (!$util.isInteger(message.textTransformOptions))
                                    return "textTransformOptions: integer expected";
                            if (message.textTransform != null && message.hasOwnProperty("textTransform"))
                                switch (message.textTransform) {
                                default:
                                    return "textTransform: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates an AlternateElementText message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.AlternateElementText} AlternateElementText
                         */
                        AlternateElementText.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.AlternateElementText)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.AlternateElementText();
                            if (object.otherElementUuid != null) {
                                if (typeof object.otherElementUuid !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.AlternateElementText.otherElementUuid: object expected");
                                message.otherElementUuid = $root.rv.data.UUID.fromObject(object.otherElementUuid);
                            }
                            if (object.otherElementName != null)
                                message.otherElementName = String(object.otherElementName);
                            if (object.textTransformOptions != null)
                                message.textTransformOptions = object.textTransformOptions >>> 0;
                            switch (object.textTransform) {
                            default:
                                if (typeof object.textTransform === "number") {
                                    message.textTransform = object.textTransform;
                                    break;
                                }
                                break;
                            case "TEXT_TRANSFORM_OPTION_NONE":
                            case 0:
                                message.textTransform = 0;
                                break;
                            case "TEXT_TRANSFORM_OPTION_REMOVE_LINE_RETURNS":
                            case 1:
                                message.textTransform = 1;
                                break;
                            case "TEXT_TRANSFORM_OPTION_ONE_WORD_PER_LINE":
                            case 2:
                                message.textTransform = 2;
                                break;
                            case "TEXT_TRANSFORM_OPTION_ONE_CHARACTER_PER_LINE":
                            case 3:
                                message.textTransform = 3;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an AlternateElementText message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.AlternateElementText} message AlternateElementText
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        AlternateElementText.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.otherElementUuid = null;
                                object.otherElementName = "";
                                object.textTransformOptions = 0;
                                object.textTransform = options.enums === String ? "TEXT_TRANSFORM_OPTION_NONE" : 0;
                            }
                            if (message.otherElementUuid != null && message.hasOwnProperty("otherElementUuid"))
                                object.otherElementUuid = $root.rv.data.UUID.toObject(message.otherElementUuid, options);
                            if (message.otherElementName != null && message.hasOwnProperty("otherElementName"))
                                object.otherElementName = message.otherElementName;
                            if (message.textTransformOptions != null && message.hasOwnProperty("textTransformOptions"))
                                object.textTransformOptions = message.textTransformOptions;
                            if (message.textTransform != null && message.hasOwnProperty("textTransform"))
                                object.textTransform = options.enums === String ? $root.rv.data.Slide.Element.DataLink.AlternateElementText.TextTransformOption[message.textTransform] === undefined ? message.textTransform : $root.rv.data.Slide.Element.DataLink.AlternateElementText.TextTransformOption[message.textTransform] : message.textTransform;
                            return object;
                        };

                        /**
                         * Converts this AlternateElementText to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        AlternateElementText.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for AlternateElementText
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementText
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        AlternateElementText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.AlternateElementText";
                        };

                        /**
                         * TextTransformOption enum.
                         * @name rv.data.Slide.Element.DataLink.AlternateElementText.TextTransformOption
                         * @enum {number}
                         * @property {number} TEXT_TRANSFORM_OPTION_NONE=0 TEXT_TRANSFORM_OPTION_NONE value
                         * @property {number} TEXT_TRANSFORM_OPTION_REMOVE_LINE_RETURNS=1 TEXT_TRANSFORM_OPTION_REMOVE_LINE_RETURNS value
                         * @property {number} TEXT_TRANSFORM_OPTION_ONE_WORD_PER_LINE=2 TEXT_TRANSFORM_OPTION_ONE_WORD_PER_LINE value
                         * @property {number} TEXT_TRANSFORM_OPTION_ONE_CHARACTER_PER_LINE=3 TEXT_TRANSFORM_OPTION_ONE_CHARACTER_PER_LINE value
                         */
                        AlternateElementText.TextTransformOption = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "TEXT_TRANSFORM_OPTION_NONE"] = 0;
                            values[valuesById[1] = "TEXT_TRANSFORM_OPTION_REMOVE_LINE_RETURNS"] = 1;
                            values[valuesById[2] = "TEXT_TRANSFORM_OPTION_ONE_WORD_PER_LINE"] = 2;
                            values[valuesById[3] = "TEXT_TRANSFORM_OPTION_ONE_CHARACTER_PER_LINE"] = 3;
                            return values;
                        })();

                        return AlternateElementText;
                    })();

                    DataLink.CCLIText = (function() {

                        /**
                         * Properties of a CCLIText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface ICCLIText
                         */

                        /**
                         * Constructs a new CCLIText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a CCLIText.
                         * @implements ICCLIText
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.ICCLIText=} [properties] Properties to set
                         */
                        function CCLIText(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new CCLIText instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.CCLIText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ICCLIText=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.CCLIText} CCLIText instance
                         */
                        CCLIText.create = function create(properties) {
                            return new CCLIText(properties);
                        };

                        /**
                         * Encodes the specified CCLIText message. Does not implicitly {@link rv.data.Slide.Element.DataLink.CCLIText.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.CCLIText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ICCLIText} message CCLIText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CCLIText.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified CCLIText message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.CCLIText.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.CCLIText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ICCLIText} message CCLIText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CCLIText.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a CCLIText message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.CCLIText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.CCLIText} CCLIText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CCLIText.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.CCLIText();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a CCLIText message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.CCLIText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.CCLIText} CCLIText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CCLIText.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a CCLIText message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.CCLIText
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        CCLIText.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a CCLIText message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.CCLIText
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.CCLIText} CCLIText
                         */
                        CCLIText.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.CCLIText)
                                return object;
                            return new $root.rv.data.Slide.Element.DataLink.CCLIText();
                        };

                        /**
                         * Creates a plain object from a CCLIText message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.CCLIText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.CCLIText} message CCLIText
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        CCLIText.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this CCLIText to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.CCLIText
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        CCLIText.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for CCLIText
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.CCLIText
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        CCLIText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.CCLIText";
                        };

                        return CCLIText;
                    })();

                    DataLink.ColorTrigger = (function() {

                        /**
                         * Properties of a ColorTrigger.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IColorTrigger
                         * @property {number|null} [time] ColorTrigger time
                         * @property {rv.data.IColor|null} [color] ColorTrigger color
                         */

                        /**
                         * Constructs a new ColorTrigger.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a ColorTrigger.
                         * @implements IColorTrigger
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IColorTrigger=} [properties] Properties to set
                         */
                        function ColorTrigger(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ColorTrigger time.
                         * @member {number} time
                         * @memberof rv.data.Slide.Element.DataLink.ColorTrigger
                         * @instance
                         */
                        ColorTrigger.prototype.time = 0;

                        /**
                         * ColorTrigger color.
                         * @member {rv.data.IColor|null|undefined} color
                         * @memberof rv.data.Slide.Element.DataLink.ColorTrigger
                         * @instance
                         */
                        ColorTrigger.prototype.color = null;

                        /**
                         * Creates a new ColorTrigger instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.ColorTrigger
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IColorTrigger=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.ColorTrigger} ColorTrigger instance
                         */
                        ColorTrigger.create = function create(properties) {
                            return new ColorTrigger(properties);
                        };

                        /**
                         * Encodes the specified ColorTrigger message. Does not implicitly {@link rv.data.Slide.Element.DataLink.ColorTrigger.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.ColorTrigger
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IColorTrigger} message ColorTrigger message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ColorTrigger.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                                writer.uint32(/* id 1, wireType 1 =*/9).double(message.time);
                            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                                $root.rv.data.Color.encode(message.color, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified ColorTrigger message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.ColorTrigger.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.ColorTrigger
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IColorTrigger} message ColorTrigger message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ColorTrigger.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a ColorTrigger message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.ColorTrigger
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.ColorTrigger} ColorTrigger
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ColorTrigger.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.ColorTrigger();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.time = reader.double();
                                        break;
                                    }
                                case 2: {
                                        message.color = $root.rv.data.Color.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a ColorTrigger message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.ColorTrigger
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.ColorTrigger} ColorTrigger
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ColorTrigger.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a ColorTrigger message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.ColorTrigger
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ColorTrigger.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.time != null && message.hasOwnProperty("time"))
                                if (typeof message.time !== "number")
                                    return "time: number expected";
                            if (message.color != null && message.hasOwnProperty("color")) {
                                let error = $root.rv.data.Color.verify(message.color);
                                if (error)
                                    return "color." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a ColorTrigger message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.ColorTrigger
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.ColorTrigger} ColorTrigger
                         */
                        ColorTrigger.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.ColorTrigger)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.ColorTrigger();
                            if (object.time != null)
                                message.time = Number(object.time);
                            if (object.color != null) {
                                if (typeof object.color !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.ColorTrigger.color: object expected");
                                message.color = $root.rv.data.Color.fromObject(object.color);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a ColorTrigger message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.ColorTrigger
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ColorTrigger} message ColorTrigger
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ColorTrigger.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.time = 0;
                                object.color = null;
                            }
                            if (message.time != null && message.hasOwnProperty("time"))
                                object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
                            if (message.color != null && message.hasOwnProperty("color"))
                                object.color = $root.rv.data.Color.toObject(message.color, options);
                            return object;
                        };

                        /**
                         * Converts this ColorTrigger to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.ColorTrigger
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ColorTrigger.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ColorTrigger
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.ColorTrigger
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ColorTrigger.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.ColorTrigger";
                        };

                        return ColorTrigger;
                    })();

                    DataLink.TimerText = (function() {

                        /**
                         * Properties of a TimerText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface ITimerText
                         * @property {rv.data.IUUID|null} [timerUuid] TimerText timerUuid
                         * @property {string|null} [timerName] TimerText timerName
                         * @property {rv.data.Timer.IFormat|null} [timerFormat] TimerText timerFormat
                         * @property {string|null} [timerFormatString] TimerText timerFormatString
                         * @property {Array.<rv.data.Slide.Element.DataLink.IColorTrigger>|null} [colorTriggers] TimerText colorTriggers
                         */

                        /**
                         * Constructs a new TimerText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a TimerText.
                         * @implements ITimerText
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.ITimerText=} [properties] Properties to set
                         */
                        function TimerText(properties) {
                            this.colorTriggers = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * TimerText timerUuid.
                         * @member {rv.data.IUUID|null|undefined} timerUuid
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @instance
                         */
                        TimerText.prototype.timerUuid = null;

                        /**
                         * TimerText timerName.
                         * @member {string} timerName
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @instance
                         */
                        TimerText.prototype.timerName = "";

                        /**
                         * TimerText timerFormat.
                         * @member {rv.data.Timer.IFormat|null|undefined} timerFormat
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @instance
                         */
                        TimerText.prototype.timerFormat = null;

                        /**
                         * TimerText timerFormatString.
                         * @member {string} timerFormatString
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @instance
                         */
                        TimerText.prototype.timerFormatString = "";

                        /**
                         * TimerText colorTriggers.
                         * @member {Array.<rv.data.Slide.Element.DataLink.IColorTrigger>} colorTriggers
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @instance
                         */
                        TimerText.prototype.colorTriggers = $util.emptyArray;

                        /**
                         * Creates a new TimerText instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ITimerText=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.TimerText} TimerText instance
                         */
                        TimerText.create = function create(properties) {
                            return new TimerText(properties);
                        };

                        /**
                         * Encodes the specified TimerText message. Does not implicitly {@link rv.data.Slide.Element.DataLink.TimerText.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ITimerText} message TimerText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        TimerText.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.timerUuid != null && Object.hasOwnProperty.call(message, "timerUuid"))
                                $root.rv.data.UUID.encode(message.timerUuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.timerName != null && Object.hasOwnProperty.call(message, "timerName"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.timerName);
                            if (message.timerFormat != null && Object.hasOwnProperty.call(message, "timerFormat"))
                                $root.rv.data.Timer.Format.encode(message.timerFormat, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.timerFormatString != null && Object.hasOwnProperty.call(message, "timerFormatString"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.timerFormatString);
                            if (message.colorTriggers != null && message.colorTriggers.length)
                                for (let i = 0; i < message.colorTriggers.length; ++i)
                                    $root.rv.data.Slide.Element.DataLink.ColorTrigger.encode(message.colorTriggers[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified TimerText message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.TimerText.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ITimerText} message TimerText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        TimerText.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a TimerText message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.TimerText} TimerText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        TimerText.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.TimerText();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.timerUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.timerName = reader.string();
                                        break;
                                    }
                                case 3: {
                                        message.timerFormat = $root.rv.data.Timer.Format.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 4: {
                                        message.timerFormatString = reader.string();
                                        break;
                                    }
                                case 5: {
                                        if (!(message.colorTriggers && message.colorTriggers.length))
                                            message.colorTriggers = [];
                                        message.colorTriggers.push($root.rv.data.Slide.Element.DataLink.ColorTrigger.decode(reader, reader.uint32()));
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a TimerText message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.TimerText} TimerText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        TimerText.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a TimerText message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        TimerText.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.timerUuid != null && message.hasOwnProperty("timerUuid")) {
                                let error = $root.rv.data.UUID.verify(message.timerUuid);
                                if (error)
                                    return "timerUuid." + error;
                            }
                            if (message.timerName != null && message.hasOwnProperty("timerName"))
                                if (!$util.isString(message.timerName))
                                    return "timerName: string expected";
                            if (message.timerFormat != null && message.hasOwnProperty("timerFormat")) {
                                let error = $root.rv.data.Timer.Format.verify(message.timerFormat);
                                if (error)
                                    return "timerFormat." + error;
                            }
                            if (message.timerFormatString != null && message.hasOwnProperty("timerFormatString"))
                                if (!$util.isString(message.timerFormatString))
                                    return "timerFormatString: string expected";
                            if (message.colorTriggers != null && message.hasOwnProperty("colorTriggers")) {
                                if (!Array.isArray(message.colorTriggers))
                                    return "colorTriggers: array expected";
                                for (let i = 0; i < message.colorTriggers.length; ++i) {
                                    let error = $root.rv.data.Slide.Element.DataLink.ColorTrigger.verify(message.colorTriggers[i]);
                                    if (error)
                                        return "colorTriggers." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a TimerText message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.TimerText} TimerText
                         */
                        TimerText.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.TimerText)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.TimerText();
                            if (object.timerUuid != null) {
                                if (typeof object.timerUuid !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.TimerText.timerUuid: object expected");
                                message.timerUuid = $root.rv.data.UUID.fromObject(object.timerUuid);
                            }
                            if (object.timerName != null)
                                message.timerName = String(object.timerName);
                            if (object.timerFormat != null) {
                                if (typeof object.timerFormat !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.TimerText.timerFormat: object expected");
                                message.timerFormat = $root.rv.data.Timer.Format.fromObject(object.timerFormat);
                            }
                            if (object.timerFormatString != null)
                                message.timerFormatString = String(object.timerFormatString);
                            if (object.colorTriggers) {
                                if (!Array.isArray(object.colorTriggers))
                                    throw TypeError(".rv.data.Slide.Element.DataLink.TimerText.colorTriggers: array expected");
                                message.colorTriggers = [];
                                for (let i = 0; i < object.colorTriggers.length; ++i) {
                                    if (typeof object.colorTriggers[i] !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.TimerText.colorTriggers: object expected");
                                    message.colorTriggers[i] = $root.rv.data.Slide.Element.DataLink.ColorTrigger.fromObject(object.colorTriggers[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a TimerText message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.TimerText} message TimerText
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        TimerText.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.colorTriggers = [];
                            if (options.defaults) {
                                object.timerUuid = null;
                                object.timerName = "";
                                object.timerFormat = null;
                                object.timerFormatString = "";
                            }
                            if (message.timerUuid != null && message.hasOwnProperty("timerUuid"))
                                object.timerUuid = $root.rv.data.UUID.toObject(message.timerUuid, options);
                            if (message.timerName != null && message.hasOwnProperty("timerName"))
                                object.timerName = message.timerName;
                            if (message.timerFormat != null && message.hasOwnProperty("timerFormat"))
                                object.timerFormat = $root.rv.data.Timer.Format.toObject(message.timerFormat, options);
                            if (message.timerFormatString != null && message.hasOwnProperty("timerFormatString"))
                                object.timerFormatString = message.timerFormatString;
                            if (message.colorTriggers && message.colorTriggers.length) {
                                object.colorTriggers = [];
                                for (let j = 0; j < message.colorTriggers.length; ++j)
                                    object.colorTriggers[j] = $root.rv.data.Slide.Element.DataLink.ColorTrigger.toObject(message.colorTriggers[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this TimerText to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        TimerText.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for TimerText
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.TimerText
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        TimerText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.TimerText";
                        };

                        return TimerText;
                    })();

                    DataLink.ClockText = (function() {

                        /**
                         * Properties of a ClockText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IClockText
                         * @property {string|null} [clockFormatString] ClockText clockFormatString
                         * @property {rv.data.Clock.IFormat|null} [format] ClockText format
                         */

                        /**
                         * Constructs a new ClockText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a ClockText.
                         * @implements IClockText
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IClockText=} [properties] Properties to set
                         */
                        function ClockText(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ClockText clockFormatString.
                         * @member {string} clockFormatString
                         * @memberof rv.data.Slide.Element.DataLink.ClockText
                         * @instance
                         */
                        ClockText.prototype.clockFormatString = "";

                        /**
                         * ClockText format.
                         * @member {rv.data.Clock.IFormat|null|undefined} format
                         * @memberof rv.data.Slide.Element.DataLink.ClockText
                         * @instance
                         */
                        ClockText.prototype.format = null;

                        /**
                         * Creates a new ClockText instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.ClockText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IClockText=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.ClockText} ClockText instance
                         */
                        ClockText.create = function create(properties) {
                            return new ClockText(properties);
                        };

                        /**
                         * Encodes the specified ClockText message. Does not implicitly {@link rv.data.Slide.Element.DataLink.ClockText.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.ClockText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IClockText} message ClockText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ClockText.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.clockFormatString != null && Object.hasOwnProperty.call(message, "clockFormatString"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clockFormatString);
                            if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                                $root.rv.data.Clock.Format.encode(message.format, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified ClockText message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.ClockText.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.ClockText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IClockText} message ClockText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ClockText.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a ClockText message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.ClockText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.ClockText} ClockText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ClockText.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.ClockText();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.clockFormatString = reader.string();
                                        break;
                                    }
                                case 5: {
                                        message.format = $root.rv.data.Clock.Format.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a ClockText message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.ClockText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.ClockText} ClockText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ClockText.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a ClockText message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.ClockText
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ClockText.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.clockFormatString != null && message.hasOwnProperty("clockFormatString"))
                                if (!$util.isString(message.clockFormatString))
                                    return "clockFormatString: string expected";
                            if (message.format != null && message.hasOwnProperty("format")) {
                                let error = $root.rv.data.Clock.Format.verify(message.format);
                                if (error)
                                    return "format." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a ClockText message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.ClockText
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.ClockText} ClockText
                         */
                        ClockText.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.ClockText)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.ClockText();
                            if (object.clockFormatString != null)
                                message.clockFormatString = String(object.clockFormatString);
                            if (object.format != null) {
                                if (typeof object.format !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.ClockText.format: object expected");
                                message.format = $root.rv.data.Clock.Format.fromObject(object.format);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a ClockText message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.ClockText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ClockText} message ClockText
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ClockText.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.clockFormatString = "";
                                object.format = null;
                            }
                            if (message.clockFormatString != null && message.hasOwnProperty("clockFormatString"))
                                object.clockFormatString = message.clockFormatString;
                            if (message.format != null && message.hasOwnProperty("format"))
                                object.format = $root.rv.data.Clock.Format.toObject(message.format, options);
                            return object;
                        };

                        /**
                         * Converts this ClockText to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.ClockText
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ClockText.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ClockText
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.ClockText
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ClockText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.ClockText";
                        };

                        return ClockText;
                    })();

                    DataLink.ChordChart = (function() {

                        /**
                         * Properties of a ChordChart.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IChordChart
                         */

                        /**
                         * Constructs a new ChordChart.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a ChordChart.
                         * @implements IChordChart
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IChordChart=} [properties] Properties to set
                         */
                        function ChordChart(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new ChordChart instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.ChordChart
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IChordChart=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.ChordChart} ChordChart instance
                         */
                        ChordChart.create = function create(properties) {
                            return new ChordChart(properties);
                        };

                        /**
                         * Encodes the specified ChordChart message. Does not implicitly {@link rv.data.Slide.Element.DataLink.ChordChart.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.ChordChart
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IChordChart} message ChordChart message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ChordChart.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified ChordChart message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.ChordChart.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.ChordChart
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IChordChart} message ChordChart message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ChordChart.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a ChordChart message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.ChordChart
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.ChordChart} ChordChart
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ChordChart.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.ChordChart();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a ChordChart message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.ChordChart
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.ChordChart} ChordChart
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ChordChart.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a ChordChart message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.ChordChart
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ChordChart.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a ChordChart message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.ChordChart
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.ChordChart} ChordChart
                         */
                        ChordChart.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.ChordChart)
                                return object;
                            return new $root.rv.data.Slide.Element.DataLink.ChordChart();
                        };

                        /**
                         * Creates a plain object from a ChordChart message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.ChordChart
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ChordChart} message ChordChart
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ChordChart.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this ChordChart to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.ChordChart
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ChordChart.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ChordChart
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.ChordChart
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ChordChart.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.ChordChart";
                        };

                        return ChordChart;
                    })();

                    DataLink.OutputScreen = (function() {

                        /**
                         * Properties of an OutputScreen.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IOutputScreen
                         * @property {rv.data.IUUID|null} [screenId] OutputScreen screenId
                         * @property {string|null} [screenName] OutputScreen screenName
                         */

                        /**
                         * Constructs a new OutputScreen.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents an OutputScreen.
                         * @implements IOutputScreen
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IOutputScreen=} [properties] Properties to set
                         */
                        function OutputScreen(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * OutputScreen screenId.
                         * @member {rv.data.IUUID|null|undefined} screenId
                         * @memberof rv.data.Slide.Element.DataLink.OutputScreen
                         * @instance
                         */
                        OutputScreen.prototype.screenId = null;

                        /**
                         * OutputScreen screenName.
                         * @member {string} screenName
                         * @memberof rv.data.Slide.Element.DataLink.OutputScreen
                         * @instance
                         */
                        OutputScreen.prototype.screenName = "";

                        /**
                         * Creates a new OutputScreen instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.OutputScreen
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IOutputScreen=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.OutputScreen} OutputScreen instance
                         */
                        OutputScreen.create = function create(properties) {
                            return new OutputScreen(properties);
                        };

                        /**
                         * Encodes the specified OutputScreen message. Does not implicitly {@link rv.data.Slide.Element.DataLink.OutputScreen.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.OutputScreen
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IOutputScreen} message OutputScreen message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        OutputScreen.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.screenId != null && Object.hasOwnProperty.call(message, "screenId"))
                                $root.rv.data.UUID.encode(message.screenId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.screenName != null && Object.hasOwnProperty.call(message, "screenName"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.screenName);
                            return writer;
                        };

                        /**
                         * Encodes the specified OutputScreen message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.OutputScreen.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.OutputScreen
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IOutputScreen} message OutputScreen message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        OutputScreen.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an OutputScreen message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.OutputScreen
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.OutputScreen} OutputScreen
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        OutputScreen.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.OutputScreen();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.screenId = $root.rv.data.UUID.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.screenName = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an OutputScreen message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.OutputScreen
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.OutputScreen} OutputScreen
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        OutputScreen.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an OutputScreen message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.OutputScreen
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        OutputScreen.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.screenId != null && message.hasOwnProperty("screenId")) {
                                let error = $root.rv.data.UUID.verify(message.screenId);
                                if (error)
                                    return "screenId." + error;
                            }
                            if (message.screenName != null && message.hasOwnProperty("screenName"))
                                if (!$util.isString(message.screenName))
                                    return "screenName: string expected";
                            return null;
                        };

                        /**
                         * Creates an OutputScreen message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.OutputScreen
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.OutputScreen} OutputScreen
                         */
                        OutputScreen.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.OutputScreen)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.OutputScreen();
                            if (object.screenId != null) {
                                if (typeof object.screenId !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.OutputScreen.screenId: object expected");
                                message.screenId = $root.rv.data.UUID.fromObject(object.screenId);
                            }
                            if (object.screenName != null)
                                message.screenName = String(object.screenName);
                            return message;
                        };

                        /**
                         * Creates a plain object from an OutputScreen message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.OutputScreen
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.OutputScreen} message OutputScreen
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        OutputScreen.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.screenId = null;
                                object.screenName = "";
                            }
                            if (message.screenId != null && message.hasOwnProperty("screenId"))
                                object.screenId = $root.rv.data.UUID.toObject(message.screenId, options);
                            if (message.screenName != null && message.hasOwnProperty("screenName"))
                                object.screenName = message.screenName;
                            return object;
                        };

                        /**
                         * Converts this OutputScreen to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.OutputScreen
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        OutputScreen.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for OutputScreen
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.OutputScreen
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        OutputScreen.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.OutputScreen";
                        };

                        return OutputScreen;
                    })();

                    DataLink.PCOLive = (function() {

                        /**
                         * Properties of a PCOLive.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IPCOLive
                         * @property {rv.data.Slide.Element.DataLink.PCOLive.Theme|null} [theme] PCOLive theme
                         * @property {rv.data.Slide.Element.DataLink.PCOLive.CountdownType|null} [countdownType] PCOLive countdownType
                         */

                        /**
                         * Constructs a new PCOLive.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a PCOLive.
                         * @implements IPCOLive
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IPCOLive=} [properties] Properties to set
                         */
                        function PCOLive(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * PCOLive theme.
                         * @member {rv.data.Slide.Element.DataLink.PCOLive.Theme} theme
                         * @memberof rv.data.Slide.Element.DataLink.PCOLive
                         * @instance
                         */
                        PCOLive.prototype.theme = 0;

                        /**
                         * PCOLive countdownType.
                         * @member {rv.data.Slide.Element.DataLink.PCOLive.CountdownType} countdownType
                         * @memberof rv.data.Slide.Element.DataLink.PCOLive
                         * @instance
                         */
                        PCOLive.prototype.countdownType = 0;

                        /**
                         * Creates a new PCOLive instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.PCOLive
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPCOLive=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.PCOLive} PCOLive instance
                         */
                        PCOLive.create = function create(properties) {
                            return new PCOLive(properties);
                        };

                        /**
                         * Encodes the specified PCOLive message. Does not implicitly {@link rv.data.Slide.Element.DataLink.PCOLive.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.PCOLive
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPCOLive} message PCOLive message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PCOLive.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.theme);
                            if (message.countdownType != null && Object.hasOwnProperty.call(message, "countdownType"))
                                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.countdownType);
                            return writer;
                        };

                        /**
                         * Encodes the specified PCOLive message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.PCOLive.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.PCOLive
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPCOLive} message PCOLive message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PCOLive.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a PCOLive message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.PCOLive
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.PCOLive} PCOLive
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PCOLive.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.PCOLive();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 2: {
                                        message.theme = reader.int32();
                                        break;
                                    }
                                case 3: {
                                        message.countdownType = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a PCOLive message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.PCOLive
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.PCOLive} PCOLive
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PCOLive.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a PCOLive message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.PCOLive
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PCOLive.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.theme != null && message.hasOwnProperty("theme"))
                                switch (message.theme) {
                                default:
                                    return "theme: enum value expected";
                                case 0:
                                case 1:
                                    break;
                                }
                            if (message.countdownType != null && message.hasOwnProperty("countdownType"))
                                switch (message.countdownType) {
                                default:
                                    return "countdownType: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a PCOLive message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.PCOLive
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.PCOLive} PCOLive
                         */
                        PCOLive.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.PCOLive)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.PCOLive();
                            switch (object.theme) {
                            default:
                                if (typeof object.theme === "number") {
                                    message.theme = object.theme;
                                    break;
                                }
                                break;
                            case "PCOLIVE_THEME_LIGHT":
                            case 0:
                                message.theme = 0;
                                break;
                            case "PCOLIVE_THEME_DARK":
                            case 1:
                                message.theme = 1;
                                break;
                            }
                            switch (object.countdownType) {
                            default:
                                if (typeof object.countdownType === "number") {
                                    message.countdownType = object.countdownType;
                                    break;
                                }
                                break;
                            case "COUNTDOWN_TYPE_FULL_ITEM_LENGTH":
                            case 0:
                                message.countdownType = 0;
                                break;
                            case "COUNTDOWN_TYPE_END_ITEM_ON_TIME":
                            case 1:
                                message.countdownType = 1;
                                break;
                            case "COUNTDOWN_TYPE_END_SERVICE_ON_TIME":
                            case 2:
                                message.countdownType = 2;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a PCOLive message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.PCOLive
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.PCOLive} message PCOLive
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PCOLive.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.theme = options.enums === String ? "PCOLIVE_THEME_LIGHT" : 0;
                                object.countdownType = options.enums === String ? "COUNTDOWN_TYPE_FULL_ITEM_LENGTH" : 0;
                            }
                            if (message.theme != null && message.hasOwnProperty("theme"))
                                object.theme = options.enums === String ? $root.rv.data.Slide.Element.DataLink.PCOLive.Theme[message.theme] === undefined ? message.theme : $root.rv.data.Slide.Element.DataLink.PCOLive.Theme[message.theme] : message.theme;
                            if (message.countdownType != null && message.hasOwnProperty("countdownType"))
                                object.countdownType = options.enums === String ? $root.rv.data.Slide.Element.DataLink.PCOLive.CountdownType[message.countdownType] === undefined ? message.countdownType : $root.rv.data.Slide.Element.DataLink.PCOLive.CountdownType[message.countdownType] : message.countdownType;
                            return object;
                        };

                        /**
                         * Converts this PCOLive to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.PCOLive
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PCOLive.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for PCOLive
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.PCOLive
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        PCOLive.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.PCOLive";
                        };

                        /**
                         * Theme enum.
                         * @name rv.data.Slide.Element.DataLink.PCOLive.Theme
                         * @enum {number}
                         * @property {number} PCOLIVE_THEME_LIGHT=0 PCOLIVE_THEME_LIGHT value
                         * @property {number} PCOLIVE_THEME_DARK=1 PCOLIVE_THEME_DARK value
                         */
                        PCOLive.Theme = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "PCOLIVE_THEME_LIGHT"] = 0;
                            values[valuesById[1] = "PCOLIVE_THEME_DARK"] = 1;
                            return values;
                        })();

                        /**
                         * CountdownType enum.
                         * @name rv.data.Slide.Element.DataLink.PCOLive.CountdownType
                         * @enum {number}
                         * @property {number} COUNTDOWN_TYPE_FULL_ITEM_LENGTH=0 COUNTDOWN_TYPE_FULL_ITEM_LENGTH value
                         * @property {number} COUNTDOWN_TYPE_END_ITEM_ON_TIME=1 COUNTDOWN_TYPE_END_ITEM_ON_TIME value
                         * @property {number} COUNTDOWN_TYPE_END_SERVICE_ON_TIME=2 COUNTDOWN_TYPE_END_SERVICE_ON_TIME value
                         */
                        PCOLive.CountdownType = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "COUNTDOWN_TYPE_FULL_ITEM_LENGTH"] = 0;
                            values[valuesById[1] = "COUNTDOWN_TYPE_END_ITEM_ON_TIME"] = 1;
                            values[valuesById[2] = "COUNTDOWN_TYPE_END_SERVICE_ON_TIME"] = 2;
                            return values;
                        })();

                        return PCOLive;
                    })();

                    DataLink.AlternateElementFill = (function() {

                        /**
                         * Properties of an AlternateElementFill.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IAlternateElementFill
                         * @property {rv.data.IUUID|null} [otherElementUuid] AlternateElementFill otherElementUuid
                         * @property {string|null} [otherElementName] AlternateElementFill otherElementName
                         */

                        /**
                         * Constructs a new AlternateElementFill.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents an AlternateElementFill.
                         * @implements IAlternateElementFill
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IAlternateElementFill=} [properties] Properties to set
                         */
                        function AlternateElementFill(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * AlternateElementFill otherElementUuid.
                         * @member {rv.data.IUUID|null|undefined} otherElementUuid
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementFill
                         * @instance
                         */
                        AlternateElementFill.prototype.otherElementUuid = null;

                        /**
                         * AlternateElementFill otherElementName.
                         * @member {string} otherElementName
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementFill
                         * @instance
                         */
                        AlternateElementFill.prototype.otherElementName = "";

                        /**
                         * Creates a new AlternateElementFill instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementFill
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IAlternateElementFill=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.AlternateElementFill} AlternateElementFill instance
                         */
                        AlternateElementFill.create = function create(properties) {
                            return new AlternateElementFill(properties);
                        };

                        /**
                         * Encodes the specified AlternateElementFill message. Does not implicitly {@link rv.data.Slide.Element.DataLink.AlternateElementFill.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementFill
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IAlternateElementFill} message AlternateElementFill message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        AlternateElementFill.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.otherElementUuid != null && Object.hasOwnProperty.call(message, "otherElementUuid"))
                                $root.rv.data.UUID.encode(message.otherElementUuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.otherElementName != null && Object.hasOwnProperty.call(message, "otherElementName"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.otherElementName);
                            return writer;
                        };

                        /**
                         * Encodes the specified AlternateElementFill message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.AlternateElementFill.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementFill
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IAlternateElementFill} message AlternateElementFill message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        AlternateElementFill.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an AlternateElementFill message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementFill
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.AlternateElementFill} AlternateElementFill
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        AlternateElementFill.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.AlternateElementFill();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.otherElementUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.otherElementName = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an AlternateElementFill message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementFill
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.AlternateElementFill} AlternateElementFill
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        AlternateElementFill.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an AlternateElementFill message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementFill
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        AlternateElementFill.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.otherElementUuid != null && message.hasOwnProperty("otherElementUuid")) {
                                let error = $root.rv.data.UUID.verify(message.otherElementUuid);
                                if (error)
                                    return "otherElementUuid." + error;
                            }
                            if (message.otherElementName != null && message.hasOwnProperty("otherElementName"))
                                if (!$util.isString(message.otherElementName))
                                    return "otherElementName: string expected";
                            return null;
                        };

                        /**
                         * Creates an AlternateElementFill message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementFill
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.AlternateElementFill} AlternateElementFill
                         */
                        AlternateElementFill.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.AlternateElementFill)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.AlternateElementFill();
                            if (object.otherElementUuid != null) {
                                if (typeof object.otherElementUuid !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.AlternateElementFill.otherElementUuid: object expected");
                                message.otherElementUuid = $root.rv.data.UUID.fromObject(object.otherElementUuid);
                            }
                            if (object.otherElementName != null)
                                message.otherElementName = String(object.otherElementName);
                            return message;
                        };

                        /**
                         * Creates a plain object from an AlternateElementFill message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementFill
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.AlternateElementFill} message AlternateElementFill
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        AlternateElementFill.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.otherElementUuid = null;
                                object.otherElementName = "";
                            }
                            if (message.otherElementUuid != null && message.hasOwnProperty("otherElementUuid"))
                                object.otherElementUuid = $root.rv.data.UUID.toObject(message.otherElementUuid, options);
                            if (message.otherElementName != null && message.hasOwnProperty("otherElementName"))
                                object.otherElementName = message.otherElementName;
                            return object;
                        };

                        /**
                         * Converts this AlternateElementFill to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementFill
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        AlternateElementFill.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for AlternateElementFill
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.AlternateElementFill
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        AlternateElementFill.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.AlternateElementFill";
                        };

                        return AlternateElementFill;
                    })();

                    DataLink.VisibilityLink = (function() {

                        /**
                         * Properties of a VisibilityLink.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IVisibilityLink
                         * @property {rv.data.Slide.Element.DataLink.VisibilityLink.VisibilityCriterion|null} [visibilityCriterion] VisibilityLink visibilityCriterion
                         * @property {Array.<rv.data.Slide.Element.DataLink.VisibilityLink.ICondition>|null} [conditions] VisibilityLink conditions
                         */

                        /**
                         * Constructs a new VisibilityLink.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a VisibilityLink.
                         * @implements IVisibilityLink
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IVisibilityLink=} [properties] Properties to set
                         */
                        function VisibilityLink(properties) {
                            this.conditions = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * VisibilityLink visibilityCriterion.
                         * @member {rv.data.Slide.Element.DataLink.VisibilityLink.VisibilityCriterion} visibilityCriterion
                         * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                         * @instance
                         */
                        VisibilityLink.prototype.visibilityCriterion = 0;

                        /**
                         * VisibilityLink conditions.
                         * @member {Array.<rv.data.Slide.Element.DataLink.VisibilityLink.ICondition>} conditions
                         * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                         * @instance
                         */
                        VisibilityLink.prototype.conditions = $util.emptyArray;

                        /**
                         * Creates a new VisibilityLink instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IVisibilityLink=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.VisibilityLink} VisibilityLink instance
                         */
                        VisibilityLink.create = function create(properties) {
                            return new VisibilityLink(properties);
                        };

                        /**
                         * Encodes the specified VisibilityLink message. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IVisibilityLink} message VisibilityLink message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        VisibilityLink.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.visibilityCriterion != null && Object.hasOwnProperty.call(message, "visibilityCriterion"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.visibilityCriterion);
                            if (message.conditions != null && message.conditions.length)
                                for (let i = 0; i < message.conditions.length; ++i)
                                    $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.encode(message.conditions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified VisibilityLink message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IVisibilityLink} message VisibilityLink message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        VisibilityLink.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a VisibilityLink message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.VisibilityLink} VisibilityLink
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        VisibilityLink.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.visibilityCriterion = reader.int32();
                                        break;
                                    }
                                case 2: {
                                        if (!(message.conditions && message.conditions.length))
                                            message.conditions = [];
                                        message.conditions.push($root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.decode(reader, reader.uint32()));
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a VisibilityLink message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.VisibilityLink} VisibilityLink
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        VisibilityLink.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a VisibilityLink message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        VisibilityLink.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                switch (message.visibilityCriterion) {
                                default:
                                    return "visibilityCriterion: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.conditions != null && message.hasOwnProperty("conditions")) {
                                if (!Array.isArray(message.conditions))
                                    return "conditions: array expected";
                                for (let i = 0; i < message.conditions.length; ++i) {
                                    let error = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.verify(message.conditions[i]);
                                    if (error)
                                        return "conditions." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a VisibilityLink message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.VisibilityLink} VisibilityLink
                         */
                        VisibilityLink.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.VisibilityLink)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink();
                            switch (object.visibilityCriterion) {
                            default:
                                if (typeof object.visibilityCriterion === "number") {
                                    message.visibilityCriterion = object.visibilityCriterion;
                                    break;
                                }
                                break;
                            case "VISIBILITY_CRITERION_ALL":
                            case 0:
                                message.visibilityCriterion = 0;
                                break;
                            case "VISIBILITY_CRITERION_ANY":
                            case 1:
                                message.visibilityCriterion = 1;
                                break;
                            case "VISIBILITY_CRITERION_NONE":
                            case 2:
                                message.visibilityCriterion = 2;
                                break;
                            }
                            if (object.conditions) {
                                if (!Array.isArray(object.conditions))
                                    throw TypeError(".rv.data.Slide.Element.DataLink.VisibilityLink.conditions: array expected");
                                message.conditions = [];
                                for (let i = 0; i < object.conditions.length; ++i) {
                                    if (typeof object.conditions[i] !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.VisibilityLink.conditions: object expected");
                                    message.conditions[i] = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.fromObject(object.conditions[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a VisibilityLink message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.VisibilityLink} message VisibilityLink
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        VisibilityLink.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.conditions = [];
                            if (options.defaults)
                                object.visibilityCriterion = options.enums === String ? "VISIBILITY_CRITERION_ALL" : 0;
                            if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                object.visibilityCriterion = options.enums === String ? $root.rv.data.Slide.Element.DataLink.VisibilityLink.VisibilityCriterion[message.visibilityCriterion] === undefined ? message.visibilityCriterion : $root.rv.data.Slide.Element.DataLink.VisibilityLink.VisibilityCriterion[message.visibilityCriterion] : message.visibilityCriterion;
                            if (message.conditions && message.conditions.length) {
                                object.conditions = [];
                                for (let j = 0; j < message.conditions.length; ++j)
                                    object.conditions[j] = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.toObject(message.conditions[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this VisibilityLink to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        VisibilityLink.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for VisibilityLink
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        VisibilityLink.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.VisibilityLink";
                        };

                        VisibilityLink.Condition = (function() {

                            /**
                             * Properties of a Condition.
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                             * @interface ICondition
                             * @property {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IElementVisibility|null} [elementVisibility] Condition elementVisibility
                             * @property {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ITimerVisibility|null} [timerVisibility] Condition timerVisibility
                             * @property {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IVideoCountdownVisibility|null} [videoCountdownVisibility] Condition videoCountdownVisibility
                             * @property {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ICaptureSessionVisibility|null} [captureSessionVisibility] Condition captureSessionVisibility
                             * @property {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IVideoInputVisibility|null} [videoInputVisibility] Condition videoInputVisibility
                             * @property {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IAudioCountdownVisibility|null} [audioCountdownVisibility] Condition audioCountdownVisibility
                             */

                            /**
                             * Constructs a new Condition.
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink
                             * @classdesc Represents a Condition.
                             * @implements ICondition
                             * @constructor
                             * @param {rv.data.Slide.Element.DataLink.VisibilityLink.ICondition=} [properties] Properties to set
                             */
                            function Condition(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Condition elementVisibility.
                             * @member {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IElementVisibility|null|undefined} elementVisibility
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @instance
                             */
                            Condition.prototype.elementVisibility = null;

                            /**
                             * Condition timerVisibility.
                             * @member {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ITimerVisibility|null|undefined} timerVisibility
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @instance
                             */
                            Condition.prototype.timerVisibility = null;

                            /**
                             * Condition videoCountdownVisibility.
                             * @member {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IVideoCountdownVisibility|null|undefined} videoCountdownVisibility
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @instance
                             */
                            Condition.prototype.videoCountdownVisibility = null;

                            /**
                             * Condition captureSessionVisibility.
                             * @member {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ICaptureSessionVisibility|null|undefined} captureSessionVisibility
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @instance
                             */
                            Condition.prototype.captureSessionVisibility = null;

                            /**
                             * Condition videoInputVisibility.
                             * @member {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IVideoInputVisibility|null|undefined} videoInputVisibility
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @instance
                             */
                            Condition.prototype.videoInputVisibility = null;

                            /**
                             * Condition audioCountdownVisibility.
                             * @member {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IAudioCountdownVisibility|null|undefined} audioCountdownVisibility
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @instance
                             */
                            Condition.prototype.audioCountdownVisibility = null;

                            // OneOf field names bound to virtual getters and setters
                            let $oneOfFields;

                            /**
                             * Condition ConditionType.
                             * @member {"elementVisibility"|"timerVisibility"|"videoCountdownVisibility"|"captureSessionVisibility"|"videoInputVisibility"|"audioCountdownVisibility"|undefined} ConditionType
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @instance
                             */
                            Object.defineProperty(Condition.prototype, "ConditionType", {
                                get: $util.oneOfGetter($oneOfFields = ["elementVisibility", "timerVisibility", "videoCountdownVisibility", "captureSessionVisibility", "videoInputVisibility", "audioCountdownVisibility"]),
                                set: $util.oneOfSetter($oneOfFields)
                            });

                            /**
                             * Creates a new Condition instance using the specified properties.
                             * @function create
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.VisibilityLink.ICondition=} [properties] Properties to set
                             * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition} Condition instance
                             */
                            Condition.create = function create(properties) {
                                return new Condition(properties);
                            };

                            /**
                             * Encodes the specified Condition message. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.verify|verify} messages.
                             * @function encode
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.VisibilityLink.ICondition} message Condition message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Condition.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.elementVisibility != null && Object.hasOwnProperty.call(message, "elementVisibility"))
                                    $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.encode(message.elementVisibility, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.timerVisibility != null && Object.hasOwnProperty.call(message, "timerVisibility"))
                                    $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.encode(message.timerVisibility, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                                if (message.videoCountdownVisibility != null && Object.hasOwnProperty.call(message, "videoCountdownVisibility"))
                                    $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.encode(message.videoCountdownVisibility, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                                if (message.captureSessionVisibility != null && Object.hasOwnProperty.call(message, "captureSessionVisibility"))
                                    $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.encode(message.captureSessionVisibility, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                                if (message.videoInputVisibility != null && Object.hasOwnProperty.call(message, "videoInputVisibility"))
                                    $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.encode(message.videoInputVisibility, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                                if (message.audioCountdownVisibility != null && Object.hasOwnProperty.call(message, "audioCountdownVisibility"))
                                    $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.encode(message.audioCountdownVisibility, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Condition message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.VisibilityLink.ICondition} message Condition message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Condition.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Condition message from the specified reader or buffer.
                             * @function decode
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition} Condition
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Condition.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.elementVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 2: {
                                            message.timerVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 3: {
                                            message.videoCountdownVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 4: {
                                            message.captureSessionVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 5: {
                                            message.videoInputVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 6: {
                                            message.audioCountdownVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.decode(reader, reader.uint32());
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Condition message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition} Condition
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Condition.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Condition message.
                             * @function verify
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Condition.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                let properties = {};
                                if (message.elementVisibility != null && message.hasOwnProperty("elementVisibility")) {
                                    properties.ConditionType = 1;
                                    {
                                        let error = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.verify(message.elementVisibility);
                                        if (error)
                                            return "elementVisibility." + error;
                                    }
                                }
                                if (message.timerVisibility != null && message.hasOwnProperty("timerVisibility")) {
                                    if (properties.ConditionType === 1)
                                        return "ConditionType: multiple values";
                                    properties.ConditionType = 1;
                                    {
                                        let error = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.verify(message.timerVisibility);
                                        if (error)
                                            return "timerVisibility." + error;
                                    }
                                }
                                if (message.videoCountdownVisibility != null && message.hasOwnProperty("videoCountdownVisibility")) {
                                    if (properties.ConditionType === 1)
                                        return "ConditionType: multiple values";
                                    properties.ConditionType = 1;
                                    {
                                        let error = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.verify(message.videoCountdownVisibility);
                                        if (error)
                                            return "videoCountdownVisibility." + error;
                                    }
                                }
                                if (message.captureSessionVisibility != null && message.hasOwnProperty("captureSessionVisibility")) {
                                    if (properties.ConditionType === 1)
                                        return "ConditionType: multiple values";
                                    properties.ConditionType = 1;
                                    {
                                        let error = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.verify(message.captureSessionVisibility);
                                        if (error)
                                            return "captureSessionVisibility." + error;
                                    }
                                }
                                if (message.videoInputVisibility != null && message.hasOwnProperty("videoInputVisibility")) {
                                    if (properties.ConditionType === 1)
                                        return "ConditionType: multiple values";
                                    properties.ConditionType = 1;
                                    {
                                        let error = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.verify(message.videoInputVisibility);
                                        if (error)
                                            return "videoInputVisibility." + error;
                                    }
                                }
                                if (message.audioCountdownVisibility != null && message.hasOwnProperty("audioCountdownVisibility")) {
                                    if (properties.ConditionType === 1)
                                        return "ConditionType: multiple values";
                                    properties.ConditionType = 1;
                                    {
                                        let error = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.verify(message.audioCountdownVisibility);
                                        if (error)
                                            return "audioCountdownVisibility." + error;
                                    }
                                }
                                return null;
                            };

                            /**
                             * Creates a Condition message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition} Condition
                             */
                            Condition.fromObject = function fromObject(object) {
                                if (object instanceof $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition)
                                    return object;
                                let message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition();
                                if (object.elementVisibility != null) {
                                    if (typeof object.elementVisibility !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.VisibilityLink.Condition.elementVisibility: object expected");
                                    message.elementVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.fromObject(object.elementVisibility);
                                }
                                if (object.timerVisibility != null) {
                                    if (typeof object.timerVisibility !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.VisibilityLink.Condition.timerVisibility: object expected");
                                    message.timerVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.fromObject(object.timerVisibility);
                                }
                                if (object.videoCountdownVisibility != null) {
                                    if (typeof object.videoCountdownVisibility !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.VisibilityLink.Condition.videoCountdownVisibility: object expected");
                                    message.videoCountdownVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.fromObject(object.videoCountdownVisibility);
                                }
                                if (object.captureSessionVisibility != null) {
                                    if (typeof object.captureSessionVisibility !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.VisibilityLink.Condition.captureSessionVisibility: object expected");
                                    message.captureSessionVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.fromObject(object.captureSessionVisibility);
                                }
                                if (object.videoInputVisibility != null) {
                                    if (typeof object.videoInputVisibility !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.VisibilityLink.Condition.videoInputVisibility: object expected");
                                    message.videoInputVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.fromObject(object.videoInputVisibility);
                                }
                                if (object.audioCountdownVisibility != null) {
                                    if (typeof object.audioCountdownVisibility !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.VisibilityLink.Condition.audioCountdownVisibility: object expected");
                                    message.audioCountdownVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.fromObject(object.audioCountdownVisibility);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Condition message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition} message Condition
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Condition.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (message.elementVisibility != null && message.hasOwnProperty("elementVisibility")) {
                                    object.elementVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.toObject(message.elementVisibility, options);
                                    if (options.oneofs)
                                        object.ConditionType = "elementVisibility";
                                }
                                if (message.timerVisibility != null && message.hasOwnProperty("timerVisibility")) {
                                    object.timerVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.toObject(message.timerVisibility, options);
                                    if (options.oneofs)
                                        object.ConditionType = "timerVisibility";
                                }
                                if (message.videoCountdownVisibility != null && message.hasOwnProperty("videoCountdownVisibility")) {
                                    object.videoCountdownVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.toObject(message.videoCountdownVisibility, options);
                                    if (options.oneofs)
                                        object.ConditionType = "videoCountdownVisibility";
                                }
                                if (message.captureSessionVisibility != null && message.hasOwnProperty("captureSessionVisibility")) {
                                    object.captureSessionVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.toObject(message.captureSessionVisibility, options);
                                    if (options.oneofs)
                                        object.ConditionType = "captureSessionVisibility";
                                }
                                if (message.videoInputVisibility != null && message.hasOwnProperty("videoInputVisibility")) {
                                    object.videoInputVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.toObject(message.videoInputVisibility, options);
                                    if (options.oneofs)
                                        object.ConditionType = "videoInputVisibility";
                                }
                                if (message.audioCountdownVisibility != null && message.hasOwnProperty("audioCountdownVisibility")) {
                                    object.audioCountdownVisibility = $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.toObject(message.audioCountdownVisibility, options);
                                    if (options.oneofs)
                                        object.ConditionType = "audioCountdownVisibility";
                                }
                                return object;
                            };

                            /**
                             * Converts this Condition to JSON.
                             * @function toJSON
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Condition.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for Condition
                             * @function getTypeUrl
                             * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            Condition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.VisibilityLink.Condition";
                            };

                            Condition.ElementVisibility = (function() {

                                /**
                                 * Properties of an ElementVisibility.
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                                 * @interface IElementVisibility
                                 * @property {rv.data.IUUID|null} [otherElementUuid] ElementVisibility otherElementUuid
                                 * @property {string|null} [otherElementName] ElementVisibility otherElementName
                                 * @property {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.ElementVisibilityCriterion|null} [visibilityCriterion] ElementVisibility visibilityCriterion
                                 */

                                /**
                                 * Constructs a new ElementVisibility.
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                                 * @classdesc Represents an ElementVisibility.
                                 * @implements IElementVisibility
                                 * @constructor
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IElementVisibility=} [properties] Properties to set
                                 */
                                function ElementVisibility(properties) {
                                    if (properties)
                                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * ElementVisibility otherElementUuid.
                                 * @member {rv.data.IUUID|null|undefined} otherElementUuid
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility
                                 * @instance
                                 */
                                ElementVisibility.prototype.otherElementUuid = null;

                                /**
                                 * ElementVisibility otherElementName.
                                 * @member {string} otherElementName
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility
                                 * @instance
                                 */
                                ElementVisibility.prototype.otherElementName = "";

                                /**
                                 * ElementVisibility visibilityCriterion.
                                 * @member {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.ElementVisibilityCriterion} visibilityCriterion
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility
                                 * @instance
                                 */
                                ElementVisibility.prototype.visibilityCriterion = 0;

                                /**
                                 * Creates a new ElementVisibility instance using the specified properties.
                                 * @function create
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IElementVisibility=} [properties] Properties to set
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility} ElementVisibility instance
                                 */
                                ElementVisibility.create = function create(properties) {
                                    return new ElementVisibility(properties);
                                };

                                /**
                                 * Encodes the specified ElementVisibility message. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.verify|verify} messages.
                                 * @function encode
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IElementVisibility} message ElementVisibility message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                ElementVisibility.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.otherElementUuid != null && Object.hasOwnProperty.call(message, "otherElementUuid"))
                                        $root.rv.data.UUID.encode(message.otherElementUuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                    if (message.otherElementName != null && Object.hasOwnProperty.call(message, "otherElementName"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.otherElementName);
                                    if (message.visibilityCriterion != null && Object.hasOwnProperty.call(message, "visibilityCriterion"))
                                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.visibilityCriterion);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified ElementVisibility message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IElementVisibility} message ElementVisibility message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                ElementVisibility.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an ElementVisibility message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility} ElementVisibility
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                ElementVisibility.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility();
                                    while (reader.pos < end) {
                                        let tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1: {
                                                message.otherElementUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                                break;
                                            }
                                        case 2: {
                                                message.otherElementName = reader.string();
                                                break;
                                            }
                                        case 3: {
                                                message.visibilityCriterion = reader.int32();
                                                break;
                                            }
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an ElementVisibility message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility} ElementVisibility
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                ElementVisibility.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an ElementVisibility message.
                                 * @function verify
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                ElementVisibility.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.otherElementUuid != null && message.hasOwnProperty("otherElementUuid")) {
                                        let error = $root.rv.data.UUID.verify(message.otherElementUuid);
                                        if (error)
                                            return "otherElementUuid." + error;
                                    }
                                    if (message.otherElementName != null && message.hasOwnProperty("otherElementName"))
                                        if (!$util.isString(message.otherElementName))
                                            return "otherElementName: string expected";
                                    if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                        switch (message.visibilityCriterion) {
                                        default:
                                            return "visibilityCriterion: enum value expected";
                                        case 0:
                                        case 1:
                                            break;
                                        }
                                    return null;
                                };

                                /**
                                 * Creates an ElementVisibility message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility} ElementVisibility
                                 */
                                ElementVisibility.fromObject = function fromObject(object) {
                                    if (object instanceof $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility)
                                        return object;
                                    let message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility();
                                    if (object.otherElementUuid != null) {
                                        if (typeof object.otherElementUuid !== "object")
                                            throw TypeError(".rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.otherElementUuid: object expected");
                                        message.otherElementUuid = $root.rv.data.UUID.fromObject(object.otherElementUuid);
                                    }
                                    if (object.otherElementName != null)
                                        message.otherElementName = String(object.otherElementName);
                                    switch (object.visibilityCriterion) {
                                    default:
                                        if (typeof object.visibilityCriterion === "number") {
                                            message.visibilityCriterion = object.visibilityCriterion;
                                            break;
                                        }
                                        break;
                                    case "ELEMENT_VISIBILITY_CRITERION_HAS_TEXT":
                                    case 0:
                                        message.visibilityCriterion = 0;
                                        break;
                                    case "ELEMENT_VISIBILITY_CRITERION_HAS_NO_TEXT":
                                    case 1:
                                        message.visibilityCriterion = 1;
                                        break;
                                    }
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an ElementVisibility message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility} message ElementVisibility
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                ElementVisibility.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    let object = {};
                                    if (options.defaults) {
                                        object.otherElementUuid = null;
                                        object.otherElementName = "";
                                        object.visibilityCriterion = options.enums === String ? "ELEMENT_VISIBILITY_CRITERION_HAS_TEXT" : 0;
                                    }
                                    if (message.otherElementUuid != null && message.hasOwnProperty("otherElementUuid"))
                                        object.otherElementUuid = $root.rv.data.UUID.toObject(message.otherElementUuid, options);
                                    if (message.otherElementName != null && message.hasOwnProperty("otherElementName"))
                                        object.otherElementName = message.otherElementName;
                                    if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                        object.visibilityCriterion = options.enums === String ? $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.ElementVisibilityCriterion[message.visibilityCriterion] === undefined ? message.visibilityCriterion : $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.ElementVisibilityCriterion[message.visibilityCriterion] : message.visibilityCriterion;
                                    return object;
                                };

                                /**
                                 * Converts this ElementVisibility to JSON.
                                 * @function toJSON
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                ElementVisibility.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Gets the default type url for ElementVisibility
                                 * @function getTypeUrl
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility
                                 * @static
                                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns {string} The default type url
                                 */
                                ElementVisibility.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                    if (typeUrlPrefix === undefined) {
                                        typeUrlPrefix = "type.googleapis.com";
                                    }
                                    return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility";
                                };

                                /**
                                 * ElementVisibilityCriterion enum.
                                 * @name rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.ElementVisibilityCriterion
                                 * @enum {number}
                                 * @property {number} ELEMENT_VISIBILITY_CRITERION_HAS_TEXT=0 ELEMENT_VISIBILITY_CRITERION_HAS_TEXT value
                                 * @property {number} ELEMENT_VISIBILITY_CRITERION_HAS_NO_TEXT=1 ELEMENT_VISIBILITY_CRITERION_HAS_NO_TEXT value
                                 */
                                ElementVisibility.ElementVisibilityCriterion = (function() {
                                    const valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "ELEMENT_VISIBILITY_CRITERION_HAS_TEXT"] = 0;
                                    values[valuesById[1] = "ELEMENT_VISIBILITY_CRITERION_HAS_NO_TEXT"] = 1;
                                    return values;
                                })();

                                return ElementVisibility;
                            })();

                            Condition.TimerVisibility = (function() {

                                /**
                                 * Properties of a TimerVisibility.
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                                 * @interface ITimerVisibility
                                 * @property {rv.data.IUUID|null} [timerUuid] TimerVisibility timerUuid
                                 * @property {string|null} [timerName] TimerVisibility timerName
                                 * @property {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.TimerVisibilityCriterion|null} [visibilityCriterion] TimerVisibility visibilityCriterion
                                 */

                                /**
                                 * Constructs a new TimerVisibility.
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                                 * @classdesc Represents a TimerVisibility.
                                 * @implements ITimerVisibility
                                 * @constructor
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ITimerVisibility=} [properties] Properties to set
                                 */
                                function TimerVisibility(properties) {
                                    if (properties)
                                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * TimerVisibility timerUuid.
                                 * @member {rv.data.IUUID|null|undefined} timerUuid
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility
                                 * @instance
                                 */
                                TimerVisibility.prototype.timerUuid = null;

                                /**
                                 * TimerVisibility timerName.
                                 * @member {string} timerName
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility
                                 * @instance
                                 */
                                TimerVisibility.prototype.timerName = "";

                                /**
                                 * TimerVisibility visibilityCriterion.
                                 * @member {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.TimerVisibilityCriterion} visibilityCriterion
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility
                                 * @instance
                                 */
                                TimerVisibility.prototype.visibilityCriterion = 0;

                                /**
                                 * Creates a new TimerVisibility instance using the specified properties.
                                 * @function create
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ITimerVisibility=} [properties] Properties to set
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility} TimerVisibility instance
                                 */
                                TimerVisibility.create = function create(properties) {
                                    return new TimerVisibility(properties);
                                };

                                /**
                                 * Encodes the specified TimerVisibility message. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.verify|verify} messages.
                                 * @function encode
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ITimerVisibility} message TimerVisibility message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                TimerVisibility.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.timerUuid != null && Object.hasOwnProperty.call(message, "timerUuid"))
                                        $root.rv.data.UUID.encode(message.timerUuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                    if (message.timerName != null && Object.hasOwnProperty.call(message, "timerName"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.timerName);
                                    if (message.visibilityCriterion != null && Object.hasOwnProperty.call(message, "visibilityCriterion"))
                                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.visibilityCriterion);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified TimerVisibility message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ITimerVisibility} message TimerVisibility message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                TimerVisibility.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes a TimerVisibility message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility} TimerVisibility
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                TimerVisibility.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility();
                                    while (reader.pos < end) {
                                        let tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1: {
                                                message.timerUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                                break;
                                            }
                                        case 2: {
                                                message.timerName = reader.string();
                                                break;
                                            }
                                        case 3: {
                                                message.visibilityCriterion = reader.int32();
                                                break;
                                            }
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes a TimerVisibility message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility} TimerVisibility
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                TimerVisibility.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies a TimerVisibility message.
                                 * @function verify
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                TimerVisibility.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.timerUuid != null && message.hasOwnProperty("timerUuid")) {
                                        let error = $root.rv.data.UUID.verify(message.timerUuid);
                                        if (error)
                                            return "timerUuid." + error;
                                    }
                                    if (message.timerName != null && message.hasOwnProperty("timerName"))
                                        if (!$util.isString(message.timerName))
                                            return "timerName: string expected";
                                    if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                        switch (message.visibilityCriterion) {
                                        default:
                                            return "visibilityCriterion: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                        case 3:
                                            break;
                                        }
                                    return null;
                                };

                                /**
                                 * Creates a TimerVisibility message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility} TimerVisibility
                                 */
                                TimerVisibility.fromObject = function fromObject(object) {
                                    if (object instanceof $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility)
                                        return object;
                                    let message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility();
                                    if (object.timerUuid != null) {
                                        if (typeof object.timerUuid !== "object")
                                            throw TypeError(".rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.timerUuid: object expected");
                                        message.timerUuid = $root.rv.data.UUID.fromObject(object.timerUuid);
                                    }
                                    if (object.timerName != null)
                                        message.timerName = String(object.timerName);
                                    switch (object.visibilityCriterion) {
                                    default:
                                        if (typeof object.visibilityCriterion === "number") {
                                            message.visibilityCriterion = object.visibilityCriterion;
                                            break;
                                        }
                                        break;
                                    case "TIMER_VISIBILITY_CRITERION_HAS_TIME_REMAINING":
                                    case 0:
                                        message.visibilityCriterion = 0;
                                        break;
                                    case "TIMER_VISIBILITY_CRITERION_HAS_EXPIRED":
                                    case 1:
                                        message.visibilityCriterion = 1;
                                        break;
                                    case "TIMER_VISIBILITY_CRITERION_IS_RUNNING":
                                    case 2:
                                        message.visibilityCriterion = 2;
                                        break;
                                    case "TIMER_VISIBILITY_CRITERION_NOT_RUNNING":
                                    case 3:
                                        message.visibilityCriterion = 3;
                                        break;
                                    }
                                    return message;
                                };

                                /**
                                 * Creates a plain object from a TimerVisibility message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility} message TimerVisibility
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                TimerVisibility.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    let object = {};
                                    if (options.defaults) {
                                        object.timerUuid = null;
                                        object.timerName = "";
                                        object.visibilityCriterion = options.enums === String ? "TIMER_VISIBILITY_CRITERION_HAS_TIME_REMAINING" : 0;
                                    }
                                    if (message.timerUuid != null && message.hasOwnProperty("timerUuid"))
                                        object.timerUuid = $root.rv.data.UUID.toObject(message.timerUuid, options);
                                    if (message.timerName != null && message.hasOwnProperty("timerName"))
                                        object.timerName = message.timerName;
                                    if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                        object.visibilityCriterion = options.enums === String ? $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.TimerVisibilityCriterion[message.visibilityCriterion] === undefined ? message.visibilityCriterion : $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.TimerVisibilityCriterion[message.visibilityCriterion] : message.visibilityCriterion;
                                    return object;
                                };

                                /**
                                 * Converts this TimerVisibility to JSON.
                                 * @function toJSON
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                TimerVisibility.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Gets the default type url for TimerVisibility
                                 * @function getTypeUrl
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility
                                 * @static
                                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns {string} The default type url
                                 */
                                TimerVisibility.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                    if (typeUrlPrefix === undefined) {
                                        typeUrlPrefix = "type.googleapis.com";
                                    }
                                    return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility";
                                };

                                /**
                                 * TimerVisibilityCriterion enum.
                                 * @name rv.data.Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.TimerVisibilityCriterion
                                 * @enum {number}
                                 * @property {number} TIMER_VISIBILITY_CRITERION_HAS_TIME_REMAINING=0 TIMER_VISIBILITY_CRITERION_HAS_TIME_REMAINING value
                                 * @property {number} TIMER_VISIBILITY_CRITERION_HAS_EXPIRED=1 TIMER_VISIBILITY_CRITERION_HAS_EXPIRED value
                                 * @property {number} TIMER_VISIBILITY_CRITERION_IS_RUNNING=2 TIMER_VISIBILITY_CRITERION_IS_RUNNING value
                                 * @property {number} TIMER_VISIBILITY_CRITERION_NOT_RUNNING=3 TIMER_VISIBILITY_CRITERION_NOT_RUNNING value
                                 */
                                TimerVisibility.TimerVisibilityCriterion = (function() {
                                    const valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "TIMER_VISIBILITY_CRITERION_HAS_TIME_REMAINING"] = 0;
                                    values[valuesById[1] = "TIMER_VISIBILITY_CRITERION_HAS_EXPIRED"] = 1;
                                    values[valuesById[2] = "TIMER_VISIBILITY_CRITERION_IS_RUNNING"] = 2;
                                    values[valuesById[3] = "TIMER_VISIBILITY_CRITERION_NOT_RUNNING"] = 3;
                                    return values;
                                })();

                                return TimerVisibility;
                            })();

                            Condition.VideoCountdownVisibility = (function() {

                                /**
                                 * Properties of a VideoCountdownVisibility.
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                                 * @interface IVideoCountdownVisibility
                                 * @property {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.VideoCountdownVisibilityCriterion|null} [visibilityCriterion] VideoCountdownVisibility visibilityCriterion
                                 */

                                /**
                                 * Constructs a new VideoCountdownVisibility.
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                                 * @classdesc Represents a VideoCountdownVisibility.
                                 * @implements IVideoCountdownVisibility
                                 * @constructor
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IVideoCountdownVisibility=} [properties] Properties to set
                                 */
                                function VideoCountdownVisibility(properties) {
                                    if (properties)
                                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * VideoCountdownVisibility visibilityCriterion.
                                 * @member {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.VideoCountdownVisibilityCriterion} visibilityCriterion
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility
                                 * @instance
                                 */
                                VideoCountdownVisibility.prototype.visibilityCriterion = 0;

                                /**
                                 * Creates a new VideoCountdownVisibility instance using the specified properties.
                                 * @function create
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IVideoCountdownVisibility=} [properties] Properties to set
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility} VideoCountdownVisibility instance
                                 */
                                VideoCountdownVisibility.create = function create(properties) {
                                    return new VideoCountdownVisibility(properties);
                                };

                                /**
                                 * Encodes the specified VideoCountdownVisibility message. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.verify|verify} messages.
                                 * @function encode
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IVideoCountdownVisibility} message VideoCountdownVisibility message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                VideoCountdownVisibility.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.visibilityCriterion != null && Object.hasOwnProperty.call(message, "visibilityCriterion"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.visibilityCriterion);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified VideoCountdownVisibility message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IVideoCountdownVisibility} message VideoCountdownVisibility message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                VideoCountdownVisibility.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes a VideoCountdownVisibility message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility} VideoCountdownVisibility
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                VideoCountdownVisibility.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility();
                                    while (reader.pos < end) {
                                        let tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1: {
                                                message.visibilityCriterion = reader.int32();
                                                break;
                                            }
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes a VideoCountdownVisibility message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility} VideoCountdownVisibility
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                VideoCountdownVisibility.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies a VideoCountdownVisibility message.
                                 * @function verify
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                VideoCountdownVisibility.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                        switch (message.visibilityCriterion) {
                                        default:
                                            return "visibilityCriterion: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                        case 3:
                                        case 4:
                                        case 5:
                                            break;
                                        }
                                    return null;
                                };

                                /**
                                 * Creates a VideoCountdownVisibility message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility} VideoCountdownVisibility
                                 */
                                VideoCountdownVisibility.fromObject = function fromObject(object) {
                                    if (object instanceof $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility)
                                        return object;
                                    let message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility();
                                    switch (object.visibilityCriterion) {
                                    default:
                                        if (typeof object.visibilityCriterion === "number") {
                                            message.visibilityCriterion = object.visibilityCriterion;
                                            break;
                                        }
                                        break;
                                    case "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING":
                                    case 0:
                                        message.visibilityCriterion = 0;
                                        break;
                                    case "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED":
                                    case 1:
                                        message.visibilityCriterion = 1;
                                        break;
                                    case "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING":
                                    case 2:
                                        message.visibilityCriterion = 2;
                                        break;
                                    case "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING":
                                    case 3:
                                        message.visibilityCriterion = 3;
                                        break;
                                    case "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING":
                                    case 4:
                                        message.visibilityCriterion = 4;
                                        break;
                                    case "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING":
                                    case 5:
                                        message.visibilityCriterion = 5;
                                        break;
                                    }
                                    return message;
                                };

                                /**
                                 * Creates a plain object from a VideoCountdownVisibility message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility} message VideoCountdownVisibility
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                VideoCountdownVisibility.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    let object = {};
                                    if (options.defaults)
                                        object.visibilityCriterion = options.enums === String ? "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING" : 0;
                                    if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                        object.visibilityCriterion = options.enums === String ? $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.VideoCountdownVisibilityCriterion[message.visibilityCriterion] === undefined ? message.visibilityCriterion : $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.VideoCountdownVisibilityCriterion[message.visibilityCriterion] : message.visibilityCriterion;
                                    return object;
                                };

                                /**
                                 * Converts this VideoCountdownVisibility to JSON.
                                 * @function toJSON
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                VideoCountdownVisibility.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Gets the default type url for VideoCountdownVisibility
                                 * @function getTypeUrl
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility
                                 * @static
                                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns {string} The default type url
                                 */
                                VideoCountdownVisibility.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                    if (typeUrlPrefix === undefined) {
                                        typeUrlPrefix = "type.googleapis.com";
                                    }
                                    return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility";
                                };

                                /**
                                 * VideoCountdownVisibilityCriterion enum.
                                 * @name rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.VideoCountdownVisibilityCriterion
                                 * @enum {number}
                                 * @property {number} VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING=0 VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING value
                                 * @property {number} VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED=1 VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED value
                                 * @property {number} VIDEO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING=2 VIDEO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING value
                                 * @property {number} VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING=3 VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING value
                                 * @property {number} VIDEO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING=4 VIDEO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING value
                                 * @property {number} VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING=5 VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING value
                                 */
                                VideoCountdownVisibility.VideoCountdownVisibilityCriterion = (function() {
                                    const valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING"] = 0;
                                    values[valuesById[1] = "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED"] = 1;
                                    values[valuesById[2] = "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING"] = 2;
                                    values[valuesById[3] = "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING"] = 3;
                                    values[valuesById[4] = "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING"] = 4;
                                    values[valuesById[5] = "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING"] = 5;
                                    return values;
                                })();

                                return VideoCountdownVisibility;
                            })();

                            Condition.AudioCountdownVisibility = (function() {

                                /**
                                 * Properties of an AudioCountdownVisibility.
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                                 * @interface IAudioCountdownVisibility
                                 * @property {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.AudioCountdownVisibilityCriterion|null} [visibilityCriterion] AudioCountdownVisibility visibilityCriterion
                                 */

                                /**
                                 * Constructs a new AudioCountdownVisibility.
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                                 * @classdesc Represents an AudioCountdownVisibility.
                                 * @implements IAudioCountdownVisibility
                                 * @constructor
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IAudioCountdownVisibility=} [properties] Properties to set
                                 */
                                function AudioCountdownVisibility(properties) {
                                    if (properties)
                                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * AudioCountdownVisibility visibilityCriterion.
                                 * @member {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.AudioCountdownVisibilityCriterion} visibilityCriterion
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility
                                 * @instance
                                 */
                                AudioCountdownVisibility.prototype.visibilityCriterion = 0;

                                /**
                                 * Creates a new AudioCountdownVisibility instance using the specified properties.
                                 * @function create
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IAudioCountdownVisibility=} [properties] Properties to set
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility} AudioCountdownVisibility instance
                                 */
                                AudioCountdownVisibility.create = function create(properties) {
                                    return new AudioCountdownVisibility(properties);
                                };

                                /**
                                 * Encodes the specified AudioCountdownVisibility message. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.verify|verify} messages.
                                 * @function encode
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IAudioCountdownVisibility} message AudioCountdownVisibility message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                AudioCountdownVisibility.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.visibilityCriterion != null && Object.hasOwnProperty.call(message, "visibilityCriterion"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.visibilityCriterion);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified AudioCountdownVisibility message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IAudioCountdownVisibility} message AudioCountdownVisibility message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                AudioCountdownVisibility.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an AudioCountdownVisibility message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility} AudioCountdownVisibility
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                AudioCountdownVisibility.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility();
                                    while (reader.pos < end) {
                                        let tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1: {
                                                message.visibilityCriterion = reader.int32();
                                                break;
                                            }
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an AudioCountdownVisibility message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility} AudioCountdownVisibility
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                AudioCountdownVisibility.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an AudioCountdownVisibility message.
                                 * @function verify
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                AudioCountdownVisibility.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                        switch (message.visibilityCriterion) {
                                        default:
                                            return "visibilityCriterion: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                        case 3:
                                        case 4:
                                        case 5:
                                            break;
                                        }
                                    return null;
                                };

                                /**
                                 * Creates an AudioCountdownVisibility message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility} AudioCountdownVisibility
                                 */
                                AudioCountdownVisibility.fromObject = function fromObject(object) {
                                    if (object instanceof $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility)
                                        return object;
                                    let message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility();
                                    switch (object.visibilityCriterion) {
                                    default:
                                        if (typeof object.visibilityCriterion === "number") {
                                            message.visibilityCriterion = object.visibilityCriterion;
                                            break;
                                        }
                                        break;
                                    case "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING":
                                    case 0:
                                        message.visibilityCriterion = 0;
                                        break;
                                    case "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED":
                                    case 1:
                                        message.visibilityCriterion = 1;
                                        break;
                                    case "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING":
                                    case 2:
                                        message.visibilityCriterion = 2;
                                        break;
                                    case "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING":
                                    case 3:
                                        message.visibilityCriterion = 3;
                                        break;
                                    case "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING":
                                    case 4:
                                        message.visibilityCriterion = 4;
                                        break;
                                    case "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING":
                                    case 5:
                                        message.visibilityCriterion = 5;
                                        break;
                                    }
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an AudioCountdownVisibility message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility} message AudioCountdownVisibility
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                AudioCountdownVisibility.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    let object = {};
                                    if (options.defaults)
                                        object.visibilityCriterion = options.enums === String ? "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING" : 0;
                                    if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                        object.visibilityCriterion = options.enums === String ? $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.AudioCountdownVisibilityCriterion[message.visibilityCriterion] === undefined ? message.visibilityCriterion : $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.AudioCountdownVisibilityCriterion[message.visibilityCriterion] : message.visibilityCriterion;
                                    return object;
                                };

                                /**
                                 * Converts this AudioCountdownVisibility to JSON.
                                 * @function toJSON
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                AudioCountdownVisibility.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Gets the default type url for AudioCountdownVisibility
                                 * @function getTypeUrl
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility
                                 * @static
                                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns {string} The default type url
                                 */
                                AudioCountdownVisibility.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                    if (typeUrlPrefix === undefined) {
                                        typeUrlPrefix = "type.googleapis.com";
                                    }
                                    return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility";
                                };

                                /**
                                 * AudioCountdownVisibilityCriterion enum.
                                 * @name rv.data.Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.AudioCountdownVisibilityCriterion
                                 * @enum {number}
                                 * @property {number} AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING=0 AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING value
                                 * @property {number} AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED=1 AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED value
                                 * @property {number} AUDIO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING=2 AUDIO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING value
                                 * @property {number} AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING=3 AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING value
                                 * @property {number} AUDIO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING=4 AUDIO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING value
                                 * @property {number} AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING=5 AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING value
                                 */
                                AudioCountdownVisibility.AudioCountdownVisibilityCriterion = (function() {
                                    const valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING"] = 0;
                                    values[valuesById[1] = "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED"] = 1;
                                    values[valuesById[2] = "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING"] = 2;
                                    values[valuesById[3] = "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING"] = 3;
                                    values[valuesById[4] = "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING"] = 4;
                                    values[valuesById[5] = "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING"] = 5;
                                    return values;
                                })();

                                return AudioCountdownVisibility;
                            })();

                            Condition.CaptureSessionVisibility = (function() {

                                /**
                                 * Properties of a CaptureSessionVisibility.
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                                 * @interface ICaptureSessionVisibility
                                 * @property {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.CaptureSessionVisibilityCriterion|null} [visibilityCriterion] CaptureSessionVisibility visibilityCriterion
                                 */

                                /**
                                 * Constructs a new CaptureSessionVisibility.
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                                 * @classdesc Represents a CaptureSessionVisibility.
                                 * @implements ICaptureSessionVisibility
                                 * @constructor
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ICaptureSessionVisibility=} [properties] Properties to set
                                 */
                                function CaptureSessionVisibility(properties) {
                                    if (properties)
                                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * CaptureSessionVisibility visibilityCriterion.
                                 * @member {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.CaptureSessionVisibilityCriterion} visibilityCriterion
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility
                                 * @instance
                                 */
                                CaptureSessionVisibility.prototype.visibilityCriterion = 0;

                                /**
                                 * Creates a new CaptureSessionVisibility instance using the specified properties.
                                 * @function create
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ICaptureSessionVisibility=} [properties] Properties to set
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility} CaptureSessionVisibility instance
                                 */
                                CaptureSessionVisibility.create = function create(properties) {
                                    return new CaptureSessionVisibility(properties);
                                };

                                /**
                                 * Encodes the specified CaptureSessionVisibility message. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.verify|verify} messages.
                                 * @function encode
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ICaptureSessionVisibility} message CaptureSessionVisibility message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                CaptureSessionVisibility.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.visibilityCriterion != null && Object.hasOwnProperty.call(message, "visibilityCriterion"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.visibilityCriterion);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified CaptureSessionVisibility message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.ICaptureSessionVisibility} message CaptureSessionVisibility message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                CaptureSessionVisibility.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes a CaptureSessionVisibility message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility} CaptureSessionVisibility
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                CaptureSessionVisibility.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility();
                                    while (reader.pos < end) {
                                        let tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1: {
                                                message.visibilityCriterion = reader.int32();
                                                break;
                                            }
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes a CaptureSessionVisibility message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility} CaptureSessionVisibility
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                CaptureSessionVisibility.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies a CaptureSessionVisibility message.
                                 * @function verify
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                CaptureSessionVisibility.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                        switch (message.visibilityCriterion) {
                                        default:
                                            return "visibilityCriterion: enum value expected";
                                        case 0:
                                        case 1:
                                            break;
                                        }
                                    return null;
                                };

                                /**
                                 * Creates a CaptureSessionVisibility message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility} CaptureSessionVisibility
                                 */
                                CaptureSessionVisibility.fromObject = function fromObject(object) {
                                    if (object instanceof $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility)
                                        return object;
                                    let message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility();
                                    switch (object.visibilityCriterion) {
                                    default:
                                        if (typeof object.visibilityCriterion === "number") {
                                            message.visibilityCriterion = object.visibilityCriterion;
                                            break;
                                        }
                                        break;
                                    case "CAPTURE_SESSION_VISIBILITY_CRITERION_ACTIVE":
                                    case 0:
                                        message.visibilityCriterion = 0;
                                        break;
                                    case "CAPTURE_SESSION_VISIBILITY_CRITERION_INACTIVE":
                                    case 1:
                                        message.visibilityCriterion = 1;
                                        break;
                                    }
                                    return message;
                                };

                                /**
                                 * Creates a plain object from a CaptureSessionVisibility message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility} message CaptureSessionVisibility
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                CaptureSessionVisibility.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    let object = {};
                                    if (options.defaults)
                                        object.visibilityCriterion = options.enums === String ? "CAPTURE_SESSION_VISIBILITY_CRITERION_ACTIVE" : 0;
                                    if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                        object.visibilityCriterion = options.enums === String ? $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.CaptureSessionVisibilityCriterion[message.visibilityCriterion] === undefined ? message.visibilityCriterion : $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.CaptureSessionVisibilityCriterion[message.visibilityCriterion] : message.visibilityCriterion;
                                    return object;
                                };

                                /**
                                 * Converts this CaptureSessionVisibility to JSON.
                                 * @function toJSON
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                CaptureSessionVisibility.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Gets the default type url for CaptureSessionVisibility
                                 * @function getTypeUrl
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility
                                 * @static
                                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns {string} The default type url
                                 */
                                CaptureSessionVisibility.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                    if (typeUrlPrefix === undefined) {
                                        typeUrlPrefix = "type.googleapis.com";
                                    }
                                    return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility";
                                };

                                /**
                                 * CaptureSessionVisibilityCriterion enum.
                                 * @name rv.data.Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.CaptureSessionVisibilityCriterion
                                 * @enum {number}
                                 * @property {number} CAPTURE_SESSION_VISIBILITY_CRITERION_ACTIVE=0 CAPTURE_SESSION_VISIBILITY_CRITERION_ACTIVE value
                                 * @property {number} CAPTURE_SESSION_VISIBILITY_CRITERION_INACTIVE=1 CAPTURE_SESSION_VISIBILITY_CRITERION_INACTIVE value
                                 */
                                CaptureSessionVisibility.CaptureSessionVisibilityCriterion = (function() {
                                    const valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "CAPTURE_SESSION_VISIBILITY_CRITERION_ACTIVE"] = 0;
                                    values[valuesById[1] = "CAPTURE_SESSION_VISIBILITY_CRITERION_INACTIVE"] = 1;
                                    return values;
                                })();

                                return CaptureSessionVisibility;
                            })();

                            Condition.VideoInputVisibility = (function() {

                                /**
                                 * Properties of a VideoInputVisibility.
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                                 * @interface IVideoInputVisibility
                                 * @property {number|null} [videoInputIndex] VideoInputVisibility videoInputIndex
                                 * @property {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.VideoInputVisibilityCriterion|null} [visibilityCriterion] VideoInputVisibility visibilityCriterion
                                 */

                                /**
                                 * Constructs a new VideoInputVisibility.
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition
                                 * @classdesc Represents a VideoInputVisibility.
                                 * @implements IVideoInputVisibility
                                 * @constructor
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IVideoInputVisibility=} [properties] Properties to set
                                 */
                                function VideoInputVisibility(properties) {
                                    if (properties)
                                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * VideoInputVisibility videoInputIndex.
                                 * @member {number} videoInputIndex
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility
                                 * @instance
                                 */
                                VideoInputVisibility.prototype.videoInputIndex = 0;

                                /**
                                 * VideoInputVisibility visibilityCriterion.
                                 * @member {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.VideoInputVisibilityCriterion} visibilityCriterion
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility
                                 * @instance
                                 */
                                VideoInputVisibility.prototype.visibilityCriterion = 0;

                                /**
                                 * Creates a new VideoInputVisibility instance using the specified properties.
                                 * @function create
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IVideoInputVisibility=} [properties] Properties to set
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility} VideoInputVisibility instance
                                 */
                                VideoInputVisibility.create = function create(properties) {
                                    return new VideoInputVisibility(properties);
                                };

                                /**
                                 * Encodes the specified VideoInputVisibility message. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.verify|verify} messages.
                                 * @function encode
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IVideoInputVisibility} message VideoInputVisibility message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                VideoInputVisibility.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.videoInputIndex != null && Object.hasOwnProperty.call(message, "videoInputIndex"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.videoInputIndex);
                                    if (message.visibilityCriterion != null && Object.hasOwnProperty.call(message, "visibilityCriterion"))
                                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.visibilityCriterion);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified VideoInputVisibility message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.IVideoInputVisibility} message VideoInputVisibility message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                VideoInputVisibility.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes a VideoInputVisibility message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility} VideoInputVisibility
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                VideoInputVisibility.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility();
                                    while (reader.pos < end) {
                                        let tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1: {
                                                message.videoInputIndex = reader.int32();
                                                break;
                                            }
                                        case 2: {
                                                message.visibilityCriterion = reader.int32();
                                                break;
                                            }
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes a VideoInputVisibility message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility} VideoInputVisibility
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                VideoInputVisibility.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies a VideoInputVisibility message.
                                 * @function verify
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                VideoInputVisibility.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.videoInputIndex != null && message.hasOwnProperty("videoInputIndex"))
                                        if (!$util.isInteger(message.videoInputIndex))
                                            return "videoInputIndex: integer expected";
                                    if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                        switch (message.visibilityCriterion) {
                                        default:
                                            return "visibilityCriterion: enum value expected";
                                        case 0:
                                        case 1:
                                            break;
                                        }
                                    return null;
                                };

                                /**
                                 * Creates a VideoInputVisibility message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility} VideoInputVisibility
                                 */
                                VideoInputVisibility.fromObject = function fromObject(object) {
                                    if (object instanceof $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility)
                                        return object;
                                    let message = new $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility();
                                    if (object.videoInputIndex != null)
                                        message.videoInputIndex = object.videoInputIndex | 0;
                                    switch (object.visibilityCriterion) {
                                    default:
                                        if (typeof object.visibilityCriterion === "number") {
                                            message.visibilityCriterion = object.visibilityCriterion;
                                            break;
                                        }
                                        break;
                                    case "VIDEO_INPUT_VISIBILITY_CRITERION_ACTIVE":
                                    case 0:
                                        message.visibilityCriterion = 0;
                                        break;
                                    case "VIDEO_INPUT_VISIBILITY_CRITERION_INACTIVE":
                                    case 1:
                                        message.visibilityCriterion = 1;
                                        break;
                                    }
                                    return message;
                                };

                                /**
                                 * Creates a plain object from a VideoInputVisibility message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility
                                 * @static
                                 * @param {rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility} message VideoInputVisibility
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                VideoInputVisibility.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    let object = {};
                                    if (options.defaults) {
                                        object.videoInputIndex = 0;
                                        object.visibilityCriterion = options.enums === String ? "VIDEO_INPUT_VISIBILITY_CRITERION_ACTIVE" : 0;
                                    }
                                    if (message.videoInputIndex != null && message.hasOwnProperty("videoInputIndex"))
                                        object.videoInputIndex = message.videoInputIndex;
                                    if (message.visibilityCriterion != null && message.hasOwnProperty("visibilityCriterion"))
                                        object.visibilityCriterion = options.enums === String ? $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.VideoInputVisibilityCriterion[message.visibilityCriterion] === undefined ? message.visibilityCriterion : $root.rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.VideoInputVisibilityCriterion[message.visibilityCriterion] : message.visibilityCriterion;
                                    return object;
                                };

                                /**
                                 * Converts this VideoInputVisibility to JSON.
                                 * @function toJSON
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                VideoInputVisibility.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Gets the default type url for VideoInputVisibility
                                 * @function getTypeUrl
                                 * @memberof rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility
                                 * @static
                                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                                 * @returns {string} The default type url
                                 */
                                VideoInputVisibility.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                    if (typeUrlPrefix === undefined) {
                                        typeUrlPrefix = "type.googleapis.com";
                                    }
                                    return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility";
                                };

                                /**
                                 * VideoInputVisibilityCriterion enum.
                                 * @name rv.data.Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.VideoInputVisibilityCriterion
                                 * @enum {number}
                                 * @property {number} VIDEO_INPUT_VISIBILITY_CRITERION_ACTIVE=0 VIDEO_INPUT_VISIBILITY_CRITERION_ACTIVE value
                                 * @property {number} VIDEO_INPUT_VISIBILITY_CRITERION_INACTIVE=1 VIDEO_INPUT_VISIBILITY_CRITERION_INACTIVE value
                                 */
                                VideoInputVisibility.VideoInputVisibilityCriterion = (function() {
                                    const valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "VIDEO_INPUT_VISIBILITY_CRITERION_ACTIVE"] = 0;
                                    values[valuesById[1] = "VIDEO_INPUT_VISIBILITY_CRITERION_INACTIVE"] = 1;
                                    return values;
                                })();

                                return VideoInputVisibility;
                            })();

                            return Condition;
                        })();

                        /**
                         * VisibilityCriterion enum.
                         * @name rv.data.Slide.Element.DataLink.VisibilityLink.VisibilityCriterion
                         * @enum {number}
                         * @property {number} VISIBILITY_CRITERION_ALL=0 VISIBILITY_CRITERION_ALL value
                         * @property {number} VISIBILITY_CRITERION_ANY=1 VISIBILITY_CRITERION_ANY value
                         * @property {number} VISIBILITY_CRITERION_NONE=2 VISIBILITY_CRITERION_NONE value
                         */
                        VisibilityLink.VisibilityCriterion = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "VISIBILITY_CRITERION_ALL"] = 0;
                            values[valuesById[1] = "VISIBILITY_CRITERION_ANY"] = 1;
                            values[valuesById[2] = "VISIBILITY_CRITERION_NONE"] = 2;
                            return values;
                        })();

                        return VisibilityLink;
                    })();

                    DataLink.SlideText = (function() {

                        /**
                         * Properties of a SlideText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface ISlideText
                         * @property {rv.data.Slide.Element.DataLink.SlideSourceType|null} [sourceSlide] SlideText sourceSlide
                         * @property {rv.data.Slide.Element.DataLink.SlideText.TextSourceOption|null} [sourceOption] SlideText sourceOption
                         * @property {boolean|null} [preserveNotesFormat] SlideText preserveNotesFormat
                         * @property {string|null} [nameToMatch] SlideText nameToMatch
                         * @property {rv.data.Slide.Element.DataLink.AlternateElementText.TextTransformOption|null} [elementTextTransform] SlideText elementTextTransform
                         */

                        /**
                         * Constructs a new SlideText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a SlideText.
                         * @implements ISlideText
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.ISlideText=} [properties] Properties to set
                         */
                        function SlideText(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * SlideText sourceSlide.
                         * @member {rv.data.Slide.Element.DataLink.SlideSourceType} sourceSlide
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @instance
                         */
                        SlideText.prototype.sourceSlide = 0;

                        /**
                         * SlideText sourceOption.
                         * @member {rv.data.Slide.Element.DataLink.SlideText.TextSourceOption} sourceOption
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @instance
                         */
                        SlideText.prototype.sourceOption = 0;

                        /**
                         * SlideText preserveNotesFormat.
                         * @member {boolean} preserveNotesFormat
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @instance
                         */
                        SlideText.prototype.preserveNotesFormat = false;

                        /**
                         * SlideText nameToMatch.
                         * @member {string} nameToMatch
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @instance
                         */
                        SlideText.prototype.nameToMatch = "";

                        /**
                         * SlideText elementTextTransform.
                         * @member {rv.data.Slide.Element.DataLink.AlternateElementText.TextTransformOption} elementTextTransform
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @instance
                         */
                        SlideText.prototype.elementTextTransform = 0;

                        /**
                         * Creates a new SlideText instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideText=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.SlideText} SlideText instance
                         */
                        SlideText.create = function create(properties) {
                            return new SlideText(properties);
                        };

                        /**
                         * Encodes the specified SlideText message. Does not implicitly {@link rv.data.Slide.Element.DataLink.SlideText.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideText} message SlideText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SlideText.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.sourceSlide != null && Object.hasOwnProperty.call(message, "sourceSlide"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sourceSlide);
                            if (message.sourceOption != null && Object.hasOwnProperty.call(message, "sourceOption"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sourceOption);
                            if (message.preserveNotesFormat != null && Object.hasOwnProperty.call(message, "preserveNotesFormat"))
                                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.preserveNotesFormat);
                            if (message.nameToMatch != null && Object.hasOwnProperty.call(message, "nameToMatch"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.nameToMatch);
                            if (message.elementTextTransform != null && Object.hasOwnProperty.call(message, "elementTextTransform"))
                                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.elementTextTransform);
                            return writer;
                        };

                        /**
                         * Encodes the specified SlideText message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.SlideText.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideText} message SlideText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SlideText.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a SlideText message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.SlideText} SlideText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SlideText.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.SlideText();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.sourceSlide = reader.int32();
                                        break;
                                    }
                                case 2: {
                                        message.sourceOption = reader.int32();
                                        break;
                                    }
                                case 3: {
                                        message.preserveNotesFormat = reader.bool();
                                        break;
                                    }
                                case 4: {
                                        message.nameToMatch = reader.string();
                                        break;
                                    }
                                case 5: {
                                        message.elementTextTransform = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a SlideText message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.SlideText} SlideText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SlideText.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a SlideText message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        SlideText.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.sourceSlide != null && message.hasOwnProperty("sourceSlide"))
                                switch (message.sourceSlide) {
                                default:
                                    return "sourceSlide: enum value expected";
                                case 0:
                                case 1:
                                    break;
                                }
                            if (message.sourceOption != null && message.hasOwnProperty("sourceOption"))
                                switch (message.sourceOption) {
                                default:
                                    return "sourceOption: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.preserveNotesFormat != null && message.hasOwnProperty("preserveNotesFormat"))
                                if (typeof message.preserveNotesFormat !== "boolean")
                                    return "preserveNotesFormat: boolean expected";
                            if (message.nameToMatch != null && message.hasOwnProperty("nameToMatch"))
                                if (!$util.isString(message.nameToMatch))
                                    return "nameToMatch: string expected";
                            if (message.elementTextTransform != null && message.hasOwnProperty("elementTextTransform"))
                                switch (message.elementTextTransform) {
                                default:
                                    return "elementTextTransform: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a SlideText message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.SlideText} SlideText
                         */
                        SlideText.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.SlideText)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.SlideText();
                            switch (object.sourceSlide) {
                            default:
                                if (typeof object.sourceSlide === "number") {
                                    message.sourceSlide = object.sourceSlide;
                                    break;
                                }
                                break;
                            case "SLIDE_SOURCE_TYPE_CURRENT_SLIDE":
                            case 0:
                                message.sourceSlide = 0;
                                break;
                            case "SLIDE_SOURCE_TYPE_NEXT_SLIDE":
                            case 1:
                                message.sourceSlide = 1;
                                break;
                            }
                            switch (object.sourceOption) {
                            default:
                                if (typeof object.sourceOption === "number") {
                                    message.sourceOption = object.sourceOption;
                                    break;
                                }
                                break;
                            case "TEXT_SOURCE_OPTION_TEXT":
                            case 0:
                                message.sourceOption = 0;
                                break;
                            case "TEXT_SOURCE_OPTION_NOTES":
                            case 1:
                                message.sourceOption = 1;
                                break;
                            case "TEXT_SOURCE_OPTION_ELEMENT_MATCHING_NAME":
                            case 2:
                                message.sourceOption = 2;
                                break;
                            }
                            if (object.preserveNotesFormat != null)
                                message.preserveNotesFormat = Boolean(object.preserveNotesFormat);
                            if (object.nameToMatch != null)
                                message.nameToMatch = String(object.nameToMatch);
                            switch (object.elementTextTransform) {
                            default:
                                if (typeof object.elementTextTransform === "number") {
                                    message.elementTextTransform = object.elementTextTransform;
                                    break;
                                }
                                break;
                            case "TEXT_TRANSFORM_OPTION_NONE":
                            case 0:
                                message.elementTextTransform = 0;
                                break;
                            case "TEXT_TRANSFORM_OPTION_REMOVE_LINE_RETURNS":
                            case 1:
                                message.elementTextTransform = 1;
                                break;
                            case "TEXT_TRANSFORM_OPTION_ONE_WORD_PER_LINE":
                            case 2:
                                message.elementTextTransform = 2;
                                break;
                            case "TEXT_TRANSFORM_OPTION_ONE_CHARACTER_PER_LINE":
                            case 3:
                                message.elementTextTransform = 3;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a SlideText message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.SlideText} message SlideText
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        SlideText.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.sourceSlide = options.enums === String ? "SLIDE_SOURCE_TYPE_CURRENT_SLIDE" : 0;
                                object.sourceOption = options.enums === String ? "TEXT_SOURCE_OPTION_TEXT" : 0;
                                object.preserveNotesFormat = false;
                                object.nameToMatch = "";
                                object.elementTextTransform = options.enums === String ? "TEXT_TRANSFORM_OPTION_NONE" : 0;
                            }
                            if (message.sourceSlide != null && message.hasOwnProperty("sourceSlide"))
                                object.sourceSlide = options.enums === String ? $root.rv.data.Slide.Element.DataLink.SlideSourceType[message.sourceSlide] === undefined ? message.sourceSlide : $root.rv.data.Slide.Element.DataLink.SlideSourceType[message.sourceSlide] : message.sourceSlide;
                            if (message.sourceOption != null && message.hasOwnProperty("sourceOption"))
                                object.sourceOption = options.enums === String ? $root.rv.data.Slide.Element.DataLink.SlideText.TextSourceOption[message.sourceOption] === undefined ? message.sourceOption : $root.rv.data.Slide.Element.DataLink.SlideText.TextSourceOption[message.sourceOption] : message.sourceOption;
                            if (message.preserveNotesFormat != null && message.hasOwnProperty("preserveNotesFormat"))
                                object.preserveNotesFormat = message.preserveNotesFormat;
                            if (message.nameToMatch != null && message.hasOwnProperty("nameToMatch"))
                                object.nameToMatch = message.nameToMatch;
                            if (message.elementTextTransform != null && message.hasOwnProperty("elementTextTransform"))
                                object.elementTextTransform = options.enums === String ? $root.rv.data.Slide.Element.DataLink.AlternateElementText.TextTransformOption[message.elementTextTransform] === undefined ? message.elementTextTransform : $root.rv.data.Slide.Element.DataLink.AlternateElementText.TextTransformOption[message.elementTextTransform] : message.elementTextTransform;
                            return object;
                        };

                        /**
                         * Converts this SlideText to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        SlideText.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for SlideText
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.SlideText
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        SlideText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.SlideText";
                        };

                        /**
                         * TextSourceOption enum.
                         * @name rv.data.Slide.Element.DataLink.SlideText.TextSourceOption
                         * @enum {number}
                         * @property {number} TEXT_SOURCE_OPTION_TEXT=0 TEXT_SOURCE_OPTION_TEXT value
                         * @property {number} TEXT_SOURCE_OPTION_NOTES=1 TEXT_SOURCE_OPTION_NOTES value
                         * @property {number} TEXT_SOURCE_OPTION_ELEMENT_MATCHING_NAME=2 TEXT_SOURCE_OPTION_ELEMENT_MATCHING_NAME value
                         */
                        SlideText.TextSourceOption = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "TEXT_SOURCE_OPTION_TEXT"] = 0;
                            values[valuesById[1] = "TEXT_SOURCE_OPTION_NOTES"] = 1;
                            values[valuesById[2] = "TEXT_SOURCE_OPTION_ELEMENT_MATCHING_NAME"] = 2;
                            return values;
                        })();

                        return SlideText;
                    })();

                    DataLink.SlideImage = (function() {

                        /**
                         * Properties of a SlideImage.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface ISlideImage
                         * @property {rv.data.Slide.Element.DataLink.SlideSourceType|null} [sourceSlide] SlideImage sourceSlide
                         */

                        /**
                         * Constructs a new SlideImage.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a SlideImage.
                         * @implements ISlideImage
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.ISlideImage=} [properties] Properties to set
                         */
                        function SlideImage(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * SlideImage sourceSlide.
                         * @member {rv.data.Slide.Element.DataLink.SlideSourceType} sourceSlide
                         * @memberof rv.data.Slide.Element.DataLink.SlideImage
                         * @instance
                         */
                        SlideImage.prototype.sourceSlide = 0;

                        /**
                         * Creates a new SlideImage instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.SlideImage
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideImage=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.SlideImage} SlideImage instance
                         */
                        SlideImage.create = function create(properties) {
                            return new SlideImage(properties);
                        };

                        /**
                         * Encodes the specified SlideImage message. Does not implicitly {@link rv.data.Slide.Element.DataLink.SlideImage.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.SlideImage
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideImage} message SlideImage message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SlideImage.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.sourceSlide != null && Object.hasOwnProperty.call(message, "sourceSlide"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sourceSlide);
                            return writer;
                        };

                        /**
                         * Encodes the specified SlideImage message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.SlideImage.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.SlideImage
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideImage} message SlideImage message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SlideImage.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a SlideImage message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.SlideImage
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.SlideImage} SlideImage
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SlideImage.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.SlideImage();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.sourceSlide = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a SlideImage message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.SlideImage
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.SlideImage} SlideImage
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SlideImage.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a SlideImage message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.SlideImage
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        SlideImage.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.sourceSlide != null && message.hasOwnProperty("sourceSlide"))
                                switch (message.sourceSlide) {
                                default:
                                    return "sourceSlide: enum value expected";
                                case 0:
                                case 1:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a SlideImage message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.SlideImage
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.SlideImage} SlideImage
                         */
                        SlideImage.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.SlideImage)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.SlideImage();
                            switch (object.sourceSlide) {
                            default:
                                if (typeof object.sourceSlide === "number") {
                                    message.sourceSlide = object.sourceSlide;
                                    break;
                                }
                                break;
                            case "SLIDE_SOURCE_TYPE_CURRENT_SLIDE":
                            case 0:
                                message.sourceSlide = 0;
                                break;
                            case "SLIDE_SOURCE_TYPE_NEXT_SLIDE":
                            case 1:
                                message.sourceSlide = 1;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a SlideImage message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.SlideImage
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.SlideImage} message SlideImage
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        SlideImage.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.sourceSlide = options.enums === String ? "SLIDE_SOURCE_TYPE_CURRENT_SLIDE" : 0;
                            if (message.sourceSlide != null && message.hasOwnProperty("sourceSlide"))
                                object.sourceSlide = options.enums === String ? $root.rv.data.Slide.Element.DataLink.SlideSourceType[message.sourceSlide] === undefined ? message.sourceSlide : $root.rv.data.Slide.Element.DataLink.SlideSourceType[message.sourceSlide] : message.sourceSlide;
                            return object;
                        };

                        /**
                         * Converts this SlideImage to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.SlideImage
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        SlideImage.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for SlideImage
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.SlideImage
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        SlideImage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.SlideImage";
                        };

                        return SlideImage;
                    })();

                    DataLink.StageMessage = (function() {

                        /**
                         * Properties of a StageMessage.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IStageMessage
                         * @property {boolean|null} [shouldFlash] StageMessage shouldFlash
                         * @property {rv.data.IColor|null} [flashColor] StageMessage flashColor
                         */

                        /**
                         * Constructs a new StageMessage.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a StageMessage.
                         * @implements IStageMessage
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IStageMessage=} [properties] Properties to set
                         */
                        function StageMessage(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * StageMessage shouldFlash.
                         * @member {boolean} shouldFlash
                         * @memberof rv.data.Slide.Element.DataLink.StageMessage
                         * @instance
                         */
                        StageMessage.prototype.shouldFlash = false;

                        /**
                         * StageMessage flashColor.
                         * @member {rv.data.IColor|null|undefined} flashColor
                         * @memberof rv.data.Slide.Element.DataLink.StageMessage
                         * @instance
                         */
                        StageMessage.prototype.flashColor = null;

                        /**
                         * Creates a new StageMessage instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.StageMessage
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IStageMessage=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.StageMessage} StageMessage instance
                         */
                        StageMessage.create = function create(properties) {
                            return new StageMessage(properties);
                        };

                        /**
                         * Encodes the specified StageMessage message. Does not implicitly {@link rv.data.Slide.Element.DataLink.StageMessage.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.StageMessage
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IStageMessage} message StageMessage message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        StageMessage.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.shouldFlash != null && Object.hasOwnProperty.call(message, "shouldFlash"))
                                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.shouldFlash);
                            if (message.flashColor != null && Object.hasOwnProperty.call(message, "flashColor"))
                                $root.rv.data.Color.encode(message.flashColor, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified StageMessage message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.StageMessage.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.StageMessage
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IStageMessage} message StageMessage message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        StageMessage.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a StageMessage message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.StageMessage
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.StageMessage} StageMessage
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        StageMessage.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.StageMessage();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.shouldFlash = reader.bool();
                                        break;
                                    }
                                case 2: {
                                        message.flashColor = $root.rv.data.Color.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a StageMessage message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.StageMessage
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.StageMessage} StageMessage
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        StageMessage.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a StageMessage message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.StageMessage
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        StageMessage.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.shouldFlash != null && message.hasOwnProperty("shouldFlash"))
                                if (typeof message.shouldFlash !== "boolean")
                                    return "shouldFlash: boolean expected";
                            if (message.flashColor != null && message.hasOwnProperty("flashColor")) {
                                let error = $root.rv.data.Color.verify(message.flashColor);
                                if (error)
                                    return "flashColor." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a StageMessage message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.StageMessage
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.StageMessage} StageMessage
                         */
                        StageMessage.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.StageMessage)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.StageMessage();
                            if (object.shouldFlash != null)
                                message.shouldFlash = Boolean(object.shouldFlash);
                            if (object.flashColor != null) {
                                if (typeof object.flashColor !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.StageMessage.flashColor: object expected");
                                message.flashColor = $root.rv.data.Color.fromObject(object.flashColor);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a StageMessage message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.StageMessage
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.StageMessage} message StageMessage
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        StageMessage.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.shouldFlash = false;
                                object.flashColor = null;
                            }
                            if (message.shouldFlash != null && message.hasOwnProperty("shouldFlash"))
                                object.shouldFlash = message.shouldFlash;
                            if (message.flashColor != null && message.hasOwnProperty("flashColor"))
                                object.flashColor = $root.rv.data.Color.toObject(message.flashColor, options);
                            return object;
                        };

                        /**
                         * Converts this StageMessage to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.StageMessage
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        StageMessage.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for StageMessage
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.StageMessage
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        StageMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.StageMessage";
                        };

                        return StageMessage;
                    })();

                    DataLink.VideoCountdown = (function() {

                        /**
                         * Properties of a VideoCountdown.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IVideoCountdown
                         * @property {rv.data.Timer.IFormat|null} [timerFormat] VideoCountdown timerFormat
                         * @property {string|null} [timerFormatString] VideoCountdown timerFormatString
                         * @property {Array.<rv.data.Slide.Element.DataLink.IColorTrigger>|null} [colorTriggers] VideoCountdown colorTriggers
                         * @property {boolean|null} [ignoreLoopingVideos] VideoCountdown ignoreLoopingVideos
                         * @property {rv.data.Slide.Element.DataLink.VideoCountdown.VideoCountdownSource|null} [videoCountdownSource] VideoCountdown videoCountdownSource
                         */

                        /**
                         * Constructs a new VideoCountdown.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a VideoCountdown.
                         * @implements IVideoCountdown
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IVideoCountdown=} [properties] Properties to set
                         */
                        function VideoCountdown(properties) {
                            this.colorTriggers = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * VideoCountdown timerFormat.
                         * @member {rv.data.Timer.IFormat|null|undefined} timerFormat
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @instance
                         */
                        VideoCountdown.prototype.timerFormat = null;

                        /**
                         * VideoCountdown timerFormatString.
                         * @member {string} timerFormatString
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @instance
                         */
                        VideoCountdown.prototype.timerFormatString = "";

                        /**
                         * VideoCountdown colorTriggers.
                         * @member {Array.<rv.data.Slide.Element.DataLink.IColorTrigger>} colorTriggers
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @instance
                         */
                        VideoCountdown.prototype.colorTriggers = $util.emptyArray;

                        /**
                         * VideoCountdown ignoreLoopingVideos.
                         * @member {boolean} ignoreLoopingVideos
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @instance
                         */
                        VideoCountdown.prototype.ignoreLoopingVideos = false;

                        /**
                         * VideoCountdown videoCountdownSource.
                         * @member {rv.data.Slide.Element.DataLink.VideoCountdown.VideoCountdownSource} videoCountdownSource
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @instance
                         */
                        VideoCountdown.prototype.videoCountdownSource = 0;

                        /**
                         * Creates a new VideoCountdown instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IVideoCountdown=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.VideoCountdown} VideoCountdown instance
                         */
                        VideoCountdown.create = function create(properties) {
                            return new VideoCountdown(properties);
                        };

                        /**
                         * Encodes the specified VideoCountdown message. Does not implicitly {@link rv.data.Slide.Element.DataLink.VideoCountdown.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IVideoCountdown} message VideoCountdown message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        VideoCountdown.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.timerFormat != null && Object.hasOwnProperty.call(message, "timerFormat"))
                                $root.rv.data.Timer.Format.encode(message.timerFormat, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.timerFormatString != null && Object.hasOwnProperty.call(message, "timerFormatString"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.timerFormatString);
                            if (message.colorTriggers != null && message.colorTriggers.length)
                                for (let i = 0; i < message.colorTriggers.length; ++i)
                                    $root.rv.data.Slide.Element.DataLink.ColorTrigger.encode(message.colorTriggers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.ignoreLoopingVideos != null && Object.hasOwnProperty.call(message, "ignoreLoopingVideos"))
                                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.ignoreLoopingVideos);
                            if (message.videoCountdownSource != null && Object.hasOwnProperty.call(message, "videoCountdownSource"))
                                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.videoCountdownSource);
                            return writer;
                        };

                        /**
                         * Encodes the specified VideoCountdown message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.VideoCountdown.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IVideoCountdown} message VideoCountdown message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        VideoCountdown.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a VideoCountdown message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.VideoCountdown} VideoCountdown
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        VideoCountdown.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.VideoCountdown();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.timerFormat = $root.rv.data.Timer.Format.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.timerFormatString = reader.string();
                                        break;
                                    }
                                case 3: {
                                        if (!(message.colorTriggers && message.colorTriggers.length))
                                            message.colorTriggers = [];
                                        message.colorTriggers.push($root.rv.data.Slide.Element.DataLink.ColorTrigger.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 4: {
                                        message.ignoreLoopingVideos = reader.bool();
                                        break;
                                    }
                                case 5: {
                                        message.videoCountdownSource = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a VideoCountdown message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.VideoCountdown} VideoCountdown
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        VideoCountdown.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a VideoCountdown message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        VideoCountdown.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.timerFormat != null && message.hasOwnProperty("timerFormat")) {
                                let error = $root.rv.data.Timer.Format.verify(message.timerFormat);
                                if (error)
                                    return "timerFormat." + error;
                            }
                            if (message.timerFormatString != null && message.hasOwnProperty("timerFormatString"))
                                if (!$util.isString(message.timerFormatString))
                                    return "timerFormatString: string expected";
                            if (message.colorTriggers != null && message.hasOwnProperty("colorTriggers")) {
                                if (!Array.isArray(message.colorTriggers))
                                    return "colorTriggers: array expected";
                                for (let i = 0; i < message.colorTriggers.length; ++i) {
                                    let error = $root.rv.data.Slide.Element.DataLink.ColorTrigger.verify(message.colorTriggers[i]);
                                    if (error)
                                        return "colorTriggers." + error;
                                }
                            }
                            if (message.ignoreLoopingVideos != null && message.hasOwnProperty("ignoreLoopingVideos"))
                                if (typeof message.ignoreLoopingVideos !== "boolean")
                                    return "ignoreLoopingVideos: boolean expected";
                            if (message.videoCountdownSource != null && message.hasOwnProperty("videoCountdownSource"))
                                switch (message.videoCountdownSource) {
                                default:
                                    return "videoCountdownSource: enum value expected";
                                case 0:
                                case 1:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a VideoCountdown message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.VideoCountdown} VideoCountdown
                         */
                        VideoCountdown.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.VideoCountdown)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.VideoCountdown();
                            if (object.timerFormat != null) {
                                if (typeof object.timerFormat !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.VideoCountdown.timerFormat: object expected");
                                message.timerFormat = $root.rv.data.Timer.Format.fromObject(object.timerFormat);
                            }
                            if (object.timerFormatString != null)
                                message.timerFormatString = String(object.timerFormatString);
                            if (object.colorTriggers) {
                                if (!Array.isArray(object.colorTriggers))
                                    throw TypeError(".rv.data.Slide.Element.DataLink.VideoCountdown.colorTriggers: array expected");
                                message.colorTriggers = [];
                                for (let i = 0; i < object.colorTriggers.length; ++i) {
                                    if (typeof object.colorTriggers[i] !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.VideoCountdown.colorTriggers: object expected");
                                    message.colorTriggers[i] = $root.rv.data.Slide.Element.DataLink.ColorTrigger.fromObject(object.colorTriggers[i]);
                                }
                            }
                            if (object.ignoreLoopingVideos != null)
                                message.ignoreLoopingVideos = Boolean(object.ignoreLoopingVideos);
                            switch (object.videoCountdownSource) {
                            default:
                                if (typeof object.videoCountdownSource === "number") {
                                    message.videoCountdownSource = object.videoCountdownSource;
                                    break;
                                }
                                break;
                            case "VIDEO_COUNTDOWN_SOURCE_PRESENTATION":
                            case 0:
                                message.videoCountdownSource = 0;
                                break;
                            case "VIDEO_COUNTDOWN_SOURCE_ANNOUNCEMENT":
                            case 1:
                                message.videoCountdownSource = 1;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a VideoCountdown message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.VideoCountdown} message VideoCountdown
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        VideoCountdown.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.colorTriggers = [];
                            if (options.defaults) {
                                object.timerFormat = null;
                                object.timerFormatString = "";
                                object.ignoreLoopingVideos = false;
                                object.videoCountdownSource = options.enums === String ? "VIDEO_COUNTDOWN_SOURCE_PRESENTATION" : 0;
                            }
                            if (message.timerFormat != null && message.hasOwnProperty("timerFormat"))
                                object.timerFormat = $root.rv.data.Timer.Format.toObject(message.timerFormat, options);
                            if (message.timerFormatString != null && message.hasOwnProperty("timerFormatString"))
                                object.timerFormatString = message.timerFormatString;
                            if (message.colorTriggers && message.colorTriggers.length) {
                                object.colorTriggers = [];
                                for (let j = 0; j < message.colorTriggers.length; ++j)
                                    object.colorTriggers[j] = $root.rv.data.Slide.Element.DataLink.ColorTrigger.toObject(message.colorTriggers[j], options);
                            }
                            if (message.ignoreLoopingVideos != null && message.hasOwnProperty("ignoreLoopingVideos"))
                                object.ignoreLoopingVideos = message.ignoreLoopingVideos;
                            if (message.videoCountdownSource != null && message.hasOwnProperty("videoCountdownSource"))
                                object.videoCountdownSource = options.enums === String ? $root.rv.data.Slide.Element.DataLink.VideoCountdown.VideoCountdownSource[message.videoCountdownSource] === undefined ? message.videoCountdownSource : $root.rv.data.Slide.Element.DataLink.VideoCountdown.VideoCountdownSource[message.videoCountdownSource] : message.videoCountdownSource;
                            return object;
                        };

                        /**
                         * Converts this VideoCountdown to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        VideoCountdown.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for VideoCountdown
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.VideoCountdown
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        VideoCountdown.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.VideoCountdown";
                        };

                        /**
                         * VideoCountdownSource enum.
                         * @name rv.data.Slide.Element.DataLink.VideoCountdown.VideoCountdownSource
                         * @enum {number}
                         * @property {number} VIDEO_COUNTDOWN_SOURCE_PRESENTATION=0 VIDEO_COUNTDOWN_SOURCE_PRESENTATION value
                         * @property {number} VIDEO_COUNTDOWN_SOURCE_ANNOUNCEMENT=1 VIDEO_COUNTDOWN_SOURCE_ANNOUNCEMENT value
                         */
                        VideoCountdown.VideoCountdownSource = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "VIDEO_COUNTDOWN_SOURCE_PRESENTATION"] = 0;
                            values[valuesById[1] = "VIDEO_COUNTDOWN_SOURCE_ANNOUNCEMENT"] = 1;
                            return values;
                        })();

                        return VideoCountdown;
                    })();

                    DataLink.AudioCountdown = (function() {

                        /**
                         * Properties of an AudioCountdown.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IAudioCountdown
                         * @property {rv.data.Timer.IFormat|null} [timerFormat] AudioCountdown timerFormat
                         * @property {string|null} [timerFormatString] AudioCountdown timerFormatString
                         * @property {Array.<rv.data.Slide.Element.DataLink.IColorTrigger>|null} [colorTriggers] AudioCountdown colorTriggers
                         * @property {boolean|null} [ignoreLoopingAudio] AudioCountdown ignoreLoopingAudio
                         */

                        /**
                         * Constructs a new AudioCountdown.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents an AudioCountdown.
                         * @implements IAudioCountdown
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IAudioCountdown=} [properties] Properties to set
                         */
                        function AudioCountdown(properties) {
                            this.colorTriggers = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * AudioCountdown timerFormat.
                         * @member {rv.data.Timer.IFormat|null|undefined} timerFormat
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @instance
                         */
                        AudioCountdown.prototype.timerFormat = null;

                        /**
                         * AudioCountdown timerFormatString.
                         * @member {string} timerFormatString
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @instance
                         */
                        AudioCountdown.prototype.timerFormatString = "";

                        /**
                         * AudioCountdown colorTriggers.
                         * @member {Array.<rv.data.Slide.Element.DataLink.IColorTrigger>} colorTriggers
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @instance
                         */
                        AudioCountdown.prototype.colorTriggers = $util.emptyArray;

                        /**
                         * AudioCountdown ignoreLoopingAudio.
                         * @member {boolean} ignoreLoopingAudio
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @instance
                         */
                        AudioCountdown.prototype.ignoreLoopingAudio = false;

                        /**
                         * Creates a new AudioCountdown instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IAudioCountdown=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.AudioCountdown} AudioCountdown instance
                         */
                        AudioCountdown.create = function create(properties) {
                            return new AudioCountdown(properties);
                        };

                        /**
                         * Encodes the specified AudioCountdown message. Does not implicitly {@link rv.data.Slide.Element.DataLink.AudioCountdown.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IAudioCountdown} message AudioCountdown message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        AudioCountdown.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.timerFormat != null && Object.hasOwnProperty.call(message, "timerFormat"))
                                $root.rv.data.Timer.Format.encode(message.timerFormat, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.timerFormatString != null && Object.hasOwnProperty.call(message, "timerFormatString"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.timerFormatString);
                            if (message.colorTriggers != null && message.colorTriggers.length)
                                for (let i = 0; i < message.colorTriggers.length; ++i)
                                    $root.rv.data.Slide.Element.DataLink.ColorTrigger.encode(message.colorTriggers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.ignoreLoopingAudio != null && Object.hasOwnProperty.call(message, "ignoreLoopingAudio"))
                                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.ignoreLoopingAudio);
                            return writer;
                        };

                        /**
                         * Encodes the specified AudioCountdown message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.AudioCountdown.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IAudioCountdown} message AudioCountdown message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        AudioCountdown.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an AudioCountdown message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.AudioCountdown} AudioCountdown
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        AudioCountdown.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.AudioCountdown();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.timerFormat = $root.rv.data.Timer.Format.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.timerFormatString = reader.string();
                                        break;
                                    }
                                case 3: {
                                        if (!(message.colorTriggers && message.colorTriggers.length))
                                            message.colorTriggers = [];
                                        message.colorTriggers.push($root.rv.data.Slide.Element.DataLink.ColorTrigger.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 4: {
                                        message.ignoreLoopingAudio = reader.bool();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an AudioCountdown message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.AudioCountdown} AudioCountdown
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        AudioCountdown.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an AudioCountdown message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        AudioCountdown.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.timerFormat != null && message.hasOwnProperty("timerFormat")) {
                                let error = $root.rv.data.Timer.Format.verify(message.timerFormat);
                                if (error)
                                    return "timerFormat." + error;
                            }
                            if (message.timerFormatString != null && message.hasOwnProperty("timerFormatString"))
                                if (!$util.isString(message.timerFormatString))
                                    return "timerFormatString: string expected";
                            if (message.colorTriggers != null && message.hasOwnProperty("colorTriggers")) {
                                if (!Array.isArray(message.colorTriggers))
                                    return "colorTriggers: array expected";
                                for (let i = 0; i < message.colorTriggers.length; ++i) {
                                    let error = $root.rv.data.Slide.Element.DataLink.ColorTrigger.verify(message.colorTriggers[i]);
                                    if (error)
                                        return "colorTriggers." + error;
                                }
                            }
                            if (message.ignoreLoopingAudio != null && message.hasOwnProperty("ignoreLoopingAudio"))
                                if (typeof message.ignoreLoopingAudio !== "boolean")
                                    return "ignoreLoopingAudio: boolean expected";
                            return null;
                        };

                        /**
                         * Creates an AudioCountdown message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.AudioCountdown} AudioCountdown
                         */
                        AudioCountdown.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.AudioCountdown)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.AudioCountdown();
                            if (object.timerFormat != null) {
                                if (typeof object.timerFormat !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.AudioCountdown.timerFormat: object expected");
                                message.timerFormat = $root.rv.data.Timer.Format.fromObject(object.timerFormat);
                            }
                            if (object.timerFormatString != null)
                                message.timerFormatString = String(object.timerFormatString);
                            if (object.colorTriggers) {
                                if (!Array.isArray(object.colorTriggers))
                                    throw TypeError(".rv.data.Slide.Element.DataLink.AudioCountdown.colorTriggers: array expected");
                                message.colorTriggers = [];
                                for (let i = 0; i < object.colorTriggers.length; ++i) {
                                    if (typeof object.colorTriggers[i] !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.AudioCountdown.colorTriggers: object expected");
                                    message.colorTriggers[i] = $root.rv.data.Slide.Element.DataLink.ColorTrigger.fromObject(object.colorTriggers[i]);
                                }
                            }
                            if (object.ignoreLoopingAudio != null)
                                message.ignoreLoopingAudio = Boolean(object.ignoreLoopingAudio);
                            return message;
                        };

                        /**
                         * Creates a plain object from an AudioCountdown message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.AudioCountdown} message AudioCountdown
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        AudioCountdown.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.colorTriggers = [];
                            if (options.defaults) {
                                object.timerFormat = null;
                                object.timerFormatString = "";
                                object.ignoreLoopingAudio = false;
                            }
                            if (message.timerFormat != null && message.hasOwnProperty("timerFormat"))
                                object.timerFormat = $root.rv.data.Timer.Format.toObject(message.timerFormat, options);
                            if (message.timerFormatString != null && message.hasOwnProperty("timerFormatString"))
                                object.timerFormatString = message.timerFormatString;
                            if (message.colorTriggers && message.colorTriggers.length) {
                                object.colorTriggers = [];
                                for (let j = 0; j < message.colorTriggers.length; ++j)
                                    object.colorTriggers[j] = $root.rv.data.Slide.Element.DataLink.ColorTrigger.toObject(message.colorTriggers[j], options);
                            }
                            if (message.ignoreLoopingAudio != null && message.hasOwnProperty("ignoreLoopingAudio"))
                                object.ignoreLoopingAudio = message.ignoreLoopingAudio;
                            return object;
                        };

                        /**
                         * Converts this AudioCountdown to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        AudioCountdown.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for AudioCountdown
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.AudioCountdown
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        AudioCountdown.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.AudioCountdown";
                        };

                        return AudioCountdown;
                    })();

                    DataLink.GroupName = (function() {

                        /**
                         * Properties of a GroupName.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IGroupName
                         * @property {rv.data.Slide.Element.DataLink.GroupSourceType|null} [groupSource] GroupName groupSource
                         */

                        /**
                         * Constructs a new GroupName.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a GroupName.
                         * @implements IGroupName
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IGroupName=} [properties] Properties to set
                         */
                        function GroupName(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * GroupName groupSource.
                         * @member {rv.data.Slide.Element.DataLink.GroupSourceType} groupSource
                         * @memberof rv.data.Slide.Element.DataLink.GroupName
                         * @instance
                         */
                        GroupName.prototype.groupSource = 0;

                        /**
                         * Creates a new GroupName instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.GroupName
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IGroupName=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.GroupName} GroupName instance
                         */
                        GroupName.create = function create(properties) {
                            return new GroupName(properties);
                        };

                        /**
                         * Encodes the specified GroupName message. Does not implicitly {@link rv.data.Slide.Element.DataLink.GroupName.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.GroupName
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IGroupName} message GroupName message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GroupName.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.groupSource != null && Object.hasOwnProperty.call(message, "groupSource"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.groupSource);
                            return writer;
                        };

                        /**
                         * Encodes the specified GroupName message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.GroupName.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.GroupName
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IGroupName} message GroupName message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GroupName.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a GroupName message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.GroupName
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.GroupName} GroupName
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GroupName.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.GroupName();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.groupSource = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a GroupName message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.GroupName
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.GroupName} GroupName
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GroupName.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a GroupName message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.GroupName
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        GroupName.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.groupSource != null && message.hasOwnProperty("groupSource"))
                                switch (message.groupSource) {
                                default:
                                    return "groupSource: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a GroupName message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.GroupName
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.GroupName} GroupName
                         */
                        GroupName.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.GroupName)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.GroupName();
                            switch (object.groupSource) {
                            default:
                                if (typeof object.groupSource === "number") {
                                    message.groupSource = object.groupSource;
                                    break;
                                }
                                break;
                            case "GROUP_SOURCE_TYPE_CURRENT_SLIDE":
                            case 0:
                                message.groupSource = 0;
                                break;
                            case "GROUP_SOURCE_TYPE_NEXT_SLIDE":
                            case 1:
                                message.groupSource = 1;
                                break;
                            case "GROUP_SOURCE_TYPE_NEXT_GROUP":
                            case 2:
                                message.groupSource = 2;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a GroupName message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.GroupName
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.GroupName} message GroupName
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        GroupName.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.groupSource = options.enums === String ? "GROUP_SOURCE_TYPE_CURRENT_SLIDE" : 0;
                            if (message.groupSource != null && message.hasOwnProperty("groupSource"))
                                object.groupSource = options.enums === String ? $root.rv.data.Slide.Element.DataLink.GroupSourceType[message.groupSource] === undefined ? message.groupSource : $root.rv.data.Slide.Element.DataLink.GroupSourceType[message.groupSource] : message.groupSource;
                            return object;
                        };

                        /**
                         * Converts this GroupName to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.GroupName
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        GroupName.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for GroupName
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.GroupName
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        GroupName.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.GroupName";
                        };

                        return GroupName;
                    })();

                    DataLink.GroupColor = (function() {

                        /**
                         * Properties of a GroupColor.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IGroupColor
                         * @property {rv.data.Slide.Element.DataLink.GroupSourceType|null} [groupSource] GroupColor groupSource
                         */

                        /**
                         * Constructs a new GroupColor.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a GroupColor.
                         * @implements IGroupColor
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IGroupColor=} [properties] Properties to set
                         */
                        function GroupColor(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * GroupColor groupSource.
                         * @member {rv.data.Slide.Element.DataLink.GroupSourceType} groupSource
                         * @memberof rv.data.Slide.Element.DataLink.GroupColor
                         * @instance
                         */
                        GroupColor.prototype.groupSource = 0;

                        /**
                         * Creates a new GroupColor instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.GroupColor
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IGroupColor=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.GroupColor} GroupColor instance
                         */
                        GroupColor.create = function create(properties) {
                            return new GroupColor(properties);
                        };

                        /**
                         * Encodes the specified GroupColor message. Does not implicitly {@link rv.data.Slide.Element.DataLink.GroupColor.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.GroupColor
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IGroupColor} message GroupColor message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GroupColor.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.groupSource != null && Object.hasOwnProperty.call(message, "groupSource"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.groupSource);
                            return writer;
                        };

                        /**
                         * Encodes the specified GroupColor message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.GroupColor.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.GroupColor
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IGroupColor} message GroupColor message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GroupColor.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a GroupColor message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.GroupColor
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.GroupColor} GroupColor
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GroupColor.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.GroupColor();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.groupSource = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a GroupColor message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.GroupColor
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.GroupColor} GroupColor
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GroupColor.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a GroupColor message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.GroupColor
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        GroupColor.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.groupSource != null && message.hasOwnProperty("groupSource"))
                                switch (message.groupSource) {
                                default:
                                    return "groupSource: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a GroupColor message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.GroupColor
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.GroupColor} GroupColor
                         */
                        GroupColor.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.GroupColor)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.GroupColor();
                            switch (object.groupSource) {
                            default:
                                if (typeof object.groupSource === "number") {
                                    message.groupSource = object.groupSource;
                                    break;
                                }
                                break;
                            case "GROUP_SOURCE_TYPE_CURRENT_SLIDE":
                            case 0:
                                message.groupSource = 0;
                                break;
                            case "GROUP_SOURCE_TYPE_NEXT_SLIDE":
                            case 1:
                                message.groupSource = 1;
                                break;
                            case "GROUP_SOURCE_TYPE_NEXT_GROUP":
                            case 2:
                                message.groupSource = 2;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a GroupColor message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.GroupColor
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.GroupColor} message GroupColor
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        GroupColor.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.groupSource = options.enums === String ? "GROUP_SOURCE_TYPE_CURRENT_SLIDE" : 0;
                            if (message.groupSource != null && message.hasOwnProperty("groupSource"))
                                object.groupSource = options.enums === String ? $root.rv.data.Slide.Element.DataLink.GroupSourceType[message.groupSource] === undefined ? message.groupSource : $root.rv.data.Slide.Element.DataLink.GroupSourceType[message.groupSource] : message.groupSource;
                            return object;
                        };

                        /**
                         * Converts this GroupColor to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.GroupColor
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        GroupColor.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for GroupColor
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.GroupColor
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        GroupColor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.GroupColor";
                        };

                        return GroupColor;
                    })();

                    DataLink.SlideLabelText = (function() {

                        /**
                         * Properties of a SlideLabelText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface ISlideLabelText
                         * @property {rv.data.Slide.Element.DataLink.SlideLabelSource|null} [slideLabelSource] SlideLabelText slideLabelSource
                         */

                        /**
                         * Constructs a new SlideLabelText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a SlideLabelText.
                         * @implements ISlideLabelText
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.ISlideLabelText=} [properties] Properties to set
                         */
                        function SlideLabelText(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * SlideLabelText slideLabelSource.
                         * @member {rv.data.Slide.Element.DataLink.SlideLabelSource} slideLabelSource
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelText
                         * @instance
                         */
                        SlideLabelText.prototype.slideLabelSource = 0;

                        /**
                         * Creates a new SlideLabelText instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideLabelText=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.SlideLabelText} SlideLabelText instance
                         */
                        SlideLabelText.create = function create(properties) {
                            return new SlideLabelText(properties);
                        };

                        /**
                         * Encodes the specified SlideLabelText message. Does not implicitly {@link rv.data.Slide.Element.DataLink.SlideLabelText.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideLabelText} message SlideLabelText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SlideLabelText.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.slideLabelSource != null && Object.hasOwnProperty.call(message, "slideLabelSource"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slideLabelSource);
                            return writer;
                        };

                        /**
                         * Encodes the specified SlideLabelText message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.SlideLabelText.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideLabelText} message SlideLabelText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SlideLabelText.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a SlideLabelText message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.SlideLabelText} SlideLabelText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SlideLabelText.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.SlideLabelText();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.slideLabelSource = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a SlideLabelText message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.SlideLabelText} SlideLabelText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SlideLabelText.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a SlideLabelText message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelText
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        SlideLabelText.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.slideLabelSource != null && message.hasOwnProperty("slideLabelSource"))
                                switch (message.slideLabelSource) {
                                default:
                                    return "slideLabelSource: enum value expected";
                                case 0:
                                case 1:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a SlideLabelText message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelText
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.SlideLabelText} SlideLabelText
                         */
                        SlideLabelText.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.SlideLabelText)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.SlideLabelText();
                            switch (object.slideLabelSource) {
                            default:
                                if (typeof object.slideLabelSource === "number") {
                                    message.slideLabelSource = object.slideLabelSource;
                                    break;
                                }
                                break;
                            case "SLIDE_LABEL_SOURCE_CURRENT_SLIDE":
                            case 0:
                                message.slideLabelSource = 0;
                                break;
                            case "SLIDE_LABEL_SOURCE_NEXT_SLIDE":
                            case 1:
                                message.slideLabelSource = 1;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a SlideLabelText message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.SlideLabelText} message SlideLabelText
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        SlideLabelText.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.slideLabelSource = options.enums === String ? "SLIDE_LABEL_SOURCE_CURRENT_SLIDE" : 0;
                            if (message.slideLabelSource != null && message.hasOwnProperty("slideLabelSource"))
                                object.slideLabelSource = options.enums === String ? $root.rv.data.Slide.Element.DataLink.SlideLabelSource[message.slideLabelSource] === undefined ? message.slideLabelSource : $root.rv.data.Slide.Element.DataLink.SlideLabelSource[message.slideLabelSource] : message.slideLabelSource;
                            return object;
                        };

                        /**
                         * Converts this SlideLabelText to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelText
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        SlideLabelText.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for SlideLabelText
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelText
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        SlideLabelText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.SlideLabelText";
                        };

                        return SlideLabelText;
                    })();

                    DataLink.SlideLabelColor = (function() {

                        /**
                         * Properties of a SlideLabelColor.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface ISlideLabelColor
                         * @property {rv.data.Slide.Element.DataLink.SlideLabelSource|null} [slideLabelSource] SlideLabelColor slideLabelSource
                         */

                        /**
                         * Constructs a new SlideLabelColor.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a SlideLabelColor.
                         * @implements ISlideLabelColor
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.ISlideLabelColor=} [properties] Properties to set
                         */
                        function SlideLabelColor(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * SlideLabelColor slideLabelSource.
                         * @member {rv.data.Slide.Element.DataLink.SlideLabelSource} slideLabelSource
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelColor
                         * @instance
                         */
                        SlideLabelColor.prototype.slideLabelSource = 0;

                        /**
                         * Creates a new SlideLabelColor instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelColor
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideLabelColor=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.SlideLabelColor} SlideLabelColor instance
                         */
                        SlideLabelColor.create = function create(properties) {
                            return new SlideLabelColor(properties);
                        };

                        /**
                         * Encodes the specified SlideLabelColor message. Does not implicitly {@link rv.data.Slide.Element.DataLink.SlideLabelColor.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelColor
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideLabelColor} message SlideLabelColor message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SlideLabelColor.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.slideLabelSource != null && Object.hasOwnProperty.call(message, "slideLabelSource"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slideLabelSource);
                            return writer;
                        };

                        /**
                         * Encodes the specified SlideLabelColor message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.SlideLabelColor.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelColor
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideLabelColor} message SlideLabelColor message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SlideLabelColor.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a SlideLabelColor message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelColor
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.SlideLabelColor} SlideLabelColor
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SlideLabelColor.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.SlideLabelColor();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.slideLabelSource = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a SlideLabelColor message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelColor
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.SlideLabelColor} SlideLabelColor
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SlideLabelColor.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a SlideLabelColor message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelColor
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        SlideLabelColor.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.slideLabelSource != null && message.hasOwnProperty("slideLabelSource"))
                                switch (message.slideLabelSource) {
                                default:
                                    return "slideLabelSource: enum value expected";
                                case 0:
                                case 1:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a SlideLabelColor message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelColor
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.SlideLabelColor} SlideLabelColor
                         */
                        SlideLabelColor.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.SlideLabelColor)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.SlideLabelColor();
                            switch (object.slideLabelSource) {
                            default:
                                if (typeof object.slideLabelSource === "number") {
                                    message.slideLabelSource = object.slideLabelSource;
                                    break;
                                }
                                break;
                            case "SLIDE_LABEL_SOURCE_CURRENT_SLIDE":
                            case 0:
                                message.slideLabelSource = 0;
                                break;
                            case "SLIDE_LABEL_SOURCE_NEXT_SLIDE":
                            case 1:
                                message.slideLabelSource = 1;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a SlideLabelColor message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelColor
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.SlideLabelColor} message SlideLabelColor
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        SlideLabelColor.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.slideLabelSource = options.enums === String ? "SLIDE_LABEL_SOURCE_CURRENT_SLIDE" : 0;
                            if (message.slideLabelSource != null && message.hasOwnProperty("slideLabelSource"))
                                object.slideLabelSource = options.enums === String ? $root.rv.data.Slide.Element.DataLink.SlideLabelSource[message.slideLabelSource] === undefined ? message.slideLabelSource : $root.rv.data.Slide.Element.DataLink.SlideLabelSource[message.slideLabelSource] : message.slideLabelSource;
                            return object;
                        };

                        /**
                         * Converts this SlideLabelColor to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelColor
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        SlideLabelColor.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for SlideLabelColor
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.SlideLabelColor
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        SlideLabelColor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.SlideLabelColor";
                        };

                        return SlideLabelColor;
                    })();

                    DataLink.PresentationNotes = (function() {

                        /**
                         * Properties of a PresentationNotes.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IPresentationNotes
                         */

                        /**
                         * Constructs a new PresentationNotes.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a PresentationNotes.
                         * @implements IPresentationNotes
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IPresentationNotes=} [properties] Properties to set
                         */
                        function PresentationNotes(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new PresentationNotes instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.PresentationNotes
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPresentationNotes=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.PresentationNotes} PresentationNotes instance
                         */
                        PresentationNotes.create = function create(properties) {
                            return new PresentationNotes(properties);
                        };

                        /**
                         * Encodes the specified PresentationNotes message. Does not implicitly {@link rv.data.Slide.Element.DataLink.PresentationNotes.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.PresentationNotes
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPresentationNotes} message PresentationNotes message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PresentationNotes.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified PresentationNotes message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.PresentationNotes.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.PresentationNotes
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPresentationNotes} message PresentationNotes message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PresentationNotes.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a PresentationNotes message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.PresentationNotes
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.PresentationNotes} PresentationNotes
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PresentationNotes.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.PresentationNotes();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a PresentationNotes message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.PresentationNotes
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.PresentationNotes} PresentationNotes
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PresentationNotes.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a PresentationNotes message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.PresentationNotes
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PresentationNotes.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a PresentationNotes message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.PresentationNotes
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.PresentationNotes} PresentationNotes
                         */
                        PresentationNotes.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.PresentationNotes)
                                return object;
                            return new $root.rv.data.Slide.Element.DataLink.PresentationNotes();
                        };

                        /**
                         * Creates a plain object from a PresentationNotes message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.PresentationNotes
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.PresentationNotes} message PresentationNotes
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PresentationNotes.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this PresentationNotes to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.PresentationNotes
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PresentationNotes.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for PresentationNotes
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.PresentationNotes
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        PresentationNotes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.PresentationNotes";
                        };

                        return PresentationNotes;
                    })();

                    DataLink.Presentation = (function() {

                        /**
                         * Properties of a Presentation.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IPresentation
                         * @property {rv.data.Slide.Element.DataLink.Presentation.PresentationSource|null} [presentationSource] Presentation presentationSource
                         */

                        /**
                         * Constructs a new Presentation.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a Presentation.
                         * @implements IPresentation
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IPresentation=} [properties] Properties to set
                         */
                        function Presentation(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Presentation presentationSource.
                         * @member {rv.data.Slide.Element.DataLink.Presentation.PresentationSource} presentationSource
                         * @memberof rv.data.Slide.Element.DataLink.Presentation
                         * @instance
                         */
                        Presentation.prototype.presentationSource = 0;

                        /**
                         * Creates a new Presentation instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.Presentation
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPresentation=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.Presentation} Presentation instance
                         */
                        Presentation.create = function create(properties) {
                            return new Presentation(properties);
                        };

                        /**
                         * Encodes the specified Presentation message. Does not implicitly {@link rv.data.Slide.Element.DataLink.Presentation.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.Presentation
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPresentation} message Presentation message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Presentation.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.presentationSource != null && Object.hasOwnProperty.call(message, "presentationSource"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.presentationSource);
                            return writer;
                        };

                        /**
                         * Encodes the specified Presentation message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.Presentation.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.Presentation
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPresentation} message Presentation message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Presentation.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Presentation message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.Presentation
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.Presentation} Presentation
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Presentation.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.Presentation();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.presentationSource = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Presentation message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.Presentation
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.Presentation} Presentation
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Presentation.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Presentation message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.Presentation
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Presentation.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.presentationSource != null && message.hasOwnProperty("presentationSource"))
                                switch (message.presentationSource) {
                                default:
                                    return "presentationSource: enum value expected";
                                case 0:
                                case 1:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a Presentation message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.Presentation
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.Presentation} Presentation
                         */
                        Presentation.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.Presentation)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.Presentation();
                            switch (object.presentationSource) {
                            default:
                                if (typeof object.presentationSource === "number") {
                                    message.presentationSource = object.presentationSource;
                                    break;
                                }
                                break;
                            case "PRESENTATION_SOURCE_PRESENTATION":
                            case 0:
                                message.presentationSource = 0;
                                break;
                            case "PRESENTATION_SOURCE_ANNOUNCEMENT":
                            case 1:
                                message.presentationSource = 1;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Presentation message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.Presentation
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.Presentation} message Presentation
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Presentation.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.presentationSource = options.enums === String ? "PRESENTATION_SOURCE_PRESENTATION" : 0;
                            if (message.presentationSource != null && message.hasOwnProperty("presentationSource"))
                                object.presentationSource = options.enums === String ? $root.rv.data.Slide.Element.DataLink.Presentation.PresentationSource[message.presentationSource] === undefined ? message.presentationSource : $root.rv.data.Slide.Element.DataLink.Presentation.PresentationSource[message.presentationSource] : message.presentationSource;
                            return object;
                        };

                        /**
                         * Converts this Presentation to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.Presentation
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Presentation.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Presentation
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.Presentation
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Presentation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.Presentation";
                        };

                        /**
                         * PresentationSource enum.
                         * @name rv.data.Slide.Element.DataLink.Presentation.PresentationSource
                         * @enum {number}
                         * @property {number} PRESENTATION_SOURCE_PRESENTATION=0 PRESENTATION_SOURCE_PRESENTATION value
                         * @property {number} PRESENTATION_SOURCE_ANNOUNCEMENT=1 PRESENTATION_SOURCE_ANNOUNCEMENT value
                         */
                        Presentation.PresentationSource = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "PRESENTATION_SOURCE_PRESENTATION"] = 0;
                            values[valuesById[1] = "PRESENTATION_SOURCE_ANNOUNCEMENT"] = 1;
                            return values;
                        })();

                        return Presentation;
                    })();

                    DataLink.PlaylistItem = (function() {

                        /**
                         * Properties of a PlaylistItem.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IPlaylistItem
                         * @property {rv.data.Slide.Element.DataLink.PlaylistItem.PlaylistItemSourceType|null} [playlistItemSource] PlaylistItem playlistItemSource
                         * @property {boolean|null} [showArrangement] PlaylistItem showArrangement
                         */

                        /**
                         * Constructs a new PlaylistItem.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a PlaylistItem.
                         * @implements IPlaylistItem
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IPlaylistItem=} [properties] Properties to set
                         */
                        function PlaylistItem(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * PlaylistItem playlistItemSource.
                         * @member {rv.data.Slide.Element.DataLink.PlaylistItem.PlaylistItemSourceType} playlistItemSource
                         * @memberof rv.data.Slide.Element.DataLink.PlaylistItem
                         * @instance
                         */
                        PlaylistItem.prototype.playlistItemSource = 0;

                        /**
                         * PlaylistItem showArrangement.
                         * @member {boolean} showArrangement
                         * @memberof rv.data.Slide.Element.DataLink.PlaylistItem
                         * @instance
                         */
                        PlaylistItem.prototype.showArrangement = false;

                        /**
                         * Creates a new PlaylistItem instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.PlaylistItem
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPlaylistItem=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.PlaylistItem} PlaylistItem instance
                         */
                        PlaylistItem.create = function create(properties) {
                            return new PlaylistItem(properties);
                        };

                        /**
                         * Encodes the specified PlaylistItem message. Does not implicitly {@link rv.data.Slide.Element.DataLink.PlaylistItem.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.PlaylistItem
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPlaylistItem} message PlaylistItem message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PlaylistItem.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.playlistItemSource != null && Object.hasOwnProperty.call(message, "playlistItemSource"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.playlistItemSource);
                            if (message.showArrangement != null && Object.hasOwnProperty.call(message, "showArrangement"))
                                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.showArrangement);
                            return writer;
                        };

                        /**
                         * Encodes the specified PlaylistItem message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.PlaylistItem.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.PlaylistItem
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPlaylistItem} message PlaylistItem message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PlaylistItem.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a PlaylistItem message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.PlaylistItem
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.PlaylistItem} PlaylistItem
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PlaylistItem.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.PlaylistItem();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.playlistItemSource = reader.int32();
                                        break;
                                    }
                                case 2: {
                                        message.showArrangement = reader.bool();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a PlaylistItem message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.PlaylistItem
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.PlaylistItem} PlaylistItem
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PlaylistItem.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a PlaylistItem message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.PlaylistItem
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PlaylistItem.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.playlistItemSource != null && message.hasOwnProperty("playlistItemSource"))
                                switch (message.playlistItemSource) {
                                default:
                                    return "playlistItemSource: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                    break;
                                }
                            if (message.showArrangement != null && message.hasOwnProperty("showArrangement"))
                                if (typeof message.showArrangement !== "boolean")
                                    return "showArrangement: boolean expected";
                            return null;
                        };

                        /**
                         * Creates a PlaylistItem message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.PlaylistItem
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.PlaylistItem} PlaylistItem
                         */
                        PlaylistItem.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.PlaylistItem)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.PlaylistItem();
                            switch (object.playlistItemSource) {
                            default:
                                if (typeof object.playlistItemSource === "number") {
                                    message.playlistItemSource = object.playlistItemSource;
                                    break;
                                }
                                break;
                            case "PLAYLIST_ITEM_SOURCE_TYPE_CURRENT":
                            case 0:
                                message.playlistItemSource = 0;
                                break;
                            case "PLAYLIST_ITEM_SOURCE_TYPE_NEXT":
                            case 1:
                                message.playlistItemSource = 1;
                                break;
                            case "PLAYLIST_ITEM_SOURCE_TYPE_CURRENT_HEADER":
                            case 2:
                                message.playlistItemSource = 2;
                                break;
                            case "PLAYLIST_ITEM_SOURCE_TYPE_NEXT_HEADER":
                            case 3:
                                message.playlistItemSource = 3;
                                break;
                            case "PLAYLIST_ITEM_SOURCE_TYPE_PARENT_PLAYLIST":
                            case 4:
                                message.playlistItemSource = 4;
                                break;
                            }
                            if (object.showArrangement != null)
                                message.showArrangement = Boolean(object.showArrangement);
                            return message;
                        };

                        /**
                         * Creates a plain object from a PlaylistItem message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.PlaylistItem
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.PlaylistItem} message PlaylistItem
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PlaylistItem.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.playlistItemSource = options.enums === String ? "PLAYLIST_ITEM_SOURCE_TYPE_CURRENT" : 0;
                                object.showArrangement = false;
                            }
                            if (message.playlistItemSource != null && message.hasOwnProperty("playlistItemSource"))
                                object.playlistItemSource = options.enums === String ? $root.rv.data.Slide.Element.DataLink.PlaylistItem.PlaylistItemSourceType[message.playlistItemSource] === undefined ? message.playlistItemSource : $root.rv.data.Slide.Element.DataLink.PlaylistItem.PlaylistItemSourceType[message.playlistItemSource] : message.playlistItemSource;
                            if (message.showArrangement != null && message.hasOwnProperty("showArrangement"))
                                object.showArrangement = message.showArrangement;
                            return object;
                        };

                        /**
                         * Converts this PlaylistItem to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.PlaylistItem
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PlaylistItem.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for PlaylistItem
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.PlaylistItem
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        PlaylistItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.PlaylistItem";
                        };

                        /**
                         * PlaylistItemSourceType enum.
                         * @name rv.data.Slide.Element.DataLink.PlaylistItem.PlaylistItemSourceType
                         * @enum {number}
                         * @property {number} PLAYLIST_ITEM_SOURCE_TYPE_CURRENT=0 PLAYLIST_ITEM_SOURCE_TYPE_CURRENT value
                         * @property {number} PLAYLIST_ITEM_SOURCE_TYPE_NEXT=1 PLAYLIST_ITEM_SOURCE_TYPE_NEXT value
                         * @property {number} PLAYLIST_ITEM_SOURCE_TYPE_CURRENT_HEADER=2 PLAYLIST_ITEM_SOURCE_TYPE_CURRENT_HEADER value
                         * @property {number} PLAYLIST_ITEM_SOURCE_TYPE_NEXT_HEADER=3 PLAYLIST_ITEM_SOURCE_TYPE_NEXT_HEADER value
                         * @property {number} PLAYLIST_ITEM_SOURCE_TYPE_PARENT_PLAYLIST=4 PLAYLIST_ITEM_SOURCE_TYPE_PARENT_PLAYLIST value
                         */
                        PlaylistItem.PlaylistItemSourceType = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "PLAYLIST_ITEM_SOURCE_TYPE_CURRENT"] = 0;
                            values[valuesById[1] = "PLAYLIST_ITEM_SOURCE_TYPE_NEXT"] = 1;
                            values[valuesById[2] = "PLAYLIST_ITEM_SOURCE_TYPE_CURRENT_HEADER"] = 2;
                            values[valuesById[3] = "PLAYLIST_ITEM_SOURCE_TYPE_NEXT_HEADER"] = 3;
                            values[valuesById[4] = "PLAYLIST_ITEM_SOURCE_TYPE_PARENT_PLAYLIST"] = 4;
                            return values;
                        })();

                        return PlaylistItem;
                    })();

                    DataLink.AutoAdvanceTimeRemaining = (function() {

                        /**
                         * Properties of an AutoAdvanceTimeRemaining.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IAutoAdvanceTimeRemaining
                         * @property {rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining.AutoAdvanceSource|null} [autoAdvanceSource] AutoAdvanceTimeRemaining autoAdvanceSource
                         * @property {rv.data.Timer.IFormat|null} [timerFormat] AutoAdvanceTimeRemaining timerFormat
                         */

                        /**
                         * Constructs a new AutoAdvanceTimeRemaining.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents an AutoAdvanceTimeRemaining.
                         * @implements IAutoAdvanceTimeRemaining
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IAutoAdvanceTimeRemaining=} [properties] Properties to set
                         */
                        function AutoAdvanceTimeRemaining(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * AutoAdvanceTimeRemaining autoAdvanceSource.
                         * @member {rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining.AutoAdvanceSource} autoAdvanceSource
                         * @memberof rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining
                         * @instance
                         */
                        AutoAdvanceTimeRemaining.prototype.autoAdvanceSource = 0;

                        /**
                         * AutoAdvanceTimeRemaining timerFormat.
                         * @member {rv.data.Timer.IFormat|null|undefined} timerFormat
                         * @memberof rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining
                         * @instance
                         */
                        AutoAdvanceTimeRemaining.prototype.timerFormat = null;

                        /**
                         * Creates a new AutoAdvanceTimeRemaining instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IAutoAdvanceTimeRemaining=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining} AutoAdvanceTimeRemaining instance
                         */
                        AutoAdvanceTimeRemaining.create = function create(properties) {
                            return new AutoAdvanceTimeRemaining(properties);
                        };

                        /**
                         * Encodes the specified AutoAdvanceTimeRemaining message. Does not implicitly {@link rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IAutoAdvanceTimeRemaining} message AutoAdvanceTimeRemaining message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        AutoAdvanceTimeRemaining.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.autoAdvanceSource != null && Object.hasOwnProperty.call(message, "autoAdvanceSource"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.autoAdvanceSource);
                            if (message.timerFormat != null && Object.hasOwnProperty.call(message, "timerFormat"))
                                $root.rv.data.Timer.Format.encode(message.timerFormat, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified AutoAdvanceTimeRemaining message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IAutoAdvanceTimeRemaining} message AutoAdvanceTimeRemaining message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        AutoAdvanceTimeRemaining.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an AutoAdvanceTimeRemaining message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining} AutoAdvanceTimeRemaining
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        AutoAdvanceTimeRemaining.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.autoAdvanceSource = reader.int32();
                                        break;
                                    }
                                case 2: {
                                        message.timerFormat = $root.rv.data.Timer.Format.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an AutoAdvanceTimeRemaining message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining} AutoAdvanceTimeRemaining
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        AutoAdvanceTimeRemaining.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an AutoAdvanceTimeRemaining message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        AutoAdvanceTimeRemaining.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.autoAdvanceSource != null && message.hasOwnProperty("autoAdvanceSource"))
                                switch (message.autoAdvanceSource) {
                                default:
                                    return "autoAdvanceSource: enum value expected";
                                case 0:
                                case 1:
                                    break;
                                }
                            if (message.timerFormat != null && message.hasOwnProperty("timerFormat")) {
                                let error = $root.rv.data.Timer.Format.verify(message.timerFormat);
                                if (error)
                                    return "timerFormat." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates an AutoAdvanceTimeRemaining message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining} AutoAdvanceTimeRemaining
                         */
                        AutoAdvanceTimeRemaining.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining();
                            switch (object.autoAdvanceSource) {
                            default:
                                if (typeof object.autoAdvanceSource === "number") {
                                    message.autoAdvanceSource = object.autoAdvanceSource;
                                    break;
                                }
                                break;
                            case "AUTO_ADVANCE_SOURCE_PRESENTATION":
                            case 0:
                                message.autoAdvanceSource = 0;
                                break;
                            case "AUTO_ADVANCE_SOURCE_ANNOUNCEMENT":
                            case 1:
                                message.autoAdvanceSource = 1;
                                break;
                            }
                            if (object.timerFormat != null) {
                                if (typeof object.timerFormat !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining.timerFormat: object expected");
                                message.timerFormat = $root.rv.data.Timer.Format.fromObject(object.timerFormat);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an AutoAdvanceTimeRemaining message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining} message AutoAdvanceTimeRemaining
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        AutoAdvanceTimeRemaining.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.autoAdvanceSource = options.enums === String ? "AUTO_ADVANCE_SOURCE_PRESENTATION" : 0;
                                object.timerFormat = null;
                            }
                            if (message.autoAdvanceSource != null && message.hasOwnProperty("autoAdvanceSource"))
                                object.autoAdvanceSource = options.enums === String ? $root.rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining.AutoAdvanceSource[message.autoAdvanceSource] === undefined ? message.autoAdvanceSource : $root.rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining.AutoAdvanceSource[message.autoAdvanceSource] : message.autoAdvanceSource;
                            if (message.timerFormat != null && message.hasOwnProperty("timerFormat"))
                                object.timerFormat = $root.rv.data.Timer.Format.toObject(message.timerFormat, options);
                            return object;
                        };

                        /**
                         * Converts this AutoAdvanceTimeRemaining to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        AutoAdvanceTimeRemaining.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for AutoAdvanceTimeRemaining
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        AutoAdvanceTimeRemaining.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining";
                        };

                        /**
                         * AutoAdvanceSource enum.
                         * @name rv.data.Slide.Element.DataLink.AutoAdvanceTimeRemaining.AutoAdvanceSource
                         * @enum {number}
                         * @property {number} AUTO_ADVANCE_SOURCE_PRESENTATION=0 AUTO_ADVANCE_SOURCE_PRESENTATION value
                         * @property {number} AUTO_ADVANCE_SOURCE_ANNOUNCEMENT=1 AUTO_ADVANCE_SOURCE_ANNOUNCEMENT value
                         */
                        AutoAdvanceTimeRemaining.AutoAdvanceSource = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "AUTO_ADVANCE_SOURCE_PRESENTATION"] = 0;
                            values[valuesById[1] = "AUTO_ADVANCE_SOURCE_ANNOUNCEMENT"] = 1;
                            return values;
                        })();

                        return AutoAdvanceTimeRemaining;
                    })();

                    DataLink.CaptureStatusText = (function() {

                        /**
                         * Properties of a CaptureStatusText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface ICaptureStatusText
                         * @property {rv.data.Slide.Element.DataLink.CaptureStatusText.IStatusText|null} [statusText] CaptureStatusText statusText
                         * @property {rv.data.Slide.Element.DataLink.CaptureStatusText.IElapsedTime|null} [elapsedTime] CaptureStatusText elapsedTime
                         */

                        /**
                         * Constructs a new CaptureStatusText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a CaptureStatusText.
                         * @implements ICaptureStatusText
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.ICaptureStatusText=} [properties] Properties to set
                         */
                        function CaptureStatusText(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * CaptureStatusText statusText.
                         * @member {rv.data.Slide.Element.DataLink.CaptureStatusText.IStatusText|null|undefined} statusText
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                         * @instance
                         */
                        CaptureStatusText.prototype.statusText = null;

                        /**
                         * CaptureStatusText elapsedTime.
                         * @member {rv.data.Slide.Element.DataLink.CaptureStatusText.IElapsedTime|null|undefined} elapsedTime
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                         * @instance
                         */
                        CaptureStatusText.prototype.elapsedTime = null;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * CaptureStatusText TextType.
                         * @member {"statusText"|"elapsedTime"|undefined} TextType
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                         * @instance
                         */
                        Object.defineProperty(CaptureStatusText.prototype, "TextType", {
                            get: $util.oneOfGetter($oneOfFields = ["statusText", "elapsedTime"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Creates a new CaptureStatusText instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ICaptureStatusText=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.CaptureStatusText} CaptureStatusText instance
                         */
                        CaptureStatusText.create = function create(properties) {
                            return new CaptureStatusText(properties);
                        };

                        /**
                         * Encodes the specified CaptureStatusText message. Does not implicitly {@link rv.data.Slide.Element.DataLink.CaptureStatusText.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ICaptureStatusText} message CaptureStatusText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CaptureStatusText.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.statusText != null && Object.hasOwnProperty.call(message, "statusText"))
                                $root.rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText.encode(message.statusText, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.elapsedTime != null && Object.hasOwnProperty.call(message, "elapsedTime"))
                                $root.rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime.encode(message.elapsedTime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified CaptureStatusText message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.CaptureStatusText.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ICaptureStatusText} message CaptureStatusText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CaptureStatusText.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a CaptureStatusText message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.CaptureStatusText} CaptureStatusText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CaptureStatusText.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.CaptureStatusText();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.statusText = $root.rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.elapsedTime = $root.rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a CaptureStatusText message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.CaptureStatusText} CaptureStatusText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CaptureStatusText.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a CaptureStatusText message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        CaptureStatusText.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.statusText != null && message.hasOwnProperty("statusText")) {
                                properties.TextType = 1;
                                {
                                    let error = $root.rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText.verify(message.statusText);
                                    if (error)
                                        return "statusText." + error;
                                }
                            }
                            if (message.elapsedTime != null && message.hasOwnProperty("elapsedTime")) {
                                if (properties.TextType === 1)
                                    return "TextType: multiple values";
                                properties.TextType = 1;
                                {
                                    let error = $root.rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime.verify(message.elapsedTime);
                                    if (error)
                                        return "elapsedTime." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a CaptureStatusText message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.CaptureStatusText} CaptureStatusText
                         */
                        CaptureStatusText.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.CaptureStatusText)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.CaptureStatusText();
                            if (object.statusText != null) {
                                if (typeof object.statusText !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.CaptureStatusText.statusText: object expected");
                                message.statusText = $root.rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText.fromObject(object.statusText);
                            }
                            if (object.elapsedTime != null) {
                                if (typeof object.elapsedTime !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.CaptureStatusText.elapsedTime: object expected");
                                message.elapsedTime = $root.rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime.fromObject(object.elapsedTime);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a CaptureStatusText message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.CaptureStatusText} message CaptureStatusText
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        CaptureStatusText.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (message.statusText != null && message.hasOwnProperty("statusText")) {
                                object.statusText = $root.rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText.toObject(message.statusText, options);
                                if (options.oneofs)
                                    object.TextType = "statusText";
                            }
                            if (message.elapsedTime != null && message.hasOwnProperty("elapsedTime")) {
                                object.elapsedTime = $root.rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime.toObject(message.elapsedTime, options);
                                if (options.oneofs)
                                    object.TextType = "elapsedTime";
                            }
                            return object;
                        };

                        /**
                         * Converts this CaptureStatusText to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        CaptureStatusText.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for CaptureStatusText
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        CaptureStatusText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.CaptureStatusText";
                        };

                        CaptureStatusText.StatusText = (function() {

                            /**
                             * Properties of a StatusText.
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                             * @interface IStatusText
                             */

                            /**
                             * Constructs a new StatusText.
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                             * @classdesc Represents a StatusText.
                             * @implements IStatusText
                             * @constructor
                             * @param {rv.data.Slide.Element.DataLink.CaptureStatusText.IStatusText=} [properties] Properties to set
                             */
                            function StatusText(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Creates a new StatusText instance using the specified properties.
                             * @function create
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.CaptureStatusText.IStatusText=} [properties] Properties to set
                             * @returns {rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText} StatusText instance
                             */
                            StatusText.create = function create(properties) {
                                return new StatusText(properties);
                            };

                            /**
                             * Encodes the specified StatusText message. Does not implicitly {@link rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText.verify|verify} messages.
                             * @function encode
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.CaptureStatusText.IStatusText} message StatusText message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            StatusText.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                return writer;
                            };

                            /**
                             * Encodes the specified StatusText message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.CaptureStatusText.IStatusText} message StatusText message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            StatusText.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a StatusText message from the specified reader or buffer.
                             * @function decode
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText} StatusText
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            StatusText.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a StatusText message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText} StatusText
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            StatusText.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a StatusText message.
                             * @function verify
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            StatusText.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                return null;
                            };

                            /**
                             * Creates a StatusText message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText} StatusText
                             */
                            StatusText.fromObject = function fromObject(object) {
                                if (object instanceof $root.rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText)
                                    return object;
                                return new $root.rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText();
                            };

                            /**
                             * Creates a plain object from a StatusText message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText} message StatusText
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            StatusText.toObject = function toObject() {
                                return {};
                            };

                            /**
                             * Converts this StatusText to JSON.
                             * @function toJSON
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            StatusText.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for StatusText
                             * @function getTypeUrl
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            StatusText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.CaptureStatusText.StatusText";
                            };

                            return StatusText;
                        })();

                        CaptureStatusText.ElapsedTime = (function() {

                            /**
                             * Properties of an ElapsedTime.
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                             * @interface IElapsedTime
                             * @property {rv.data.Timer.IFormat|null} [timerFormat] ElapsedTime timerFormat
                             */

                            /**
                             * Constructs a new ElapsedTime.
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText
                             * @classdesc Represents an ElapsedTime.
                             * @implements IElapsedTime
                             * @constructor
                             * @param {rv.data.Slide.Element.DataLink.CaptureStatusText.IElapsedTime=} [properties] Properties to set
                             */
                            function ElapsedTime(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * ElapsedTime timerFormat.
                             * @member {rv.data.Timer.IFormat|null|undefined} timerFormat
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime
                             * @instance
                             */
                            ElapsedTime.prototype.timerFormat = null;

                            /**
                             * Creates a new ElapsedTime instance using the specified properties.
                             * @function create
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.CaptureStatusText.IElapsedTime=} [properties] Properties to set
                             * @returns {rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime} ElapsedTime instance
                             */
                            ElapsedTime.create = function create(properties) {
                                return new ElapsedTime(properties);
                            };

                            /**
                             * Encodes the specified ElapsedTime message. Does not implicitly {@link rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime.verify|verify} messages.
                             * @function encode
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.CaptureStatusText.IElapsedTime} message ElapsedTime message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            ElapsedTime.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.timerFormat != null && Object.hasOwnProperty.call(message, "timerFormat"))
                                    $root.rv.data.Timer.Format.encode(message.timerFormat, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified ElapsedTime message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.CaptureStatusText.IElapsedTime} message ElapsedTime message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            ElapsedTime.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes an ElapsedTime message from the specified reader or buffer.
                             * @function decode
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime} ElapsedTime
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            ElapsedTime.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.timerFormat = $root.rv.data.Timer.Format.decode(reader, reader.uint32());
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes an ElapsedTime message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime} ElapsedTime
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            ElapsedTime.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies an ElapsedTime message.
                             * @function verify
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            ElapsedTime.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.timerFormat != null && message.hasOwnProperty("timerFormat")) {
                                    let error = $root.rv.data.Timer.Format.verify(message.timerFormat);
                                    if (error)
                                        return "timerFormat." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates an ElapsedTime message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime} ElapsedTime
                             */
                            ElapsedTime.fromObject = function fromObject(object) {
                                if (object instanceof $root.rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime)
                                    return object;
                                let message = new $root.rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime();
                                if (object.timerFormat != null) {
                                    if (typeof object.timerFormat !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime.timerFormat: object expected");
                                    message.timerFormat = $root.rv.data.Timer.Format.fromObject(object.timerFormat);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from an ElapsedTime message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime} message ElapsedTime
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            ElapsedTime.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults)
                                    object.timerFormat = null;
                                if (message.timerFormat != null && message.hasOwnProperty("timerFormat"))
                                    object.timerFormat = $root.rv.data.Timer.Format.toObject(message.timerFormat, options);
                                return object;
                            };

                            /**
                             * Converts this ElapsedTime to JSON.
                             * @function toJSON
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            ElapsedTime.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for ElapsedTime
                             * @function getTypeUrl
                             * @memberof rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            ElapsedTime.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.CaptureStatusText.ElapsedTime";
                            };

                            return ElapsedTime;
                        })();

                        return CaptureStatusText;
                    })();

                    DataLink.CaptureStatusColor = (function() {

                        /**
                         * Properties of a CaptureStatusColor.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface ICaptureStatusColor
                         */

                        /**
                         * Constructs a new CaptureStatusColor.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a CaptureStatusColor.
                         * @implements ICaptureStatusColor
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.ICaptureStatusColor=} [properties] Properties to set
                         */
                        function CaptureStatusColor(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new CaptureStatusColor instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusColor
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ICaptureStatusColor=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.CaptureStatusColor} CaptureStatusColor instance
                         */
                        CaptureStatusColor.create = function create(properties) {
                            return new CaptureStatusColor(properties);
                        };

                        /**
                         * Encodes the specified CaptureStatusColor message. Does not implicitly {@link rv.data.Slide.Element.DataLink.CaptureStatusColor.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusColor
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ICaptureStatusColor} message CaptureStatusColor message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CaptureStatusColor.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified CaptureStatusColor message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.CaptureStatusColor.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusColor
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ICaptureStatusColor} message CaptureStatusColor message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CaptureStatusColor.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a CaptureStatusColor message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusColor
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.CaptureStatusColor} CaptureStatusColor
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CaptureStatusColor.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.CaptureStatusColor();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a CaptureStatusColor message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusColor
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.CaptureStatusColor} CaptureStatusColor
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CaptureStatusColor.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a CaptureStatusColor message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusColor
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        CaptureStatusColor.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a CaptureStatusColor message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusColor
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.CaptureStatusColor} CaptureStatusColor
                         */
                        CaptureStatusColor.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.CaptureStatusColor)
                                return object;
                            return new $root.rv.data.Slide.Element.DataLink.CaptureStatusColor();
                        };

                        /**
                         * Creates a plain object from a CaptureStatusColor message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusColor
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.CaptureStatusColor} message CaptureStatusColor
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        CaptureStatusColor.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this CaptureStatusColor to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusColor
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        CaptureStatusColor.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for CaptureStatusColor
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.CaptureStatusColor
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        CaptureStatusColor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.CaptureStatusColor";
                        };

                        return CaptureStatusColor;
                    })();

                    DataLink.SlideCount = (function() {

                        /**
                         * Properties of a SlideCount.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface ISlideCount
                         * @property {rv.data.Slide.Element.DataLink.SlideCount.SlideCountSourceType|null} [slideCountSourceType] SlideCount slideCountSourceType
                         */

                        /**
                         * Constructs a new SlideCount.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a SlideCount.
                         * @implements ISlideCount
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.ISlideCount=} [properties] Properties to set
                         */
                        function SlideCount(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * SlideCount slideCountSourceType.
                         * @member {rv.data.Slide.Element.DataLink.SlideCount.SlideCountSourceType} slideCountSourceType
                         * @memberof rv.data.Slide.Element.DataLink.SlideCount
                         * @instance
                         */
                        SlideCount.prototype.slideCountSourceType = 0;

                        /**
                         * Creates a new SlideCount instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.SlideCount
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideCount=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.SlideCount} SlideCount instance
                         */
                        SlideCount.create = function create(properties) {
                            return new SlideCount(properties);
                        };

                        /**
                         * Encodes the specified SlideCount message. Does not implicitly {@link rv.data.Slide.Element.DataLink.SlideCount.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.SlideCount
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideCount} message SlideCount message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SlideCount.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.slideCountSourceType != null && Object.hasOwnProperty.call(message, "slideCountSourceType"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slideCountSourceType);
                            return writer;
                        };

                        /**
                         * Encodes the specified SlideCount message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.SlideCount.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.SlideCount
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ISlideCount} message SlideCount message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SlideCount.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a SlideCount message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.SlideCount
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.SlideCount} SlideCount
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SlideCount.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.SlideCount();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.slideCountSourceType = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a SlideCount message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.SlideCount
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.SlideCount} SlideCount
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SlideCount.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a SlideCount message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.SlideCount
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        SlideCount.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.slideCountSourceType != null && message.hasOwnProperty("slideCountSourceType"))
                                switch (message.slideCountSourceType) {
                                default:
                                    return "slideCountSourceType: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a SlideCount message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.SlideCount
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.SlideCount} SlideCount
                         */
                        SlideCount.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.SlideCount)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.SlideCount();
                            switch (object.slideCountSourceType) {
                            default:
                                if (typeof object.slideCountSourceType === "number") {
                                    message.slideCountSourceType = object.slideCountSourceType;
                                    break;
                                }
                                break;
                            case "SLIDE_COUNT_SOURCE_TYPE_CURRENT":
                            case 0:
                                message.slideCountSourceType = 0;
                                break;
                            case "SLIDE_COUNT_SOURCE_TYPE_REMAINING":
                            case 1:
                                message.slideCountSourceType = 1;
                                break;
                            case "SLIDE_COUNT_SOURCE_TYPE_TOTAL":
                            case 2:
                                message.slideCountSourceType = 2;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a SlideCount message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.SlideCount
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.SlideCount} message SlideCount
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        SlideCount.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.slideCountSourceType = options.enums === String ? "SLIDE_COUNT_SOURCE_TYPE_CURRENT" : 0;
                            if (message.slideCountSourceType != null && message.hasOwnProperty("slideCountSourceType"))
                                object.slideCountSourceType = options.enums === String ? $root.rv.data.Slide.Element.DataLink.SlideCount.SlideCountSourceType[message.slideCountSourceType] === undefined ? message.slideCountSourceType : $root.rv.data.Slide.Element.DataLink.SlideCount.SlideCountSourceType[message.slideCountSourceType] : message.slideCountSourceType;
                            return object;
                        };

                        /**
                         * Converts this SlideCount to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.SlideCount
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        SlideCount.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for SlideCount
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.SlideCount
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        SlideCount.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.SlideCount";
                        };

                        /**
                         * SlideCountSourceType enum.
                         * @name rv.data.Slide.Element.DataLink.SlideCount.SlideCountSourceType
                         * @enum {number}
                         * @property {number} SLIDE_COUNT_SOURCE_TYPE_CURRENT=0 SLIDE_COUNT_SOURCE_TYPE_CURRENT value
                         * @property {number} SLIDE_COUNT_SOURCE_TYPE_REMAINING=1 SLIDE_COUNT_SOURCE_TYPE_REMAINING value
                         * @property {number} SLIDE_COUNT_SOURCE_TYPE_TOTAL=2 SLIDE_COUNT_SOURCE_TYPE_TOTAL value
                         */
                        SlideCount.SlideCountSourceType = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "SLIDE_COUNT_SOURCE_TYPE_CURRENT"] = 0;
                            values[valuesById[1] = "SLIDE_COUNT_SOURCE_TYPE_REMAINING"] = 1;
                            values[valuesById[2] = "SLIDE_COUNT_SOURCE_TYPE_TOTAL"] = 2;
                            return values;
                        })();

                        return SlideCount;
                    })();

                    DataLink.PlaybackMarkerIdentifier = (function() {

                        /**
                         * Properties of a PlaybackMarkerIdentifier.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IPlaybackMarkerIdentifier
                         * @property {rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.Destination|null} [destination] PlaybackMarkerIdentifier destination
                         * @property {rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.Type|null} [type] PlaybackMarkerIdentifier type
                         * @property {string|null} [name] PlaybackMarkerIdentifier name
                         */

                        /**
                         * Constructs a new PlaybackMarkerIdentifier.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a PlaybackMarkerIdentifier.
                         * @implements IPlaybackMarkerIdentifier
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IPlaybackMarkerIdentifier=} [properties] Properties to set
                         */
                        function PlaybackMarkerIdentifier(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * PlaybackMarkerIdentifier destination.
                         * @member {rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.Destination} destination
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier
                         * @instance
                         */
                        PlaybackMarkerIdentifier.prototype.destination = 0;

                        /**
                         * PlaybackMarkerIdentifier type.
                         * @member {rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.Type} type
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier
                         * @instance
                         */
                        PlaybackMarkerIdentifier.prototype.type = 0;

                        /**
                         * PlaybackMarkerIdentifier name.
                         * @member {string} name
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier
                         * @instance
                         */
                        PlaybackMarkerIdentifier.prototype.name = "";

                        /**
                         * Creates a new PlaybackMarkerIdentifier instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPlaybackMarkerIdentifier=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier} PlaybackMarkerIdentifier instance
                         */
                        PlaybackMarkerIdentifier.create = function create(properties) {
                            return new PlaybackMarkerIdentifier(properties);
                        };

                        /**
                         * Encodes the specified PlaybackMarkerIdentifier message. Does not implicitly {@link rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPlaybackMarkerIdentifier} message PlaybackMarkerIdentifier message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PlaybackMarkerIdentifier.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.destination != null && Object.hasOwnProperty.call(message, "destination"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.destination);
                            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                            return writer;
                        };

                        /**
                         * Encodes the specified PlaybackMarkerIdentifier message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPlaybackMarkerIdentifier} message PlaybackMarkerIdentifier message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PlaybackMarkerIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a PlaybackMarkerIdentifier message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier} PlaybackMarkerIdentifier
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PlaybackMarkerIdentifier.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.destination = reader.int32();
                                        break;
                                    }
                                case 2: {
                                        message.type = reader.int32();
                                        break;
                                    }
                                case 3: {
                                        message.name = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a PlaybackMarkerIdentifier message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier} PlaybackMarkerIdentifier
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PlaybackMarkerIdentifier.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a PlaybackMarkerIdentifier message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PlaybackMarkerIdentifier.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.destination != null && message.hasOwnProperty("destination"))
                                switch (message.destination) {
                                default:
                                    return "destination: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.type != null && message.hasOwnProperty("type"))
                                switch (message.type) {
                                default:
                                    return "type: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                    break;
                                }
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            return null;
                        };

                        /**
                         * Creates a PlaybackMarkerIdentifier message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier} PlaybackMarkerIdentifier
                         */
                        PlaybackMarkerIdentifier.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier();
                            switch (object.destination) {
                            default:
                                if (typeof object.destination === "number") {
                                    message.destination = object.destination;
                                    break;
                                }
                                break;
                            case "PLAYBACK_MARKER_DESTINATION_PRESENTATION":
                            case 0:
                                message.destination = 0;
                                break;
                            case "PLAYBACK_MARKER_DESTINATION_ANNOUNCEMENT":
                            case 1:
                                message.destination = 1;
                                break;
                            case "PLAYBACK_MARKER_DESTINATION_AUDIO":
                            case 2:
                                message.destination = 2;
                                break;
                            }
                            switch (object.type) {
                            default:
                                if (typeof object.type === "number") {
                                    message.type = object.type;
                                    break;
                                }
                                break;
                            case "PLAYBACK_MARKER_IDENTIFIER_FIRST":
                            case 0:
                                message.type = 0;
                                break;
                            case "PLAYBACK_MARKER_IDENTIFIER_PREVIOUS":
                            case 1:
                                message.type = 1;
                                break;
                            case "PLAYBACK_MARKER_IDENTIFIER_NEXT":
                            case 2:
                                message.type = 2;
                                break;
                            case "PLAYBACK_MARKER_IDENTIFIER_LAST":
                            case 3:
                                message.type = 3;
                                break;
                            case "PLAYBACK_MARKER_IDENTIFIER_NAME":
                            case 4:
                                message.type = 4;
                                break;
                            }
                            if (object.name != null)
                                message.name = String(object.name);
                            return message;
                        };

                        /**
                         * Creates a plain object from a PlaybackMarkerIdentifier message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier} message PlaybackMarkerIdentifier
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PlaybackMarkerIdentifier.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.destination = options.enums === String ? "PLAYBACK_MARKER_DESTINATION_PRESENTATION" : 0;
                                object.type = options.enums === String ? "PLAYBACK_MARKER_IDENTIFIER_FIRST" : 0;
                                object.name = "";
                            }
                            if (message.destination != null && message.hasOwnProperty("destination"))
                                object.destination = options.enums === String ? $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.Destination[message.destination] === undefined ? message.destination : $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.Destination[message.destination] : message.destination;
                            if (message.type != null && message.hasOwnProperty("type"))
                                object.type = options.enums === String ? $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.Type[message.type] === undefined ? message.type : $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.Type[message.type] : message.type;
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            return object;
                        };

                        /**
                         * Converts this PlaybackMarkerIdentifier to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PlaybackMarkerIdentifier.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for PlaybackMarkerIdentifier
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        PlaybackMarkerIdentifier.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier";
                        };

                        /**
                         * Type enum.
                         * @name rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.Type
                         * @enum {number}
                         * @property {number} PLAYBACK_MARKER_IDENTIFIER_FIRST=0 PLAYBACK_MARKER_IDENTIFIER_FIRST value
                         * @property {number} PLAYBACK_MARKER_IDENTIFIER_PREVIOUS=1 PLAYBACK_MARKER_IDENTIFIER_PREVIOUS value
                         * @property {number} PLAYBACK_MARKER_IDENTIFIER_NEXT=2 PLAYBACK_MARKER_IDENTIFIER_NEXT value
                         * @property {number} PLAYBACK_MARKER_IDENTIFIER_LAST=3 PLAYBACK_MARKER_IDENTIFIER_LAST value
                         * @property {number} PLAYBACK_MARKER_IDENTIFIER_NAME=4 PLAYBACK_MARKER_IDENTIFIER_NAME value
                         */
                        PlaybackMarkerIdentifier.Type = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "PLAYBACK_MARKER_IDENTIFIER_FIRST"] = 0;
                            values[valuesById[1] = "PLAYBACK_MARKER_IDENTIFIER_PREVIOUS"] = 1;
                            values[valuesById[2] = "PLAYBACK_MARKER_IDENTIFIER_NEXT"] = 2;
                            values[valuesById[3] = "PLAYBACK_MARKER_IDENTIFIER_LAST"] = 3;
                            values[valuesById[4] = "PLAYBACK_MARKER_IDENTIFIER_NAME"] = 4;
                            return values;
                        })();

                        /**
                         * Destination enum.
                         * @name rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.Destination
                         * @enum {number}
                         * @property {number} PLAYBACK_MARKER_DESTINATION_PRESENTATION=0 PLAYBACK_MARKER_DESTINATION_PRESENTATION value
                         * @property {number} PLAYBACK_MARKER_DESTINATION_ANNOUNCEMENT=1 PLAYBACK_MARKER_DESTINATION_ANNOUNCEMENT value
                         * @property {number} PLAYBACK_MARKER_DESTINATION_AUDIO=2 PLAYBACK_MARKER_DESTINATION_AUDIO value
                         */
                        PlaybackMarkerIdentifier.Destination = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "PLAYBACK_MARKER_DESTINATION_PRESENTATION"] = 0;
                            values[valuesById[1] = "PLAYBACK_MARKER_DESTINATION_ANNOUNCEMENT"] = 1;
                            values[valuesById[2] = "PLAYBACK_MARKER_DESTINATION_AUDIO"] = 2;
                            return values;
                        })();

                        return PlaybackMarkerIdentifier;
                    })();

                    DataLink.PlaybackMarkerText = (function() {

                        /**
                         * Properties of a PlaybackMarkerText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IPlaybackMarkerText
                         * @property {rv.data.Slide.Element.DataLink.IPlaybackMarkerIdentifier|null} [identifier] PlaybackMarkerText identifier
                         * @property {boolean|null} [shouldUseMarkerColor] PlaybackMarkerText shouldUseMarkerColor
                         * @property {rv.data.Slide.Element.DataLink.PlaybackMarkerText.IName|null} [name] PlaybackMarkerText name
                         * @property {rv.data.Slide.Element.DataLink.PlaybackMarkerText.ITime|null} [time] PlaybackMarkerText time
                         */

                        /**
                         * Constructs a new PlaybackMarkerText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a PlaybackMarkerText.
                         * @implements IPlaybackMarkerText
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IPlaybackMarkerText=} [properties] Properties to set
                         */
                        function PlaybackMarkerText(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * PlaybackMarkerText identifier.
                         * @member {rv.data.Slide.Element.DataLink.IPlaybackMarkerIdentifier|null|undefined} identifier
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @instance
                         */
                        PlaybackMarkerText.prototype.identifier = null;

                        /**
                         * PlaybackMarkerText shouldUseMarkerColor.
                         * @member {boolean} shouldUseMarkerColor
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @instance
                         */
                        PlaybackMarkerText.prototype.shouldUseMarkerColor = false;

                        /**
                         * PlaybackMarkerText name.
                         * @member {rv.data.Slide.Element.DataLink.PlaybackMarkerText.IName|null|undefined} name
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @instance
                         */
                        PlaybackMarkerText.prototype.name = null;

                        /**
                         * PlaybackMarkerText time.
                         * @member {rv.data.Slide.Element.DataLink.PlaybackMarkerText.ITime|null|undefined} time
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @instance
                         */
                        PlaybackMarkerText.prototype.time = null;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * PlaybackMarkerText TextType.
                         * @member {"name"|"time"|undefined} TextType
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @instance
                         */
                        Object.defineProperty(PlaybackMarkerText.prototype, "TextType", {
                            get: $util.oneOfGetter($oneOfFields = ["name", "time"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Creates a new PlaybackMarkerText instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPlaybackMarkerText=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerText} PlaybackMarkerText instance
                         */
                        PlaybackMarkerText.create = function create(properties) {
                            return new PlaybackMarkerText(properties);
                        };

                        /**
                         * Encodes the specified PlaybackMarkerText message. Does not implicitly {@link rv.data.Slide.Element.DataLink.PlaybackMarkerText.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPlaybackMarkerText} message PlaybackMarkerText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PlaybackMarkerText.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.identifier != null && Object.hasOwnProperty.call(message, "identifier"))
                                $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.encode(message.identifier, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name.encode(message.name, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                                $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time.encode(message.time, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.shouldUseMarkerColor != null && Object.hasOwnProperty.call(message, "shouldUseMarkerColor"))
                                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.shouldUseMarkerColor);
                            return writer;
                        };

                        /**
                         * Encodes the specified PlaybackMarkerText message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.PlaybackMarkerText.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IPlaybackMarkerText} message PlaybackMarkerText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PlaybackMarkerText.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a PlaybackMarkerText message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerText} PlaybackMarkerText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PlaybackMarkerText.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.identifier = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 4: {
                                        message.shouldUseMarkerColor = reader.bool();
                                        break;
                                    }
                                case 2: {
                                        message.name = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 3: {
                                        message.time = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a PlaybackMarkerText message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerText} PlaybackMarkerText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PlaybackMarkerText.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a PlaybackMarkerText message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PlaybackMarkerText.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.identifier != null && message.hasOwnProperty("identifier")) {
                                let error = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.verify(message.identifier);
                                if (error)
                                    return "identifier." + error;
                            }
                            if (message.shouldUseMarkerColor != null && message.hasOwnProperty("shouldUseMarkerColor"))
                                if (typeof message.shouldUseMarkerColor !== "boolean")
                                    return "shouldUseMarkerColor: boolean expected";
                            if (message.name != null && message.hasOwnProperty("name")) {
                                properties.TextType = 1;
                                {
                                    let error = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name.verify(message.name);
                                    if (error)
                                        return "name." + error;
                                }
                            }
                            if (message.time != null && message.hasOwnProperty("time")) {
                                if (properties.TextType === 1)
                                    return "TextType: multiple values";
                                properties.TextType = 1;
                                {
                                    let error = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time.verify(message.time);
                                    if (error)
                                        return "time." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a PlaybackMarkerText message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerText} PlaybackMarkerText
                         */
                        PlaybackMarkerText.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText)
                                return object;
                            let message = new $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText();
                            if (object.identifier != null) {
                                if (typeof object.identifier !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.PlaybackMarkerText.identifier: object expected");
                                message.identifier = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.fromObject(object.identifier);
                            }
                            if (object.shouldUseMarkerColor != null)
                                message.shouldUseMarkerColor = Boolean(object.shouldUseMarkerColor);
                            if (object.name != null) {
                                if (typeof object.name !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.PlaybackMarkerText.name: object expected");
                                message.name = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name.fromObject(object.name);
                            }
                            if (object.time != null) {
                                if (typeof object.time !== "object")
                                    throw TypeError(".rv.data.Slide.Element.DataLink.PlaybackMarkerText.time: object expected");
                                message.time = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time.fromObject(object.time);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a PlaybackMarkerText message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.PlaybackMarkerText} message PlaybackMarkerText
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PlaybackMarkerText.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.identifier = null;
                                object.shouldUseMarkerColor = false;
                            }
                            if (message.identifier != null && message.hasOwnProperty("identifier"))
                                object.identifier = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerIdentifier.toObject(message.identifier, options);
                            if (message.name != null && message.hasOwnProperty("name")) {
                                object.name = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name.toObject(message.name, options);
                                if (options.oneofs)
                                    object.TextType = "name";
                            }
                            if (message.time != null && message.hasOwnProperty("time")) {
                                object.time = $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time.toObject(message.time, options);
                                if (options.oneofs)
                                    object.TextType = "time";
                            }
                            if (message.shouldUseMarkerColor != null && message.hasOwnProperty("shouldUseMarkerColor"))
                                object.shouldUseMarkerColor = message.shouldUseMarkerColor;
                            return object;
                        };

                        /**
                         * Converts this PlaybackMarkerText to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PlaybackMarkerText.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for PlaybackMarkerText
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        PlaybackMarkerText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.PlaybackMarkerText";
                        };

                        PlaybackMarkerText.Name = (function() {

                            /**
                             * Properties of a Name.
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                             * @interface IName
                             */

                            /**
                             * Constructs a new Name.
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                             * @classdesc Represents a Name.
                             * @implements IName
                             * @constructor
                             * @param {rv.data.Slide.Element.DataLink.PlaybackMarkerText.IName=} [properties] Properties to set
                             */
                            function Name(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Creates a new Name instance using the specified properties.
                             * @function create
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.PlaybackMarkerText.IName=} [properties] Properties to set
                             * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name} Name instance
                             */
                            Name.create = function create(properties) {
                                return new Name(properties);
                            };

                            /**
                             * Encodes the specified Name message. Does not implicitly {@link rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name.verify|verify} messages.
                             * @function encode
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.PlaybackMarkerText.IName} message Name message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Name.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                return writer;
                            };

                            /**
                             * Encodes the specified Name message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.PlaybackMarkerText.IName} message Name message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Name.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Name message from the specified reader or buffer.
                             * @function decode
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name} Name
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Name.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Name message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name} Name
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Name.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Name message.
                             * @function verify
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Name.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                return null;
                            };

                            /**
                             * Creates a Name message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name} Name
                             */
                            Name.fromObject = function fromObject(object) {
                                if (object instanceof $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name)
                                    return object;
                                return new $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name();
                            };

                            /**
                             * Creates a plain object from a Name message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name} message Name
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Name.toObject = function toObject() {
                                return {};
                            };

                            /**
                             * Converts this Name to JSON.
                             * @function toJSON
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Name.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for Name
                             * @function getTypeUrl
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            Name.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.PlaybackMarkerText.Name";
                            };

                            return Name;
                        })();

                        PlaybackMarkerText.Time = (function() {

                            /**
                             * Properties of a Time.
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                             * @interface ITime
                             * @property {rv.data.Timer.IFormat|null} [format] Time format
                             */

                            /**
                             * Constructs a new Time.
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText
                             * @classdesc Represents a Time.
                             * @implements ITime
                             * @constructor
                             * @param {rv.data.Slide.Element.DataLink.PlaybackMarkerText.ITime=} [properties] Properties to set
                             */
                            function Time(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Time format.
                             * @member {rv.data.Timer.IFormat|null|undefined} format
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time
                             * @instance
                             */
                            Time.prototype.format = null;

                            /**
                             * Creates a new Time instance using the specified properties.
                             * @function create
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.PlaybackMarkerText.ITime=} [properties] Properties to set
                             * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time} Time instance
                             */
                            Time.create = function create(properties) {
                                return new Time(properties);
                            };

                            /**
                             * Encodes the specified Time message. Does not implicitly {@link rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time.verify|verify} messages.
                             * @function encode
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.PlaybackMarkerText.ITime} message Time message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Time.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                                    $root.rv.data.Timer.Format.encode(message.format, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Time message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.PlaybackMarkerText.ITime} message Time message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Time.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Time message from the specified reader or buffer.
                             * @function decode
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time} Time
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Time.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.format = $root.rv.data.Timer.Format.decode(reader, reader.uint32());
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Time message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time} Time
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Time.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Time message.
                             * @function verify
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Time.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.format != null && message.hasOwnProperty("format")) {
                                    let error = $root.rv.data.Timer.Format.verify(message.format);
                                    if (error)
                                        return "format." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Time message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time} Time
                             */
                            Time.fromObject = function fromObject(object) {
                                if (object instanceof $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time)
                                    return object;
                                let message = new $root.rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time();
                                if (object.format != null) {
                                    if (typeof object.format !== "object")
                                        throw TypeError(".rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time.format: object expected");
                                    message.format = $root.rv.data.Timer.Format.fromObject(object.format);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Time message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time
                             * @static
                             * @param {rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time} message Time
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Time.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults)
                                    object.format = null;
                                if (message.format != null && message.hasOwnProperty("format"))
                                    object.format = $root.rv.data.Timer.Format.toObject(message.format, options);
                                return object;
                            };

                            /**
                             * Converts this Time to JSON.
                             * @function toJSON
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Time.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for Time
                             * @function getTypeUrl
                             * @memberof rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            Time.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.PlaybackMarkerText.Time";
                            };

                            return Time;
                        })();

                        return PlaybackMarkerText;
                    })();

                    DataLink.ChordProChart = (function() {

                        /**
                         * Properties of a ChordProChart.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface IChordProChart
                         */

                        /**
                         * Constructs a new ChordProChart.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a ChordProChart.
                         * @implements IChordProChart
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.IChordProChart=} [properties] Properties to set
                         */
                        function ChordProChart(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new ChordProChart instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.ChordProChart
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IChordProChart=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.ChordProChart} ChordProChart instance
                         */
                        ChordProChart.create = function create(properties) {
                            return new ChordProChart(properties);
                        };

                        /**
                         * Encodes the specified ChordProChart message. Does not implicitly {@link rv.data.Slide.Element.DataLink.ChordProChart.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.ChordProChart
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IChordProChart} message ChordProChart message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ChordProChart.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified ChordProChart message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.ChordProChart.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.ChordProChart
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.IChordProChart} message ChordProChart message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ChordProChart.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a ChordProChart message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.ChordProChart
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.ChordProChart} ChordProChart
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ChordProChart.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.ChordProChart();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a ChordProChart message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.ChordProChart
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.ChordProChart} ChordProChart
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ChordProChart.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a ChordProChart message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.ChordProChart
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ChordProChart.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a ChordProChart message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.ChordProChart
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.ChordProChart} ChordProChart
                         */
                        ChordProChart.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.ChordProChart)
                                return object;
                            return new $root.rv.data.Slide.Element.DataLink.ChordProChart();
                        };

                        /**
                         * Creates a plain object from a ChordProChart message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.ChordProChart
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ChordProChart} message ChordProChart
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ChordProChart.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this ChordProChart to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.ChordProChart
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ChordProChart.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ChordProChart
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.ChordProChart
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ChordProChart.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.ChordProChart";
                        };

                        return ChordProChart;
                    })();

                    DataLink.TimecodeText = (function() {

                        /**
                         * Properties of a TimecodeText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface ITimecodeText
                         */

                        /**
                         * Constructs a new TimecodeText.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a TimecodeText.
                         * @implements ITimecodeText
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.ITimecodeText=} [properties] Properties to set
                         */
                        function TimecodeText(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new TimecodeText instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ITimecodeText=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.TimecodeText} TimecodeText instance
                         */
                        TimecodeText.create = function create(properties) {
                            return new TimecodeText(properties);
                        };

                        /**
                         * Encodes the specified TimecodeText message. Does not implicitly {@link rv.data.Slide.Element.DataLink.TimecodeText.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ITimecodeText} message TimecodeText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        TimecodeText.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified TimecodeText message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.TimecodeText.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ITimecodeText} message TimecodeText message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        TimecodeText.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a TimecodeText message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.TimecodeText} TimecodeText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        TimecodeText.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.TimecodeText();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a TimecodeText message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeText
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.TimecodeText} TimecodeText
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        TimecodeText.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a TimecodeText message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeText
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        TimecodeText.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a TimecodeText message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeText
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.TimecodeText} TimecodeText
                         */
                        TimecodeText.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.TimecodeText)
                                return object;
                            return new $root.rv.data.Slide.Element.DataLink.TimecodeText();
                        };

                        /**
                         * Creates a plain object from a TimecodeText message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeText
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.TimecodeText} message TimecodeText
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        TimecodeText.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this TimecodeText to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeText
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        TimecodeText.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for TimecodeText
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeText
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        TimecodeText.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.TimecodeText";
                        };

                        return TimecodeText;
                    })();

                    DataLink.TimecodeStatus = (function() {

                        /**
                         * Properties of a TimecodeStatus.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @interface ITimecodeStatus
                         */

                        /**
                         * Constructs a new TimecodeStatus.
                         * @memberof rv.data.Slide.Element.DataLink
                         * @classdesc Represents a TimecodeStatus.
                         * @implements ITimecodeStatus
                         * @constructor
                         * @param {rv.data.Slide.Element.DataLink.ITimecodeStatus=} [properties] Properties to set
                         */
                        function TimecodeStatus(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new TimecodeStatus instance using the specified properties.
                         * @function create
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeStatus
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ITimecodeStatus=} [properties] Properties to set
                         * @returns {rv.data.Slide.Element.DataLink.TimecodeStatus} TimecodeStatus instance
                         */
                        TimecodeStatus.create = function create(properties) {
                            return new TimecodeStatus(properties);
                        };

                        /**
                         * Encodes the specified TimecodeStatus message. Does not implicitly {@link rv.data.Slide.Element.DataLink.TimecodeStatus.verify|verify} messages.
                         * @function encode
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeStatus
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ITimecodeStatus} message TimecodeStatus message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        TimecodeStatus.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified TimecodeStatus message, length delimited. Does not implicitly {@link rv.data.Slide.Element.DataLink.TimecodeStatus.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeStatus
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.ITimecodeStatus} message TimecodeStatus message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        TimecodeStatus.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a TimecodeStatus message from the specified reader or buffer.
                         * @function decode
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeStatus
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {rv.data.Slide.Element.DataLink.TimecodeStatus} TimecodeStatus
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        TimecodeStatus.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.DataLink.TimecodeStatus();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a TimecodeStatus message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeStatus
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {rv.data.Slide.Element.DataLink.TimecodeStatus} TimecodeStatus
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        TimecodeStatus.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a TimecodeStatus message.
                         * @function verify
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeStatus
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        TimecodeStatus.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a TimecodeStatus message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeStatus
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {rv.data.Slide.Element.DataLink.TimecodeStatus} TimecodeStatus
                         */
                        TimecodeStatus.fromObject = function fromObject(object) {
                            if (object instanceof $root.rv.data.Slide.Element.DataLink.TimecodeStatus)
                                return object;
                            return new $root.rv.data.Slide.Element.DataLink.TimecodeStatus();
                        };

                        /**
                         * Creates a plain object from a TimecodeStatus message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeStatus
                         * @static
                         * @param {rv.data.Slide.Element.DataLink.TimecodeStatus} message TimecodeStatus
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        TimecodeStatus.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this TimecodeStatus to JSON.
                         * @function toJSON
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeStatus
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        TimecodeStatus.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for TimecodeStatus
                         * @function getTypeUrl
                         * @memberof rv.data.Slide.Element.DataLink.TimecodeStatus
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        TimecodeStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/rv.data.Slide.Element.DataLink.TimecodeStatus";
                        };

                        return TimecodeStatus;
                    })();

                    /**
                     * SlideSourceType enum.
                     * @name rv.data.Slide.Element.DataLink.SlideSourceType
                     * @enum {number}
                     * @property {number} SLIDE_SOURCE_TYPE_CURRENT_SLIDE=0 SLIDE_SOURCE_TYPE_CURRENT_SLIDE value
                     * @property {number} SLIDE_SOURCE_TYPE_NEXT_SLIDE=1 SLIDE_SOURCE_TYPE_NEXT_SLIDE value
                     */
                    DataLink.SlideSourceType = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "SLIDE_SOURCE_TYPE_CURRENT_SLIDE"] = 0;
                        values[valuesById[1] = "SLIDE_SOURCE_TYPE_NEXT_SLIDE"] = 1;
                        return values;
                    })();

                    /**
                     * GroupSourceType enum.
                     * @name rv.data.Slide.Element.DataLink.GroupSourceType
                     * @enum {number}
                     * @property {number} GROUP_SOURCE_TYPE_CURRENT_SLIDE=0 GROUP_SOURCE_TYPE_CURRENT_SLIDE value
                     * @property {number} GROUP_SOURCE_TYPE_NEXT_SLIDE=1 GROUP_SOURCE_TYPE_NEXT_SLIDE value
                     * @property {number} GROUP_SOURCE_TYPE_NEXT_GROUP=2 GROUP_SOURCE_TYPE_NEXT_GROUP value
                     */
                    DataLink.GroupSourceType = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "GROUP_SOURCE_TYPE_CURRENT_SLIDE"] = 0;
                        values[valuesById[1] = "GROUP_SOURCE_TYPE_NEXT_SLIDE"] = 1;
                        values[valuesById[2] = "GROUP_SOURCE_TYPE_NEXT_GROUP"] = 2;
                        return values;
                    })();

                    /**
                     * SlideLabelSource enum.
                     * @name rv.data.Slide.Element.DataLink.SlideLabelSource
                     * @enum {number}
                     * @property {number} SLIDE_LABEL_SOURCE_CURRENT_SLIDE=0 SLIDE_LABEL_SOURCE_CURRENT_SLIDE value
                     * @property {number} SLIDE_LABEL_SOURCE_NEXT_SLIDE=1 SLIDE_LABEL_SOURCE_NEXT_SLIDE value
                     */
                    DataLink.SlideLabelSource = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "SLIDE_LABEL_SOURCE_CURRENT_SLIDE"] = 0;
                        values[valuesById[1] = "SLIDE_LABEL_SOURCE_NEXT_SLIDE"] = 1;
                        return values;
                    })();

                    return DataLink;
                })();

                Element.TextScroller = (function() {

                    /**
                     * Properties of a TextScroller.
                     * @memberof rv.data.Slide.Element
                     * @interface ITextScroller
                     * @property {boolean|null} [shouldScroll] TextScroller shouldScroll
                     * @property {number|null} [scrollRate] TextScroller scrollRate
                     * @property {boolean|null} [shouldRepeat] TextScroller shouldRepeat
                     * @property {number|null} [repeatDistance] TextScroller repeatDistance
                     * @property {rv.data.Slide.Element.TextScroller.Direction|null} [scrollingDirection] TextScroller scrollingDirection
                     * @property {boolean|null} [startsOffScreen] TextScroller startsOffScreen
                     * @property {number|null} [fadeLeft] TextScroller fadeLeft
                     * @property {number|null} [fadeRight] TextScroller fadeRight
                     */

                    /**
                     * Constructs a new TextScroller.
                     * @memberof rv.data.Slide.Element
                     * @classdesc Represents a TextScroller.
                     * @implements ITextScroller
                     * @constructor
                     * @param {rv.data.Slide.Element.ITextScroller=} [properties] Properties to set
                     */
                    function TextScroller(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TextScroller shouldScroll.
                     * @member {boolean} shouldScroll
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @instance
                     */
                    TextScroller.prototype.shouldScroll = false;

                    /**
                     * TextScroller scrollRate.
                     * @member {number} scrollRate
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @instance
                     */
                    TextScroller.prototype.scrollRate = 0;

                    /**
                     * TextScroller shouldRepeat.
                     * @member {boolean} shouldRepeat
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @instance
                     */
                    TextScroller.prototype.shouldRepeat = false;

                    /**
                     * TextScroller repeatDistance.
                     * @member {number} repeatDistance
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @instance
                     */
                    TextScroller.prototype.repeatDistance = 0;

                    /**
                     * TextScroller scrollingDirection.
                     * @member {rv.data.Slide.Element.TextScroller.Direction} scrollingDirection
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @instance
                     */
                    TextScroller.prototype.scrollingDirection = 0;

                    /**
                     * TextScroller startsOffScreen.
                     * @member {boolean} startsOffScreen
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @instance
                     */
                    TextScroller.prototype.startsOffScreen = false;

                    /**
                     * TextScroller fadeLeft.
                     * @member {number} fadeLeft
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @instance
                     */
                    TextScroller.prototype.fadeLeft = 0;

                    /**
                     * TextScroller fadeRight.
                     * @member {number} fadeRight
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @instance
                     */
                    TextScroller.prototype.fadeRight = 0;

                    /**
                     * Creates a new TextScroller instance using the specified properties.
                     * @function create
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @static
                     * @param {rv.data.Slide.Element.ITextScroller=} [properties] Properties to set
                     * @returns {rv.data.Slide.Element.TextScroller} TextScroller instance
                     */
                    TextScroller.create = function create(properties) {
                        return new TextScroller(properties);
                    };

                    /**
                     * Encodes the specified TextScroller message. Does not implicitly {@link rv.data.Slide.Element.TextScroller.verify|verify} messages.
                     * @function encode
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @static
                     * @param {rv.data.Slide.Element.ITextScroller} message TextScroller message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TextScroller.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.shouldScroll != null && Object.hasOwnProperty.call(message, "shouldScroll"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.shouldScroll);
                        if (message.scrollRate != null && Object.hasOwnProperty.call(message, "scrollRate"))
                            writer.uint32(/* id 2, wireType 1 =*/17).double(message.scrollRate);
                        if (message.shouldRepeat != null && Object.hasOwnProperty.call(message, "shouldRepeat"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.shouldRepeat);
                        if (message.repeatDistance != null && Object.hasOwnProperty.call(message, "repeatDistance"))
                            writer.uint32(/* id 4, wireType 1 =*/33).double(message.repeatDistance);
                        if (message.scrollingDirection != null && Object.hasOwnProperty.call(message, "scrollingDirection"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.scrollingDirection);
                        if (message.startsOffScreen != null && Object.hasOwnProperty.call(message, "startsOffScreen"))
                            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.startsOffScreen);
                        if (message.fadeLeft != null && Object.hasOwnProperty.call(message, "fadeLeft"))
                            writer.uint32(/* id 7, wireType 1 =*/57).double(message.fadeLeft);
                        if (message.fadeRight != null && Object.hasOwnProperty.call(message, "fadeRight"))
                            writer.uint32(/* id 8, wireType 1 =*/65).double(message.fadeRight);
                        return writer;
                    };

                    /**
                     * Encodes the specified TextScroller message, length delimited. Does not implicitly {@link rv.data.Slide.Element.TextScroller.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @static
                     * @param {rv.data.Slide.Element.ITextScroller} message TextScroller message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TextScroller.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TextScroller message from the specified reader or buffer.
                     * @function decode
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {rv.data.Slide.Element.TextScroller} TextScroller
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TextScroller.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Slide.Element.TextScroller();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1: {
                                    message.shouldScroll = reader.bool();
                                    break;
                                }
                            case 2: {
                                    message.scrollRate = reader.double();
                                    break;
                                }
                            case 3: {
                                    message.shouldRepeat = reader.bool();
                                    break;
                                }
                            case 4: {
                                    message.repeatDistance = reader.double();
                                    break;
                                }
                            case 5: {
                                    message.scrollingDirection = reader.int32();
                                    break;
                                }
                            case 6: {
                                    message.startsOffScreen = reader.bool();
                                    break;
                                }
                            case 7: {
                                    message.fadeLeft = reader.double();
                                    break;
                                }
                            case 8: {
                                    message.fadeRight = reader.double();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TextScroller message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {rv.data.Slide.Element.TextScroller} TextScroller
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TextScroller.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TextScroller message.
                     * @function verify
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TextScroller.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.shouldScroll != null && message.hasOwnProperty("shouldScroll"))
                            if (typeof message.shouldScroll !== "boolean")
                                return "shouldScroll: boolean expected";
                        if (message.scrollRate != null && message.hasOwnProperty("scrollRate"))
                            if (typeof message.scrollRate !== "number")
                                return "scrollRate: number expected";
                        if (message.shouldRepeat != null && message.hasOwnProperty("shouldRepeat"))
                            if (typeof message.shouldRepeat !== "boolean")
                                return "shouldRepeat: boolean expected";
                        if (message.repeatDistance != null && message.hasOwnProperty("repeatDistance"))
                            if (typeof message.repeatDistance !== "number")
                                return "repeatDistance: number expected";
                        if (message.scrollingDirection != null && message.hasOwnProperty("scrollingDirection"))
                            switch (message.scrollingDirection) {
                            default:
                                return "scrollingDirection: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.startsOffScreen != null && message.hasOwnProperty("startsOffScreen"))
                            if (typeof message.startsOffScreen !== "boolean")
                                return "startsOffScreen: boolean expected";
                        if (message.fadeLeft != null && message.hasOwnProperty("fadeLeft"))
                            if (typeof message.fadeLeft !== "number")
                                return "fadeLeft: number expected";
                        if (message.fadeRight != null && message.hasOwnProperty("fadeRight"))
                            if (typeof message.fadeRight !== "number")
                                return "fadeRight: number expected";
                        return null;
                    };

                    /**
                     * Creates a TextScroller message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {rv.data.Slide.Element.TextScroller} TextScroller
                     */
                    TextScroller.fromObject = function fromObject(object) {
                        if (object instanceof $root.rv.data.Slide.Element.TextScroller)
                            return object;
                        let message = new $root.rv.data.Slide.Element.TextScroller();
                        if (object.shouldScroll != null)
                            message.shouldScroll = Boolean(object.shouldScroll);
                        if (object.scrollRate != null)
                            message.scrollRate = Number(object.scrollRate);
                        if (object.shouldRepeat != null)
                            message.shouldRepeat = Boolean(object.shouldRepeat);
                        if (object.repeatDistance != null)
                            message.repeatDistance = Number(object.repeatDistance);
                        switch (object.scrollingDirection) {
                        default:
                            if (typeof object.scrollingDirection === "number") {
                                message.scrollingDirection = object.scrollingDirection;
                                break;
                            }
                            break;
                        case "DIRECTION_LEFT":
                        case 0:
                            message.scrollingDirection = 0;
                            break;
                        case "DIRECTION_RIGHT":
                        case 1:
                            message.scrollingDirection = 1;
                            break;
                        case "DIRECTION_UP":
                        case 2:
                            message.scrollingDirection = 2;
                            break;
                        case "DIRECTION_DOWN":
                        case 3:
                            message.scrollingDirection = 3;
                            break;
                        }
                        if (object.startsOffScreen != null)
                            message.startsOffScreen = Boolean(object.startsOffScreen);
                        if (object.fadeLeft != null)
                            message.fadeLeft = Number(object.fadeLeft);
                        if (object.fadeRight != null)
                            message.fadeRight = Number(object.fadeRight);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TextScroller message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @static
                     * @param {rv.data.Slide.Element.TextScroller} message TextScroller
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TextScroller.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.shouldScroll = false;
                            object.scrollRate = 0;
                            object.shouldRepeat = false;
                            object.repeatDistance = 0;
                            object.scrollingDirection = options.enums === String ? "DIRECTION_LEFT" : 0;
                            object.startsOffScreen = false;
                            object.fadeLeft = 0;
                            object.fadeRight = 0;
                        }
                        if (message.shouldScroll != null && message.hasOwnProperty("shouldScroll"))
                            object.shouldScroll = message.shouldScroll;
                        if (message.scrollRate != null && message.hasOwnProperty("scrollRate"))
                            object.scrollRate = options.json && !isFinite(message.scrollRate) ? String(message.scrollRate) : message.scrollRate;
                        if (message.shouldRepeat != null && message.hasOwnProperty("shouldRepeat"))
                            object.shouldRepeat = message.shouldRepeat;
                        if (message.repeatDistance != null && message.hasOwnProperty("repeatDistance"))
                            object.repeatDistance = options.json && !isFinite(message.repeatDistance) ? String(message.repeatDistance) : message.repeatDistance;
                        if (message.scrollingDirection != null && message.hasOwnProperty("scrollingDirection"))
                            object.scrollingDirection = options.enums === String ? $root.rv.data.Slide.Element.TextScroller.Direction[message.scrollingDirection] === undefined ? message.scrollingDirection : $root.rv.data.Slide.Element.TextScroller.Direction[message.scrollingDirection] : message.scrollingDirection;
                        if (message.startsOffScreen != null && message.hasOwnProperty("startsOffScreen"))
                            object.startsOffScreen = message.startsOffScreen;
                        if (message.fadeLeft != null && message.hasOwnProperty("fadeLeft"))
                            object.fadeLeft = options.json && !isFinite(message.fadeLeft) ? String(message.fadeLeft) : message.fadeLeft;
                        if (message.fadeRight != null && message.hasOwnProperty("fadeRight"))
                            object.fadeRight = options.json && !isFinite(message.fadeRight) ? String(message.fadeRight) : message.fadeRight;
                        return object;
                    };

                    /**
                     * Converts this TextScroller to JSON.
                     * @function toJSON
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TextScroller.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for TextScroller
                     * @function getTypeUrl
                     * @memberof rv.data.Slide.Element.TextScroller
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    TextScroller.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/rv.data.Slide.Element.TextScroller";
                    };

                    /**
                     * Direction enum.
                     * @name rv.data.Slide.Element.TextScroller.Direction
                     * @enum {number}
                     * @property {number} DIRECTION_LEFT=0 DIRECTION_LEFT value
                     * @property {number} DIRECTION_RIGHT=1 DIRECTION_RIGHT value
                     * @property {number} DIRECTION_UP=2 DIRECTION_UP value
                     * @property {number} DIRECTION_DOWN=3 DIRECTION_DOWN value
                     */
                    TextScroller.Direction = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "DIRECTION_LEFT"] = 0;
                        values[valuesById[1] = "DIRECTION_RIGHT"] = 1;
                        values[valuesById[2] = "DIRECTION_UP"] = 2;
                        values[valuesById[3] = "DIRECTION_DOWN"] = 3;
                        return values;
                    })();

                    return TextScroller;
                })();

                /**
                 * TextRevealType enum.
                 * @name rv.data.Slide.Element.TextRevealType
                 * @enum {number}
                 * @property {number} TEXT_REVEAL_TYPE_NONE=0 TEXT_REVEAL_TYPE_NONE value
                 * @property {number} TEXT_REVEAL_TYPE_BULLET=1 TEXT_REVEAL_TYPE_BULLET value
                 * @property {number} TEXT_REVEAL_TYPE_UNDERLINE=2 TEXT_REVEAL_TYPE_UNDERLINE value
                 */
                Element.TextRevealType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "TEXT_REVEAL_TYPE_NONE"] = 0;
                    values[valuesById[1] = "TEXT_REVEAL_TYPE_BULLET"] = 1;
                    values[valuesById[2] = "TEXT_REVEAL_TYPE_UNDERLINE"] = 2;
                    return values;
                })();

                /**
                 * Info enum.
                 * @name rv.data.Slide.Element.Info
                 * @enum {number}
                 * @property {number} INFO_NONE=0 INFO_NONE value
                 * @property {number} INFO_IS_TEMPLATE_ELEMENT=1 INFO_IS_TEMPLATE_ELEMENT value
                 * @property {number} INFO_IS_TEXT_ELEMENT=2 INFO_IS_TEXT_ELEMENT value
                 * @property {number} INFO_IS_TEXT_TICKER=4 INFO_IS_TEXT_TICKER value
                 */
                Element.Info = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "INFO_NONE"] = 0;
                    values[valuesById[1] = "INFO_IS_TEMPLATE_ELEMENT"] = 1;
                    values[valuesById[2] = "INFO_IS_TEXT_ELEMENT"] = 2;
                    values[valuesById[4] = "INFO_IS_TEXT_TICKER"] = 4;
                    return values;
                })();

                return Element;
            })();

            return Slide;
        })();

        data.AlignmentGuide = (function() {

            /**
             * Properties of an AlignmentGuide.
             * @memberof rv.data
             * @interface IAlignmentGuide
             * @property {rv.data.IUUID|null} [uuid] AlignmentGuide uuid
             * @property {rv.data.AlignmentGuide.GuidelineOrientation|null} [orientation] AlignmentGuide orientation
             * @property {number|null} [location] AlignmentGuide location
             */

            /**
             * Constructs a new AlignmentGuide.
             * @memberof rv.data
             * @classdesc Represents an AlignmentGuide.
             * @implements IAlignmentGuide
             * @constructor
             * @param {rv.data.IAlignmentGuide=} [properties] Properties to set
             */
            function AlignmentGuide(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlignmentGuide uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.AlignmentGuide
             * @instance
             */
            AlignmentGuide.prototype.uuid = null;

            /**
             * AlignmentGuide orientation.
             * @member {rv.data.AlignmentGuide.GuidelineOrientation} orientation
             * @memberof rv.data.AlignmentGuide
             * @instance
             */
            AlignmentGuide.prototype.orientation = 0;

            /**
             * AlignmentGuide location.
             * @member {number} location
             * @memberof rv.data.AlignmentGuide
             * @instance
             */
            AlignmentGuide.prototype.location = 0;

            /**
             * Creates a new AlignmentGuide instance using the specified properties.
             * @function create
             * @memberof rv.data.AlignmentGuide
             * @static
             * @param {rv.data.IAlignmentGuide=} [properties] Properties to set
             * @returns {rv.data.AlignmentGuide} AlignmentGuide instance
             */
            AlignmentGuide.create = function create(properties) {
                return new AlignmentGuide(properties);
            };

            /**
             * Encodes the specified AlignmentGuide message. Does not implicitly {@link rv.data.AlignmentGuide.verify|verify} messages.
             * @function encode
             * @memberof rv.data.AlignmentGuide
             * @static
             * @param {rv.data.IAlignmentGuide} message AlignmentGuide message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlignmentGuide.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.orientation);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.location);
                return writer;
            };

            /**
             * Encodes the specified AlignmentGuide message, length delimited. Does not implicitly {@link rv.data.AlignmentGuide.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.AlignmentGuide
             * @static
             * @param {rv.data.IAlignmentGuide} message AlignmentGuide message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlignmentGuide.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlignmentGuide message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.AlignmentGuide
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.AlignmentGuide} AlignmentGuide
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlignmentGuide.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.AlignmentGuide();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.orientation = reader.int32();
                            break;
                        }
                    case 3: {
                            message.location = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlignmentGuide message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.AlignmentGuide
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.AlignmentGuide} AlignmentGuide
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlignmentGuide.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlignmentGuide message.
             * @function verify
             * @memberof rv.data.AlignmentGuide
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlignmentGuide.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                if (message.orientation != null && message.hasOwnProperty("orientation"))
                    switch (message.orientation) {
                    default:
                        return "orientation: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.location != null && message.hasOwnProperty("location"))
                    if (typeof message.location !== "number")
                        return "location: number expected";
                return null;
            };

            /**
             * Creates an AlignmentGuide message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.AlignmentGuide
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.AlignmentGuide} AlignmentGuide
             */
            AlignmentGuide.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.AlignmentGuide)
                    return object;
                let message = new $root.rv.data.AlignmentGuide();
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.AlignmentGuide.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                switch (object.orientation) {
                default:
                    if (typeof object.orientation === "number") {
                        message.orientation = object.orientation;
                        break;
                    }
                    break;
                case "GUIDELINE_ORIENTATION_HORIZONTAL":
                case 0:
                    message.orientation = 0;
                    break;
                case "GUIDELINE_ORIENTATION_VERTICAL":
                case 1:
                    message.orientation = 1;
                    break;
                }
                if (object.location != null)
                    message.location = Number(object.location);
                return message;
            };

            /**
             * Creates a plain object from an AlignmentGuide message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.AlignmentGuide
             * @static
             * @param {rv.data.AlignmentGuide} message AlignmentGuide
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlignmentGuide.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uuid = null;
                    object.orientation = options.enums === String ? "GUIDELINE_ORIENTATION_HORIZONTAL" : 0;
                    object.location = 0;
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                if (message.orientation != null && message.hasOwnProperty("orientation"))
                    object.orientation = options.enums === String ? $root.rv.data.AlignmentGuide.GuidelineOrientation[message.orientation] === undefined ? message.orientation : $root.rv.data.AlignmentGuide.GuidelineOrientation[message.orientation] : message.orientation;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = options.json && !isFinite(message.location) ? String(message.location) : message.location;
                return object;
            };

            /**
             * Converts this AlignmentGuide to JSON.
             * @function toJSON
             * @memberof rv.data.AlignmentGuide
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlignmentGuide.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AlignmentGuide
             * @function getTypeUrl
             * @memberof rv.data.AlignmentGuide
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AlignmentGuide.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.AlignmentGuide";
            };

            /**
             * GuidelineOrientation enum.
             * @name rv.data.AlignmentGuide.GuidelineOrientation
             * @enum {number}
             * @property {number} GUIDELINE_ORIENTATION_HORIZONTAL=0 GUIDELINE_ORIENTATION_HORIZONTAL value
             * @property {number} GUIDELINE_ORIENTATION_VERTICAL=1 GUIDELINE_ORIENTATION_VERTICAL value
             */
            AlignmentGuide.GuidelineOrientation = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "GUIDELINE_ORIENTATION_HORIZONTAL"] = 0;
                values[valuesById[1] = "GUIDELINE_ORIENTATION_VERTICAL"] = 1;
                return values;
            })();

            return AlignmentGuide;
        })();

        data.PresentationSlide = (function() {

            /**
             * Properties of a PresentationSlide.
             * @memberof rv.data
             * @interface IPresentationSlide
             * @property {rv.data.ISlide|null} [baseSlide] PresentationSlide baseSlide
             * @property {rv.data.PresentationSlide.INotes|null} [notes] PresentationSlide notes
             * @property {Array.<rv.data.IAlignmentGuide>|null} [templateGuidelines] PresentationSlide templateGuidelines
             * @property {rv.data.IURL|null} [chordChart] PresentationSlide chordChart
             * @property {rv.data.ITransition|null} [transition] PresentationSlide transition
             */

            /**
             * Constructs a new PresentationSlide.
             * @memberof rv.data
             * @classdesc Represents a PresentationSlide.
             * @implements IPresentationSlide
             * @constructor
             * @param {rv.data.IPresentationSlide=} [properties] Properties to set
             */
            function PresentationSlide(properties) {
                this.templateGuidelines = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PresentationSlide baseSlide.
             * @member {rv.data.ISlide|null|undefined} baseSlide
             * @memberof rv.data.PresentationSlide
             * @instance
             */
            PresentationSlide.prototype.baseSlide = null;

            /**
             * PresentationSlide notes.
             * @member {rv.data.PresentationSlide.INotes|null|undefined} notes
             * @memberof rv.data.PresentationSlide
             * @instance
             */
            PresentationSlide.prototype.notes = null;

            /**
             * PresentationSlide templateGuidelines.
             * @member {Array.<rv.data.IAlignmentGuide>} templateGuidelines
             * @memberof rv.data.PresentationSlide
             * @instance
             */
            PresentationSlide.prototype.templateGuidelines = $util.emptyArray;

            /**
             * PresentationSlide chordChart.
             * @member {rv.data.IURL|null|undefined} chordChart
             * @memberof rv.data.PresentationSlide
             * @instance
             */
            PresentationSlide.prototype.chordChart = null;

            /**
             * PresentationSlide transition.
             * @member {rv.data.ITransition|null|undefined} transition
             * @memberof rv.data.PresentationSlide
             * @instance
             */
            PresentationSlide.prototype.transition = null;

            /**
             * Creates a new PresentationSlide instance using the specified properties.
             * @function create
             * @memberof rv.data.PresentationSlide
             * @static
             * @param {rv.data.IPresentationSlide=} [properties] Properties to set
             * @returns {rv.data.PresentationSlide} PresentationSlide instance
             */
            PresentationSlide.create = function create(properties) {
                return new PresentationSlide(properties);
            };

            /**
             * Encodes the specified PresentationSlide message. Does not implicitly {@link rv.data.PresentationSlide.verify|verify} messages.
             * @function encode
             * @memberof rv.data.PresentationSlide
             * @static
             * @param {rv.data.IPresentationSlide} message PresentationSlide message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PresentationSlide.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.baseSlide != null && Object.hasOwnProperty.call(message, "baseSlide"))
                    $root.rv.data.Slide.encode(message.baseSlide, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.notes != null && Object.hasOwnProperty.call(message, "notes"))
                    $root.rv.data.PresentationSlide.Notes.encode(message.notes, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.templateGuidelines != null && message.templateGuidelines.length)
                    for (let i = 0; i < message.templateGuidelines.length; ++i)
                        $root.rv.data.AlignmentGuide.encode(message.templateGuidelines[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.chordChart != null && Object.hasOwnProperty.call(message, "chordChart"))
                    $root.rv.data.URL.encode(message.chordChart, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.transition != null && Object.hasOwnProperty.call(message, "transition"))
                    $root.rv.data.Transition.encode(message.transition, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PresentationSlide message, length delimited. Does not implicitly {@link rv.data.PresentationSlide.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.PresentationSlide
             * @static
             * @param {rv.data.IPresentationSlide} message PresentationSlide message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PresentationSlide.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PresentationSlide message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.PresentationSlide
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.PresentationSlide} PresentationSlide
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PresentationSlide.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.PresentationSlide();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.baseSlide = $root.rv.data.Slide.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.notes = $root.rv.data.PresentationSlide.Notes.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            if (!(message.templateGuidelines && message.templateGuidelines.length))
                                message.templateGuidelines = [];
                            message.templateGuidelines.push($root.rv.data.AlignmentGuide.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            message.chordChart = $root.rv.data.URL.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.transition = $root.rv.data.Transition.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PresentationSlide message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.PresentationSlide
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.PresentationSlide} PresentationSlide
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PresentationSlide.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PresentationSlide message.
             * @function verify
             * @memberof rv.data.PresentationSlide
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PresentationSlide.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.baseSlide != null && message.hasOwnProperty("baseSlide")) {
                    let error = $root.rv.data.Slide.verify(message.baseSlide);
                    if (error)
                        return "baseSlide." + error;
                }
                if (message.notes != null && message.hasOwnProperty("notes")) {
                    let error = $root.rv.data.PresentationSlide.Notes.verify(message.notes);
                    if (error)
                        return "notes." + error;
                }
                if (message.templateGuidelines != null && message.hasOwnProperty("templateGuidelines")) {
                    if (!Array.isArray(message.templateGuidelines))
                        return "templateGuidelines: array expected";
                    for (let i = 0; i < message.templateGuidelines.length; ++i) {
                        let error = $root.rv.data.AlignmentGuide.verify(message.templateGuidelines[i]);
                        if (error)
                            return "templateGuidelines." + error;
                    }
                }
                if (message.chordChart != null && message.hasOwnProperty("chordChart")) {
                    let error = $root.rv.data.URL.verify(message.chordChart);
                    if (error)
                        return "chordChart." + error;
                }
                if (message.transition != null && message.hasOwnProperty("transition")) {
                    let error = $root.rv.data.Transition.verify(message.transition);
                    if (error)
                        return "transition." + error;
                }
                return null;
            };

            /**
             * Creates a PresentationSlide message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.PresentationSlide
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.PresentationSlide} PresentationSlide
             */
            PresentationSlide.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.PresentationSlide)
                    return object;
                let message = new $root.rv.data.PresentationSlide();
                if (object.baseSlide != null) {
                    if (typeof object.baseSlide !== "object")
                        throw TypeError(".rv.data.PresentationSlide.baseSlide: object expected");
                    message.baseSlide = $root.rv.data.Slide.fromObject(object.baseSlide);
                }
                if (object.notes != null) {
                    if (typeof object.notes !== "object")
                        throw TypeError(".rv.data.PresentationSlide.notes: object expected");
                    message.notes = $root.rv.data.PresentationSlide.Notes.fromObject(object.notes);
                }
                if (object.templateGuidelines) {
                    if (!Array.isArray(object.templateGuidelines))
                        throw TypeError(".rv.data.PresentationSlide.templateGuidelines: array expected");
                    message.templateGuidelines = [];
                    for (let i = 0; i < object.templateGuidelines.length; ++i) {
                        if (typeof object.templateGuidelines[i] !== "object")
                            throw TypeError(".rv.data.PresentationSlide.templateGuidelines: object expected");
                        message.templateGuidelines[i] = $root.rv.data.AlignmentGuide.fromObject(object.templateGuidelines[i]);
                    }
                }
                if (object.chordChart != null) {
                    if (typeof object.chordChart !== "object")
                        throw TypeError(".rv.data.PresentationSlide.chordChart: object expected");
                    message.chordChart = $root.rv.data.URL.fromObject(object.chordChart);
                }
                if (object.transition != null) {
                    if (typeof object.transition !== "object")
                        throw TypeError(".rv.data.PresentationSlide.transition: object expected");
                    message.transition = $root.rv.data.Transition.fromObject(object.transition);
                }
                return message;
            };

            /**
             * Creates a plain object from a PresentationSlide message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.PresentationSlide
             * @static
             * @param {rv.data.PresentationSlide} message PresentationSlide
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PresentationSlide.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.templateGuidelines = [];
                if (options.defaults) {
                    object.baseSlide = null;
                    object.notes = null;
                    object.chordChart = null;
                    object.transition = null;
                }
                if (message.baseSlide != null && message.hasOwnProperty("baseSlide"))
                    object.baseSlide = $root.rv.data.Slide.toObject(message.baseSlide, options);
                if (message.notes != null && message.hasOwnProperty("notes"))
                    object.notes = $root.rv.data.PresentationSlide.Notes.toObject(message.notes, options);
                if (message.templateGuidelines && message.templateGuidelines.length) {
                    object.templateGuidelines = [];
                    for (let j = 0; j < message.templateGuidelines.length; ++j)
                        object.templateGuidelines[j] = $root.rv.data.AlignmentGuide.toObject(message.templateGuidelines[j], options);
                }
                if (message.chordChart != null && message.hasOwnProperty("chordChart"))
                    object.chordChart = $root.rv.data.URL.toObject(message.chordChart, options);
                if (message.transition != null && message.hasOwnProperty("transition"))
                    object.transition = $root.rv.data.Transition.toObject(message.transition, options);
                return object;
            };

            /**
             * Converts this PresentationSlide to JSON.
             * @function toJSON
             * @memberof rv.data.PresentationSlide
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PresentationSlide.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PresentationSlide
             * @function getTypeUrl
             * @memberof rv.data.PresentationSlide
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PresentationSlide.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.PresentationSlide";
            };

            PresentationSlide.Notes = (function() {

                /**
                 * Properties of a Notes.
                 * @memberof rv.data.PresentationSlide
                 * @interface INotes
                 * @property {Uint8Array|null} [rtfData] Notes rtfData
                 * @property {rv.data.Graphics.Text.IAttributes|null} [attributes] Notes attributes
                 */

                /**
                 * Constructs a new Notes.
                 * @memberof rv.data.PresentationSlide
                 * @classdesc Represents a Notes.
                 * @implements INotes
                 * @constructor
                 * @param {rv.data.PresentationSlide.INotes=} [properties] Properties to set
                 */
                function Notes(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Notes rtfData.
                 * @member {Uint8Array} rtfData
                 * @memberof rv.data.PresentationSlide.Notes
                 * @instance
                 */
                Notes.prototype.rtfData = $util.newBuffer([]);

                /**
                 * Notes attributes.
                 * @member {rv.data.Graphics.Text.IAttributes|null|undefined} attributes
                 * @memberof rv.data.PresentationSlide.Notes
                 * @instance
                 */
                Notes.prototype.attributes = null;

                /**
                 * Creates a new Notes instance using the specified properties.
                 * @function create
                 * @memberof rv.data.PresentationSlide.Notes
                 * @static
                 * @param {rv.data.PresentationSlide.INotes=} [properties] Properties to set
                 * @returns {rv.data.PresentationSlide.Notes} Notes instance
                 */
                Notes.create = function create(properties) {
                    return new Notes(properties);
                };

                /**
                 * Encodes the specified Notes message. Does not implicitly {@link rv.data.PresentationSlide.Notes.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.PresentationSlide.Notes
                 * @static
                 * @param {rv.data.PresentationSlide.INotes} message Notes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Notes.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.rtfData != null && Object.hasOwnProperty.call(message, "rtfData"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.rtfData);
                    if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                        $root.rv.data.Graphics.Text.Attributes.encode(message.attributes, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Notes message, length delimited. Does not implicitly {@link rv.data.PresentationSlide.Notes.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.PresentationSlide.Notes
                 * @static
                 * @param {rv.data.PresentationSlide.INotes} message Notes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Notes.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Notes message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.PresentationSlide.Notes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.PresentationSlide.Notes} Notes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Notes.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.PresentationSlide.Notes();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.rtfData = reader.bytes();
                                break;
                            }
                        case 2: {
                                message.attributes = $root.rv.data.Graphics.Text.Attributes.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Notes message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.PresentationSlide.Notes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.PresentationSlide.Notes} Notes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Notes.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Notes message.
                 * @function verify
                 * @memberof rv.data.PresentationSlide.Notes
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Notes.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.rtfData != null && message.hasOwnProperty("rtfData"))
                        if (!(message.rtfData && typeof message.rtfData.length === "number" || $util.isString(message.rtfData)))
                            return "rtfData: buffer expected";
                    if (message.attributes != null && message.hasOwnProperty("attributes")) {
                        let error = $root.rv.data.Graphics.Text.Attributes.verify(message.attributes);
                        if (error)
                            return "attributes." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Notes message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.PresentationSlide.Notes
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.PresentationSlide.Notes} Notes
                 */
                Notes.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.PresentationSlide.Notes)
                        return object;
                    let message = new $root.rv.data.PresentationSlide.Notes();
                    if (object.rtfData != null)
                        if (typeof object.rtfData === "string")
                            $util.base64.decode(object.rtfData, message.rtfData = $util.newBuffer($util.base64.length(object.rtfData)), 0);
                        else if (object.rtfData.length >= 0)
                            message.rtfData = object.rtfData;
                    if (object.attributes != null) {
                        if (typeof object.attributes !== "object")
                            throw TypeError(".rv.data.PresentationSlide.Notes.attributes: object expected");
                        message.attributes = $root.rv.data.Graphics.Text.Attributes.fromObject(object.attributes);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Notes message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.PresentationSlide.Notes
                 * @static
                 * @param {rv.data.PresentationSlide.Notes} message Notes
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Notes.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.rtfData = "";
                        else {
                            object.rtfData = [];
                            if (options.bytes !== Array)
                                object.rtfData = $util.newBuffer(object.rtfData);
                        }
                        object.attributes = null;
                    }
                    if (message.rtfData != null && message.hasOwnProperty("rtfData"))
                        object.rtfData = options.bytes === String ? $util.base64.encode(message.rtfData, 0, message.rtfData.length) : options.bytes === Array ? Array.prototype.slice.call(message.rtfData) : message.rtfData;
                    if (message.attributes != null && message.hasOwnProperty("attributes"))
                        object.attributes = $root.rv.data.Graphics.Text.Attributes.toObject(message.attributes, options);
                    return object;
                };

                /**
                 * Converts this Notes to JSON.
                 * @function toJSON
                 * @memberof rv.data.PresentationSlide.Notes
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Notes.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Notes
                 * @function getTypeUrl
                 * @memberof rv.data.PresentationSlide.Notes
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Notes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.PresentationSlide.Notes";
                };

                return Notes;
            })();

            return PresentationSlide;
        })();

        data.Stage = (function() {

            /**
             * Properties of a Stage.
             * @memberof rv.data
             * @interface IStage
             */

            /**
             * Constructs a new Stage.
             * @memberof rv.data
             * @classdesc Represents a Stage.
             * @implements IStage
             * @constructor
             * @param {rv.data.IStage=} [properties] Properties to set
             */
            function Stage(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Stage instance using the specified properties.
             * @function create
             * @memberof rv.data.Stage
             * @static
             * @param {rv.data.IStage=} [properties] Properties to set
             * @returns {rv.data.Stage} Stage instance
             */
            Stage.create = function create(properties) {
                return new Stage(properties);
            };

            /**
             * Encodes the specified Stage message. Does not implicitly {@link rv.data.Stage.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Stage
             * @static
             * @param {rv.data.IStage} message Stage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Stage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Stage message, length delimited. Does not implicitly {@link rv.data.Stage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Stage
             * @static
             * @param {rv.data.IStage} message Stage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Stage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Stage message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Stage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Stage} Stage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Stage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Stage();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Stage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Stage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Stage} Stage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Stage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Stage message.
             * @function verify
             * @memberof rv.data.Stage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Stage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Stage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Stage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Stage} Stage
             */
            Stage.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Stage)
                    return object;
                return new $root.rv.data.Stage();
            };

            /**
             * Creates a plain object from a Stage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Stage
             * @static
             * @param {rv.data.Stage} message Stage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Stage.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Stage to JSON.
             * @function toJSON
             * @memberof rv.data.Stage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Stage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Stage
             * @function getTypeUrl
             * @memberof rv.data.Stage
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Stage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Stage";
            };

            Stage.Layout = (function() {

                /**
                 * Properties of a Layout.
                 * @memberof rv.data.Stage
                 * @interface ILayout
                 * @property {rv.data.IUUID|null} [uuid] Layout uuid
                 * @property {string|null} [name] Layout name
                 * @property {rv.data.ISlide|null} [slide] Layout slide
                 */

                /**
                 * Constructs a new Layout.
                 * @memberof rv.data.Stage
                 * @classdesc Represents a Layout.
                 * @implements ILayout
                 * @constructor
                 * @param {rv.data.Stage.ILayout=} [properties] Properties to set
                 */
                function Layout(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Layout uuid.
                 * @member {rv.data.IUUID|null|undefined} uuid
                 * @memberof rv.data.Stage.Layout
                 * @instance
                 */
                Layout.prototype.uuid = null;

                /**
                 * Layout name.
                 * @member {string} name
                 * @memberof rv.data.Stage.Layout
                 * @instance
                 */
                Layout.prototype.name = "";

                /**
                 * Layout slide.
                 * @member {rv.data.ISlide|null|undefined} slide
                 * @memberof rv.data.Stage.Layout
                 * @instance
                 */
                Layout.prototype.slide = null;

                /**
                 * Creates a new Layout instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Stage.Layout
                 * @static
                 * @param {rv.data.Stage.ILayout=} [properties] Properties to set
                 * @returns {rv.data.Stage.Layout} Layout instance
                 */
                Layout.create = function create(properties) {
                    return new Layout(properties);
                };

                /**
                 * Encodes the specified Layout message. Does not implicitly {@link rv.data.Stage.Layout.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Stage.Layout
                 * @static
                 * @param {rv.data.Stage.ILayout} message Layout message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Layout.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                        $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.slide != null && Object.hasOwnProperty.call(message, "slide"))
                        $root.rv.data.Slide.encode(message.slide, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Layout message, length delimited. Does not implicitly {@link rv.data.Stage.Layout.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Stage.Layout
                 * @static
                 * @param {rv.data.Stage.ILayout} message Layout message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Layout.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Layout message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Stage.Layout
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Stage.Layout} Layout
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Layout.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Stage.Layout();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.name = reader.string();
                                break;
                            }
                        case 3: {
                                message.slide = $root.rv.data.Slide.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Layout message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Stage.Layout
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Stage.Layout} Layout
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Layout.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Layout message.
                 * @function verify
                 * @memberof rv.data.Stage.Layout
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Layout.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uuid != null && message.hasOwnProperty("uuid")) {
                        let error = $root.rv.data.UUID.verify(message.uuid);
                        if (error)
                            return "uuid." + error;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.slide != null && message.hasOwnProperty("slide")) {
                        let error = $root.rv.data.Slide.verify(message.slide);
                        if (error)
                            return "slide." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Layout message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Stage.Layout
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Stage.Layout} Layout
                 */
                Layout.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Stage.Layout)
                        return object;
                    let message = new $root.rv.data.Stage.Layout();
                    if (object.uuid != null) {
                        if (typeof object.uuid !== "object")
                            throw TypeError(".rv.data.Stage.Layout.uuid: object expected");
                        message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.slide != null) {
                        if (typeof object.slide !== "object")
                            throw TypeError(".rv.data.Stage.Layout.slide: object expected");
                        message.slide = $root.rv.data.Slide.fromObject(object.slide);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Layout message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Stage.Layout
                 * @static
                 * @param {rv.data.Stage.Layout} message Layout
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Layout.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.uuid = null;
                        object.name = "";
                        object.slide = null;
                    }
                    if (message.uuid != null && message.hasOwnProperty("uuid"))
                        object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.slide != null && message.hasOwnProperty("slide"))
                        object.slide = $root.rv.data.Slide.toObject(message.slide, options);
                    return object;
                };

                /**
                 * Converts this Layout to JSON.
                 * @function toJSON
                 * @memberof rv.data.Stage.Layout
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Layout.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Layout
                 * @function getTypeUrl
                 * @memberof rv.data.Stage.Layout
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Layout.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Stage.Layout";
                };

                return Layout;
            })();

            Stage.Document = (function() {

                /**
                 * Properties of a Document.
                 * @memberof rv.data.Stage
                 * @interface IDocument
                 * @property {rv.data.IApplicationInfo|null} [applicationInfo] Document applicationInfo
                 * @property {Array.<rv.data.Stage.ILayout>|null} [layouts] Document layouts
                 */

                /**
                 * Constructs a new Document.
                 * @memberof rv.data.Stage
                 * @classdesc Represents a Document.
                 * @implements IDocument
                 * @constructor
                 * @param {rv.data.Stage.IDocument=} [properties] Properties to set
                 */
                function Document(properties) {
                    this.layouts = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Document applicationInfo.
                 * @member {rv.data.IApplicationInfo|null|undefined} applicationInfo
                 * @memberof rv.data.Stage.Document
                 * @instance
                 */
                Document.prototype.applicationInfo = null;

                /**
                 * Document layouts.
                 * @member {Array.<rv.data.Stage.ILayout>} layouts
                 * @memberof rv.data.Stage.Document
                 * @instance
                 */
                Document.prototype.layouts = $util.emptyArray;

                /**
                 * Creates a new Document instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Stage.Document
                 * @static
                 * @param {rv.data.Stage.IDocument=} [properties] Properties to set
                 * @returns {rv.data.Stage.Document} Document instance
                 */
                Document.create = function create(properties) {
                    return new Document(properties);
                };

                /**
                 * Encodes the specified Document message. Does not implicitly {@link rv.data.Stage.Document.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Stage.Document
                 * @static
                 * @param {rv.data.Stage.IDocument} message Document message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Document.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.applicationInfo != null && Object.hasOwnProperty.call(message, "applicationInfo"))
                        $root.rv.data.ApplicationInfo.encode(message.applicationInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.layouts != null && message.layouts.length)
                        for (let i = 0; i < message.layouts.length; ++i)
                            $root.rv.data.Stage.Layout.encode(message.layouts[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Document message, length delimited. Does not implicitly {@link rv.data.Stage.Document.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Stage.Document
                 * @static
                 * @param {rv.data.Stage.IDocument} message Document message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Document.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Document message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Stage.Document
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Stage.Document} Document
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Document.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Stage.Document();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.applicationInfo = $root.rv.data.ApplicationInfo.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                if (!(message.layouts && message.layouts.length))
                                    message.layouts = [];
                                message.layouts.push($root.rv.data.Stage.Layout.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Document message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Stage.Document
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Stage.Document} Document
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Document.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Document message.
                 * @function verify
                 * @memberof rv.data.Stage.Document
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Document.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.applicationInfo != null && message.hasOwnProperty("applicationInfo")) {
                        let error = $root.rv.data.ApplicationInfo.verify(message.applicationInfo);
                        if (error)
                            return "applicationInfo." + error;
                    }
                    if (message.layouts != null && message.hasOwnProperty("layouts")) {
                        if (!Array.isArray(message.layouts))
                            return "layouts: array expected";
                        for (let i = 0; i < message.layouts.length; ++i) {
                            let error = $root.rv.data.Stage.Layout.verify(message.layouts[i]);
                            if (error)
                                return "layouts." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Document message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Stage.Document
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Stage.Document} Document
                 */
                Document.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Stage.Document)
                        return object;
                    let message = new $root.rv.data.Stage.Document();
                    if (object.applicationInfo != null) {
                        if (typeof object.applicationInfo !== "object")
                            throw TypeError(".rv.data.Stage.Document.applicationInfo: object expected");
                        message.applicationInfo = $root.rv.data.ApplicationInfo.fromObject(object.applicationInfo);
                    }
                    if (object.layouts) {
                        if (!Array.isArray(object.layouts))
                            throw TypeError(".rv.data.Stage.Document.layouts: array expected");
                        message.layouts = [];
                        for (let i = 0; i < object.layouts.length; ++i) {
                            if (typeof object.layouts[i] !== "object")
                                throw TypeError(".rv.data.Stage.Document.layouts: object expected");
                            message.layouts[i] = $root.rv.data.Stage.Layout.fromObject(object.layouts[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Document message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Stage.Document
                 * @static
                 * @param {rv.data.Stage.Document} message Document
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Document.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.layouts = [];
                    if (options.defaults)
                        object.applicationInfo = null;
                    if (message.applicationInfo != null && message.hasOwnProperty("applicationInfo"))
                        object.applicationInfo = $root.rv.data.ApplicationInfo.toObject(message.applicationInfo, options);
                    if (message.layouts && message.layouts.length) {
                        object.layouts = [];
                        for (let j = 0; j < message.layouts.length; ++j)
                            object.layouts[j] = $root.rv.data.Stage.Layout.toObject(message.layouts[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Document to JSON.
                 * @function toJSON
                 * @memberof rv.data.Stage.Document
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Document.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Document
                 * @function getTypeUrl
                 * @memberof rv.data.Stage.Document
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Document.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Stage.Document";
                };

                return Document;
            })();

            Stage.ScreenAssignment = (function() {

                /**
                 * Properties of a ScreenAssignment.
                 * @memberof rv.data.Stage
                 * @interface IScreenAssignment
                 * @property {rv.data.ICollectionElementType|null} [screen] ScreenAssignment screen
                 * @property {rv.data.ICollectionElementType|null} [layout] ScreenAssignment layout
                 */

                /**
                 * Constructs a new ScreenAssignment.
                 * @memberof rv.data.Stage
                 * @classdesc Represents a ScreenAssignment.
                 * @implements IScreenAssignment
                 * @constructor
                 * @param {rv.data.Stage.IScreenAssignment=} [properties] Properties to set
                 */
                function ScreenAssignment(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ScreenAssignment screen.
                 * @member {rv.data.ICollectionElementType|null|undefined} screen
                 * @memberof rv.data.Stage.ScreenAssignment
                 * @instance
                 */
                ScreenAssignment.prototype.screen = null;

                /**
                 * ScreenAssignment layout.
                 * @member {rv.data.ICollectionElementType|null|undefined} layout
                 * @memberof rv.data.Stage.ScreenAssignment
                 * @instance
                 */
                ScreenAssignment.prototype.layout = null;

                /**
                 * Creates a new ScreenAssignment instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Stage.ScreenAssignment
                 * @static
                 * @param {rv.data.Stage.IScreenAssignment=} [properties] Properties to set
                 * @returns {rv.data.Stage.ScreenAssignment} ScreenAssignment instance
                 */
                ScreenAssignment.create = function create(properties) {
                    return new ScreenAssignment(properties);
                };

                /**
                 * Encodes the specified ScreenAssignment message. Does not implicitly {@link rv.data.Stage.ScreenAssignment.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Stage.ScreenAssignment
                 * @static
                 * @param {rv.data.Stage.IScreenAssignment} message ScreenAssignment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ScreenAssignment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.screen != null && Object.hasOwnProperty.call(message, "screen"))
                        $root.rv.data.CollectionElementType.encode(message.screen, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.layout != null && Object.hasOwnProperty.call(message, "layout"))
                        $root.rv.data.CollectionElementType.encode(message.layout, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ScreenAssignment message, length delimited. Does not implicitly {@link rv.data.Stage.ScreenAssignment.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Stage.ScreenAssignment
                 * @static
                 * @param {rv.data.Stage.IScreenAssignment} message ScreenAssignment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ScreenAssignment.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ScreenAssignment message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Stage.ScreenAssignment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Stage.ScreenAssignment} ScreenAssignment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ScreenAssignment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Stage.ScreenAssignment();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.screen = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.layout = $root.rv.data.CollectionElementType.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ScreenAssignment message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Stage.ScreenAssignment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Stage.ScreenAssignment} ScreenAssignment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ScreenAssignment.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ScreenAssignment message.
                 * @function verify
                 * @memberof rv.data.Stage.ScreenAssignment
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ScreenAssignment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.screen != null && message.hasOwnProperty("screen")) {
                        let error = $root.rv.data.CollectionElementType.verify(message.screen);
                        if (error)
                            return "screen." + error;
                    }
                    if (message.layout != null && message.hasOwnProperty("layout")) {
                        let error = $root.rv.data.CollectionElementType.verify(message.layout);
                        if (error)
                            return "layout." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ScreenAssignment message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Stage.ScreenAssignment
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Stage.ScreenAssignment} ScreenAssignment
                 */
                ScreenAssignment.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Stage.ScreenAssignment)
                        return object;
                    let message = new $root.rv.data.Stage.ScreenAssignment();
                    if (object.screen != null) {
                        if (typeof object.screen !== "object")
                            throw TypeError(".rv.data.Stage.ScreenAssignment.screen: object expected");
                        message.screen = $root.rv.data.CollectionElementType.fromObject(object.screen);
                    }
                    if (object.layout != null) {
                        if (typeof object.layout !== "object")
                            throw TypeError(".rv.data.Stage.ScreenAssignment.layout: object expected");
                        message.layout = $root.rv.data.CollectionElementType.fromObject(object.layout);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ScreenAssignment message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Stage.ScreenAssignment
                 * @static
                 * @param {rv.data.Stage.ScreenAssignment} message ScreenAssignment
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ScreenAssignment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.screen = null;
                        object.layout = null;
                    }
                    if (message.screen != null && message.hasOwnProperty("screen"))
                        object.screen = $root.rv.data.CollectionElementType.toObject(message.screen, options);
                    if (message.layout != null && message.hasOwnProperty("layout"))
                        object.layout = $root.rv.data.CollectionElementType.toObject(message.layout, options);
                    return object;
                };

                /**
                 * Converts this ScreenAssignment to JSON.
                 * @function toJSON
                 * @memberof rv.data.Stage.ScreenAssignment
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ScreenAssignment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ScreenAssignment
                 * @function getTypeUrl
                 * @memberof rv.data.Stage.ScreenAssignment
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ScreenAssignment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Stage.ScreenAssignment";
                };

                return ScreenAssignment;
            })();

            return Stage;
        })();

        data.Cue = (function() {

            /**
             * Properties of a Cue.
             * @memberof rv.data
             * @interface ICue
             * @property {rv.data.IUUID|null} [uuid] Cue uuid
             * @property {string|null} [name] Cue name
             * @property {rv.data.Cue.CompletionTargetType|null} [completionTargetType] Cue completionTargetType
             * @property {rv.data.IUUID|null} [completionTargetUuid] Cue completionTargetUuid
             * @property {rv.data.Cue.CompletionActionType|null} [completionActionType] Cue completionActionType
             * @property {rv.data.IUUID|null} [completionActionUuid] Cue completionActionUuid
             * @property {rv.data.Cue.ITimecodeTime|null} [triggerTime] Cue triggerTime
             * @property {rv.data.IHotKey|null} [hotKey] Cue hotKey
             * @property {Array.<rv.data.IAction>|null} [actions] Cue actions
             * @property {Array.<rv.data.Cue.IPendingImportsEntry>|null} [pendingImports] Cue pendingImports
             * @property {boolean|null} [isEnabled] Cue isEnabled
             * @property {number|null} [completionTime] Cue completionTime
             */

            /**
             * Constructs a new Cue.
             * @memberof rv.data
             * @classdesc Represents a Cue.
             * @implements ICue
             * @constructor
             * @param {rv.data.ICue=} [properties] Properties to set
             */
            function Cue(properties) {
                this.actions = [];
                this.pendingImports = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Cue uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.Cue
             * @instance
             */
            Cue.prototype.uuid = null;

            /**
             * Cue name.
             * @member {string} name
             * @memberof rv.data.Cue
             * @instance
             */
            Cue.prototype.name = "";

            /**
             * Cue completionTargetType.
             * @member {rv.data.Cue.CompletionTargetType} completionTargetType
             * @memberof rv.data.Cue
             * @instance
             */
            Cue.prototype.completionTargetType = 0;

            /**
             * Cue completionTargetUuid.
             * @member {rv.data.IUUID|null|undefined} completionTargetUuid
             * @memberof rv.data.Cue
             * @instance
             */
            Cue.prototype.completionTargetUuid = null;

            /**
             * Cue completionActionType.
             * @member {rv.data.Cue.CompletionActionType} completionActionType
             * @memberof rv.data.Cue
             * @instance
             */
            Cue.prototype.completionActionType = 0;

            /**
             * Cue completionActionUuid.
             * @member {rv.data.IUUID|null|undefined} completionActionUuid
             * @memberof rv.data.Cue
             * @instance
             */
            Cue.prototype.completionActionUuid = null;

            /**
             * Cue triggerTime.
             * @member {rv.data.Cue.ITimecodeTime|null|undefined} triggerTime
             * @memberof rv.data.Cue
             * @instance
             */
            Cue.prototype.triggerTime = null;

            /**
             * Cue hotKey.
             * @member {rv.data.IHotKey|null|undefined} hotKey
             * @memberof rv.data.Cue
             * @instance
             */
            Cue.prototype.hotKey = null;

            /**
             * Cue actions.
             * @member {Array.<rv.data.IAction>} actions
             * @memberof rv.data.Cue
             * @instance
             */
            Cue.prototype.actions = $util.emptyArray;

            /**
             * Cue pendingImports.
             * @member {Array.<rv.data.Cue.IPendingImportsEntry>} pendingImports
             * @memberof rv.data.Cue
             * @instance
             */
            Cue.prototype.pendingImports = $util.emptyArray;

            /**
             * Cue isEnabled.
             * @member {boolean} isEnabled
             * @memberof rv.data.Cue
             * @instance
             */
            Cue.prototype.isEnabled = false;

            /**
             * Cue completionTime.
             * @member {number} completionTime
             * @memberof rv.data.Cue
             * @instance
             */
            Cue.prototype.completionTime = 0;

            /**
             * Creates a new Cue instance using the specified properties.
             * @function create
             * @memberof rv.data.Cue
             * @static
             * @param {rv.data.ICue=} [properties] Properties to set
             * @returns {rv.data.Cue} Cue instance
             */
            Cue.create = function create(properties) {
                return new Cue(properties);
            };

            /**
             * Encodes the specified Cue message. Does not implicitly {@link rv.data.Cue.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Cue
             * @static
             * @param {rv.data.ICue} message Cue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Cue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.completionTargetType != null && Object.hasOwnProperty.call(message, "completionTargetType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.completionTargetType);
                if (message.completionTargetUuid != null && Object.hasOwnProperty.call(message, "completionTargetUuid"))
                    $root.rv.data.UUID.encode(message.completionTargetUuid, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.completionActionType != null && Object.hasOwnProperty.call(message, "completionActionType"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.completionActionType);
                if (message.completionActionUuid != null && Object.hasOwnProperty.call(message, "completionActionUuid"))
                    $root.rv.data.UUID.encode(message.completionActionUuid, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.triggerTime != null && Object.hasOwnProperty.call(message, "triggerTime"))
                    $root.rv.data.Cue.TimecodeTime.encode(message.triggerTime, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.hotKey != null && Object.hasOwnProperty.call(message, "hotKey"))
                    $root.rv.data.HotKey.encode(message.hotKey, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.actions != null && message.actions.length)
                    for (let i = 0; i < message.actions.length; ++i)
                        $root.rv.data.Action.encode(message.actions[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.pendingImports != null && message.pendingImports.length)
                    for (let i = 0; i < message.pendingImports.length; ++i)
                        $root.rv.data.Cue.PendingImportsEntry.encode(message.pendingImports[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.isEnabled != null && Object.hasOwnProperty.call(message, "isEnabled"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.isEnabled);
                if (message.completionTime != null && Object.hasOwnProperty.call(message, "completionTime"))
                    writer.uint32(/* id 13, wireType 1 =*/105).double(message.completionTime);
                return writer;
            };

            /**
             * Encodes the specified Cue message, length delimited. Does not implicitly {@link rv.data.Cue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Cue
             * @static
             * @param {rv.data.ICue} message Cue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Cue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Cue message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Cue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Cue} Cue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Cue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Cue();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.completionTargetType = reader.int32();
                            break;
                        }
                    case 4: {
                            message.completionTargetUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.completionActionType = reader.int32();
                            break;
                        }
                    case 6: {
                            message.completionActionUuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.triggerTime = $root.rv.data.Cue.TimecodeTime.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.hotKey = $root.rv.data.HotKey.decode(reader, reader.uint32());
                            break;
                        }
                    case 10: {
                            if (!(message.actions && message.actions.length))
                                message.actions = [];
                            message.actions.push($root.rv.data.Action.decode(reader, reader.uint32()));
                            break;
                        }
                    case 11: {
                            if (!(message.pendingImports && message.pendingImports.length))
                                message.pendingImports = [];
                            message.pendingImports.push($root.rv.data.Cue.PendingImportsEntry.decode(reader, reader.uint32()));
                            break;
                        }
                    case 12: {
                            message.isEnabled = reader.bool();
                            break;
                        }
                    case 13: {
                            message.completionTime = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Cue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Cue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Cue} Cue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Cue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Cue message.
             * @function verify
             * @memberof rv.data.Cue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Cue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.completionTargetType != null && message.hasOwnProperty("completionTargetType"))
                    switch (message.completionTargetType) {
                    default:
                        return "completionTargetType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.completionTargetUuid != null && message.hasOwnProperty("completionTargetUuid")) {
                    let error = $root.rv.data.UUID.verify(message.completionTargetUuid);
                    if (error)
                        return "completionTargetUuid." + error;
                }
                if (message.completionActionType != null && message.hasOwnProperty("completionActionType"))
                    switch (message.completionActionType) {
                    default:
                        return "completionActionType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.completionActionUuid != null && message.hasOwnProperty("completionActionUuid")) {
                    let error = $root.rv.data.UUID.verify(message.completionActionUuid);
                    if (error)
                        return "completionActionUuid." + error;
                }
                if (message.triggerTime != null && message.hasOwnProperty("triggerTime")) {
                    let error = $root.rv.data.Cue.TimecodeTime.verify(message.triggerTime);
                    if (error)
                        return "triggerTime." + error;
                }
                if (message.hotKey != null && message.hasOwnProperty("hotKey")) {
                    let error = $root.rv.data.HotKey.verify(message.hotKey);
                    if (error)
                        return "hotKey." + error;
                }
                if (message.actions != null && message.hasOwnProperty("actions")) {
                    if (!Array.isArray(message.actions))
                        return "actions: array expected";
                    for (let i = 0; i < message.actions.length; ++i) {
                        let error = $root.rv.data.Action.verify(message.actions[i]);
                        if (error)
                            return "actions." + error;
                    }
                }
                if (message.pendingImports != null && message.hasOwnProperty("pendingImports")) {
                    if (!Array.isArray(message.pendingImports))
                        return "pendingImports: array expected";
                    for (let i = 0; i < message.pendingImports.length; ++i) {
                        let error = $root.rv.data.Cue.PendingImportsEntry.verify(message.pendingImports[i]);
                        if (error)
                            return "pendingImports." + error;
                    }
                }
                if (message.isEnabled != null && message.hasOwnProperty("isEnabled"))
                    if (typeof message.isEnabled !== "boolean")
                        return "isEnabled: boolean expected";
                if (message.completionTime != null && message.hasOwnProperty("completionTime"))
                    if (typeof message.completionTime !== "number")
                        return "completionTime: number expected";
                return null;
            };

            /**
             * Creates a Cue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Cue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Cue} Cue
             */
            Cue.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Cue)
                    return object;
                let message = new $root.rv.data.Cue();
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.Cue.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.completionTargetType) {
                default:
                    if (typeof object.completionTargetType === "number") {
                        message.completionTargetType = object.completionTargetType;
                        break;
                    }
                    break;
                case "COMPLETION_TARGET_TYPE_NONE":
                case 0:
                    message.completionTargetType = 0;
                    break;
                case "COMPLETION_TARGET_TYPE_NEXT":
                case 1:
                    message.completionTargetType = 1;
                    break;
                case "COMPLETION_TARGET_TYPE_RANDOM":
                case 2:
                    message.completionTargetType = 2;
                    break;
                case "COMPLETION_TARGET_TYPE_CUE":
                case 3:
                    message.completionTargetType = 3;
                    break;
                case "COMPLETION_TARGET_TYPE_FIRST":
                case 4:
                    message.completionTargetType = 4;
                    break;
                }
                if (object.completionTargetUuid != null) {
                    if (typeof object.completionTargetUuid !== "object")
                        throw TypeError(".rv.data.Cue.completionTargetUuid: object expected");
                    message.completionTargetUuid = $root.rv.data.UUID.fromObject(object.completionTargetUuid);
                }
                switch (object.completionActionType) {
                default:
                    if (typeof object.completionActionType === "number") {
                        message.completionActionType = object.completionActionType;
                        break;
                    }
                    break;
                case "COMPLETION_ACTION_TYPE_FIRST":
                case 0:
                    message.completionActionType = 0;
                    break;
                case "COMPLETION_ACTION_TYPE_LAST":
                case 1:
                    message.completionActionType = 1;
                    break;
                case "COMPLETION_ACTION_TYPE_AFTER_ACTION":
                case 2:
                    message.completionActionType = 2;
                    break;
                case "COMPLETION_ACTION_TYPE_AFTER_TIME":
                case 3:
                    message.completionActionType = 3;
                    break;
                }
                if (object.completionActionUuid != null) {
                    if (typeof object.completionActionUuid !== "object")
                        throw TypeError(".rv.data.Cue.completionActionUuid: object expected");
                    message.completionActionUuid = $root.rv.data.UUID.fromObject(object.completionActionUuid);
                }
                if (object.triggerTime != null) {
                    if (typeof object.triggerTime !== "object")
                        throw TypeError(".rv.data.Cue.triggerTime: object expected");
                    message.triggerTime = $root.rv.data.Cue.TimecodeTime.fromObject(object.triggerTime);
                }
                if (object.hotKey != null) {
                    if (typeof object.hotKey !== "object")
                        throw TypeError(".rv.data.Cue.hotKey: object expected");
                    message.hotKey = $root.rv.data.HotKey.fromObject(object.hotKey);
                }
                if (object.actions) {
                    if (!Array.isArray(object.actions))
                        throw TypeError(".rv.data.Cue.actions: array expected");
                    message.actions = [];
                    for (let i = 0; i < object.actions.length; ++i) {
                        if (typeof object.actions[i] !== "object")
                            throw TypeError(".rv.data.Cue.actions: object expected");
                        message.actions[i] = $root.rv.data.Action.fromObject(object.actions[i]);
                    }
                }
                if (object.pendingImports) {
                    if (!Array.isArray(object.pendingImports))
                        throw TypeError(".rv.data.Cue.pendingImports: array expected");
                    message.pendingImports = [];
                    for (let i = 0; i < object.pendingImports.length; ++i) {
                        if (typeof object.pendingImports[i] !== "object")
                            throw TypeError(".rv.data.Cue.pendingImports: object expected");
                        message.pendingImports[i] = $root.rv.data.Cue.PendingImportsEntry.fromObject(object.pendingImports[i]);
                    }
                }
                if (object.isEnabled != null)
                    message.isEnabled = Boolean(object.isEnabled);
                if (object.completionTime != null)
                    message.completionTime = Number(object.completionTime);
                return message;
            };

            /**
             * Creates a plain object from a Cue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Cue
             * @static
             * @param {rv.data.Cue} message Cue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Cue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.actions = [];
                    object.pendingImports = [];
                }
                if (options.defaults) {
                    object.uuid = null;
                    object.name = "";
                    object.completionTargetType = options.enums === String ? "COMPLETION_TARGET_TYPE_NONE" : 0;
                    object.completionTargetUuid = null;
                    object.completionActionType = options.enums === String ? "COMPLETION_ACTION_TYPE_FIRST" : 0;
                    object.completionActionUuid = null;
                    object.triggerTime = null;
                    object.hotKey = null;
                    object.isEnabled = false;
                    object.completionTime = 0;
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.completionTargetType != null && message.hasOwnProperty("completionTargetType"))
                    object.completionTargetType = options.enums === String ? $root.rv.data.Cue.CompletionTargetType[message.completionTargetType] === undefined ? message.completionTargetType : $root.rv.data.Cue.CompletionTargetType[message.completionTargetType] : message.completionTargetType;
                if (message.completionTargetUuid != null && message.hasOwnProperty("completionTargetUuid"))
                    object.completionTargetUuid = $root.rv.data.UUID.toObject(message.completionTargetUuid, options);
                if (message.completionActionType != null && message.hasOwnProperty("completionActionType"))
                    object.completionActionType = options.enums === String ? $root.rv.data.Cue.CompletionActionType[message.completionActionType] === undefined ? message.completionActionType : $root.rv.data.Cue.CompletionActionType[message.completionActionType] : message.completionActionType;
                if (message.completionActionUuid != null && message.hasOwnProperty("completionActionUuid"))
                    object.completionActionUuid = $root.rv.data.UUID.toObject(message.completionActionUuid, options);
                if (message.triggerTime != null && message.hasOwnProperty("triggerTime"))
                    object.triggerTime = $root.rv.data.Cue.TimecodeTime.toObject(message.triggerTime, options);
                if (message.hotKey != null && message.hasOwnProperty("hotKey"))
                    object.hotKey = $root.rv.data.HotKey.toObject(message.hotKey, options);
                if (message.actions && message.actions.length) {
                    object.actions = [];
                    for (let j = 0; j < message.actions.length; ++j)
                        object.actions[j] = $root.rv.data.Action.toObject(message.actions[j], options);
                }
                if (message.pendingImports && message.pendingImports.length) {
                    object.pendingImports = [];
                    for (let j = 0; j < message.pendingImports.length; ++j)
                        object.pendingImports[j] = $root.rv.data.Cue.PendingImportsEntry.toObject(message.pendingImports[j], options);
                }
                if (message.isEnabled != null && message.hasOwnProperty("isEnabled"))
                    object.isEnabled = message.isEnabled;
                if (message.completionTime != null && message.hasOwnProperty("completionTime"))
                    object.completionTime = options.json && !isFinite(message.completionTime) ? String(message.completionTime) : message.completionTime;
                return object;
            };

            /**
             * Converts this Cue to JSON.
             * @function toJSON
             * @memberof rv.data.Cue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Cue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Cue
             * @function getTypeUrl
             * @memberof rv.data.Cue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Cue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Cue";
            };

            Cue.TimecodeTime = (function() {

                /**
                 * Properties of a TimecodeTime.
                 * @memberof rv.data.Cue
                 * @interface ITimecodeTime
                 * @property {number|null} [time] TimecodeTime time
                 */

                /**
                 * Constructs a new TimecodeTime.
                 * @memberof rv.data.Cue
                 * @classdesc Represents a TimecodeTime.
                 * @implements ITimecodeTime
                 * @constructor
                 * @param {rv.data.Cue.ITimecodeTime=} [properties] Properties to set
                 */
                function TimecodeTime(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TimecodeTime time.
                 * @member {number} time
                 * @memberof rv.data.Cue.TimecodeTime
                 * @instance
                 */
                TimecodeTime.prototype.time = 0;

                /**
                 * Creates a new TimecodeTime instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Cue.TimecodeTime
                 * @static
                 * @param {rv.data.Cue.ITimecodeTime=} [properties] Properties to set
                 * @returns {rv.data.Cue.TimecodeTime} TimecodeTime instance
                 */
                TimecodeTime.create = function create(properties) {
                    return new TimecodeTime(properties);
                };

                /**
                 * Encodes the specified TimecodeTime message. Does not implicitly {@link rv.data.Cue.TimecodeTime.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Cue.TimecodeTime
                 * @static
                 * @param {rv.data.Cue.ITimecodeTime} message TimecodeTime message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimecodeTime.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.time);
                    return writer;
                };

                /**
                 * Encodes the specified TimecodeTime message, length delimited. Does not implicitly {@link rv.data.Cue.TimecodeTime.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Cue.TimecodeTime
                 * @static
                 * @param {rv.data.Cue.ITimecodeTime} message TimecodeTime message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimecodeTime.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TimecodeTime message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Cue.TimecodeTime
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Cue.TimecodeTime} TimecodeTime
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimecodeTime.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Cue.TimecodeTime();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.time = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TimecodeTime message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Cue.TimecodeTime
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Cue.TimecodeTime} TimecodeTime
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimecodeTime.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TimecodeTime message.
                 * @function verify
                 * @memberof rv.data.Cue.TimecodeTime
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TimecodeTime.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.time != null && message.hasOwnProperty("time"))
                        if (typeof message.time !== "number")
                            return "time: number expected";
                    return null;
                };

                /**
                 * Creates a TimecodeTime message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Cue.TimecodeTime
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Cue.TimecodeTime} TimecodeTime
                 */
                TimecodeTime.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Cue.TimecodeTime)
                        return object;
                    let message = new $root.rv.data.Cue.TimecodeTime();
                    if (object.time != null)
                        message.time = Number(object.time);
                    return message;
                };

                /**
                 * Creates a plain object from a TimecodeTime message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Cue.TimecodeTime
                 * @static
                 * @param {rv.data.Cue.TimecodeTime} message TimecodeTime
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimecodeTime.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.time = 0;
                    if (message.time != null && message.hasOwnProperty("time"))
                        object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
                    return object;
                };

                /**
                 * Converts this TimecodeTime to JSON.
                 * @function toJSON
                 * @memberof rv.data.Cue.TimecodeTime
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TimecodeTime.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TimecodeTime
                 * @function getTypeUrl
                 * @memberof rv.data.Cue.TimecodeTime
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TimecodeTime.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Cue.TimecodeTime";
                };

                return TimecodeTime;
            })();

            Cue.PendingImportsEntry = (function() {

                /**
                 * Properties of a PendingImportsEntry.
                 * @memberof rv.data.Cue
                 * @interface IPendingImportsEntry
                 * @property {string|null} [key] PendingImportsEntry key
                 * @property {rv.data.IURLs|null} [value] PendingImportsEntry value
                 */

                /**
                 * Constructs a new PendingImportsEntry.
                 * @memberof rv.data.Cue
                 * @classdesc Represents a PendingImportsEntry.
                 * @implements IPendingImportsEntry
                 * @constructor
                 * @param {rv.data.Cue.IPendingImportsEntry=} [properties] Properties to set
                 */
                function PendingImportsEntry(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PendingImportsEntry key.
                 * @member {string} key
                 * @memberof rv.data.Cue.PendingImportsEntry
                 * @instance
                 */
                PendingImportsEntry.prototype.key = "";

                /**
                 * PendingImportsEntry value.
                 * @member {rv.data.IURLs|null|undefined} value
                 * @memberof rv.data.Cue.PendingImportsEntry
                 * @instance
                 */
                PendingImportsEntry.prototype.value = null;

                /**
                 * Creates a new PendingImportsEntry instance using the specified properties.
                 * @function create
                 * @memberof rv.data.Cue.PendingImportsEntry
                 * @static
                 * @param {rv.data.Cue.IPendingImportsEntry=} [properties] Properties to set
                 * @returns {rv.data.Cue.PendingImportsEntry} PendingImportsEntry instance
                 */
                PendingImportsEntry.create = function create(properties) {
                    return new PendingImportsEntry(properties);
                };

                /**
                 * Encodes the specified PendingImportsEntry message. Does not implicitly {@link rv.data.Cue.PendingImportsEntry.verify|verify} messages.
                 * @function encode
                 * @memberof rv.data.Cue.PendingImportsEntry
                 * @static
                 * @param {rv.data.Cue.IPendingImportsEntry} message PendingImportsEntry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PendingImportsEntry.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.rv.data.URLs.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PendingImportsEntry message, length delimited. Does not implicitly {@link rv.data.Cue.PendingImportsEntry.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof rv.data.Cue.PendingImportsEntry
                 * @static
                 * @param {rv.data.Cue.IPendingImportsEntry} message PendingImportsEntry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PendingImportsEntry.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PendingImportsEntry message from the specified reader or buffer.
                 * @function decode
                 * @memberof rv.data.Cue.PendingImportsEntry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {rv.data.Cue.PendingImportsEntry} PendingImportsEntry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PendingImportsEntry.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Cue.PendingImportsEntry();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.key = reader.string();
                                break;
                            }
                        case 2: {
                                message.value = $root.rv.data.URLs.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PendingImportsEntry message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof rv.data.Cue.PendingImportsEntry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {rv.data.Cue.PendingImportsEntry} PendingImportsEntry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PendingImportsEntry.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PendingImportsEntry message.
                 * @function verify
                 * @memberof rv.data.Cue.PendingImportsEntry
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PendingImportsEntry.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!$util.isString(message.key))
                            return "key: string expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        let error = $root.rv.data.URLs.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };

                /**
                 * Creates a PendingImportsEntry message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof rv.data.Cue.PendingImportsEntry
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {rv.data.Cue.PendingImportsEntry} PendingImportsEntry
                 */
                PendingImportsEntry.fromObject = function fromObject(object) {
                    if (object instanceof $root.rv.data.Cue.PendingImportsEntry)
                        return object;
                    let message = new $root.rv.data.Cue.PendingImportsEntry();
                    if (object.key != null)
                        message.key = String(object.key);
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".rv.data.Cue.PendingImportsEntry.value: object expected");
                        message.value = $root.rv.data.URLs.fromObject(object.value);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PendingImportsEntry message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof rv.data.Cue.PendingImportsEntry
                 * @static
                 * @param {rv.data.Cue.PendingImportsEntry} message PendingImportsEntry
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PendingImportsEntry.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.key = "";
                        object.value = null;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = message.key;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.rv.data.URLs.toObject(message.value, options);
                    return object;
                };

                /**
                 * Converts this PendingImportsEntry to JSON.
                 * @function toJSON
                 * @memberof rv.data.Cue.PendingImportsEntry
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PendingImportsEntry.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PendingImportsEntry
                 * @function getTypeUrl
                 * @memberof rv.data.Cue.PendingImportsEntry
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PendingImportsEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/rv.data.Cue.PendingImportsEntry";
                };

                return PendingImportsEntry;
            })();

            /**
             * CompletionTargetType enum.
             * @name rv.data.Cue.CompletionTargetType
             * @enum {number}
             * @property {number} COMPLETION_TARGET_TYPE_NONE=0 COMPLETION_TARGET_TYPE_NONE value
             * @property {number} COMPLETION_TARGET_TYPE_NEXT=1 COMPLETION_TARGET_TYPE_NEXT value
             * @property {number} COMPLETION_TARGET_TYPE_RANDOM=2 COMPLETION_TARGET_TYPE_RANDOM value
             * @property {number} COMPLETION_TARGET_TYPE_CUE=3 COMPLETION_TARGET_TYPE_CUE value
             * @property {number} COMPLETION_TARGET_TYPE_FIRST=4 COMPLETION_TARGET_TYPE_FIRST value
             */
            Cue.CompletionTargetType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COMPLETION_TARGET_TYPE_NONE"] = 0;
                values[valuesById[1] = "COMPLETION_TARGET_TYPE_NEXT"] = 1;
                values[valuesById[2] = "COMPLETION_TARGET_TYPE_RANDOM"] = 2;
                values[valuesById[3] = "COMPLETION_TARGET_TYPE_CUE"] = 3;
                values[valuesById[4] = "COMPLETION_TARGET_TYPE_FIRST"] = 4;
                return values;
            })();

            /**
             * CompletionActionType enum.
             * @name rv.data.Cue.CompletionActionType
             * @enum {number}
             * @property {number} COMPLETION_ACTION_TYPE_FIRST=0 COMPLETION_ACTION_TYPE_FIRST value
             * @property {number} COMPLETION_ACTION_TYPE_LAST=1 COMPLETION_ACTION_TYPE_LAST value
             * @property {number} COMPLETION_ACTION_TYPE_AFTER_ACTION=2 COMPLETION_ACTION_TYPE_AFTER_ACTION value
             * @property {number} COMPLETION_ACTION_TYPE_AFTER_TIME=3 COMPLETION_ACTION_TYPE_AFTER_TIME value
             */
            Cue.CompletionActionType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COMPLETION_ACTION_TYPE_FIRST"] = 0;
                values[valuesById[1] = "COMPLETION_ACTION_TYPE_LAST"] = 1;
                values[valuesById[2] = "COMPLETION_ACTION_TYPE_AFTER_ACTION"] = 2;
                values[valuesById[3] = "COMPLETION_ACTION_TYPE_AFTER_TIME"] = 3;
                return values;
            })();

            return Cue;
        })();

        data.Group = (function() {

            /**
             * Properties of a Group.
             * @memberof rv.data
             * @interface IGroup
             * @property {rv.data.IUUID|null} [uuid] Group uuid
             * @property {string|null} [name] Group name
             * @property {rv.data.IColor|null} [color] Group color
             * @property {rv.data.IHotKey|null} [hotKey] Group hotKey
             * @property {rv.data.IUUID|null} [applicationGroupIdentifier] Group applicationGroupIdentifier
             * @property {string|null} [applicationGroupName] Group applicationGroupName
             */

            /**
             * Constructs a new Group.
             * @memberof rv.data
             * @classdesc Represents a Group.
             * @implements IGroup
             * @constructor
             * @param {rv.data.IGroup=} [properties] Properties to set
             */
            function Group(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Group uuid.
             * @member {rv.data.IUUID|null|undefined} uuid
             * @memberof rv.data.Group
             * @instance
             */
            Group.prototype.uuid = null;

            /**
             * Group name.
             * @member {string} name
             * @memberof rv.data.Group
             * @instance
             */
            Group.prototype.name = "";

            /**
             * Group color.
             * @member {rv.data.IColor|null|undefined} color
             * @memberof rv.data.Group
             * @instance
             */
            Group.prototype.color = null;

            /**
             * Group hotKey.
             * @member {rv.data.IHotKey|null|undefined} hotKey
             * @memberof rv.data.Group
             * @instance
             */
            Group.prototype.hotKey = null;

            /**
             * Group applicationGroupIdentifier.
             * @member {rv.data.IUUID|null|undefined} applicationGroupIdentifier
             * @memberof rv.data.Group
             * @instance
             */
            Group.prototype.applicationGroupIdentifier = null;

            /**
             * Group applicationGroupName.
             * @member {string} applicationGroupName
             * @memberof rv.data.Group
             * @instance
             */
            Group.prototype.applicationGroupName = "";

            /**
             * Creates a new Group instance using the specified properties.
             * @function create
             * @memberof rv.data.Group
             * @static
             * @param {rv.data.IGroup=} [properties] Properties to set
             * @returns {rv.data.Group} Group instance
             */
            Group.create = function create(properties) {
                return new Group(properties);
            };

            /**
             * Encodes the specified Group message. Does not implicitly {@link rv.data.Group.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Group
             * @static
             * @param {rv.data.IGroup} message Group message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Group.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                    $root.rv.data.UUID.encode(message.uuid, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    $root.rv.data.Color.encode(message.color, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.hotKey != null && Object.hasOwnProperty.call(message, "hotKey"))
                    $root.rv.data.HotKey.encode(message.hotKey, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.applicationGroupIdentifier != null && Object.hasOwnProperty.call(message, "applicationGroupIdentifier"))
                    $root.rv.data.UUID.encode(message.applicationGroupIdentifier, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.applicationGroupName != null && Object.hasOwnProperty.call(message, "applicationGroupName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.applicationGroupName);
                return writer;
            };

            /**
             * Encodes the specified Group message, length delimited. Does not implicitly {@link rv.data.Group.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Group
             * @static
             * @param {rv.data.IGroup} message Group message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Group.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Group message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Group
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Group} Group
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Group.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Group();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uuid = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.color = $root.rv.data.Color.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.hotKey = $root.rv.data.HotKey.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.applicationGroupIdentifier = $root.rv.data.UUID.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.applicationGroupName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Group message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Group
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Group} Group
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Group.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Group message.
             * @function verify
             * @memberof rv.data.Group
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Group.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uuid != null && message.hasOwnProperty("uuid")) {
                    let error = $root.rv.data.UUID.verify(message.uuid);
                    if (error)
                        return "uuid." + error;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.color != null && message.hasOwnProperty("color")) {
                    let error = $root.rv.data.Color.verify(message.color);
                    if (error)
                        return "color." + error;
                }
                if (message.hotKey != null && message.hasOwnProperty("hotKey")) {
                    let error = $root.rv.data.HotKey.verify(message.hotKey);
                    if (error)
                        return "hotKey." + error;
                }
                if (message.applicationGroupIdentifier != null && message.hasOwnProperty("applicationGroupIdentifier")) {
                    let error = $root.rv.data.UUID.verify(message.applicationGroupIdentifier);
                    if (error)
                        return "applicationGroupIdentifier." + error;
                }
                if (message.applicationGroupName != null && message.hasOwnProperty("applicationGroupName"))
                    if (!$util.isString(message.applicationGroupName))
                        return "applicationGroupName: string expected";
                return null;
            };

            /**
             * Creates a Group message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Group
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Group} Group
             */
            Group.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Group)
                    return object;
                let message = new $root.rv.data.Group();
                if (object.uuid != null) {
                    if (typeof object.uuid !== "object")
                        throw TypeError(".rv.data.Group.uuid: object expected");
                    message.uuid = $root.rv.data.UUID.fromObject(object.uuid);
                }
                if (object.name != null)
                    message.name = String(object.name);
                if (object.color != null) {
                    if (typeof object.color !== "object")
                        throw TypeError(".rv.data.Group.color: object expected");
                    message.color = $root.rv.data.Color.fromObject(object.color);
                }
                if (object.hotKey != null) {
                    if (typeof object.hotKey !== "object")
                        throw TypeError(".rv.data.Group.hotKey: object expected");
                    message.hotKey = $root.rv.data.HotKey.fromObject(object.hotKey);
                }
                if (object.applicationGroupIdentifier != null) {
                    if (typeof object.applicationGroupIdentifier !== "object")
                        throw TypeError(".rv.data.Group.applicationGroupIdentifier: object expected");
                    message.applicationGroupIdentifier = $root.rv.data.UUID.fromObject(object.applicationGroupIdentifier);
                }
                if (object.applicationGroupName != null)
                    message.applicationGroupName = String(object.applicationGroupName);
                return message;
            };

            /**
             * Creates a plain object from a Group message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Group
             * @static
             * @param {rv.data.Group} message Group
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Group.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uuid = null;
                    object.name = "";
                    object.color = null;
                    object.hotKey = null;
                    object.applicationGroupIdentifier = null;
                    object.applicationGroupName = "";
                }
                if (message.uuid != null && message.hasOwnProperty("uuid"))
                    object.uuid = $root.rv.data.UUID.toObject(message.uuid, options);
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.color != null && message.hasOwnProperty("color"))
                    object.color = $root.rv.data.Color.toObject(message.color, options);
                if (message.hotKey != null && message.hasOwnProperty("hotKey"))
                    object.hotKey = $root.rv.data.HotKey.toObject(message.hotKey, options);
                if (message.applicationGroupIdentifier != null && message.hasOwnProperty("applicationGroupIdentifier"))
                    object.applicationGroupIdentifier = $root.rv.data.UUID.toObject(message.applicationGroupIdentifier, options);
                if (message.applicationGroupName != null && message.hasOwnProperty("applicationGroupName"))
                    object.applicationGroupName = message.applicationGroupName;
                return object;
            };

            /**
             * Converts this Group to JSON.
             * @function toJSON
             * @memberof rv.data.Group
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Group.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Group
             * @function getTypeUrl
             * @memberof rv.data.Group
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Group.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Group";
            };

            return Group;
        })();

        data.ProGroupsDocument = (function() {

            /**
             * Properties of a ProGroupsDocument.
             * @memberof rv.data
             * @interface IProGroupsDocument
             * @property {Array.<rv.data.IGroup>|null} [groups] ProGroupsDocument groups
             */

            /**
             * Constructs a new ProGroupsDocument.
             * @memberof rv.data
             * @classdesc Represents a ProGroupsDocument.
             * @implements IProGroupsDocument
             * @constructor
             * @param {rv.data.IProGroupsDocument=} [properties] Properties to set
             */
            function ProGroupsDocument(properties) {
                this.groups = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProGroupsDocument groups.
             * @member {Array.<rv.data.IGroup>} groups
             * @memberof rv.data.ProGroupsDocument
             * @instance
             */
            ProGroupsDocument.prototype.groups = $util.emptyArray;

            /**
             * Creates a new ProGroupsDocument instance using the specified properties.
             * @function create
             * @memberof rv.data.ProGroupsDocument
             * @static
             * @param {rv.data.IProGroupsDocument=} [properties] Properties to set
             * @returns {rv.data.ProGroupsDocument} ProGroupsDocument instance
             */
            ProGroupsDocument.create = function create(properties) {
                return new ProGroupsDocument(properties);
            };

            /**
             * Encodes the specified ProGroupsDocument message. Does not implicitly {@link rv.data.ProGroupsDocument.verify|verify} messages.
             * @function encode
             * @memberof rv.data.ProGroupsDocument
             * @static
             * @param {rv.data.IProGroupsDocument} message ProGroupsDocument message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProGroupsDocument.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groups != null && message.groups.length)
                    for (let i = 0; i < message.groups.length; ++i)
                        $root.rv.data.Group.encode(message.groups[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ProGroupsDocument message, length delimited. Does not implicitly {@link rv.data.ProGroupsDocument.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.ProGroupsDocument
             * @static
             * @param {rv.data.IProGroupsDocument} message ProGroupsDocument message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProGroupsDocument.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProGroupsDocument message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.ProGroupsDocument
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.ProGroupsDocument} ProGroupsDocument
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProGroupsDocument.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.ProGroupsDocument();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.groups && message.groups.length))
                                message.groups = [];
                            message.groups.push($root.rv.data.Group.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProGroupsDocument message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.ProGroupsDocument
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.ProGroupsDocument} ProGroupsDocument
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProGroupsDocument.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProGroupsDocument message.
             * @function verify
             * @memberof rv.data.ProGroupsDocument
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProGroupsDocument.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groups != null && message.hasOwnProperty("groups")) {
                    if (!Array.isArray(message.groups))
                        return "groups: array expected";
                    for (let i = 0; i < message.groups.length; ++i) {
                        let error = $root.rv.data.Group.verify(message.groups[i]);
                        if (error)
                            return "groups." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ProGroupsDocument message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.ProGroupsDocument
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.ProGroupsDocument} ProGroupsDocument
             */
            ProGroupsDocument.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.ProGroupsDocument)
                    return object;
                let message = new $root.rv.data.ProGroupsDocument();
                if (object.groups) {
                    if (!Array.isArray(object.groups))
                        throw TypeError(".rv.data.ProGroupsDocument.groups: array expected");
                    message.groups = [];
                    for (let i = 0; i < object.groups.length; ++i) {
                        if (typeof object.groups[i] !== "object")
                            throw TypeError(".rv.data.ProGroupsDocument.groups: object expected");
                        message.groups[i] = $root.rv.data.Group.fromObject(object.groups[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ProGroupsDocument message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.ProGroupsDocument
             * @static
             * @param {rv.data.ProGroupsDocument} message ProGroupsDocument
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProGroupsDocument.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.groups = [];
                if (message.groups && message.groups.length) {
                    object.groups = [];
                    for (let j = 0; j < message.groups.length; ++j)
                        object.groups[j] = $root.rv.data.Group.toObject(message.groups[j], options);
                }
                return object;
            };

            /**
             * Converts this ProGroupsDocument to JSON.
             * @function toJSON
             * @memberof rv.data.ProGroupsDocument
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProGroupsDocument.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ProGroupsDocument
             * @function getTypeUrl
             * @memberof rv.data.ProGroupsDocument
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ProGroupsDocument.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.ProGroupsDocument";
            };

            return ProGroupsDocument;
        })();

        data.MusicKeyScale = (function() {

            /**
             * Properties of a MusicKeyScale.
             * @memberof rv.data
             * @interface IMusicKeyScale
             * @property {rv.data.MusicKeyScale.MusicKey|null} [musicKey] MusicKeyScale musicKey
             * @property {rv.data.MusicKeyScale.MusicScale|null} [musicScale] MusicKeyScale musicScale
             */

            /**
             * Constructs a new MusicKeyScale.
             * @memberof rv.data
             * @classdesc Represents a MusicKeyScale.
             * @implements IMusicKeyScale
             * @constructor
             * @param {rv.data.IMusicKeyScale=} [properties] Properties to set
             */
            function MusicKeyScale(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MusicKeyScale musicKey.
             * @member {rv.data.MusicKeyScale.MusicKey} musicKey
             * @memberof rv.data.MusicKeyScale
             * @instance
             */
            MusicKeyScale.prototype.musicKey = 0;

            /**
             * MusicKeyScale musicScale.
             * @member {rv.data.MusicKeyScale.MusicScale} musicScale
             * @memberof rv.data.MusicKeyScale
             * @instance
             */
            MusicKeyScale.prototype.musicScale = 0;

            /**
             * Creates a new MusicKeyScale instance using the specified properties.
             * @function create
             * @memberof rv.data.MusicKeyScale
             * @static
             * @param {rv.data.IMusicKeyScale=} [properties] Properties to set
             * @returns {rv.data.MusicKeyScale} MusicKeyScale instance
             */
            MusicKeyScale.create = function create(properties) {
                return new MusicKeyScale(properties);
            };

            /**
             * Encodes the specified MusicKeyScale message. Does not implicitly {@link rv.data.MusicKeyScale.verify|verify} messages.
             * @function encode
             * @memberof rv.data.MusicKeyScale
             * @static
             * @param {rv.data.IMusicKeyScale} message MusicKeyScale message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MusicKeyScale.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.musicKey != null && Object.hasOwnProperty.call(message, "musicKey"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.musicKey);
                if (message.musicScale != null && Object.hasOwnProperty.call(message, "musicScale"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.musicScale);
                return writer;
            };

            /**
             * Encodes the specified MusicKeyScale message, length delimited. Does not implicitly {@link rv.data.MusicKeyScale.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.MusicKeyScale
             * @static
             * @param {rv.data.IMusicKeyScale} message MusicKeyScale message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MusicKeyScale.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MusicKeyScale message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.MusicKeyScale
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.MusicKeyScale} MusicKeyScale
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MusicKeyScale.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.MusicKeyScale();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.musicKey = reader.int32();
                            break;
                        }
                    case 2: {
                            message.musicScale = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MusicKeyScale message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.MusicKeyScale
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.MusicKeyScale} MusicKeyScale
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MusicKeyScale.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MusicKeyScale message.
             * @function verify
             * @memberof rv.data.MusicKeyScale
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MusicKeyScale.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.musicKey != null && message.hasOwnProperty("musicKey"))
                    switch (message.musicKey) {
                    default:
                        return "musicKey: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                        break;
                    }
                if (message.musicScale != null && message.hasOwnProperty("musicScale"))
                    switch (message.musicScale) {
                    default:
                        return "musicScale: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a MusicKeyScale message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.MusicKeyScale
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.MusicKeyScale} MusicKeyScale
             */
            MusicKeyScale.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.MusicKeyScale)
                    return object;
                let message = new $root.rv.data.MusicKeyScale();
                switch (object.musicKey) {
                default:
                    if (typeof object.musicKey === "number") {
                        message.musicKey = object.musicKey;
                        break;
                    }
                    break;
                case "MUSIC_KEY_A_FLAT":
                case 0:
                    message.musicKey = 0;
                    break;
                case "MUSIC_KEY_A":
                case 1:
                    message.musicKey = 1;
                    break;
                case "MUSIC_KEY_A_SHARP":
                case 2:
                    message.musicKey = 2;
                    break;
                case "MUSIC_KEY_B_FLAT":
                case 3:
                    message.musicKey = 3;
                    break;
                case "MUSIC_KEY_B":
                case 4:
                    message.musicKey = 4;
                    break;
                case "MUSIC_KEY_B_SHARP":
                case 5:
                    message.musicKey = 5;
                    break;
                case "MUSIC_KEY_C_FLAT":
                case 6:
                    message.musicKey = 6;
                    break;
                case "MUSIC_KEY_C":
                case 7:
                    message.musicKey = 7;
                    break;
                case "MUSIC_KEY_C_SHARP":
                case 8:
                    message.musicKey = 8;
                    break;
                case "MUSIC_KEY_D_FLAT":
                case 9:
                    message.musicKey = 9;
                    break;
                case "MUSIC_KEY_D":
                case 10:
                    message.musicKey = 10;
                    break;
                case "MUSIC_KEY_D_SHARP":
                case 11:
                    message.musicKey = 11;
                    break;
                case "MUSIC_KEY_E_FLAT":
                case 12:
                    message.musicKey = 12;
                    break;
                case "MUSIC_KEY_E":
                case 13:
                    message.musicKey = 13;
                    break;
                case "MUSIC_KEY_E_SHARP":
                case 14:
                    message.musicKey = 14;
                    break;
                case "MUSIC_KEY_F_FLAT":
                case 15:
                    message.musicKey = 15;
                    break;
                case "MUSIC_KEY_F":
                case 16:
                    message.musicKey = 16;
                    break;
                case "MUSIC_KEY_F_SHARP":
                case 17:
                    message.musicKey = 17;
                    break;
                case "MUSIC_KEY_G_FLAT":
                case 18:
                    message.musicKey = 18;
                    break;
                case "MUSIC_KEY_G":
                case 19:
                    message.musicKey = 19;
                    break;
                case "MUSIC_KEY_G_SHARP":
                case 20:
                    message.musicKey = 20;
                    break;
                }
                switch (object.musicScale) {
                default:
                    if (typeof object.musicScale === "number") {
                        message.musicScale = object.musicScale;
                        break;
                    }
                    break;
                case "MUSIC_SCALE_MAJOR":
                case 0:
                    message.musicScale = 0;
                    break;
                case "MUSIC_SCALE_MINOR":
                case 1:
                    message.musicScale = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a MusicKeyScale message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.MusicKeyScale
             * @static
             * @param {rv.data.MusicKeyScale} message MusicKeyScale
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MusicKeyScale.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.musicKey = options.enums === String ? "MUSIC_KEY_A_FLAT" : 0;
                    object.musicScale = options.enums === String ? "MUSIC_SCALE_MAJOR" : 0;
                }
                if (message.musicKey != null && message.hasOwnProperty("musicKey"))
                    object.musicKey = options.enums === String ? $root.rv.data.MusicKeyScale.MusicKey[message.musicKey] === undefined ? message.musicKey : $root.rv.data.MusicKeyScale.MusicKey[message.musicKey] : message.musicKey;
                if (message.musicScale != null && message.hasOwnProperty("musicScale"))
                    object.musicScale = options.enums === String ? $root.rv.data.MusicKeyScale.MusicScale[message.musicScale] === undefined ? message.musicScale : $root.rv.data.MusicKeyScale.MusicScale[message.musicScale] : message.musicScale;
                return object;
            };

            /**
             * Converts this MusicKeyScale to JSON.
             * @function toJSON
             * @memberof rv.data.MusicKeyScale
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MusicKeyScale.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MusicKeyScale
             * @function getTypeUrl
             * @memberof rv.data.MusicKeyScale
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MusicKeyScale.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.MusicKeyScale";
            };

            /**
             * MusicKey enum.
             * @name rv.data.MusicKeyScale.MusicKey
             * @enum {number}
             * @property {number} MUSIC_KEY_A_FLAT=0 MUSIC_KEY_A_FLAT value
             * @property {number} MUSIC_KEY_A=1 MUSIC_KEY_A value
             * @property {number} MUSIC_KEY_A_SHARP=2 MUSIC_KEY_A_SHARP value
             * @property {number} MUSIC_KEY_B_FLAT=3 MUSIC_KEY_B_FLAT value
             * @property {number} MUSIC_KEY_B=4 MUSIC_KEY_B value
             * @property {number} MUSIC_KEY_B_SHARP=5 MUSIC_KEY_B_SHARP value
             * @property {number} MUSIC_KEY_C_FLAT=6 MUSIC_KEY_C_FLAT value
             * @property {number} MUSIC_KEY_C=7 MUSIC_KEY_C value
             * @property {number} MUSIC_KEY_C_SHARP=8 MUSIC_KEY_C_SHARP value
             * @property {number} MUSIC_KEY_D_FLAT=9 MUSIC_KEY_D_FLAT value
             * @property {number} MUSIC_KEY_D=10 MUSIC_KEY_D value
             * @property {number} MUSIC_KEY_D_SHARP=11 MUSIC_KEY_D_SHARP value
             * @property {number} MUSIC_KEY_E_FLAT=12 MUSIC_KEY_E_FLAT value
             * @property {number} MUSIC_KEY_E=13 MUSIC_KEY_E value
             * @property {number} MUSIC_KEY_E_SHARP=14 MUSIC_KEY_E_SHARP value
             * @property {number} MUSIC_KEY_F_FLAT=15 MUSIC_KEY_F_FLAT value
             * @property {number} MUSIC_KEY_F=16 MUSIC_KEY_F value
             * @property {number} MUSIC_KEY_F_SHARP=17 MUSIC_KEY_F_SHARP value
             * @property {number} MUSIC_KEY_G_FLAT=18 MUSIC_KEY_G_FLAT value
             * @property {number} MUSIC_KEY_G=19 MUSIC_KEY_G value
             * @property {number} MUSIC_KEY_G_SHARP=20 MUSIC_KEY_G_SHARP value
             */
            MusicKeyScale.MusicKey = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MUSIC_KEY_A_FLAT"] = 0;
                values[valuesById[1] = "MUSIC_KEY_A"] = 1;
                values[valuesById[2] = "MUSIC_KEY_A_SHARP"] = 2;
                values[valuesById[3] = "MUSIC_KEY_B_FLAT"] = 3;
                values[valuesById[4] = "MUSIC_KEY_B"] = 4;
                values[valuesById[5] = "MUSIC_KEY_B_SHARP"] = 5;
                values[valuesById[6] = "MUSIC_KEY_C_FLAT"] = 6;
                values[valuesById[7] = "MUSIC_KEY_C"] = 7;
                values[valuesById[8] = "MUSIC_KEY_C_SHARP"] = 8;
                values[valuesById[9] = "MUSIC_KEY_D_FLAT"] = 9;
                values[valuesById[10] = "MUSIC_KEY_D"] = 10;
                values[valuesById[11] = "MUSIC_KEY_D_SHARP"] = 11;
                values[valuesById[12] = "MUSIC_KEY_E_FLAT"] = 12;
                values[valuesById[13] = "MUSIC_KEY_E"] = 13;
                values[valuesById[14] = "MUSIC_KEY_E_SHARP"] = 14;
                values[valuesById[15] = "MUSIC_KEY_F_FLAT"] = 15;
                values[valuesById[16] = "MUSIC_KEY_F"] = 16;
                values[valuesById[17] = "MUSIC_KEY_F_SHARP"] = 17;
                values[valuesById[18] = "MUSIC_KEY_G_FLAT"] = 18;
                values[valuesById[19] = "MUSIC_KEY_G"] = 19;
                values[valuesById[20] = "MUSIC_KEY_G_SHARP"] = 20;
                return values;
            })();

            /**
             * MusicScale enum.
             * @name rv.data.MusicKeyScale.MusicScale
             * @enum {number}
             * @property {number} MUSIC_SCALE_MAJOR=0 MUSIC_SCALE_MAJOR value
             * @property {number} MUSIC_SCALE_MINOR=1 MUSIC_SCALE_MINOR value
             */
            MusicKeyScale.MusicScale = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MUSIC_SCALE_MAJOR"] = 0;
                values[valuesById[1] = "MUSIC_SCALE_MINOR"] = 1;
                return values;
            })();

            return MusicKeyScale;
        })();

        data.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @memberof rv.data
             * @interface ITimestamp
             * @property {number|Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */

            /**
             * Constructs a new Timestamp.
             * @memberof rv.data
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {rv.data.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @member {number|Long} seconds
             * @memberof rv.data.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof rv.data.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @function create
             * @memberof rv.data.Timestamp
             * @static
             * @param {rv.data.ITimestamp=} [properties] Properties to set
             * @returns {rv.data.Timestamp} Timestamp instance
             */
            Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link rv.data.Timestamp.verify|verify} messages.
             * @function encode
             * @memberof rv.data.Timestamp
             * @static
             * @param {rv.data.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link rv.data.Timestamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rv.data.Timestamp
             * @static
             * @param {rv.data.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @function decode
             * @memberof rv.data.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rv.data.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.rv.data.Timestamp();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.seconds = reader.int64();
                            break;
                        }
                    case 2: {
                            message.nanos = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rv.data.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rv.data.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof rv.data.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rv.data.Timestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rv.data.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.rv.data.Timestamp)
                    return object;
                let message = new $root.rv.data.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rv.data.Timestamp
             * @static
             * @param {rv.data.Timestamp} message Timestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Timestamp to JSON.
             * @function toJSON
             * @memberof rv.data.Timestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Timestamp
             * @function getTypeUrl
             * @memberof rv.data.Timestamp
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Timestamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/rv.data.Timestamp";
            };

            return Timestamp;
        })();

        return data;
    })();

    return rv;
})();

export { $root as default };
